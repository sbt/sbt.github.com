<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of sbt</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/reference/custom-202509.css">
        <link rel="stylesheet" href="src/reference/mdbook-admonish.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            
            // var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
            var default_theme = "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of sbt</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-cn">Chinese Simplified (中文)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (日本語)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("ja");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                            lang.href = `${full_path_to_root}${lang.id}/${path}`;
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sbt-ハンドブック-日本語版草稿"><a class="header" href="#sbt-ハンドブック-日本語版草稿">sbt ハンドブック (日本語版草稿)</a></h1>
<p>これは未だリリースされていない sbt 2.x のドキュメンテーションの草稿だ。一般的な概念は sbt 1.x とも一貫しているが、2.x 系および本稿の詳細は今後変更される可能性がある。</p>
<p><img src="files/sbt-logo.svg" alt="sbt logo" /></p>
<p>sbt は主に Scala と Java のためのシンプルなビルド・ツールだ。sbt は、Coursier を用いたライブラリ依存性のダウンロード、プロジェクトの差分コンパイルや差分テスト、IntelliJ や VS Code などの IDE との統合、JAR パッケージの作成、および JVM コミュニティーがパッケージ管理に用いる <a href="https://central.sonatype.com/">Central Repo</a> への公開などを行う。</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<p>Scala を始めるには、一行の <code>build.sbt</code> を書くだけでいい。</p>
<h2 id="リンク"><a class="header" href="#リンク">リンク</a></h2>
<ul>
<li>本稿のソースは <a href="https://github.com/sbt/website/">sbt/website</a> にて管理されている</li>
<li><a href="https://www.scala-sbt.org/1.x/docs/ja/Getting-Started.html">sbt 1.x のドキュメンテーション</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-runner-のインストール"><a class="header" href="#sbt-runner-のインストール">sbt runner のインストール</a></h1>
<p>sbt プロジェクトをビルドするためには、以下の手順をたどる必要がある:</p>
<ul>
<li>JDK をインストールする (Eclipse Adoptium Temurin JDK 8、11、17、もしくは ARM チップの macOS の場合、Zulu JDK を推奨)。</li>
<li>sbt runner のインストール。</li>
</ul>
<p>sbt runner は、宣言されたバージョンの sbt を必要に応じてダウンロードして、実行するスクリプトだ。この機構によってユーザのマシン環境に依存することなく、ビルド作者が sbt のバージョンを正確に管理することができる。</p>
<h3 id="システム要件"><a class="header" href="#システム要件">システム要件</a></h3>
<p>sbt は主なオペレーティング・システムにおいて動作するが、事前に JDK 8 以上がインストールされていることを必要とする。</p>
<pre><code class="language-bash">java -version
# openjdk version "1.8.0_352"
</code></pre>
<h3 id="sdkman-からのインストール"><a class="header" href="#sdkman-からのインストール">SDKMAN からのインストール</a></h3>
<p>JDK と sbt のインストールをするのに、<a href="https://sdkman.io/">SDKMAN</a> を使うことができる。</p>
<pre><code class="language-bash">sdk install java $(sdk list java | grep -o "\b8\.[0-9]*\.[0-9]*\-tem" | head -1)
sdk install sbt
</code></pre>
<h3 id="ユニバーサルパッケージ"><a class="header" href="#ユニバーサルパッケージ">ユニバーサル・パッケージ</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.6/sbt-1.11.6.zip">sbt-1.11.6.zip</a></li>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.6/sbt-1.11.6.tgz">sbt-1.11.6.tgz</a></li>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.6/sbt-1.11.6.msi">sbt-1.11.6.msi</a></li>
</ul>
<h2 id="sbt-runner-の確認"><a class="header" href="#sbt-runner-の確認">sbt runner の確認</a></h2>
<pre><code class="language-bash">sbt --script-version
# 1.11.6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="例題でみる-sbt"><a class="header" href="#例題でみる-sbt">例題でみる sbt</a></h1>
<p>このページは、 <a href="Setup.html">sbt runner をインストール</a>したことを前提とする。</p>
<p>sbt の内部がどうなっているかや理由みたいなことを解説する代わりに、例題を次々と見ていこう。</p>
<h3 id="最小-sbt-ビルドを作る"><a class="header" href="#最小-sbt-ビルドを作る">最小 sbt ビルドを作る</a></h3>
<pre><code class="language-bash">mkdir foo-build
cd foo-build
touch build.sbt
mkdir project
echo "sbt.version=2.0.0-RC6" &gt; project/build.properties
</code></pre>
<h3 id="sbt-シェルを起ち上げる"><a class="header" href="#sbt-シェルを起ち上げる">sbt シェルを起ち上げる</a></h3>
<pre><code class="language-bash">$ sbt
[info] welcome to sbt 2.0.0-RC6 (Azul Systems, Inc. Java)
....
[info] started sbt server
sbt:foo-build&gt;
</code></pre>
<h3 id="sbt-シェルを終了させる"><a class="header" href="#sbt-シェルを終了させる">sbt シェルを終了させる</a></h3>
<p>sbt シェルを終了させるには、<code>exit</code> と入力するか、Ctrl+D (Unix) か Ctrl+Z (Windows) を押す。</p>
<pre><code>sbt:foo-build&gt; exit
</code></pre>
<h3 id="プロジェクトをコンパイルする"><a class="header" href="#プロジェクトをコンパイルする">プロジェクトをコンパイルする</a></h3>
<p>表記の慣例として <code>sbt:...&gt;</code> や <code>&gt;</code> というプロンプトは、sbt シェルに入っていることを意味することにする。</p>
<pre><code class="language-bash">$ sbt
sbt:foo-build&gt; compile
[success] elapsed time: 0 s, cache 0%, 1 onsite task
</code></pre>
<h3 id="コード変更時に再コンパイルする"><a class="header" href="#コード変更時に再コンパイルする">コード変更時に再コンパイルする</a></h3>
<p><code>compile</code> コマンド (やその他のコマンド) を <code>~</code> で始めると、プロジェクト内のソース・ファイルが変更されるたびにそのコマンドが自動的に再実行される。</p>
<pre><code>sbt:foo-build&gt; ~compile
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
[info] 1. Monitoring source files for foo-build/compile...
[info]    Press &lt;enter&gt; to interrupt or '?' for more options.
</code></pre>
<h3 id="ソースファイルを書く"><a class="header" href="#ソースファイルを書く">ソース・ファイルを書く</a></h3>
<p>上記のコマンドは走らせたままにする。別のシェルかファイルマネージャーからプロジェクトのディレクトリへ行って、<code>src/main/scala/example</code> というディレクトリを作る。次に好きなエディタを使って <code>example</code> ディレクトリ内に以下のファイルを作成する:</p>
<pre><code class="language-scala">package example

@main def main(args: String*): Unit =
  println(s"Hello ${args.mkString}")
</code></pre>
<p>この新しいファイルは実行中のコマンドが自動的に検知したはずだ:</p>
<pre><code>[info] Build triggered by /tmp/foo-build/src/main/scala/example/Hello.scala. Running 'compile'.
[info] compiling 1 Scala source to /tmp/foo-build/target/out/jvm/scala-3.3.3/foo/backend ...
[success] elapsed time: 1 s, cache 0%, 1 onsite task
[info] 2. Monitoring source files for foo-build/compile...
[info]    Press &lt;enter&gt; to interrupt or '?' for more options.
</code></pre>
<p><code>~compile</code> を抜けるには <code>Enter</code> を押す。</p>
<h3 id="以前のコマンドを実行する"><a class="header" href="#以前のコマンドを実行する">以前のコマンドを実行する</a></h3>
<p>sbt シェル内で上矢印キーを 2回押して、上で実行した <code>compile</code> コマンドを探す。</p>
<pre><code>sbt:foo-build&gt; compile
</code></pre>
<h3 id="ヘルプを読む"><a class="header" href="#ヘルプを読む">ヘルプを読む</a></h3>
<p><code>help</code> コマンドを使って、基礎コマンドの一覧を表示する。</p>
<pre><code>sbt:foo-build&gt; help

  &lt;command&gt; (; &lt;command&gt;)*                       Runs the provided semicolon-separated commands.
  about                                          Displays basic information about sbt and the build.
  tasks                                          Lists the tasks defined for the current project.
  settings                                       Lists the settings defined for the current project.
  reload                                         (Re)loads the current project or changes to plugins project or returns from it.
  new                                            Creates a new sbt build.
  new                                            Creates a new sbt build.
  projects                                       Lists the names of available projects or temporarily adds/removes extra builds to the session.

....
</code></pre>
<p>特定のタスクの説明を表示させる:</p>
<pre><code>sbt:foo-build&gt; help run
Runs a main class, passing along arguments provided on the command line.
</code></pre>
<h3 id="アプリを実行する"><a class="header" href="#アプリを実行する">アプリを実行する</a></h3>
<pre><code>sbt:foo-build&gt; run
[info] running example.main
Hello
[success] elapsed time: 0 s, cache 50%, 1 disk cache hit, 1 onsite task
</code></pre>
<h3 id="sbt-シェルから-scalaversion-を設定する"><a class="header" href="#sbt-シェルから-scalaversion-を設定する">sbt シェルから scalaVersion を設定する</a></h3>
<pre><code>sbt:foo-build&gt; set scalaVersion := "3.7.3"
[info] Defining scalaVersion
[info] The new value will be used by Compile / bspBuildTarget, Compile / dependencyTreeCrossProjectId and 51 others.
[info]  Run `last` for details.
[info] Reapplying settings...
[info] set current project to foo (in build file:/tmp/foo-build/)
</code></pre>
<p><code>scalaVersion</code> セッティングを確認する:</p>
<pre><code>sbt:foo-build&gt; scalaVersion
[info] 3.7.3
</code></pre>
<h3 id="セッションを-buildsbt-へと保存する"><a class="header" href="#セッションを-buildsbt-へと保存する">セッションを build.sbt へと保存する</a></h3>
<p>アドホックに設定したセッティングは <code>session save</code> で保存できる。</p>
<pre><code>sbt:foo-build&gt; session save
[info] Reapplying settings...
[info] set current project to foo-build (in build file:/tmp/foo-build/)
[warn] build source files have changed
[warn] modified files:
[warn]   /tmp/foo-build/build.sbt
[warn] Apply these changes by running `reload`.
[warn] Automatically reload the build when source changes are detected by setting `Global / onChangedBuildSource := ReloadOnSourceChanges`.
[warn] Disable this warning by setting `Global / onChangedBuildSource := IgnoreSourceChanges`.
</code></pre>
<p><code>build.sbt</code> ファイルは以下のようになったはずだ:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

</code></pre>
<h3 id="プロジェクトに名前を付ける"><a class="header" href="#プロジェクトに名前を付ける">プロジェクトに名前を付ける</a></h3>
<p>エディタを使って、<code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
</code></pre>
<h3 id="ビルドの再読み込み"><a class="header" href="#ビルドの再読み込み">ビルドの再読み込み</a></h3>
<p><code>reload</code> コマンドを使ってビルドを再読み込みする。このコマンドは <code>build.sbt</code> を読み直して、そこに書かれたセッティングを再適用する。</p>
<pre><code>sbt:foo-build&gt; reload
[info] welcome to sbt 2.x (Azul Systems, Inc. Java)
[info] loading project definition from /tmp/foo-build/project
[info] loading settings for project hello from build.sbt ...
[info] set current project to Hello (in build file:/tmp/foo-build/)
sbt:Hello&gt;
</code></pre>
<p>プロンプトが <code>sbt:Hello&gt;</code> に変わったことに注目してほしい。</p>
<h3 id="librarydependencies-に-toolkit-test-を追加する"><a class="header" href="#librarydependencies-に-toolkit-test-を追加する">libraryDependencies に toolkit-test を追加する</a></h3>
<p>エディタを使って、<code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
libraryDependencies += "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test
</code></pre>
<p><code>reload</code> コマンドを使って、<code>build.sbt</code> の変更を反映させる。</p>
<pre><code>sbt:Hello&gt; reload
</code></pre>
<h3 id="差分テストを実行する"><a class="header" href="#差分テストを実行する">差分テストを実行する</a></h3>
<pre><code>sbt:Hello&gt; test
</code></pre>
<h3 id="差分テストを継続的に実行する"><a class="header" href="#差分テストを継続的に実行する">差分テストを継続的に実行する</a></h3>
<pre><code>sbt:Hello&gt; ~test
</code></pre>
<h3 id="テストを書く"><a class="header" href="#テストを書く">テストを書く</a></h3>
<p>上のコマンドを走らせたままで、エディタから <code>src/test/scala/example/HelloSuite.scala</code> という名前のファイルを作成する:</p>
<pre><code class="language-scala">package example

class HelloSuite extends munit.FunSuite:
  test("Hello should start with H") {
    assert("hello".startsWith("H"))
  }
end HelloSuite
</code></pre>
<p><code>~test</code> が検知したはずだ:</p>
<pre><code>example.HelloSuite:
==&gt; X example.HelloSuite.Hello should start with H  0.012s munit.FailException: /tmp/foo-build/src/test/scala/example/HelloSuite.scala:5 assertion failed
4:  test("Hello should start with H") {
5:    assert("hello".startsWith("H"))
6:  }
    at munit.FunSuite.assert(FunSuite.scala:11)
    at example.HelloSuite.$init$$$anonfun$1(HelloSuite.scala:5)
[error] Failed: Total 1, Failed 1, Errors 0, Passed 0
[error] Failed tests:
[error]   example.HelloSuite
[error] (Test / testQuick) sbt.TestsFailedException: Tests unsuccessful
[error] elapsed time: 1 s, cache 50%, 3 disk cache hits, 3 onsite tasks
</code></pre>
<h3 id="テストが通るようにする"><a class="header" href="#テストが通るようにする">テストが通るようにする</a></h3>
<p>エディタを使って <code>src/test/scala/example/HelloSuite.scala</code> を以下のように変更する:</p>
<pre><code class="language-scala">package example

class HelloSuite extends munit.FunSuite:
  test("Hello should start with H") {
    assert("Hello".startsWith("H"))
  }
end HelloSuite
</code></pre>
<p>テストが通過したことを確認して、<code>Enter</code> を押して継続的テストを抜ける。</p>
<h3 id="ライブラリ依存性を追加する"><a class="header" href="#ライブラリ依存性を追加する">ライブラリ依存性を追加する</a></h3>
<p>エディタを使って、<code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
libraryDependencies ++= Seq(
  "org.scala-lang" %% "toolkit" % "0.1.7",
  "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test,
)
</code></pre>
<p><code>reload</code> コマンドを使って、<code>build.sbt</code> の変更を反映させる。</p>
<h3 id="scala-repl-を使う"><a class="header" href="#scala-repl-を使う">Scala REPL を使う</a></h3>
<p>New York の現在の天気を調べてみる。</p>
<pre><code class="language-scala">sbt:Hello&gt; console
Welcome to Scala 3.3.3 (1.8.0_402, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.

scala&gt;
import sttp.client4.quick.*
import sttp.client4.Response

val newYorkLatitude: Double = 40.7143
val newYorkLongitude: Double = -74.006
val response: Response[String] = quickRequest
  .get(
    uri"https://api.open-meteo.com/v1/forecast?latitude=\$newYorkLatitude&amp;longitude=\$newYorkLongitude&amp;current_weather=true"
  )
  .send()

println(ujson.read(response.body).render(indent = 2))

// press Ctrl+D

// Exiting paste mode, now interpreting.

{
  "latitude": 40.710335,
  "longitude": -73.99307,
  "generationtime_ms": 0.36704540252685547,
  "utc_offset_seconds": 0,
  "timezone": "GMT",
  "timezone_abbreviation": "GMT",
  "elevation": 51,
  "current_weather": {
    "temperature": 21.3,
    "windspeed": 16.7,
    "winddirection": 205,
    "weathercode": 3,
    "is_day": 1,
    "time": "2023-08-04T10:00"
  }
}
import sttp.client4.quick._
import sttp.client4.Response
val newYorkLatitude: Double = 40.7143
val newYorkLongitude: Double = -74.006
val response: sttp.client4.Response[String] = Response({"latitude":40.710335,"longitude":-73.99307,"generationtime_ms":0.36704540252685547,"utc_offset_seconds":0,"timezone":"GMT","timezone_abbreviation":"GMT","elevation":51.0,"current_weather":{"temperature":21.3,"windspeed":16.7,"winddirection":205.0,"weathercode":3,"is_day":1,"time":"2023-08-04T10:00"}},200,,List(:status: 200, content-encoding: deflate, content-type: application/json; charset=utf-8, date: Fri, 04 Aug 2023 10:09:11 GMT),List(),RequestMetadata(GET,https://api.open-meteo.com/v1/forecast?latitude=40.7143&amp;longitude...

scala&gt; :q // to quit
</code></pre>
<h3 id="サブプロジェクトを作成する"><a class="header" href="#サブプロジェクトを作成する">サブプロジェクトを作成する</a></h3>
<p><code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

lazy val hello = project
  .in(file("."))
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core"
  )
</code></pre>
<p><code>reload</code> コマンドを使って、<code>build.sbt</code> の変更を反映させる。</p>
<h3 id="全てのサブプロジェクトを列挙する"><a class="header" href="#全てのサブプロジェクトを列挙する">全てのサブプロジェクトを列挙する</a></h3>
<pre><code>sbt:Hello&gt; projects
[info] In file:/tmp/foo-build/
[info]   * hello
[info]     helloCore
</code></pre>
<h3 id="サブプロジェクトをコンパイルする"><a class="header" href="#サブプロジェクトをコンパイルする">サブプロジェクトをコンパイルする</a></h3>
<pre><code>sbt:Hello&gt; helloCore/compile
</code></pre>
<h3 id="サブプロジェクトに-toolkit-test-を追加する"><a class="header" href="#サブプロジェクトに-toolkit-test-を追加する">サブプロジェクトに toolkit-test を追加する</a></h3>
<p><code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      toolkitTest % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<h3 id="コマンドをブロードキャストする"><a class="header" href="#コマンドをブロードキャストする">コマンドをブロードキャストする</a></h3>
<p><code>hello</code> に送ったコマンドを <code>helloCore</code> にもブロードキャストするために集約を設定する:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .aggregate(helloCore)
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      toolkitTest % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<p><code>reload</code> 後、<code>~test</code> は両方のサブプロジェクトに作用する:</p>
<pre><code class="language-scala">sbt:Hello&gt; ~test
</code></pre>
<p><code>Enter</code> を押して継続的テストを抜ける。</p>
<h3 id="hello-が-hellocore-に依存するようにする"><a class="header" href="#hello-が-hellocore-に依存するようにする">hello が helloCore に依存するようにする</a></h3>
<p>サブプロジェクト間の依存関係を定義するには <code>.dependsOn(...)</code> を使う。ついでに、toolkit への依存性も <code>helloCore</code> に移そう。</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := "Hello",
    libraryDependencies += toolkitTest % Test
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += "org.scala-lang" %% "toolkit" % "0.1.7",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<h3 id="ujson-を使って-json-をパースする"><a class="header" href="#ujson-を使って-json-をパースする">uJson を使って JSON をパースする</a></h3>
<p><code>helloCore</code> に uJson を追加しよう。</p>
<p><code>core/src/main/scala/example/core/Weather.scala</code> を追加する:</p>
<pre><code class="language-scala">package example.core

import sttp.client4.quick._
import sttp.client4.Response

object Weather:
  def temp() =
    val response: Response[String] = quickRequest
      .get(
        uri"https://api.open-meteo.com/v1/forecast?latitude=40.7143&amp;longitude=-74.006&amp;current_weather=true"
      )
      .send()
    val json = ujson.read(response.body)
    json.obj("current_weather")("temperature").num
end Weather
</code></pre>
<p>次に <code>src/main/scala/example/Hello.scala</code> を以下のように変更する:</p>
<pre><code class="language-scala">package example

import example.core.Weather

@main def main(args: String*): Unit =
  val temp = Weather.temp()
  println(s"Hello! The current temperature in New York is $temp C.")
</code></pre>
<p>アプリを走らせてみて、うまくいったか確認する:</p>
<pre><code>sbt:Hello&gt; run
[info] compiling 1 Scala source to /tmp/foo-build/core/target/scala-2.13/classes ...
[info] compiling 1 Scala source to /tmp/foo-build/target/scala-2.13/classes ...
[info] running example.Hello
Hello! The current temperature in New York is 22.7 C.
</code></pre>
<!--
### Add sbt-native-packager plugin

Using an editor, create `project/plugins.sbt`:

@@snip [example-weather-plugins]($root$/src/sbt-test/ref/example-weather/changes/plugins.sbt) {}

Next change `build.sbt` as follows to add `JavaAppPackaging`:

@@snip [example-weather-build2]($root$/src/sbt-test/ref/example-weather/changes/build.sbt) {}

### Reload and create a .zip distribution

```
sbt:Hello> reload
...
sbt:Hello> dist
[info] Wrote /private/tmp/foo-build/target/scala-2.13/hello_2.13-0.1.0-SNAPSHOT.pom
[info] Main Scala API documentation to /tmp/foo-build/target/scala-2.13/api...
[info] Main Scala API documentation successful.
[info] Main Scala API documentation to /tmp/foo-build/core/target/scala-2.13/api...
[info] Wrote /tmp/foo-build/core/target/scala-2.13/hello-core_2.13-0.1.0-SNAPSHOT.pom
[info] Main Scala API documentation successful.
[success] All package validations passed
[info] Your package is ready in /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
```

Here's how you can run the packaged app:

```
$ /tmp/someother
$ cd /tmp/someother
$ unzip -o -d /tmp/someother /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
$ ./hello-0.1.0-SNAPSHOT/bin/hello
Hello! The current temperature in New York is 22.7 C.
```

### Dockerize your app

_Note that a Docker daemon will need to be running in order for this to work._

```
sbt:Hello> Docker/publishLocal
....
[info] Built image hello with tags [0.1.0-SNAPSHOT]
```

Here's how to run the Dockerized app:

```
$ docker run hello:0.1.0-SNAPSHOT
Hello! The current temperature in New York is 22.7 C.
```

### Set the version

Change `build.sbt` as follows:

@@snip [example-weather-build3]($root$/src/sbt-test/ref/example-weather/changes/build3.sbt) {}

-->
<h3 id="一時的に-scalaversion-を変更する"><a class="header" href="#一時的に-scalaversion-を変更する">一時的に scalaVersion を変更する</a></h3>
<pre><code>sbt:Hello&gt; ++3.3.3!
[info] Forcing Scala version to 3.3.3 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
</code></pre>
<p><code>scalaVersion</code> セッティングを確認する:</p>
<pre><code>sbt:Hello&gt; scalaVersion
[info] helloCore / scalaVersion
[info]  3.3.3
[info] scalaVersion
[info]  3.3.3
</code></pre>
<p>このセッティングは <code>reload</code> 後には無効となる。</p>
<!--
### Inspect the dist task

To find out more about `dist`, try `help` and `inspect`.

```scala
sbt:Hello> help dist
Creates the distribution packages.
sbt:Hello> inspect dist
```

To call inspect recursively on the dependency tasks use `inspect tree`.

```scala
sbt:Hello> inspect tree dist
[info] dist = Task[java.io.File]
[info]   +-Universal / dist = Task[java.io.File]
....
```

-->
<h3 id="バッチモード"><a class="header" href="#バッチモード">バッチ・モード</a></h3>
<p>sbt のコマンドをターミナルから直接渡して sbt をバッチモードで実行することができる。</p>
<pre><code>$ sbt clean "testOnly HelloSuite"
</code></pre>
<h3 id="sbt-new-コマンド"><a class="header" href="#sbt-new-コマンド">sbt new コマンド</a></h3>
<p>sbt <code>new</code> コマンドを使って手早く簡単な Hello world ビルドをセットアップすることができる。</p>
<pre><code>$ sbt new scala/scala-seed.g8
....
A minimal Scala project.

name [My Something Project]: hello

Template applied in ./hello
</code></pre>
<p>プロジェクト名を入力するプロンプトが出てきたら <code>hello</code> と入力する。</p>
<p>これで、<code>hello</code> ディレクトリ以下に新しいプロジェクトができた。</p>
<h3 id="クレジット"><a class="header" href="#クレジット">クレジット</a></h3>
<p>本ページは William “Scala William” Narmontas さん作の <a href="https://www.scalawilliam.com/essential-sbt/">Essential sbt</a> というチュートリアルに基づいて書かれた。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-入門"><a class="header" href="#sbt-入門">sbt 入門</a></h1>
<p>sbt は、柔軟かつ強力なビルド定義を持つが、それを裏付けるいくつかの概念がある。それらの概念は数こそ多くはないが、sbt は他のビルドシステムとは少し違うので、ドキュメントを読まずに使おうとすると、きっと細かい点でつまづいてしまうだろう。</p>
<p>この sbt 入門ガイドでは、sbt ビルド定義を作成してメンテナンスしていく上で知っておくべき概念を説明していく。</p>
<p>このガイドを一通り読んでおくことを強く推奨したい。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-の存在理由"><a class="header" href="#sbt-の存在理由">sbt の存在理由</a></h1>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p><a href="https://docs.scala-lang.org/scala3/book/taste-hello-world.html">Scala 3 Book</a> に書かれてある通り、Scala においてライブラリやプログラムは Scala コンパイラ <code>scalac</code> によってコンパイルされる:</p>
<pre><code class="language-scala">@main def hello() = println("Hello, World!")
</code></pre>
<pre><code class="language-bash">$ scalac hello.scala
$ scala hello
Hello, World!
</code></pre>
<p>いちいち毎回 <code>scalac</code> に全ての Scala ソースファイル名を直接渡すのは面倒だし遅い。</p>
<p>さらに、例題的なプログラム以外のものを書こうとすると普通はライブラリ依存性を持つことになり、つまり間接的なライブラリ依存を持つことにもなる。Scala エコシステムは、Scala 2.12系、2.13系、3.x系、JVMプラットフォーム、 JSプラットフォーム、 Native プラットフォームなどがあるため二重、三重に複雑な問題だ。</p>
<p>JAR ファイルや <code>scalac</code> を直接用いるという代わりに、サブプロジェクトという抽象概念とビルドツールを導入することで、無意味に非効率的な苦労を回避することができる。</p>
<h2 id="sbt"><a class="header" href="#sbt">sbt</a></h2>
<p><strong>sbt</strong> は主に Scala と Java のためのシンプルなビルド・ツールだ。sbt を使うことで、サブプロジェクトおよびそれらの依存性、カスタム・タスクを宣言することができ、高速かつ再現性のあるビルドを得ることができる。</p>
<p>この目標のため、sbt はいくつかのことを行う:</p>
<ul>
<li>sbt 自身のバージョンは <code>project/build.properties</code> にて指定される。</li>
<li><strong>build.sbt DSL</strong> という DSL (ドメイン特定言語) を定義し、<code>build.sbt</code> にて Scala バージョンその他のサブプロジェクトに関する情報を宣言できるようにする。</li>
<li>Cousier を用いてサブプロジェクトのライブラリ依存性や間接的依存性を取得する。</li>
<li>Zinc を呼び出して Scala や Java ソースの差分コンパイルを行う。</li>
<li>可能な限り、タスクを並列実行する。</li>
<li>JVM エコシステム全般と相互乗り入れが可能なように、パッケージが Maven リポジトリにどのように公開されるべきかの慣習を定義する。</li>
</ul>
<p>sbt は、プログラムやライブラリのビルドに必要なコマンド実装の大部分を標準化していると言っても過言ではない。</p>
<h2 id="buildsbt-dsl-の必要性"><a class="header" href="#buildsbt-dsl-の必要性">build.sbt DSL の必要性</a></h2>
<p>sbt はサブプロジェクトとタスクグラフを宣言するのに Scala 言語をベースとする build.sbt DSL を採用する。昨今では、YAML や XML といった設定形式の代わりに DSL を使っていることは sbt に限らない。Gradle、Google 由来の Bazel 、Meta の Buck、Apple の SwiftPM など多くのビルドツールが DSL を用いてサブプロジェクトを定義する。</p>
<p><code>build.sbt</code> は、<code>scalaVersion</code> と <code>libraryDependencies</code> のみを宣言すればあたかも YAML ファイルのように始めることができるが、ビルドシステムへの要求が高度になってもスケールすることができる。</p>
<ul>
<li>ライブラリのためのバージョン番号など同じ情報の繰り返しを回避するため、<code>build.sbt</code> は <code>val</code> を使って変数を宣言できる。</li>
<li>セッティングやタスクの定義内で必要に応じて <code>if</code> のような Scala 言語の言語構文を使うことができる。</li>
<li>セッティングやタスクが静的型付けされているため、ビルドが始まる前にタイポミスや型の間違いなどをキャッチできる。型は、タスク間でのデータの受け渡しにも役立つ。</li>
<li><code>Initialized[Task[A]]</code> を用いた<strong>構造的並行性</strong>を提供する。この DSL はいわゆる「直接スタイル」な <code>.value</code> 構文を用いて簡潔にタスクグラフを定義することができる。</li>
<li>プラグインを通して sbt の機能を拡張して、カスタム・タスクや Scala.JS といった言語拡張を行うという強力な権限をコミュニティーに与えている。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新しいビルドの作成"><a class="header" href="#新しいビルドの作成">新しいビルドの作成</a></h1>
<p>新しいビルドを作成するには、<code>sbt new</code> を使う。</p>
<pre><code class="language-bash">$ mkdir /tmp/foo
$ cd /tmp/foo
$ sbt new

Welcome to sbt new!
Here are some templates to get started:
 a) scala/toolkit.local               - Scala Toolkit (beta) by Scala Center and VirtusLab
 b) typelevel/toolkit.local           - Toolkit to start building Typelevel apps
 c) sbt/cross-platform.local          - A cross-JVM/JS/Native project
 d) scala/scala3.g8                   - Scala 3 seed template
 e) scala/scala-seed.g8               - Scala 2 seed template
 f) playframework/play-scala-seed.g8  - A Play project in Scala
 g) playframework/play-java-seed.g8   - A Play project in Java
 i) softwaremill/tapir.g8             - A tapir project using Netty
 m) scala-js/vite.g8                  - A Scala.JS + Vite project
 n) holdenk/sparkProjectTemplate.g8   - A Scala Spark project
 o) spotify/scio.g8                   - A Scio project
 p) disneystreaming/smithy4s.g8       - A Smithy4s project
 q) quit
Select a template:
</code></pre>
<p>「a」を選択すると、いくつかの質問が追加で表示される:</p>
<pre><code class="language-bash">Select a template: a
Scala version (default: 3.3.0):
Scala Toolkit version (default: 0.2.0):
</code></pre>
<p>リターンキーを押せば、デフォルト値が選択される。</p>
<pre><code>[info] Updated file /private/tmp/bar/project/build.properties: set sbt.version to 1.9.8
[info] welcome to sbt 1.9.8 (Azul Systems, Inc. Java 1.8.0_352)
....
[info] set current project to bar (in build file:/private/tmp/foo/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/d0ac1409c0117a949d47/sock
[info] started sbt server
sbt:bar&gt; exit
[info] shutting down sbt server
</code></pre>
<p>以下はこのテンプレートによって作成されたファイルだ:</p>
<pre><code class="language-bash">.
├── build.sbt
├── project
│   └── build.properties
├── src
│   ├── main
│   │   └── scala
│   │       └── example
│   │           └── Main.scala
│   └── test
│       └── scala
│           └── example
│               └── ExampleSuite.scala
└── target
</code></pre>
<p><code>build.sbt</code> ファイルを見ていこう:</p>
<pre><code class="language-scala">val toolkitV = "0.2.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV

scalaVersion := "3.3.0"
libraryDependencies += toolkit
libraryDependencies += (toolkitTest % Test)
</code></pre>
<p>これは、<strong>ビルド定義</strong>と呼ばれ、sbt がプロジェクトをコンパイルするのに必要な情報が記述されている。これは、<code>.sbt</code> 形式という Scala 言語のサブセットで書かれている。</p>
<p>以下は <code>src/main/scala/example/Main.scala</code> の内容だ:</p>
<pre><code class="language-scala">package example

@main def main(args: String*): Unit =
  println(s"Hello ${args.mkString}")
</code></pre>
<p>これは、Hello world のテンプレートだ。これを実行するには、<code>sbt --client</code> と打ち込んで sbt シェルを起動して、シェル内から <code>run &lt;名前&gt;</code> と入力する:</p>
<pre><code>$ sbt --client
[info] entering *experimental* thin client - BEEP WHIRR
[info] server was not detected. starting an instance
....
info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:bar&gt; run Raj
[info] running example.main Raj
Hello Raj
[success] Total time: 0 s, completed Feb 18, 2024 2:38:10 PM
</code></pre>
<h3 id="giter8-テンプレート"><a class="header" href="#giter8-テンプレート">Giter8 テンプレート</a></h3>
<p><code>.local</code> テンプレートもいくつかあるが、基本的に <code>sbt new</code> は <a href="https://www.foundweekends.org/giter8/">Giter8</a> と統合して GitHub 上でホスティングされるテンプレートを開く。例えば、<code>scala/scala3.g8</code> は Scala チームによりメンテナンスされ、新しい Scala 3 のビルドを作成する:</p>
<pre><code>$ /tmp
$ sbt new scala/scala3.g8
</code></pre>
<p><a href="https://github.com/foundweekends/giter8/wiki/giter8-templates">Giter8 wiki</a> では 100 以上のテンプレートが列挙されていて、新しいビルドを手早く作ることができる。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-のコンポーネント"><a class="header" href="#sbt-のコンポーネント">sbt のコンポーネント</a></h1>
<h2 id="sbt-runner"><a class="header" href="#sbt-runner">sbt runner</a></h2>
<p>sbt のビルドは、「<code>sbt</code> という名前のシェルスクリプト」によって実行され、このスクリプトは sbt runner と呼ばれる。</p>
<h3 id="projectbuildproperties-による-sbt-バージョンの指定"><a class="header" href="#projectbuildproperties-による-sbt-バージョンの指定">project/build.properties による sbt バージョンの指定</a></h3>
<p>sbt runner は、そのサブコンポーネントである sbt launcher を実行し、sbt launcher は <code>project/build.properties</code> を読み込んで、そのビルドに使われる sbt のバージョンを決定し、キャッシュに無ければ sbt 本体をダウンロードする:</p>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
<p>これは、つまり</p>
<ul>
<li>ビルドをチェックアウトした人が、各々の sbt runner のバージョンに関わらわず、同一の sbt のバージョンを実行し</li>
<li>sbt 本体のバージョンは git のようなバージョン管理システムによって管理されることを意味する</li>
</ul>
<h3 id="sbtn-sbt---client"><a class="header" href="#sbtn-sbt---client">sbtn (<code>sbt --client</code>)</a></h3>
<p>sbtn (native thin client) は sbt runner のサブコンポーネントの一つで、sbt runner に <code>--client</code> フラグを渡すと呼ばれ、sbt server にコマンドを送信するのに使われる。名前に n が付いているのは、それが GraalVM native-image によってネーティブ・コードにコンパイルされていることに由来する。sbtn と sbt server は安定しているため、最近の sbt のバージョンなら大体動作するようになっている。</p>
<h2 id="sbt-server-sbt---server"><a class="header" href="#sbt-server-sbt---server">sbt server (<code>sbt --server</code>)</a></h2>
<p>sbt server は、ビルドツール本体で、そのバージョンは <code>project/build.properties</code> によって指定される。sbt server は、sbtn やエディタから注文を受け取るレジ係の役割を持つ。</p>
<h3 id="coursier"><a class="header" href="#coursier">Coursier</a></h3>
<p>sbt server は、そのサブコンポーネントとして <a href="https://get-coursier.io/">Couriser</a> を実行して、Scala 標準ライブラリ、Scala コンパイラ、ビルドで使われるその他のライブラリ依存性の解決を行う。</p>
<h3 id="zinc"><a class="header" href="#zinc">Zinc</a></h3>
<p>Zinc は、sbt プロジェクトにより開発、メンテされている、Scala の差分コンパイラだ。Zinc の側面として見落とされがちなのは、Zinc は<strong>ここ数年に出た全てのバージョン</strong>の Scala コンパイラに対する安定した API を提供しているということがある。Coursier がどんな Scala バージョンでも解決できることと合わせると、sbt は <code>build.sbt</code> に一行書くだけで、ここ数年に出たどのバージョンの Scala でも走らせることができる:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<h3 id="bsp-server"><a class="header" href="#bsp-server">BSP server</a></h3>
<p>sbt server は <a href="https://build-server-protocol.github.io/">Build Server Protocol (BSP)</a> をサポートして、ビルド対象の列挙、ビルドの実行、その他を行うことができる。これにより、IntelliJ や Metals といった IDE が既に実行中の sbt server  とコードを用いて通信することが可能となる。</p>
<h2 id="sbt-server-との接続"><a class="header" href="#sbt-server-との接続">sbt server との接続</a></h2>
<p>sbt server との接続方法を 3通りみていく。</p>
<h3 id="sbtn-を用いた-sbt-シェル"><a class="header" href="#sbtn-を用いた-sbt-シェル">sbtn を用いた sbt シェル</a></h3>
<p>ビルドのワーキング・ディレクトリ内で <code>sbt</code> を実行する:</p>
<pre><code class="language-bash">sbt
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/sbt-components.html#admonition-note"></a>
</div>
<div>
<p>In sbt 1.x, equivalent command was <code>sbt --client</code></p>
</div>
</div>
<p>これは以下のように表示されるはずだ:</p>
<pre><code class="language-bash">$ sbt
[info] server was not detected. starting an instance
[info] welcome to sbt 2.0.0-alpha7 (Azul Systems, Inc. Java 1.8.0_352)
[info] loading project definition from /private/tmp/bar/project
[info] loading settings for project bar from build.sbt ...
[info] set current project to bar (in build file:/private/tmp/bar/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/2.0.0-alpha7/server/d0ac1409c0117a949d47/sock
[info] started sbt server
[info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:bar&gt;
</code></pre>
<p>sbt をコマンドラインの引数無しで実行すると、sbt シェルが起動する。sbt シェルは、コマンド打ち込むためのプロンプトを持つが、タブ補完が効き、履歴も持っている。</p>
<p>例えば、sbt シェルに <code>compile</code> と打ち込むことができる:</p>
<pre><code class="language-bash">sbt:bar&gt; compile
</code></pre>
<p><code>compile</code> を再実行するには、上矢印を押下して、リターンキーを押す。</p>
<p>sbt シェルを中止するには、<code>exit</code> と打ち込むか、 <code>Ctrl-D</code> (Unix) もしくは <code>Ctrl-Z</code> (Windows) を使う。</p>
<h3 id="sbtn-を用いたバッチモード"><a class="header" href="#sbtn-を用いたバッチモード">sbtn を用いたバッチ・モード</a></h3>
<p>sbt をバッチ・モードで使うことも可能だ:</p>
<pre><code class="language-bash">sbt compile
sbt testOnly TestA
</code></pre>
<pre><code class="language-bash">$ sbt compile
&gt; compile
</code></pre>
<h3 id="sbt-server-のシャットダウン"><a class="header" href="#sbt-server-のシャットダウン">sbt server のシャットダウン</a></h3>
<p>マシン上の sbt server を全てシャットダウンするには以下を実行する:</p>
<pre><code class="language-bash">sbt shutdownall
</code></pre>
<p>現行のものだけをシャットダウンするには以下を実行する:</p>
<pre><code class="language-bash">sbt shutdown
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本タスク"><a class="header" href="#基本タスク">基本タスク</a></h1>
<p>このページは sbt をセットアップした後の、基本的な使い方を解説する。このページは、<a href="guide/./sbt-components.html">sbt のコンポーネント</a>を既に読んだことを前提とする。</p>
<p>sbt を使っているリポジトリを pull してきたら、手軽に使ってみることができる。まずは、GitHub などから、リポジトリを選んでチェックアウトする。</p>
<pre><code class="language-bash">$ git clone https://github.com/scalanlp/breeze.git
$ cd breeze
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/basic-tasks.html#admonition-note"></a>
</div>
<div>
<p>scalanlp/breeze は sbt 1.x を使っているが、ここでは sbt 2.x を使っている想定で書いていく。</p>
</div>
</div>
<h3 id="sbtn-を用いた-sbt-シェル-1"><a class="header" href="#sbtn-を用いた-sbt-シェル-1">sbtn を用いた sbt シェル</a></h3>
<p><a href="guide/./sbt-components.html">sbt のコンポーネント</a> でも言及されたように、sbt シェルを起動する:</p>
<pre><code>$ sbt
</code></pre>
<p>これは以下のように表示されるはずだ:</p>
<pre><code class="language-bash">$ sbt
[info] entering *experimental* thin client - BEEP WHIRR
[info] server was not detected. starting an instance
[info] welcome to sbt 1.5.5 (Azul Systems, Inc. Java 1.8.0_352)
[info] loading global plugins from /Users/eed3si9n/.sbt/1.0/plugins
[info] loading settings for project breeze-build from plugins.sbt ...
[info] loading project definition from /private/tmp/breeze/project
Downloading https://repo1.maven.org/maven2/org/scalanlp/sbt-breeze-expand-codegen_2.12_1.0/0.2.1/sbt-breeze-expand-codegen-0.2.1.pom
....
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/dd982e07e85c7de1b618/sock
[info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:breeze-parent&gt;
</code></pre>
<h2 id="projects-コマンド"><a class="header" href="#projects-コマンド">projects コマンド</a></h2>
<p>まずは手始めに、<code>projects</code> コマンドを使ってサブプロジェクトを列挙してみる:</p>
<pre><code>sbt:breeze-parent&gt; projects
[info] In file:/private/tmp/breeze/
[info]     benchmark
[info]     macros
[info]     math
[info]     natives
[info]   * root
[info]     viz
</code></pre>
<p>現行のサプブロジェクト <code>root</code> を含み、合計 6つのをサブプロジェクトを持つビルドであることが分かる。</p>
<h2 id="tasks-コマンド"><a class="header" href="#tasks-コマンド">tasks コマンド</a></h2>
<p>同様に、<code>tasks</code> コマンドを用いて、このビルドが持つ全タスクを列挙することができる:</p>
<pre><code>sbt:breeze-parent&gt; tasks

This is a list of tasks defined for the current project.
It does not list the scopes the tasks are defined in; use the 'inspect' command for that.
Tasks produce values.  Use the 'show' command to run the task and print the resulting value.

  bgRun            Start an application's default main class as a background job
  bgRunMain        Start a provided main class as a background job
  clean            Deletes files produced by the build, such as generated sources, compiled classes, and task caches.
  compile          Compiles sources.
  console          Starts the Scala interpreter with the project classes on the classpath.
  consoleProject   Starts the Scala interpreter with the sbt and the build definition on the classpath and useful imports.
  consoleQuick     Starts the Scala interpreter with the project dependencies on the classpath.
  copyResources    Copies resources to the output directory.
  doc              Generates API documentation.
  package          Produces the main artifact, such as a binary jar.  This is typically an alias for the task that actually does the packaging.
  packageBin       Produces a main artifact, such as a binary jar.
  packageDoc       Produces a documentation artifact, such as a jar containing API documentation.
  packageSrc       Produces a source artifact, such as a jar containing sources and resources.
  publish          Publishes artifacts to a repository.
  publishLocal     Publishes artifacts to the local Ivy repository.
  publishM2        Publishes artifacts to the local Maven repository.
  run              Runs a main class, passing along arguments provided on the command line.
  runMain          Runs the main class selected by the first argument, passing the remaining arguments to the main method.
  test             Executes all tests.
  testOnly         Executes the tests provided as arguments or all tests if no arguments are provided.
  testQuick        Executes the tests that either failed before, were not run or whose transitive dependencies changed, among those provided as arguments.
  update           Resolves and optionally retrieves dependencies, producing a report.

More tasks may be viewed by increasing verbosity.  See 'help tasks'
</code></pre>
<h3 id="compile"><a class="header" href="#compile">compile</a></h3>
<p><code>compile</code> タスクは、ライブラリ依存性の解決とダウンロードを行った後に、ソースのコンパイルを行う。</p>
<pre><code>&gt; compile
</code></pre>
<p>これは以下のように表示されるはずだ:</p>
<pre><code>sbt:breeze-parent&gt; compile
[info] compiling 341 Scala sources and 1 Java source to /private/tmp/breeze/math/target/scala-3.1.3/classes ...
  | =&gt; math / Compile / compileIncremental 51s
</code></pre>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p><code>run</code> タスクは、サブプロジェクトのメインクラスを実行する。sbt シェルから <code>math/run</code> と打ち込む:</p>
<pre><code>&gt; math/run
</code></pre>
<p><code>math/run</code> は、<code>math</code> サブプロジェクトにスコープ付けされた <code>run</code> タスクを意味する。これは、以下のように表示されるはずだ:</p>
<pre><code>sbt:breeze-parent&gt; math/run
[info] Scala version: 3.1.3 true
....

Multiple main classes detected. Select one to run:
 [1] breeze.optimize.linear.NNLS
 [2] breeze.optimize.proximal.NonlinearMinimizer
 [3] breeze.optimize.proximal.QuadraticMinimizer
 [4] breeze.util.UpdateSerializedObjects

Enter number:
</code></pre>
<p>プロンプトには <code>1</code> と入力する。</p>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p><code>test</code> タスクは、以前に失敗したテスト、未だ実行されていないテスト、及び間接的依存性に変化があったテストを実行する。</p>
<pre><code>&gt; math/test
</code></pre>
<p>これは以下のように表示されるはずだ:</p>
<pre><code>sbt:breeze-parent&gt; math/testQuick
[info] FeatureVectorTest:
[info] - axpy fv dv (1 second, 106 milliseconds)
[info] - axpy fv vb (9 milliseconds)
[info] - DM mult (19 milliseconds)
[info] - CSC mult (32 milliseconds)
[info] - DM trans mult (4 milliseconds)
....
[info] Run completed in 58 seconds, 183 milliseconds.
[info] Total number of tests run: 1285
[info] Suites: completed 168, aborted 0
[info] Tests: succeeded 1285, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 130 s (02:10), completed Feb 19, 2024
</code></pre>
<h2 id="watch-チルダ-コマンド"><a class="header" href="#watch-チルダ-コマンド">watch (チルダ) コマンド</a></h2>
<p>編集-コンパイル-テストの一連のサイクルの高速化のために、ソースが保存されるたびに自動的に再コンパイルか再テストを行うように sbt に命令することができる。</p>
<p>コマンドの前に <code>~</code> を付けることで、ファイルが変更されるたびに自動的にそのコマンドが実行されるようになる。例えば、sbt シェルから以下のように打ち込む:</p>
<pre><code>&gt; ~test
</code></pre>
<p>リターンキーを押下して、監視を中止する。<code>~</code> の前置記法は sbt シェルからもバッチ・モードからでも使用可能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ビルド定義の基本"><a class="header" href="#ビルド定義の基本">ビルド定義の基本</a></h1>
<p>このページは <code>build.sbt</code> のビルド定義を解説する。</p>
<h3 id="ビルド定義とは何か"><a class="header" href="#ビルド定義とは何か">ビルド定義とは何か</a></h3>
<p><strong>ビルド定義</strong>は、<code>build.sbt</code> にて定義され、プロジェクト (型は <code>Project</code>) の集合によって構成される。 <strong>プロジェクト</strong>という用語が曖昧であることがあるため、このガイドではこれらを<strong>サブプロジェクト</strong>と呼ぶことが多い。</p>
<p>例えば、カレントディレクトリにあるサブプロジェクトは <code>build.sbt</code> に以下のように定義できる：</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
name := "Hello"
</code></pre>
<p>より明示的に書くと:</p>
<pre><code class="language-scala">lazy val root = (project in file("."))
  .settings(
    scalaVersion := "3.3.3",
    name := "Hello",
  )
</code></pre>
<p>それぞれのサブプロジェクトは、キーと値のペアによって詳細が設定される。例えば、<code>name</code> というキーがあるが、それはサブプロジェクト名という文字列の値に関連付けられる。キーと値のペア列は <code>.settings(...)</code> メソッド内に列挙される。</p>
<h2 id="buildsbt-dsl"><a class="header" href="#buildsbt-dsl">build.sbt DSL</a></h2>
<p><code>build.sbt</code> は、Scala に基づいた build.sbt DSL と呼ばれるドメイン特定言語 (DSL) を用いてサブプロジェクトを定義する。まずは <code>scalaVersion</code> と <code>libraryDependencies</code> のみを宣言して、YAML ファイルのように <code>build.sbt</code> を使うことができるが、ビルドの成長に応じてその他の機能を使ってビルド定義を整理することができる。</p>
<h3 id="型付けされたセッティング式"><a class="header" href="#型付けされたセッティング式">型付けされたセッティング式</a></h3>
<p><code>build.sbt</code> DSL をより詳しくみていこう:</p>
<pre><code class="language-scala">organization  :=         "com.example"
^^^^^^^^^^^^  ^^^^^^^^   ^^^^^^^^^^^^^
key           operator   (setting/task) body
</code></pre>
<p>それぞれのエントリーは<strong>セッティング式</strong>と呼ばれる。セッティング式にはタスク式と呼ばれるものもある。この違いは後で説明する。</p>
<p>セッティング式は以下の 3部から構成される:</p>
<ol>
<li>左辺項を<strong>キー</strong> (key) という。</li>
<li><strong>演算子</strong>。この場合は <code>:=</code>。</li>
<li>右辺項は<strong>本文</strong> (body)、もしくはセッティング本文という。</li>
</ol>
<p>左辺値の <code>name</code>、<code>version</code>、および <code>scalaVersion</code> はキーである。 キーは <a href="guide/../../api/sbt/SettingKey.html"><code>SettingKey[A]</code></a>、 <a href="guide/../../api/sbt/TaskKey.html"><code>TaskKey[A]</code></a>、もしくは <a href="guide/../../api/sbt/InputKey.html"><code>InputKey[A]</code></a> のインスタンスで、 <code>A</code> はその値の型である。キーの種類に関しては後述する。</p>
<p><code>name</code> キーは <code>SettingKey[String]</code> に型付けされているため、 <code>name</code> の <code>:=</code> 演算子も <code>String</code> に型付けされている。これにより、誤った型の値を使おうとするとビルド定義はコンパイルエラーになる:</p>
<pre><code class="language-scala">name := 42 // コンパイルできない
</code></pre>
<h3 id="val-と-lazy-val"><a class="header" href="#val-と-lazy-val"><code>val</code> と <code>lazy val</code></a></h3>
<p>ライブラリのバージョン番号など同じ情報の繰り返しを避けるために、<code>build.sbt</code> 内の任意の行に <code>val</code>、<code>lazy val</code>、<code>def</code> を書くことができる。</p>
<pre><code class="language-scala">val toolkitV = "0.2.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV

scalaVersion := "3.7.3"
libraryDependencies += toolkit
libraryDependencies += (toolkitTest % Test)
</code></pre>
<p>上の例で <code>val</code> は変数を定義し、上の行から順に初期化される。そのため、<code>toolkitV</code> が参照される前に定義される必要がある。</p>
<p>以下は悪い例:</p>
<pre><code class="language-scala">// 悪い例
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV // 未初期化の参照!
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV // 未初期化の参照!
val toolkitV = "0.2.0"
</code></pre>
<p><code>build.sbt</code> に未初期化の事前参照を含む場合、sbt は <code>NullPointerException</code> による <code>java.lang.ExceptionInInitializerError</code> を投げて起動に失敗する。これをコンパイラに直させる方法の 1つとして、変数に <code>lazy</code> を付けて遅延変数として定義するという方法がある:</p>
<pre><code class="language-scala">lazy val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
lazy val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV
lazy val toolkitV = "0.2.0"
</code></pre>
<p>何でも <code>lazy val</code> を付けるのに渋い顔をする人もいるかもしれないが、僕たちは Scala 3 の <code>lazy val</code> は効率が良く、ビルド定義をコピー・ペーストに対して堅牢にすると思っている。</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/build-definition-basics.html#admonition-note"></a>
</div>
<div>
<p><code>build.sbt</code> トップレベルでのクラスやオブジェクトの定義は禁止されている。
それらは、<code>project/</code> ディレクトリ内の Scala ソース内に書かれる。</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ライブラリ依存性の基本"><a class="header" href="#ライブラリ依存性の基本">ライブラリ依存性の基本</a></h1>
<p>このページは、sbt を使ったライブラリ依存性管理の基本を説明する。</p>
<p>sbt はマネージ依存性 (managed dependency) を実装するのに内部で <a href="https://get-coursier.io/">Coursier</a> を採用していて、Coursier、npm、PIP などのパッケージ管理を使った事がある人は違和感無く入り込めるだろう。</p>
<div id="admonition-マネージ依存性とは何か" class="admonition admonish-note" role="note" aria-labelledby="admonition-マネージ依存性とは何か-title">
<div class="admonition-title">
<div id="admonition-マネージ依存性とは何か-title">
<p>マネージ依存性とは何か</p>
</div>
<a class="admonition-anchor-link" href="guide/library-dependency-basics.html#admonition-マネージ依存性とは何か"></a>
</div>
<div>
<p>JAR ファイルを 1つ 1つ手でダウンロードする (アンマネージ依存性) 代わりに、マネージ依存性システムはサブプロジェクトで使われる外部ライブラリの取得を自動化する。Coursier のようなツールは宣言された <code>ModuleID</code> 列を解釈して、依存性解決 (全ての間接的依存性を展開して、バージョン衝突を解決して、正確なバージョンを決定する) を行い、結果となったアーティファクトをダウンロードしキャッシュして、一貫性のある JAR 管理を保証する。</p>
</div>
</div>
<h2 id="librarydependencies-キー"><a class="header" href="#librarydependencies-キー"><code>libraryDependencies</code> キー</a></h2>
<p>依存性の宣言は、以下のようになる。ここで、<code>groupId</code>、<code>artifactId</code>、と <code>revision</code> は文字列だ:</p>
<pre><code class="language-scala">libraryDependencies += groupID % artifactID % revision
</code></pre>
<p>もしくは、以下のようになる。このときの <code>configuration</code> は文字列もしくは <code>Configuration</code> の値だ (<code>Test</code> など)。</p>
<pre><code class="language-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre>
<p>コンパイルを実行すると:</p>
<pre><code>&gt; compile
</code></pre>
<p>sbt は自動的に依存性を解決して、JAR ファイルをダウンロードする。</p>
<h3 id="-を使って正しい-scala-バージョンを入手する"><a class="header" href="#-を使って正しい-scala-バージョンを入手する"><code>%%</code> を使って正しい Scala バージョンを入手する</a></h3>
<p><code>groupID % artifactID % revision</code> のかわりに、 <code>groupID %% artifactID % revision</code> を使うと（違いは <code>groupID</code> の後ろの二つ連なった <code>%%</code>）、 sbt はプロジェクトの Scala のバイナリバージョンをアーティファクト名に追加する。これはただの略記法なので <code>%%</code> 無しで書くこともできる:</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-lang" % "toolkit_3" % "0.2.0"
</code></pre>
<p>ビルドの Scala バージョンが 3.x だとすると、以下の設定は上記と等価だ（<code>"org.scala-lang"</code> の後ろの二つ連なった <code>%%</code> に注意）:</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-lang" %% "toolkit" % "0.2.0"
</code></pre>
<p>多くの依存ライブラリは複数の Scala バイナリバージョンに対してコンパイルされており、この機構はそのうちの中からプロジェクトとバイナリ互換性のある正しいものを選択する便利機能だ。</p>
<h2 id="ライブラリ依存性を一箇所にまとめる"><a class="header" href="#ライブラリ依存性を一箇所にまとめる">ライブラリ依存性を一箇所にまとめる</a></h2>
<p><code>project</code> 内の任意の <code>.scala</code> ファイルがビルド定義の一部となることを利用する一つの例として <code>project/Dependencies.scala</code> というファイルを作ってライブラリ依存性を一箇所にまとめるということができる。</p>
<pre><code class="language-scala">// project/Dependencies.scala にこのファイルを置く

import sbt.*

object Dependencies:
  // versions
  lazy val toolkitV = "0.2.0"

  // libraries
  val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
  val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV
end Dependencies
</code></pre>
<p>この <code>Dependencies</code> オブジェクトは <code>build.sbt</code> 内で利用可能となる。 定義されている <code>val</code> が使いやすいように <code>Dependencies.*</code> を import しておこう。</p>
<pre><code class="language-scala">import Dependencies.*

scalaVersion := "3.7.3"
name := "something"
libraryDependencies += toolkit
libraryDependencies += toolkitTest % Test
</code></pre>
<h2 id="ライブラリ依存性の可視化"><a class="header" href="#ライブラリ依存性の可視化">ライブラリ依存性の可視化</a></h2>
<p>sbt シェルに <code>Compile/dependencyTree</code> と入力すると、ライブラリ依存性の間接的依存性を含むツリーが表示される:</p>
<pre><code>&gt; Compile/dependencyTree
</code></pre>
<p>これは以下のように表示されるはずだ:</p>
<pre><code>sbt:bar&gt; Compile/dependencyTree
[info] default:bar_3:0.1.0-SNAPSHOT
[info]   +-org.scala-lang:scala3-library_3:3.3.1 [S]
[info]   +-org.scala-lang:toolkit_3:0.2.0
[info]     +-com.lihaoyi:os-lib_3:0.9.1
[info]     | +-com.lihaoyi:geny_3:1.0.0
[info]     | | +-org.scala-lang:scala3-library_3:3.1.3 (evicted by: 3.3.1)
[info]     | | +-org.scala-lang:scala3-library_3:3.3.1 [S]
....
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="マルチプロジェクトの基本"><a class="header" href="#マルチプロジェクトの基本">マルチプロジェクトの基本</a></h1>
<p>簡単なプログラムならば単一プロジェクトから作り始めてもいいが、ビルドが複数の小さいのサブプロジェクトに分かれていくのが普通だ。</p>
<p>ビルド内のサブプロジェクトは、それぞれ独自のソースディレクトリを持ち、<code>packageBin</code> を実行すると独自の JAR ファイルを生成するなど、概ね通常のプロジェクトと同様に動作する。</p>
<p><strong>サブプロジェクト</strong>は、<code>lazy val</code> を用いて <a href="guide/../../api/sbt/Project.html">Project</a> 型の値を宣言することで定義される。例えば:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
LocalRootProject / publish / skip := true

lazy val core = (project in file("core"))
  .settings(
    name := "core",
  )

lazy val util = (project in file("util"))
  .dependsOn(core)
  .settings(
    name := "util",
  )
</code></pre>
<p><code>val</code> 定義された変数名はプロジェクトの ID 及びベースディレクトリの名前になる。ID は sbt シェルからプロジェクトを指定する時に用いられる。</p>
<p>sbt は必ずルートプロジェクトを定義するので、上の例のビルド定義は合計 3つのサブプロジェクトを持つ。</p>
<h2 id="サブプロジェクト間依存性"><a class="header" href="#サブプロジェクト間依存性">サブプロジェクト間依存性</a></h2>
<p>あるサブプロジェクトを、他のサブプロジェクトにあるコードに依存させたい場合、<code>dependsOn(...)</code> を使ってこれを宣言する。例えば、<code>util</code> に <code>core</code> のクラスパスが必要な場合は <code>util</code> の定義を次のように書く:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .dependsOn(core)
</code></pre>
<h2 id="タスク集約"><a class="header" href="#タスク集約">タスク集約</a></h2>
<p>タスク集約は、集約する側のサブプロジェクトで任意のタスクを実行するとき、集約される側の複数のサブプロジェクトでも同じタスクが実行されるという関係を意味する。</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val root = (project in file("."))
  .autoAggregate
  .settings(
    publish / skip := true
  )

lazy val util = (project in file("util"))

lazy val core = (project in file("core"))
</code></pre>
<p>上の例では、ルートプロジェクトが <code>util</code> と <code>core</code> を集約する。そのため、sbt シェルに <code>compile</code> と打ち込むと、3つのサブプロジェクトが並列にコンパイルされる。</p>
<h2 id="ルートプロジェクト"><a class="header" href="#ルートプロジェクト">ルートプロジェクト</a></h2>
<p>ビルドのルートにあるサブプロジェクトは、<strong>ルートプロジェクト</strong>と呼ばれ、ビルドの中で特別な役割を果たすことがある。もしルートディレクトリにサブプロジェクトが定義されてない場合、sbt は自動的に他のプロジェクトを集約するデフォルトのルートプロジェクトを生成する。</p>
<h2 id="コモンセッティング"><a class="header" href="#コモンセッティング">コモン・セッティング</a></h2>
<p>sbt 2.x系では、<code>settings(...)</code> を使わずに <code>build.sbt</code> にセッティングを直書きした場合、<strong>コモン・セッティング</strong>として全サブプロジェクトに注入される。</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)
</code></pre>
<p>上の例では、<code>scalaVersion</code> セッティングはデフォルトのルートプロジェクト、<code>core</code>、<code>util</code> に適用される。</p>
<p>既にサブプロジェクトにスコープ付けされたセッティングはこのルールの例外となる。</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)

// これは app のみに適用される
app / name := "app1"
</code></pre>
<p>この例外を利用して、以下のように、ルートプロジェクトにのみ適用されるセッティングを書くことができる:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)

// これらは root にのみ適用される
LocalRootProject / name := "root"
LocalRootProject / publish / skip := true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プラグインの基本"><a class="header" href="#プラグインの基本">プラグインの基本</a></h1>
<!--
Please read the earlier pages in the Getting Started Guide first, in
particular you need to understand [build.sbt][Basic-Def], [task graph][Task-Graph],
[library dependencies][Library-Dependencies], before reading this page.
-->
<h2 id="プラグインとは何か"><a class="header" href="#プラグインとは何か">プラグインとは何か</a></h2>
<p>プラグインは、新しいセッティングやタスクを追加することでビルド定義を拡張する。例えば、プラグインを使って <code>githubWorkflowGenerate</code> というタスクを追加して、GitHub Actions のための YAML を自動生成することができる。</p>
<!--
For example, a plugin
could add a `codeCoverage` task which would generate a test coverage report.
-->
<h2 id="scaladex-を使ったプラグインバージョンの検索"><a class="header" href="#scaladex-を使ったプラグインバージョンの検索">Scaladex を使ったプラグイン・バージョンの検索</a></h2>
<p><a href="https://index.scala-lang.org/search?platform=sbt2">Scaladex</a> を用いてプラグインを検索して、そのプラグインの最新バージョンを探すことができる。</p>
<h2 id="プラグインの宣言"><a class="header" href="#プラグインの宣言">プラグインの宣言</a></h2>
<p>ビルドが <code>hello</code> というディレクトリにあるとして、sbt-github-actions をビルド定義に追加したい場合、<code>hello/project/plugins.sbt</code> というファイルを作成して、プラグインの ModuleID を <code>addSbtPlugin(...)</code> に渡すことで、プラグイン依存性を宣言する:</p>
<pre><code class="language-scala">// In project/plugins.sbt

addSbtPlugin("com.github.sbt" % "sbt-github-actions" % "0.28.0")
</code></pre>
<p>ビルドに sbt-assembly を追加する場合、以下を追加する:</p>
<pre><code class="language-scala">// In project/plugins.sbt

addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "2.3.1")
</code></pre>
<p><a href="guide/../recipes/source-dependency-plugin.html">ソース依存性プラグイン</a>レシピには git リポジトリにホスティングされたプラグインを直接使う実験的技法が書かれてる。</p>
<p>プラグインは、通常サブプロジェクトに追加されるセッティングやタスクを提供することでその機能を実現する。次のセクションでその仕組みをもう少し詳しくみていく。</p>
<h2 id="auto-plugin-の有効化と無効化"><a class="header" href="#auto-plugin-の有効化と無効化">auto plugin の有効化と無効化</a></h2>
<p>プラグインは、自身が持つセッティング群がビルド定義に自動的に追加されるよう宣言することができ、 その場合、プラグインの利用者は何もしなくてもいい。</p>
<p>auto plugin 機能は、セッティング群とその依存関係がサブプロジェクトに自動的、かつ安全に設定されることを保証する。auto plugin の多くはデフォルトのセッティング群を自動的に追加するが、中には明示的な有効化を必要とするものもある。</p>
<p>明示的な有効化が必要な auto plugin を使っている場合は、以下を <code>build.sbt</code> に追加する必要がある:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .enablePlugins(FooPlugin, BarPlugin)
  .settings(
    name := "hello-util"
  )
</code></pre>
<p><code>enablePlugins</code> メソッドを使って、そのサブプロジェクトで使用したい auto plugin を明示的に定義できる。</p>
<p>逆に <code>disablePlugins</code> メソッドを使ってプラグインを除外することもできる。例えば、<code>util</code> から <code>IvyPlugin</code> のセッティングを除外したいとすると、<code>build.sbt</code> を以下のように変更する:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .enablePlugins(FooPlugin, BarPlugin)
  .disablePlugins(plugins.IvyPlugin)
  .settings(
    name := "hello-util"
  )
</code></pre>
<p>明示的な有効化が必要か否かは、それぞれの auto plugin がドキュメントで明記しておくべきだ。あるプロジェクトでどんな auto plugin が有効化されているか気になったら、 sbt シェルから <code>plugins</code> コマンドを実行してみよう。</p>
<pre><code class="language-scala">sbt:hello&gt; plugins
In build /tmp/hello/:
  Enabled plugins in hello:
    sbt.plugins.CorePlugin
    sbt.plugins.DependencyTreePlugin
    sbt.plugins.Giter8TemplatePlugin
    sbt.plugins.IvyPlugin
    sbt.plugins.JUnitXmlReportPlugin
    sbt.plugins.JvmPlugin
    sbt.plugins.SemanticdbPlugin
Plugins that are loaded to the build but not enabled in any subprojects:
  sbt.ScriptedPlugin
  sbt.plugins.SbtPlugin
</code></pre>
<p>ここでは、<code>plugins</code> の表示によって sbt のデフォルトのプラグインが全て有効化されていることが分かる。 sbt のデフォルトセッティングは 7つのプラグインによって提供される:</p>
<ol>
<li><code>CorePlugin</code>: タスクの並列実行などのコア機能。</li>
<li><code>DependencyTreePlugin</code>: 依存性のツリー表示タスク。</li>
<li><code>Giter8TemplatePlugin</code>: <code>sbt new</code> 機能の提供。</li>
<li><code>IvyPlugin</code>: モジュールの依存性解決と公開機能。</li>
<li><code>JUnitXmlReportPlugin</code>: junit-xml の生成。</li>
<li><code>JvmPlugin</code>: Java/Scala サブプロジェクトのコンパイル、テスト、実行、パッケージ化の機構。</li>
<li><code>SemanticdbPlugin</code>: SemanticDB の生成。</li>
</ol>
<!--
### Global plugins

Plugins can be installed for all your projects at once by declaring them
in `$global_plugins_base$`. `$global_plugins_base$` is an sbt project whose
classpath is exported to all sbt build definition projects. Roughly
speaking, any `.sbt` or `.scala` files in `$global_plugins_base$` behave as if
they were in the `project/` directory for all projects.

You can create `$global_plugins_base$build.sbt` and put `addSbtPlugin()`
expressions in there to add plugins to all your projects at once.
Because doing so would increase the dependency on the machine environment,
this feature should be used sparingly. See
[Best Practices][global-vs-local-plugins].
-->
<h2 id="利用可能なプラグイン"><a class="header" href="#利用可能なプラグイン">利用可能なプラグイン</a></h2>
<p><a href="https://index.scala-lang.org/search?platform=sbt2">Scaladex</a> の他に<a href="guide/../community-plugins.html">プラグインのリスト</a>がある。</p>
<!--
For more details, including ways of developing plugins, see
[Plugins][Plugins].
For best practices, see
[Plugins-Best-Practices][Plugins-Best-Practices].
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-layout"><a class="header" href="#build-layout">Build layout</a></h1>
<p>sbt uses conventions for file placement to make it easy to dive into a new sbt build:</p>
<pre><code>.
├── build.sbt
├── project/
│   ├── build.properties
│   ├── Dependencies.scala
│   └── plugins.sbt
├── src/
│   ├── main/
│   │   ├── java/
│   │   ├── resources/
│   │   ├── scala/
│   │   └── scala-2.13/
│   └── test/
│       ├── java/
│       ├── resources/
│       ├── scala/
│       └── scala-2.13/
├── subproject-core/
│   └── src/
│       ├── main/
│       └── test/
├─── subproject-util/
│   └── src/
│       ├── main/
│       └── test/
└── target/
</code></pre>
<ul>
<li>The local root directory <code>.</code> is the starting point of your build.</li>
<li>In sbt's terminology, the <em>base directory</em> is the directory containing the subproject. In the above, <code>.</code>, <code>subproject-core</code>, and <code>subproject-util</code> are base directories.</li>
<li>The build definition is described in <code>build.sbt</code> (actually any files named <code>*.sbt</code>) in the local root directory.</li>
<li>The sbt version is tracked in <code>project/build.properties</code>.</li>
<li>Generated files (compiled classes, packaged jars, managed files, caches, and documentation) will be written to the <code>target</code> directory by default.</li>
</ul>
<h3 id="build-support-files"><a class="header" href="#build-support-files">Build support files</a></h3>
<p>In addition to <code>build.sbt</code>, <code>project</code> directory can contain <code>.scala</code> files that define helper objects and one-off plugins. See <a href="guide/Organizing-Build.html">organizing the build</a> for more.</p>
<pre><code>.
├── build.sbt
├── project/
│   ├── build.properties
│   ├── Dependencies.scala
│   └── plugins.sbt
....
</code></pre>
<p>You may see <code>.sbt</code> files inside <code>project/</code> but they are not equivalent to <code>.sbt</code> files in the project's base directory. Explaining this will come <a href="guide/Organizing-Build.html">later</a>, since you'll need some background information first.</p>
<h3 id="source-code"><a class="header" href="#source-code">Source code</a></h3>
<p>sbt uses the same directory structure as <a href="https://maven.apache.org/">Maven</a> for source files by default (all paths are relative to the base directory):</p>
<pre><code>....
├── src/
│   ├── main/
│   │   ├── java/        &lt;main Java sources&gt;
│   │   ├── resources/   &lt;files to include in main JAR&gt;
│   │   ├── scala/       &lt;main Scala sources&gt;
│   │   └── scala-2.13/  &lt;main Scala 2.13 specific sources&gt;
│   └── test/
│       ├── java/        &lt;test Java sources&gt;
│       ├── resources/   &lt;files to include in test JAR&gt;
│       ├── scala/       &lt;test Scala sources&gt;
│       └── scala-2.13/  &lt;test Scala 2.13 specific sources&gt;
....
</code></pre>
<p>Other directories in <code>src/</code> will be ignored. Additionally, all hidden directories will be ignored.</p>
<p>Source code can be placed in the project's base directory as <code>hello/app.scala</code>, which may be OK for small projects, though for normal projects people tend to keep the projects in the <code>src/main/</code> directory to keep things neat. The fact that you can place <code>*.scala</code> source code in the base directory might seem like an odd trick, but this fact becomes relevant <a href="guide/Organizing-Build.html">later</a>.</p>
<h3 id="configuring-version-control"><a class="header" href="#configuring-version-control">Configuring version control</a></h3>
<p>Your <code>.gitignore</code> (or equivalent for other version control systems) should contain:</p>
<pre><code>target/
</code></pre>
<p>Note that this deliberately has a trailing <code>/</code> (to match only directories) and it deliberately has no leading <code>/</code> (to match <code>project/target/</code> in addition to plain <code>target/</code>).</p>
<p>sbt automates building, testing, and deployment of your subprojects from information in the build definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-with-ides"><a class="header" href="#sbt-with-ides">sbt with IDEs</a></h1>
<p>While it's possible to code Scala with just an editor and sbt, most programmers today use an Integrated Development Environment, or IDE for short. Two of the popular IDEs in Scala are <a href="https://scalameta.org/metals/">Metals</a> and <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>, and they both integrate with sbt builds.</p>
<p>A few of the advantages of using the IDEs are:</p>
<ul>
<li>Jump to definition</li>
<li>Code completion based on static types</li>
<li>Listing compilation errors, and jumping to the error positions</li>
<li>Interactive debugging</li>
</ul>
<p>Here are a few recipes on how to configure the IDEs to integrate with sbt:</p>
<ul>
<li><a href="guide/../recipes/use-sbt-as-metals-build-server.html">Use sbt as Metals build server</a></li>
<li><a href="guide/../recipes/import-to-intellij.html">Import to IntelliJ IDEA</a></li>
<li><a href="guide/../recipes/use-neovim.html">Use Neovim</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変更点"><a class="header" href="#変更点">変更点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-20-の変更点"><a class="header" href="#sbt-20-の変更点">sbt 2.0 の変更点</a></h1>
<h2 id="互換性に影響のある変更点"><a class="header" href="#互換性に影響のある変更点">互換性に影響のある変更点</a></h2>
<p>See also <a href="changes/./migrating-from-sbt-1.x.html">Migrating from sbt 1.x</a>.</p>
<ul>
<li><strong>Scala 3 in metabuild</strong>. sbt 2.x build.sbt DSL, used for build definitions and plugins, is based on Scala 3.x (currently <strong>3.7.3</strong>)  (Both sbt 1.x and 2.x are capable of building Scala 2.x and 3.x) by <a href="https://github.com/eed3si9n">@eed3si9n</a>, <a href="https://github.com/adpi2">@adpi2</a>, and others.</li>
<li><strong>コモン・セッティング</strong>。build.sbt に直書きされたセッティングは、ルートサブプロジェクトだけではなく、全てのサブプロジェクトに追加され、これまで <code>ThisBuild</code> が受け持ってきた役目を果たすことができる。</li>
<li><strong>差分テスト</strong>。<code>test</code> は、テスト結果をキャッシュする差分テストへと変更された。全テストを走らせたい場合は <code>testFull</code> を使う by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7686">#7686</a></li>
<li><strong>キャッシュ化されたタスク</strong>。全てのタスクはデフォルトで、キャッシュ化されている。詳細は<a href="changes/../concepts/caching.html">キャッシュ</a>参照。</li>
<li><strong>Depedency tree</strong>. <code>dependencyTree</code> tasks are unified to one input task by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8199">#8199</a></li>
<li><code>test</code> タスクの形が <code>Unit</code> から <code>TestResult</code> へと変更された by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8181">#8181</a></li>
<li>以前 <code>URL</code> に型付けされていたデフォルトのセッティングやタスクキー (<code>apiMappings</code>, <code>apiURL</code>, <code>homepage</code>, <code>organizationHomepage</code>, <code>releaseNotesURL</code> など) は <code>URI</code> に変更された in <a href="https://github.com/sbt/sbt/pull/7927">#7927</a></li>
<li><code>license</code> キーの型が <code>Seq[(String, URL)]</code> から <code>Seq[License]</code> へと変更された in  <a href="https://github.com/sbt/sbt/pull/7927">#7927</a></li>
<li>sbt 2.x プラグインは <code>_sbt2_3</code> という suffix を用いて公開される by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7671">#7671</a></li>
<li>sbt 2.x は、<code>platform</code> セッティングを追加して、<code>ModuleID</code> の <code>%%%</code> 演算子を使わなくても、<code>%%</code> 演算子だけで JVM、JS、Native のクロスビルドができるようにした by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/6746">#6746</a></li>
<li><code>useCoursier</code> セッティングを廃止して、Coursier をオプトアウトできないようにした by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7712">#7712</a></li>
<li><code>Key.Classpath</code> is changed to be an alias of the <code>Seq[Attributed[xsbti.HashedVirtualFileRef]]</code> type, instead of <code>Seq[Attributed[File]]</code>. Similarly, some task keys that used to return <code>File</code> have changed to return <code>HashedVirtualFileRef</code> instead. See <a href="changes/../concepts/caching.html#caching-files">Caching Files</a>.</li>
<li>In sbt 2.x <code>target</code> defaults to <code>target/out/jvm/scala-3.7.3/&lt;subproject&gt;/</code>, as opposed to <code>&lt;subproject&gt;/target/</code>.</li>
<li>sbt 2.x auto reloads by default on <code>build.sbt</code> changes, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8211">#8211</a></li>
<li><code>Project#autoAggregate</code> is added for automatic aggregation, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8290">#8290</a></li>
</ul>
<h3 id="勧告どおり廃止された機能"><a class="header" href="#勧告どおり廃止された機能">勧告どおり廃止された機能</a></h3>
<ul>
<li>Removed <code>IntegrationTest</code> configuration in <a href="https://github.com/sbt/sbt/pull/8184">#8184</a></li>
<li>Removed sbt 0.13 style shell syntax in <a href="https://github.com/sbt/sbt/pull/7700">#7700</a></li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Project matrix</strong>. Project matrix, which was available via plugin in sbt 1.x, is in-sourced to provide parallel cross build support.</li>
<li><strong>sbt query</strong>. sbt 2.x extends the unified slash syntax to support query of subprojects. Details below.</li>
<li><strong>Local/remote cache system</strong>. Details below</li>
<li><strong>Client-side run</strong>. Details below.</li>
</ul>
<h3 id="コモンセッティング-1"><a class="header" href="#コモンセッティング-1">コモン・セッティング</a></h3>
<p>In sbt 2.x, the bare settings in <code>build.sbt</code> are interpreted to be common settings, and are injected to all subprojects. This means we can now set <code>scalaVersion</code> without using <code>ThisBuild</code> scoping:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<p>This also fixes the so-called dynamic dispatch problem:</p>
<pre><code class="language-scala">lazy val hi = taskKey[String]("")
hi := name.value + "!"
</code></pre>
<p>In sbt 1.x <code>hi</code> task will capture the name of the root project, but in sbt 2.x it will return the <code>name</code> of each subproject with <code>!</code>:</p>
<pre><code class="language-scala">$ sbt show hi
[info] entering *experimental* thin client - BEEP WHIRR
[info] terminate the server with `shutdown`
&gt; show hi
[info] foo / hi
[info]  foo!
[info] hi
[info]  root!
</code></pre>
<p>Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/6746">#6746</a></p>
<h3 id="sbt-query"><a class="header" href="#sbt-query">sbt query</a></h3>
<p>To filter down the subprojects, sbt 2.x introduces sbt query.</p>
<pre><code class="language-bash">$ sbt foo.../test
</code></pre>
<p>The above runs all subprojects that begins with <code>foo</code>.</p>
<pre><code class="language-bash">$ sbt ...@scalaBinaryVersion=3/test
</code></pre>
<p>The above runs all subprojects whose <code>scalaBinaryVersion</code> is <code>3</code>. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7699">#7699</a></p>
<h3 id="incremental-test"><a class="header" href="#incremental-test">Incremental test</a></h3>
<p>In sbt 2.x, <code>test</code> task became an input task that accept arguments that can filter the test suites to run:</p>
<pre><code class="language-bash">&gt; test *Example*
</code></pre>
<p>In addition, <code>test</code> is incremental and cached. This means, the test will not run unless it previously failed or something changed since the last run.</p>
<p>See <a href="changes/../reference/sbt-test.html">test</a> for details.</p>
<h3 id="localremote-cache-system"><a class="header" href="#localremote-cache-system">Local/remote cache system</a></h3>
<p>sbt 2.x implements cached task by default, which can automatically cache the task results to local disk and Bazel-compatible remote cache.</p>
<pre><code class="language-scala">lazy val task1 = taskKey[String]("doc for task1")

task1 := name.value + version.value + "!"
</code></pre>
<p>This tracks the inputs into the <code>task1</code> and creates a machine-wide disk cache, which can also be configured to also use a remote cache. Since it's common for sbt tasks to also produce files on the side, we also provide a mechanism to cache file contents:</p>
<pre><code class="language-scala">lazy val task1 = taskKey[String]("doc for task1")

task1 := {
  val converter = fileConverter.value
  ....
  val output = converter.toVirtualFile(somefile)
  Def.declareOutput(output)
  name.value + version.value + "!"
}
</code></pre>
<p>See <a href="changes/../concepts/caching.html">Caching</a> for details. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7464">#7464</a> / <a href="https://github.com/sbt/sbt/pull/7525">#7525</a>.</p>
<h3 id="client-side-run"><a class="header" href="#client-side-run">Client-side run</a></h3>
<p>The sbt runner 1.10.10 and later script defaults to using sbtn (GraalVM native-image client) for sbt 2.x. In sbt 2.0, sbt server sends the <code>run</code> task back to sbtn, which will fork a fresh JVM. All you have to do is:</p>
<pre><code class="language-bash">sbt run
</code></pre>
<p>This avoids blocking the sbt server, and you can have multiple runs. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8060">#8060</a>. See also <a href="changes/../reference/sbt-run.html">run</a> documentation.</p>
<h3 id="performance-improvements"><a class="header" href="#performance-improvements">Performance improvements</a></h3>
<p>Adrien Piquerez contributed a series of changes to improve performance while he was at Scala Center.</p>
<ul>
<li>perf: Reduces number of long-living instances to speed up startup by 20% relative to 2.0.0-M2 by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7866">#7866</a></li>
<li>perf: Reduces creation of <code>Setting</code> and <code>Initialize</code>  by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7880">#7880</a></li>
<li>perf: Refactors <code>Settings</code> and optimize indexing of aggregate keys by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7879">#7879</a></li>
<li>perf: Removes instances of <code>Info</code> and <code>BasicAttributeMap</code> by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7882">#7882</a></li>
</ul>
<h2 id="previously-on-sbt"><a class="header" href="#previously-on-sbt">Previously on sbt</a></h2>
<p>See also:</p>
<ul>
<li><a href="https://www.scala-sbt.org/1.x/docs/sbt-1.0-Release-Notes.html">sbt 1.0 changes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-sbt-1x"><a class="header" href="#migrating-from-sbt-1x">Migrating from sbt 1.x</a></h1>
<h2 id="changing-buildsbt-dsl-to-scala-3x"><a class="header" href="#changing-buildsbt-dsl-to-scala-3x">Changing <code>build.sbt</code> DSL to Scala 3.x</a></h2>
<p>As a reminder, users can build either Scala 2.x or Scala 3.x programs using either sbt 1.x or sbt 2.x. However, the Scala that underlies the <code>build.sbt</code> DSL is determined by the sbt version. In sbt 2.0, we are migrating to Scala 3.7.x.</p>
<p>This means that if you implement custom tasks or sbt plugins for sbt 2.x, it must be done using Scala 3.x. Consult <a href="https://docs.scala-lang.org/scala3/guides/migration/incompatibility-table.html">Scala 3.x incompatibility table</a> and <a href="https://docs.scala-lang.org/scala3/guides/migration/tooling-scala2-xsource3.html">Scala 2 with -Xsource:3</a> for details about Scala 3.x.</p>
<pre><code class="language-scala">// This works on Scala 2.12.20 under -Xsource:3
import sbt.{ given, * }
</code></pre>
<h3 id="import-given"><a class="header" href="#import-given">Import given</a></h3>
<p>One of the differences between Scala 2.x and 3.x is the way typeclass instances are imported into scope. In Scala 2.x <code>import FooCodec._</code> was used whereas Scala 3 uses <code>import FooCodec.given</code>. Writing:</p>
<pre><code class="language-scala">// The following works for both sbt 1.x and 2.x
import sbt.librarymanagement.LibraryManagementCodec.{ given, * }
</code></pre>
<h3 id="avoid-postfix"><a class="header" href="#avoid-postfix">Avoid postfix</a></h3>
<p>It wasn't uncommon for sbt 0.13 and 1.x examples to use postfix notations, especially with <code>ModuleID</code>:</p>
<pre><code class="language-scala">// BAD
libraryDependencies +=
  "com.github.sbt" % "junit-interface" % "0.13.2" withSources() withJavadoc()
</code></pre>
<p>The above will fail to load on sbt 2.x:</p>
<pre><code class="language-scala">-- Error: /private/tmp/foo/build.sbt:9:61 --------------------------------------
9 |  "com.github.sbt" % "junit-interface" % "0.13.2" withSources() withJavadoc()
  |                                                             ^^
  |can't supply unit value with infix notation because nullary method withSources
   in class ModuleIDExtra: (): sbt.librarymanagement.ModuleID takes no arguments;
   use dotted invocation instead: (...).withSources()
</code></pre>
<p>To fix this, use the normal (dotted) function call notation:</p>
<pre><code class="language-scala">// GOOD
libraryDependencies +=
  ("com.github.sbt" % "junit-interface" % "0.13.2").withSources().withJavadoc()
</code></pre>
<h2 id="bare-settings-changes"><a class="header" href="#bare-settings-changes">Bare settings changes</a></h2>
<pre><code class="language-scala">version := "0.1.0"
scalaVersion := "3.7.3"
</code></pre>
<p><em>Bare settings</em>, like the example above, are settings written directly in <code>build.sbt</code> without <code>settings(...)</code>.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="changes/migrating-from-sbt-1.x.html#admonition-warning"></a>
</div>
<div>
<p>In sbt 1.x bare settings were project settings that applied only to the root subproject. In sbt 2.x, the bare settings in <code>build.sbt</code> are common settings that are injected to <strong>all subprojects</strong>.</p>
</div>
</div>
<pre><code class="language-scala">name := "root"         // all subprojects will be named root!
publish / skip := true // all subprojects will be skipped!
</code></pre>
<p>To apply some settings to the root subproject only, either define it using multi-project build, or scope the setting under <code>LocalRootProject</code>:</p>
<pre><code class="language-scala">LocalRootProject / name := "root"
LocalRootProject / publish / skip := true
</code></pre>
<h3 id="migrating-thisbuild"><a class="header" href="#migrating-thisbuild">Migrating ThisBuild</a></h3>
<p>In sbt 2.x, bare settings settings should no longer be scoped to <code>ThisBuild</code>. One benefit of the new <em>common settings</em> over <code>ThisBuild</code> is that it would act in a more predictable delegation. These settings are inserted between plugins settings and those defined in <code>settings(...)</code>, meaning they can be used to define settings like <code>Compile / scalacOptions</code>, which was not possible with <code>ThisBuild</code>.</p>
<h2 id="migrating-to-cached-tasks"><a class="header" href="#migrating-to-cached-tasks">Migrating to cached tasks</a></h2>
<p>See <a href="changes/../reference/cached-task.html">Cached task</a> reference for details, including the way to opt out of caching.</p>
<h2 id="migration-away-from-integrationtest"><a class="header" href="#migration-away-from-integrationtest">Migration away from IntegrationTest</a></h2>
<p>To migrate away from the <code>IntegrationTest</code> configuration, create a separate subproject and implement it as normal test.</p>
<h2 id="migrating-to-slash-syntax"><a class="header" href="#migrating-to-slash-syntax">Migrating to slash syntax</a></h2>
<p>sbt 1.x supported both the sbt 0.13 style syntax and the slash syntax. sbt 2.x removes the support for the sbt 0.13 syntax, so use the slash syntax for both sbt shell and in <code>build.sbt</code>:</p>
<pre><code class="language-scala">&lt;project-id&gt; / Config / intask / key
</code></pre>
<p>For example, <code>test:compile</code> will no longer work on the shell. Use <code>Test/compile</code> instead. See <a href="https://eed3si9n.com/syntactic-scalafix-rule-for-unified-slash-syntax/">syntactic Scalafix rule for unified slash syntax</a> for semi-automated migration of <code>build.sbt</code> files.</p>
<pre><code class="language-bash">scalafix --rules=https://gist.githubusercontent.com/eed3si9n/57e83f5330592d968ce49f0d5030d4d5/raw/7f576f16a90e432baa49911c9a66204c354947bb/Sbt0_13BuildSyntax.scala *.sbt project/*.scala
</code></pre>
<h2 id="cross-building-sbt-plugins"><a class="header" href="#cross-building-sbt-plugins">Cross building sbt plugins</a></h2>
<p>In sbt 2.x, if you cross build an sbt plugin with Scala 3.x and 2.12.x, it will automatically cross build against sbt 1.x and sbt 2.x:</p>
<pre><code class="language-scala">// using sbt 2.x
lazy val plugin = (projectMatrix in file("plugin"))
  .enablePlugins(SbtPlugin)
  .settings(
    name := "sbt-vimquit",
  )
  .jvmPlatform(scalaVersions = Seq("3.6.2", "2.12.20"))
</code></pre>
<p>If you use <code>projectMatrix</code>, make sure to move the plugin to a subdirectory like <code>plugin/</code>. Otherwise, the synthetic root project will also pick up the <code>src/</code>.</p>
<h3 id="cross-building-sbt-plugin-with-sbt-1x"><a class="header" href="#cross-building-sbt-plugin-with-sbt-1x">Cross building sbt plugin with sbt 1.x</a></h3>
<p>Use sbt 1.10.2 or later, if you want to cross build using sbt 1.x.</p>
<pre><code class="language-scala">// using sbt 1.x
lazy val scala212 = "2.12.20"
lazy val scala3 = "3.6.2"
ThisBuild / crossScalaVersions := Seq(scala212, scala3)

lazy val plugin = (project in file("plugin"))
  .enablePlugins(SbtPlugin)
  .settings(
    name := "sbt-vimquit",
    (pluginCrossBuild / sbtVersion) := {
      scalaBinaryVersion.value match {
        case "2.12" =&gt; "1.5.8"
        case _      =&gt; "2.0.0-RC6"
      }
    },
  )
</code></pre>
<h2 id="changes-to-"><a class="header" href="#changes-to-">Changes to <code>%%</code></a></h2>
<p>In sbt 2.x, <code>ModuleID</code>'s <code>%%</code> operator has become platform-aware. For JVM subprojects, <code>%%</code> works as before, encoding Scala suffix (for example <code>_3</code>) on Maven repositories.</p>
<h3 id="migrating--operator"><a class="header" href="#migrating--operator">Migrating <code>%%%</code> operator</a></h3>
<p>When Scala.JS or Scala Native becomes available on sbt 2.x, <code>%%</code> will encode both the Scala version (such as <code>_3</code>) and the platform suffix (<code>_sjs1</code> etc). As a result, <code>%%%</code> can be replaced with <code>%%</code>:</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-js" %% "scalajs-dom" % "2.8.0"
</code></pre>
<p>Use <code>.platform(Platform.jvm)</code> in case where JVM libraries are needed.</p>
<h2 id="changes-to-target"><a class="header" href="#changes-to-target">Changes to <code>target</code></a></h2>
<p>In sbt 2.x, the <code>target</code> directory is unified to be a single <code>target/</code> directory in the working directory, and each subproject creates a subdirectory encoding platform, Scala version, and the subproject id. To absorb this change in scripted tests, <code>exists</code>, <code>absent</code>, and <code>delete</code> now supports glob expression <code>**</code>, as well as <code>||</code>.</p>
<pre><code class="language-bash"># before
$ absent target/out/jvm/scala-3.3.1/clean-managed/src_managed/foo.txt
$ exists target/out/jvm/scala-3.3.1/clean-managed/src_managed/bar.txt

# after
$ absent target/**/src_managed/foo.txt
$ exists target/**/src_managed/bar.txt

# either is ok
$ exists target/**/proj/src_managed/bar.txt || proj/target/**/src_managed/bar.txt
</code></pre>
<h2 id="the-plugincompat-technique"><a class="header" href="#the-plugincompat-technique">The PluginCompat technique</a></h2>
<p>To use the same <code>*.scala</code> source but target both sbt 1.x and 2.x, we can create a shim, for example an object named <code>PluginCompat</code> in both <code>src/main/scala-2.12/</code> and <code>src/main/scala-3/</code>.</p>
<h3 id="migrating-classpath-type"><a class="header" href="#migrating-classpath-type">Migrating Classpath type</a></h3>
<p>sbt 2.x changed the <code>Classpath</code> type to be an alias of the <code>Seq[Attributed[xsbti.HashedVirtualFileRef]]</code> type. The following is a shim created to work with classpaths from both sbt 1.x and 2.x.</p>
<pre><code class="language-scala">// src/main/scala-3/PluginCompat.scala

package sbtfoo

import java.nio.file.{ Path =&gt; NioPath }
import sbt.*
import xsbti.{ FileConverter, HashedVirtualFileRef, VirtualFile }

private[sbtfoo] object PluginCompat:
  type FileRef = HashedVirtualFileRef
  type Out = VirtualFile

  def toNioPath(a: Attributed[HashedVirtualFileRef])(using conv: FileConverter): NioPath =
    conv.toPath(a.data)
  inline def toFile(a: Attributed[HashedVirtualFileRef])(using conv: FileConverter): File =
    toNioPath(a).toFile()
  def toNioPaths(cp: Seq[Attributed[HashedVirtualFileRef]])(using conv: FileConverter): Vector[NioPath] =
    cp.map(toNioPath).toVector
  inline def toFiles(cp: Seq[Attributed[HashedVirtualFileRef]])(using conv: FileConverter): Vector[File] =
    toNioPaths(cp).map(_.toFile())
end PluginCompat
</code></pre>
<p>and here's for sbt 1.x:</p>
<pre><code class="language-scala">// src/main/scala-2.12/PluginCompat.scala

package sbtfoo

import sbt.*

private[sbtfoo] object PluginCompat {
  type FileRef = java.io.File
  type Out = java.io.File

  def toNioPath(a: Attributed[File])(implicit conv: FileConverter): NioPath =
    a.data.toPath()
  def toFile(a: Attributed[File])(implicit conv: FileConverter): File =
    a.data
  def toNioPaths(cp: Seq[Attributed[File]])(implicit conv: FileConverter): Vector[NioPath] =
    cp.map(_.data.toPath()).toVector
  def toFiles(cp: Seq[Attributed[File]])(implicit conv: FileConverter): Vector[File] =
    cp.map(_.data).toVector

  // This adds `Def.uncached(...)`
  implicit class DefOp(singleton: Def.type) {
    def uncached[A1](a: A1): A1 = a
  }
}
</code></pre>
<p>Now we can import <code>PluginCompat.*</code> and use <code>toNioPaths(...)</code> etc to absorb the differences between sbt 1.x and 2.x. The above demonstrates how we can absorb the classpath type change, and convert it into a vector of NIO Paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command"><a class="header" href="#command">Command</a></h1>
<p>A <em>command</em> is a system-level building block of sbt, often used to capture user interaction or IDE interaction.</p>
<p><img src="concepts/../files/command.svg" style="width: 50%;"></img></p>
<p>We can think of each command as a <code>State =&gt; State</code> function. In sbt, the state represents the following:</p>
<ol>
<li>Build structure (<code>build.sbt</code> etc)</li>
<li>Your disk (source code, JAR outputs, etc)</li>
</ol>
<p>Thus, a command would typically modify either the build structure or the disk. For example, the <code>set</code> command can apply a setting to modify the build strcuture:</p>
<pre><code class="language-scala">&gt; set name := "foo"
</code></pre>
<p>The <code>act</code> command can lift a task such as <code>compile</code> into a command:</p>
<pre><code class="language-scala">&gt; compile
</code></pre>
<p>The compilation would read from the disk and write outputs, or display error messages on the screen.</p>
<h2 id="commands-are-sequentially-processed"><a class="header" href="#commands-are-sequentially-processed">Commands are sequentially processed</a></h2>
<p>Because there is only one state, a characteristic of commands is that they are executed one at a time.</p>
<p><img src="concepts/../files/command2.svg" alt="command" /></p>
<p>There are some execptions to this rule, but generally commands run sequentially. One mental image that might be useful is that a command is similar to a cashier taking an order in a cafe, and it will be processed in the sequence it was received.</p>
<h2 id="tasks-run-in-parallel"><a class="header" href="#tasks-run-in-parallel">Tasks run in parallel</a></h2>
<p>As mentioned above, the <code>act</code> command translates tasks into the command level. While doing so, the <code>act</code> command will broadcast the task across the aggregated subprojects and run independent tasks in parallel.</p>
<p>Similarly, the <code>reload</code> command that runs during the startup of a session will initialize the settings in parallel.</p>
<p><img src="concepts/../files/act.svg" alt="act" /></p>
<h2 id="the-role-of-sbt-server"><a class="header" href="#the-role-of-sbt-server">The role of sbt server</a></h2>
<p>sbt server is a service that accepts commands from either the command line or a network API called Build Server Protocol. This mechanism allows both the build user and IDEs to share the same sbt session.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-building"><a class="header" href="#cross-building">Cross building</a></h1>
<p><em>Cross building</em> refers to the idea of building multiple targets from the same set of source file. This includes Scala cross building, targeting multiple versions of Scala releases; platform cross building, targeting JVM, Scala.JS, and Scala Native; and custom virtual axes like Spark versions.</p>
<h2 id="using-cross-built-libraries"><a class="header" href="#using-cross-built-libraries">Using cross-built libraries</a></h2>
<p>To use a library built against multiple versions of Scala, double the first <code>%</code> in a ModuleID to be <code>%%</code>. This tells sbt that it should append the Scala ABI (application binary interface) suffix to the dependency's name. For example:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" %% "cats-effect" % "3.5.4"
</code></pre>
<p>When the current Scala version is Scala 3.x, the above is equivalent to the following:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" % "cats-effect_3" % "3.5.4"
</code></pre>
<p>See <a href="concepts/../reference/cross-building-setup.html">cross building setup</a> for more details on the setup.</p>
<h2 id="historical-context"><a class="header" href="#historical-context">Historical context</a></h2>
<p>In the earlier years of Scala (pre-Scala 2.9), the Scala library did not maintain binary compatibility even at the patch level, so each time a new Scala version was released, the libraries had to be re-released against the new version of Scala. This meant that a library user needed to pick a specific version that was compatible with the Scala version they were using.</p>
<p>Even after Scala 2.9.x, the Scala library did not maintain the binary compatibility at minor version level, so the libraries compiled against Scala 2.10.x was not compatible with 2.11.x.</p>
<p>To workaround this problem, sbt developed cross building mechanism such that:</p>
<ul>
<li>Same set of source files can be compiled against multiple versions of Scala</li>
<li>Define a convention to append ABI version (e.g. <code>_2.12</code>) to the Maven artifact</li>
<li>Later this mechanism was extended to support Scala.JS and other platforms</li>
</ul>
<h2 id="project-matrix"><a class="header" href="#project-matrix">Project matrix</a></h2>
<p>sbt 2.x introduces project matrix, which enables cross building to happen in parallel.</p>
<pre><code class="language-scala">organization := "com.example"
scalaVersion := "3.7.3"
version      := "0.1.0-SNAPSHOT"

lazy val core = (projectMatrix in file("core"))
  .settings(
    name := "core"
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
<p>See <a href="concepts/../reference/cross-building-setup.html">cross building setup</a> for more details on the setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-query-1"><a class="header" href="#sbt-query-1">sbt query</a></h1>
<p>sbt 2.x extends the slash syntax to enable aggregation of subprojects:</p>
<p><em>act</em> <code>::=</code> [ <em>query</em> <code>/</code> ] [ <em>config</em> <code>/</code> ] [ <em>in-task</em> <code>/</code> ] ( <em>taskKey</em> | <em>settingKey</em> )</p>
<p>In other words, sbt query is a new way of writing the subproject-axis.</p>
<h3 id="subproject-reference"><a class="header" href="#subproject-reference">Subproject reference</a></h3>
<p>A subproject reference works a query to select the subproject:</p>
<div id="admonition-buildsbt-example-1" class="admonition admonish-example" role="note" aria-labelledby="admonition-buildsbt-example-1-title">
<div class="admonition-title">
<div id="admonition-buildsbt-example-1-title">
<p>build.sbt example 1</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-buildsbt-example-1"></a>
</div>
<div>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val foo = project
</code></pre>
</div>
</div>
<p>Given the above build, we can run tests on <code>foo</code> subproject as follows, which is the same syntax as it was in sbt 1.x:</p>
<pre><code>foo/test
</code></pre>
<h3 id="-wildcard"><a class="header" href="#-wildcard"><code>...</code> wildcard</a></h3>
<p><code>...</code> wildcard matches to any characters, and can be combined with other letters and numbers to filter down the root aggregate list. For example, we can run tests on all subproject that starts with <code>foo</code> as follows:</p>
<pre><code>foo.../test
</code></pre>
<div id="admonition-note--vs-" class="admonition admonish-note" role="note" aria-labelledby="admonition-note--vs--title">
<div class="admonition-title">
<div id="admonition-note--vs--title">
<p>Note: * vs ...</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-note--vs-"></a>
</div>
<div>
<p>sbt query intentionally uses <code>...</code> (dot dot dot) instead of more intuitive <code>*</code> (asterisk) because <code>*</code> is often used in a shell as a wildcard to match existing files or directories. This would require quoting, and forgetting to quote <code>*/test</code> would match to something like <code>src/test</code>.</p>
</div>
</div>
<h3 id="scalabinaryversion-parameter"><a class="header" href="#scalabinaryversion-parameter"><code>@scalaBinaryVersion</code> parameter</a></h3>
<p><code>@scalaBinaryVersion</code> parameter matches to the subproject's <code>scalaBinaryVersion</code> setting.</p>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-example"></a>
</div>
<div>
<pre><code class="language-scala">val toolkitV = "0.5.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV

lazy val foo = projectMatrix
  .settings(
    libraryDependencies += toolkit,
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))

lazy val bar = projectMatrix
  .settings(
    libraryDependencies += toolkit,
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
</div>
</div>
<p>For example, we can run tests on all 3.x subprojects as follows:</p>
<pre><code>...@scalaBinaryVersion=3/test
</code></pre>
<p>This can be used from a terminal as follows:</p>
<pre><code class="language-bash">$ sbt ...@scalaBinaryVersion=3/test
[info] entering *experimental* thin client - BEEP WHIRR
[info] terminate the server with `shutdown`
&gt; ...@scalaBinaryVersion=3/test
[info] Passed: Total 0, Failed 0, Errors 0, Passed 0
[info] No tests to run for Test / testQuick
[info] compiling 1 Scala source to /tmp/foo/target/out/jvm/scala-3.6.4/foo/test-backend ...
[info] Passed: Total 0, Failed 0, Errors 0, Passed 0
[info] No tests to run for bar / Test / testQuick
example.ExampleSuite:
  + Scala version 0.003s
[info] Passed: Total 1, Failed 0, Errors 0, Passed 1
</code></pre>
<p>This lets us filter down the aggregated subprojects, which could be a lot using <code>projectMatrix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>sbt 2.0 introduces hybrid local/remote cache system, which can cache the task results to local disk and Bazel-compatible remote cache. Throughout sbt releases it has implemented various caches, like <code>update</code> cache, incremental compilation, but sbt 2.x's cache is a significant step change for a few reasons:</p>
<ol>
<li><strong>Automatic</strong>. sbt 2.x cache automates the caching by embedding itself into the task macro unlike sbt 1.x wherein the plugin author called the cache functions manually in the task implementation.</li>
<li><strong>Machine-wide</strong>. sbt 2.x disk cache is shared among all builds on a machine.</li>
<li><strong>Remote-ready</strong>. In sbt 2.x, the cache storage is configured separately such that all cacheable tasks are automatically remote-cache-ready.</li>
</ol>
<h2 id="basics-of-caching"><a class="header" href="#basics-of-caching">Basics of caching</a></h2>
<p>The basic idea is treat as if the build process is a pure function that takes input <code>(A1, A2, A3, ...)</code> and return some outputs <code>(R1, List(O1, O2, O3, ...))</code>. For example, we can take a list of source files, Scala version, and produce a <code>*.jar</code> file at the end. If the assumption holds, then for the same inputs, we can memorize the ouput JAR for everyone. We are interested in this technique because using the memorized output JAR would be faster than performing the actual task like Scala compilation etc.</p>
<h3 id="hermetic-build"><a class="header" href="#hermetic-build">Hermetic build</a></h3>
<p>As a mental model of the <em>build as a pure function</em>, build engineers sometimes use the term <em>hermetic build</em>, which is a build that takes place in a shipping container in a dessert with no clocks or the Internet. If we can produce a JAR file from that state, then the JAR file should be safe to be shared by any machine. Why did I mention the clock? It's because a JAR file could capture the timestamp, and thus produce slightly different JARs each time. To avoid this, hermetic build tools overwrite the timestamp to a fixed date 2010-01-01 regardless of when the build took place.</p>
<p>A build that ends up capturing ephemeral inputs, are said to <em>break the hermeticity</em> or <em>non-hermetic</em>. Another common way the hermeticity is broken is capturing absolute paths as either input or output. Sometimes the path gets embedded into the JAR via a macro, you might not know until you inspect the bytecode.</p>
<h2 id="automatic-caching"><a class="header" href="#automatic-caching">Automatic caching</a></h2>
<p>Here's a demonstration of the automatic caching:</p>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := name.value + version.value + "!"
</code></pre>
<p>In sbt 2.x, the task result will be automatically cached based on the two settings <code>name</code> and <code>version</code>. The first time we run the task it will be executed onsite, but the second time onward, it will use the disk cache:</p>
<pre><code>sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 0%, 1 onsite task
sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
</code></pre>
<h3 id="caching-is-serialization-hard"><a class="header" href="#caching-is-serialization-hard">Caching is serialization-hard</a></h3>
<p>To participate in the automatic caching, the input keys (e.g. <code>name</code> and <code>version</code>) must provide a given for <code>sjsonnew.HashWriter</code> typeclass and return type must provide a given for <code>sjsonnew.JsonFormat</code>. <a href="https://www.scala-sbt.org/contraband/">Contraband</a> can be used to generate sjson-new codecs.</p>
<h2 id="caching-files"><a class="header" href="#caching-files">Caching files</a></h2>
<p>Caching files (e.g. <code>java.io.File</code>) requires its own consideration, not because it's technically difficult, but mostly because of the ambiguity and assumptions when files are involved. When we say a "file" it could actually mean:</p>
<ol>
<li>Relative path from a well-known location</li>
<li>Materialized actual file</li>
<li>A unique proof of a file, or a content hash</li>
</ol>
<p>Technically speaking, a <code>File</code> just means the file path, so we can deserialize just the filename such as <code>target/a/b.jar</code>. This will fail the downstream tasks if they assumed that <code>target/a/b.jar</code> would exist in the file system. For clarity, and also for avoiding to capture absolute paths, sbt 2.x provides three separate types for the three cases.</p>
<ul>
<li><code>xsbti.VirtualFileRef</code> is used to mean just the relative path, which is equivalent to passing a string</li>
<li><code>xsbti.VirtualFile</code> represents a materialized file with contents, which could be a virtual file or a file in your disk</li>
</ul>
<p>However, for the purpose of hermetic build, neither is great to represent a list of files. Having just the filename alone doesn't guarantee that the file will be the same, and carrying the entire content of the files is too inefficient in a JSON etc.</p>
<p>This is where the mysterious third option, a unique proof of file comes in handy. In addition to the relative path, <code>HashedVirtualFileRef</code> tracks the SHA-256 content hash and the file size. This can easily be serialized to JSON yet we can reference the exact file.</p>
<h3 id="the-effect-of-file-creation"><a class="header" href="#the-effect-of-file-creation">The effect of file creation</a></h3>
<p>There are many tasks that generate file that do not use <code>VirtualFile</code> as the return type. For example, <code>compile</code> returns <code>Analysis</code> instead, and <code>*.class</code> file generation happens as a <em>side effect</em> in sbt 1.x.</p>
<p>To participate in caching, we need to declare these effects as something we care about.</p>
<pre><code class="language-scala">someKey := {
  val conv = fileConverter.value
  val out: java.nio.file.Path = createFile(...)
  val vf: xsbti.VirtualFile = conv.toVirtualFile(out)
  Def.declareOutput(vf)
  vf: xsbti.HashedVirtualFileRef
}
</code></pre>
<h2 id="remote-caching"><a class="header" href="#remote-caching">Remote caching</a></h2>
<p>You can optionally extend the build to use remote cache in addition to the local disk cache. Remote caching could improve build performance by allowing multiple machines to share build artifacts and outputs.</p>
<p>Imagine you have a dozen people in your project or a company. Each morning, you will <code>git pull</code> the changes the dozen people made, and you need to build their code. If you have a successful project, the code size will only get bigger over time, and the % of the time you spend building someone else's in your day increases. This becomes the limiting factor of your team size and code size. Remote caching reverses this tide by CI systems hydrate the cache and you can download the artifacts and task outputs.</p>
<p>sbt 2.x implements Bazel-compatible gRPC interface, which works with number of backend both open source and commercial. See <a href="concepts/../reference/remote-cache-setup.html">Remote cache setup</a> for more details.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>See also <a href="concepts/../reference/cached-task.html">Cached task</a> reference guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-1"><a class="header" href="#reference-1">Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-1"><a class="header" href="#sbt-1">sbt</a></h1>
<p>See <a href="reference/../guide/basic-tasks.html">Basic Tasks</a> in the Getting Started Guide for an intro to the basics.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<p><code>sbt</code><br> <code>sbt</code> <em>command</em> <em>args</em><br> <code>sbt --server</code><br> <code>sbt --script-version</code></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>sbt is a simple build tool created originally for Scala and Java. It lets us declare subprojects and their various dependencies and custom tasks to ensure that we'll always get a fast, repeatable build.</p>
<h3 id="sbt-runner-and-sbt-server"><a class="header" href="#sbt-runner-and-sbt-server">sbt runner and sbt server</a></h3>
<ul>
<li>sbt runner is a system shell script named <code>sbt</code>, or <code>sbt.bat</code> on Windows. That is capable of running <em>any version of sbt</em>. This is sometimes called "sbt-the-shell-script".
<ul>
<li>When sbt 2.x is detected, sbt runner executes in a client mode, typically using sbtn, a GraalVM native implementation of the thin client program.</li>
<li>sbt runner also executes sbt launcher, a launcher that is capable of running <em>any verions of sbt</em>.</li>
<li>When you install sbt from a installer, what you're installing is the sbt runner.</li>
</ul>
</li>
<li>sbt server is sbt's main artifact, and the actual build tool.
<ul>
<li>The sbt version is determined by <code>project/build.properties</code> in each working directory.</li>
<li>sbt server accepts commands from sbtn, network API, or via its own sbt shell.</li>
</ul>
</li>
</ul>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
<p>This mechanism allows builds to be configured to a specific version of sbt, and everyone working on the project would use the same build semantics, regardless of the sbt runner installed on their machine.</p>
<p>This also means that some features are implemented at sbt runner or sbtn level, while other features are implemented at sbt server level.</p>
<h2 id="sbt-commands"><a class="header" href="#sbt-commands">sbt commands</a></h2>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt.html#admonition-note"></a>
</div>
<div>
<p>There is a technical distinction in sbt between <em>tasks</em>, which are
<em>inside</em> the build definition, and <em>commands</em>, which often manipulate the
build definition itself.
This specific sbt meaning of <em>command</em> means there's no good general term for
<em>thing you can type at the sbt prompt</em>, which may be a setting, task, or command.</p>
</div>
</div>
<!--
-   Some tasks produce useful values. The `toString` representation of
    these values can be shown using `show <task>` to run the task
    instead of just `<task>`.
-   In a multi-project build, execution dependencies and the aggregate
    setting control which tasks from which projects are executed. See
    [multi-project builds][Multi-Project].
-->
<h3 id="project-level-tasks"><a class="header" href="#project-level-tasks">Project-level tasks</a></h3>
<ul>
<li><code>clean</code> Deletes all generated files (the <code>target</code> directory).</li>
<li><a href="reference/./sbt-publish.html"><code>publish</code></a> Publishes artifacts (such as JARs) to the repository defined by the publishTo setting, described in Publishing.</li>
<li><a href="reference/./sbt-publish.html"><code>publishLocal</code></a> Publishes artifacts (such as JARs) to the local Ivy repository as described in Publishing.</li>
<li><a href="reference/./sbt-update.html"><code>update</code></a> Resolves and retrieves external dependencies.</li>
</ul>
<h3 id="configuration-level-tasks"><a class="header" href="#configuration-level-tasks">Configuration-level tasks</a></h3>
<p>Configuration-level tasks are tasks associated with a configuration. For example, <code>compile</code>, which is equivalent to <code>Compile/compile</code>, compiles the main source code (the <code>Compile</code> configuration). <code>Test/compile</code> compiles the test source code (the <code>Test</code> configuration). Most tasks for the <code>Compile</code> configuration have an equivalent in the <code>Test</code> configuration that can be run using a <code>Test/</code> prefix.</p>
<ul>
<li>
<p><a href="reference/./sbt-compile.html"><code>compile</code></a> Compiles the main sources (in the <code>src/main/scala</code> directory). <code>Test/compile</code> compiles test sources (in the src/test/scala/ directory).</p>
</li>
<li>
<p><code>console</code> Starts the Scala interpreter with a classpath including the compiled sources, all JARs in the lib directory, and managed libraries. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows). Similarly, Test/console starts the interpreter with the test classes and classpath.</p>
</li>
<li>
<p><code>doc</code> Generates API documentation for Scala source files in <code>src/main/scala</code> using scaladoc. <code>Test/doc</code> generates API documentation for source files in <code>src/test/scala</code>.</p>
</li>
<li>
<p><code>package</code> Creates a JAR file containing the files in <code>src/main/resources</code> and the classes compiled from <code>src/main/scala</code>. <code>Test/package</code> creates a JAR containing the files in <code>src/test/resources</code> and the class compiled from <code>src/test/scala</code>.</p>
</li>
<li>
<p><code>packageDoc</code> Creates a JAR file containing API documentation generated from Scala source files in src/main/scala. Test/packageDoc creates a JAR containing API documentation for test sources files in src/test/scala.</p>
</li>
<li>
<p><code>packageSrc</code>: Creates a JAR file containing all main source files and resources. The packaged paths are relative to src/main/scala and src/main/resources. Similarly, Test/packageSrc operates on test source files and resources.</p>
</li>
<li>
<p><a href="reference/./sbt-run.html"><code>run &lt;argument&gt;*</code></a> Runs the main class for the project in the same virtual machine as sbt. The main class is passed the arguments provided.</p>
</li>
<li>
<p><code>runMain &lt;main-class&gt; &lt;argument&gt;*</code> Runs the specified main class for the project in the same virtual machine as sbt. The main class is passed the arguments provided.<!-- See
  [Running Project Code][Running-Project-Code] for
  details on the use of System.exit and multithreading (including
  GUIs) in code run by this action. `Test/runMain` runs the specified
  main class in the test code. --></p>
</li>
<li>
<p><a href="reference/./sbt-tes.html"><code>test &lt;test&gt;*</code></a> Runs the tests specified as arguments (or all tests if no arguments are given) that:</p>
<ol>
<li>have not been run yet OR</li>
<li>failed the last time they were run OR</li>
<li>had any transitive dependencies recompiled since the last successful run <code>*</code> is interpreted as a wildcard in the test name.</li>
</ol>
</li>
<li>
<p><a href="reference/./sbt-test.html"><code>testFull</code></a> Runs all tests detected during test compilation.</p>
</li>
<li>
<p><a href="reference/./sbt-test.html"><code>testOnly &lt;test&gt;*</code></a> Runs the tests provided as arguments.</p>
</li>
</ul>
<!--
-   `consoleQuick` Starts the Scala interpreter with the project's
    compile-time dependencies on the classpath. Test/consoleQuick uses
    the test dependencies. This task differs from console in that it
    does not force compilation of the current project's sources.
-   `consoleProject` Enters an interactive session with sbt and the
    build definition on the classpath. The build definition and related
    values are bound to variables and common packages and values are
    imported. See the [consoleProject documentation][Console-Project]
    for more information.
-->
<h3 id="general-commands"><a class="header" href="#general-commands">General commands</a></h3>
<ul>
<li>
<p><code>exit</code> or <code>quit</code> End the current interactive session or build. Additionally, Ctrl+D (Unix) or Ctrl+Z (Windows) will exit the interactive prompt.</p>
</li>
<li>
<p><code>help &lt;command&gt;</code> Displays detailed help for the specified command. If the command does not exist, help lists detailed help for commands whose name or description match the argument, which is interpreted as a regular expression. If no command is provided, displays brief descriptions of the main commands. Related commands are tasks and settings.</p>
</li>
<li>
<p><code>projects [add|remove &lt;URI&gt;]</code> List all available projects if no arguments provided or adds/removes the build at the provided URI.</p>
<!-- (See [multi-project builds][Multi-Project] for details on multi-project
builds.) -->
</li>
<li>
<p><code>project &lt;project-id&gt;</code> Change the current project to the project with ID <code>&lt;project-id&gt;</code>. Further operations will be done in the context of the given project.</p>
<!-- (See [multi-project builds][Multi-Project] for
details on multiple project builds.) -->
</li>
<li>
<p><a href="reference/./watch.html">Watch command</a> <code>~ &lt;command&gt;</code> Executes the project specified action or method whenever source files change.</p>
</li>
<li>
<p><code>&lt; filename</code> Executes the commands in the given file. Each command should be on its own line. Empty lines and lines beginning with '#' are ignored</p>
</li>
<li>
<p><code>A ; B</code> Execute A and if it succeeds, run B. Note that the leading semicolon is required.</p>
</li>
<li>
<p><code>eval &lt;Scala-expression&gt;</code> Evaluates the given Scala expression and returns the result and inferred type. This can be used to set system properties, as a calculator, to fork processes, etc ... For example:</p>
<pre><code>&gt; eval System.setProperty("demo", "true")
&gt; eval 1+1
&gt; eval "ls -l" !
</code></pre>
</li>
</ul>
<!--
-   `+ <command>` Executes the project specified action or method for
    all versions of Scala defined in the crossScalaVersions setting.
-   `++ <version|home-directory> <command>` Temporarily changes the
    version of Scala building the project and executes the provided
    command. `<command>` is optional. The specified version of Scala is
    used until the project is reloaded, settings are modified (such as
    by the set or session commands), or ++ is run again. `<version>`
    does not need to be listed in the build definition, but it must be
    available in a repository. Alternatively, specify the path to a
    Scala installation.
-->
<h3 id="commands-for-managing-the-build-definition"><a class="header" href="#commands-for-managing-the-build-definition">Commands for managing the build definition</a></h3>
<ul>
<li>
<p><code>reload [plugins|return]</code> If no argument is specified, reloads the build, recompiling any build or plugin definitions as necessary. reload plugins changes the current project to the build definition project (in <code>project/</code>). This can be useful to directly manipulate the build definition. For example, running clean on the build definition project will force snapshots to be updated and the build definition to be recompiled. reload return changes back to the main project.</p>
</li>
<li>
<p><code>set &lt;setting-expression&gt;</code> Evaluates and applies the given setting definition. The setting applies until sbt is restarted, the build is reloaded, or the setting is overridden by another set command or removed by the session command.<!-- See [.sbt build definition][Basic-Def] and
  [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
<li>
<p><code>session &lt;command&gt;</code> Manages session settings defined by the <code>set</code> command. It can persist settings configured at the prompt.<!-- See [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
<li>
<p><code>inspect &lt;setting-key&gt;</code> Displays information about settings, such as the value, description, defining scope, dependencies, delegation chain, and related settings.<!-- See [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
</ul>
<h2 id="sbt-runner-and-launcher"><a class="header" href="#sbt-runner-and-launcher">sbt runner and launcher</a></h2>
<p>When launching the <code>sbt</code> runner from the system shell, various system properties or JVM extra options can be specified to influence its behaviour.</p>
<h3 id="sbt-jvm-options-and-system-properties"><a class="header" href="#sbt-jvm-options-and-system-properties">sbt JVM options and system properties</a></h3>
<p>If the <code>JAVA_OPTS</code> and/or <code>SBT_OPTS</code> environment variables are defined when <code>sbt</code> starts, their content is passed as command line arguments to the JVM running sbt server.</p>
<p>If a file named <code>.jvmopts</code> exists in the  current directory, its content is appended to <code>JAVA_OPTS</code> at sbt startup. Similarly, if <code>.sbtopts</code> and/or <code>/etc/sbt/sbtopts</code> exist, their content is appended to <code>SBT_OPTS</code>. The default value of <code>JAVA_OPTS</code> is <code>-Dfile.encoding=UTF8</code>.</p>
<p>You can also specify JVM system properties and command line options directly as <code>sbt</code> arguments: any <code>-Dkey=val</code> argument will be passed as-is to the JVM, and any <code>-J-Xfoo</code> will be passed as <code>-Xfoo</code>.</p>
<p>See also <code>sbt --help</code> for more details.</p>
<h3 id="sbt-jvm-heap-permgen-and-stack-sizes"><a class="header" href="#sbt-jvm-heap-permgen-and-stack-sizes">sbt JVM heap, permgen, and stack sizes</a></h3>
<p>If you find yourself running out of permgen space or your workstation is low on memory, adjust the JVM configuration as you would for any java application.</p>
<p>For example a common set of memory-related options is:</p>
<pre><code class="language-bash">export SBT_OPTS="-Xmx2048M -Xss2M"
sbt
</code></pre>
<p>Or if you prefer to specify them just for this session:</p>
<pre><code class="language-bash">sbt -J-Xmx2048M -J-Xss2M
</code></pre>
<h3 id="boot-directory"><a class="header" href="#boot-directory">Boot directory</a></h3>
<p><code>sbt</code> runner is just a bootstrap, the actual sbt server, Scala compiler and standard library are by default downloaded to the shared directory  <code>\$HOME/.sbt/boot/</code>.</p>
<p>To change the location of this directory, set the <code>sbt.boot.directory</code> system property. A relative path will be resolved against the current working directory, which can be useful if you want to avoid sharing the boot directory between projects. For example, the following uses the pre-0.11 style of putting the boot directory in <code>project/boot/</code>:</p>
<pre><code class="language-bash">sbt -Dsbt.boot.directory=project/boot/
</code></pre>
<h3 id="terminal-encoding"><a class="header" href="#terminal-encoding">Terminal encoding</a></h3>
<p>The character encoding used by your terminal may differ from Java's default encoding for your platform. In this case, you will need to specify the <code>file.encoding=&lt;encoding&gt;</code> system property, which might look like:</p>
<pre><code class="language-bash">export JAVA_OPTS="-Dfile.encoding=Cp1252"
sbt
</code></pre>
<h3 id="httphttpsftp-proxy"><a class="header" href="#httphttpsftp-proxy">HTTP/HTTPS/FTP Proxy</a></h3>
<p>On Unix, sbt will pick up any HTTP, HTTPS, or FTP proxy settings from the standard <code>http_proxy</code>, <code>https_proxy</code>, and <code>ftp_proxy</code> environment variables. If you are behind a proxy requiring authentication, you need to pass some supplementary flags at sbt startup. See <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/doc-files/net-properties.html">JVM networking system properties</a> for more details.</p>
<p>For example:</p>
<pre><code class="language-bash">sbt -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre>
<p>On Windows, your script should set properties for proxy host, port, and if applicable, username and password. For example, for HTTP:</p>
<pre><code class="language-bash">sbt -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre>
<p>Replace <code>http</code> with <code>https</code> or <code>ftp</code> in the above command line to configure HTTPS or FTP.</p>
<h3 id="other-system-properties"><a class="header" href="#other-system-properties">Other system properties</a></h3>
<p>The following system properties can also be passed to <code>sbt</code> runner:</p>
<h4 id="-dsbtbannertrue"><a class="header" href="#-dsbtbannertrue"><code>-Dsbt.banner=true</code></a></h4>
<p>Show a welcome banner advertising new features.</p>
<h4 id="-dsbtcitrue"><a class="header" href="#-dsbtcitrue"><code>-Dsbt.ci=true</code></a></h4>
<p>Default <code>false</code> (unless then env var <code>BUILD_NUMBER</code> is set). For continuous integration environments. Suppress supershell and color.</p>
<h4 id="-dsbtclienttrue"><a class="header" href="#-dsbtclienttrue"><code>-Dsbt.client=true</code></a></h4>
<p>Run the sbt client.</p>
<h4 id="-dsbtcolorauto"><a class="header" href="#-dsbtcolorauto"><code>-Dsbt.color=auto</code></a></h4>
<ul>
<li>To turn on color, use <code>always</code> or <code>true</code>.</li>
<li>To turn off color, use <code>never</code> or <code>false</code>.</li>
<li>To use color if the output is a terminal (not a pipe) that supports color, use <code>auto</code>.</li>
</ul>
<h4 id="-dsbtcoursierhomehomecachecoursierv1"><a class="header" href="#-dsbtcoursierhomehomecachecoursierv1"><code>-Dsbt.coursier.home=$HOME/.cache/coursier/v1</code></a></h4>
<p>Location of the Coursier artifact cache, where the default is defined by <a href="https://get-coursier.io/docs/cache.html#default-location">Coursier cache resolution logic</a>. You can verify the value with the command <code>csrCacheDirectory</code>.</p>
<h4 id="-dsbtgenbuildpropstrue"><a class="header" href="#-dsbtgenbuildpropstrue"><code>-Dsbt.genbuildprops=true</code></a></h4>
<p>Generate <code>build.properties</code> if missing. If unset, this defers to <code>sbt.skip.version.write</code>.</p>
<h4 id="-dsbtglobalbasehomesbt"><a class="header" href="#-dsbtglobalbasehomesbt"><code>-Dsbt.global.base=$HOME/.sbt/</code></a></h4>
<p>The directory containing global settings and plugins.</p>
<h4 id="-dsbtoverridebuildrepostrue"><a class="header" href="#-dsbtoverridebuildrepostrue"><code>-Dsbt.override.build.repos=true</code></a></h4>
<p>If true, repositories configured in a build definition are ignored and the repositories configured for the launcher are used instead.</p>
<!-- See <tt>sbt.repository.config</tt> and the <a href="reference/Launcher-Configuration.html">sbt launcher</a> documentation. -->
<h4 id="-dsbtrepositoryconfighomesbtrepositories"><a class="header" href="#-dsbtrepositoryconfighomesbtrepositories"><code>-Dsbt.repository.config=$HOME/.sbt/repositories</code></a></h4>
<p>A file containing the repositories to use for the launcher. The format is the same as a <code>[repositories]</code> section for a sbt launcher configuration file. This setting is typically used in conjunction with setting <code>sbt.override.build.repos</code> to <code>true</code>.</p>
<!-- (see <tt>sbt.override.build.repos</tt> and the <a href="reference/Launcher-Configuration.html">sbt launcher</a> documentation).</td> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-update"><a class="header" href="#sbt-update">sbt update</a></h1>
<p>See <a href="reference/../guide/library-dependency-basics.html">library depdency basics</a> in the Getting Started guide to learn about the basics.</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>update</code></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>sbt uses <a href="https://get-coursier.io/">Coursier</a> to implement library management, also known as a package manager in other ecosystems. The general idea of library management is that you can specify external libraries you would like to use in your subprojects, and the library management system would:</p>
<ul>
<li>Check if such versions exists in the listed repositories</li>
<li>Look for the transitive dependencies (i.e. the libraries used by the libraries)</li>
<li>Attempt to resolve version conflicts, if any</li>
<li>Download the artifacts, such as JAR files, from the repositories</li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Declaring a dependency looks like:</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre>
<p>or</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision % configuration
</code></pre>
<!--
See [configurations](#ivy-configurations) for details on configuration
mappings.
-->
<p>Also, several dependencies can be declared together:</p>
<pre><code class="language-scala">libraryDependencies ++= Seq(
  groupID %% artifactID % revision,
  groupID %% otherID % otherRevision
)
</code></pre>
<p>If you are using a dependency that was built with sbt, double the first <code>%</code> to be <code>%%</code>:</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre>
<p>This will use the right JAR for the dependency built with the version of Scala that you are currently using. If you get an error while resolving this kind of dependency, that dependency probably wasn't published for the version of Scala you are using. See <a href="reference/../concepts/cross-building.html">Cross building</a> for details.</p>
<!--
Ivy can select the latest revision of a module according to constraints
you specify. Instead of a fixed revision like `"1.6.1"`, you specify
`"latest.integration"`, `"2.9.+"`, or `"[1.0,)"`. See the
[Ivy revisions](https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision)
documentation for details.
-->
<h3 id="versionscheme-and-eviction-errors"><a class="header" href="#versionscheme-and-eviction-errors"><code>versionScheme</code> and eviction errors</a></h3>
<p>sbt allows library authors to declare the version semantics using the <code>versionScheme</code> setting:</p>
<pre><code class="language-scala">// Semantic Versioning applied to 0.x, as well as 1.x, 2.x, etc
versionScheme := Some(VersionScheme.EarlySemVer)
</code></pre>
<p>When Coursier finds multiple versions of a library, for example Cats Effect 2.x and Cats Effect 3.0.0-M4, it often resolves the conflict by removing the older version from the graph. This process is colloquially called eviction, like "Cats Effect 2.2.0 was evicted."</p>
<p>This would work if the new tenant is binary compatible with Cats Effect 2.2.0. In this case, the library authors have declared that they are <em>not</em> binary compatible, so the eviction was actually unsafe. An unsafe eviction would cause runtime issues such as <code>ClassNotFoundException</code>. Instead Coursier should've failed to resolve.</p>
<pre><code class="language-scala">lazy val use = project
  .settings(
    name := "use",
    libraryDependencies ++= Seq(
      "org.http4s" %% "http4s-blaze-server" % "0.21.11",
      "org.typelevel" %% "cats-effect" % "3.0.0-M4",
    ),
  )
</code></pre>
<p>sbt performs this secondary compatibility check after Coursier returns a candidate:</p>
<pre><code>[error] stack trace is suppressed; run last use / update for the full output
[error] (use / update) found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
[error]
[error]   * org.typelevel:cats-effect_2.12:3.0.0-M4 (early-semver) is selected over {2.2.0, 2.0.0, 2.0.0, 2.2.0}
[error]       +- use:use_2.12:0.1.0-SNAPSHOT                        (depends on 3.0.0-M4)
[error]       +- org.http4s:http4s-core_2.12:0.21.11                (depends on 2.2.0)
[error]       +- io.chrisdavenport:vault_2.12:2.0.0                 (depends on 2.0.0)
[error]       +- io.chrisdavenport:unique_2.12:2.0.0                (depends on 2.0.0)
[error]       +- co.fs2:fs2-core_2.12:2.4.5                         (depends on 2.2.0)
[error]
[error]
[error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
</code></pre>
<p>This mechanism is called the <em>eviction error</em>.</p>
<h4 id="opting-out-of-the-the-eviction-error"><a class="header" href="#opting-out-of-the-the-eviction-error">Opting out of the the eviction error</a></h4>
<p>If the library authors have declared the compatibility breakage, but if you want to ignore the strict check (often for <code>scala-xml</code>), you can write this in <code>project/plugins.sbt</code> and <code>build.sbt</code>:</p>
<pre><code class="language-scala">libraryDependencySchemes += "org.scala-lang.modules" %% "scala-xml" % VersionScheme.Always
</code></pre>
<p>To ignore all eviction errors:</p>
<pre><code class="language-scala">evictionErrorLevel := Level.Info
</code></pre>
<h3 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h3>
<p>sbt uses the standard Maven Central repository by default. Declare additional repositories with the form:</p>
<pre><code class="language-scala">resolvers += name at location
</code></pre>
<p>For example:</p>
<pre><code class="language-scala">libraryDependencies ++= Seq(
    "org.apache.derby" % "derby" % "10.4.1.3",
    "org.specs" % "specs" % "1.6.1"
)

resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
</code></pre>
<p>sbt can search your local Maven repository if you add it as a repository:</p>
<pre><code class="language-scala">resolvers += Resolver.mavenLocal
</code></pre>
<!--
See [Resolvers][Resolvers] for details on defining other types of repositories.
-->
<h4 id="override-default-resolvers"><a class="header" href="#override-default-resolvers">Override default resolvers</a></h4>
<p><code>resolvers</code> configures additional, inline user resolvers. By default, <code>sbt</code> combines these resolvers with default repositories (Maven Central and the local Ivy repository) to form <code>externalResolvers</code>. To have more control over repositories, set <code>externalResolvers</code> directly. To only specify repositories in addition to the usual defaults, configure <code>resolvers</code>.</p>
<p>For example, to use the Sonatype OSS Snapshots repository in addition to the default repositories,</p>
<pre><code class="language-scala">resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
</code></pre>
<p>To use the local repository, but not the Maven Central repository:</p>
<pre><code class="language-scala">externalResolvers := Resolver.combineDefaultResolvers(resolvers.value.toVector, mavenCentral = false)
</code></pre>
<h4 id="override-all-resolvers-for-all-builds"><a class="header" href="#override-all-resolvers-for-all-builds">Override all resolvers for all builds</a></h4>
<p>The repositories used to retrieve sbt, Scala, plugins, and application dependencies can be configured globally and declared to override the resolvers configured in a build or plugin definition. There are two parts:</p>
<ol>
<li>Define the repositories used by the launcher.</li>
<li>Specify that these repositories should override those in build definitions.</li>
</ol>
<p>The repositories used by the launcher can be overridden by defining <code>~/.sbt/repositories</code>, which must contain a <code>[repositories]</code> section with the same format as the <code>Launcher</code> configuration file. For example:</p>
<pre><code>[repositories]
local
my-maven-repo: https://example.org/repo
my-ivy-repo: https://example.org/ivy-repo/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre>
<p>A different location for the repositories file may be specified by the <code>sbt.repository.config</code> system property in the sbt startup script. The final step is to set <code>sbt.override.build.repos</code> to true to use these repositories for dependency resolution and retrieval.</p>
<h3 id="exclude-transitive-dependencies"><a class="header" href="#exclude-transitive-dependencies">Exclude Transitive Dependencies</a></h3>
<p>In certain cases a transitive dependency should be excluded from all dependencies. This can be achieved by setting up <code>ExclusionRules</code> in <code>excludeDependencies</code>.</p>
<pre><code class="language-scala">excludeDependencies ++= Seq(
  // commons-logging is replaced by jcl-over-slf4j
  ExclusionRule("commons-logging", "commons-logging")
)
</code></pre>
<p>To exclude certain transitive dependencies of a dependency, use the <code>excludeAll</code> or <code>exclude</code> methods. The <code>exclude</code> method should be used when a pom will be published for the project. It requires the organization and module name to exclude. For example,</p>
<pre><code class="language-scala">libraryDependencies += 
  ("log4j" % "log4j" % "1.2.15").exclude("javax.jms", "jms")
</code></pre>
<!--
The `excludeAll` method is more flexible, but because it cannot be
represented in a pom.xml, it should only be used when a pom doesn't need
to be generated. For example,

```scala
libraryDependencies +=
  "log4j" % "log4j" % "1.2.15" excludeAll(
    ExclusionRule(organization = "com.sun.jdmk"),
    ExclusionRule(organization = "com.sun.jmx"),
    ExclusionRule(organization = "javax.jms")
  )
```

See [ModuleID](../api/sbt/librarymanagement/ModuleID.html) for API details.
-->
<h3 id="explicit-url"><a class="header" href="#explicit-url">Explicit URL</a></h3>
<p>If your project requires a dependency that is not present in a repository, a direct URL to its jar can be specified as follows:</p>
<pre><code class="language-scala">libraryDependencies += "slinky" % "slinky" % "2.1" from "https://slinky2.googlecode.com/svn/artifacts/2.1/slinky.jar"
</code></pre>
<p>The URL is only used as a fallback if the dependency cannot be found through the configured repositories. Also, the explicit URL is not included in published metadata (that is, the pom or ivy.xml).</p>
<h3 id="disable-transitivity"><a class="header" href="#disable-transitivity">Disable Transitivity</a></h3>
<p>By default, these declarations fetch all project dependencies, transitively. In some instances, you may find that the dependencies listed for a project aren't necessary for it to build. Projects using the Felix OSGI framework, for instance, only explicitly require its main jar to compile and run. Avoid fetching artifact dependencies with either <code>intransitive()</code> or <code>notTransitive()</code>, as in this example:</p>
<pre><code class="language-scala">libraryDependencies += ("org.apache.felix" % "org.apache.felix.framework" % "1.8.0").intransitive()
</code></pre>
<h3 id="classifiers"><a class="header" href="#classifiers">Classifiers</a></h3>
<p>You can specify the classifier for a dependency using the <code>classifier</code> method. For example, to get the jdk15 version of TestNG:</p>
<pre><code class="language-scala">libraryDependencies += ("org.testng" % "testng" % "5.7").classifier("jdk15")
</code></pre>
<p>For multiple classifiers, use multiple <code>classifier</code> calls:</p>
<pre><code class="language-scala">libraryDependencies += 
  "org.lwjgl.lwjgl" % "lwjgl-platform" % lwjglVersion classifier "natives-windows" classifier "natives-linux" classifier "natives-osx"
</code></pre>
<p>To obtain particular classifiers for all dependencies transitively, run the <code>updateClassifiers</code> task. By default, this resolves all artifacts with the <code>sources</code> or <code>javadoc</code> classifier. Select the classifiers to obtain by configuring the <code>transitiveClassifiers</code> setting. For example, to only retrieve sources:</p>
<pre><code class="language-scala">transitiveClassifiers := Seq("sources")
</code></pre>
<h3 id="download-sources"><a class="header" href="#download-sources">Download Sources</a></h3>
<p>Downloading source and API documentation jars is usually handled by an IDE plugin. These plugins use the <code>updateClassifiers</code> and <code>updateSbtClassifiers</code> tasks, which produce an <code>Update-Report</code> referencing these jars.</p>
<p>To have sbt download the dependency's sources without using an IDE plugin, add <code>withSources()</code> to the dependency definition. For API jars, add <code>withJavadoc()</code>. For example:</p>
<pre><code class="language-scala">libraryDependencies += 
  ("org.apache.felix" % "org.apache.felix.framework" % "1.8.0").withSources().withJavadoc()
</code></pre>
<p>Note that this is not transitive. Use the <code>update*Classifiers</code> tasks for that.</p>
<!--
### Extra Attributes

[Extra attributes](https://ant.apache.org/ivy/history/2.3.0/concept.html#extra)
can be specified by passing key/value pairs to the `extra` method.

To select dependencies by extra attributes:

```scala
libraryDependencies += ("org" % "name" % "rev").extra("color" -> "blue")
```

To define extra attributes on the current project:

```scala
projectID := {
    val previous = projectID.value
    previous.extra("color" -> "blue", "component" -> "compiler-interface")
}
```
-->
<!--
#### Configurations

Ivy configurations are a useful feature for your build when you need
custom groups of dependencies, such as for a plugin. Ivy configurations
are essentially named sets of dependencies. You can read the
[Ivy documentation](https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html)
for details.

The built-in use of configurations in sbt is similar to scopes in Maven.
sbt adds dependencies to different classpaths by the configuration that
they are defined in. See the description of
[Maven Scopes](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope)
for details.

You put a dependency in a configuration by selecting one or more of its
configurations to map to one or more of your project's configurations.
The most common case is to have one of your configurations `A` use a
dependency's configuration `B`. The mapping for this looks like
`"A->B"`. To apply this mapping to a dependency, add it to the end of
your dependency definition:

```scala
libraryDependencies += "org.scalatest" %% "scalatest" % "$example_scalatest_version$" % "test->compile"
```

This says that your project's `"test"` configuration uses `ScalaTest`'s
`"compile"` configuration. See the
[Ivy documentation](https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html)
for more advanced mappings. Most projects published to Maven
repositories will use the `"compile"` configuration.

A useful application of configurations is to group dependencies that are
not used on normal classpaths. For example, your project might use a
`"js"` configuration to automatically download jQuery and then include
it in your jar by modifying `resources`. For example:

```scala
val JS = config("js") hide

ivyConfigurations += JS

libraryDependencies += "jquery" % "jquery" % "3.2.1" % "js->default" from "https://code.jquery.com/jquery-3.2.1.min.js"

Compile / resources ++= update.value.select(configurationFilter("js"))
```

The `config` method defines a new configuration with name `"js"` and
makes it private to the project so that it is not used for publishing.
See [Update Report][Update-Report] for more information on selecting
managed artifacts.

A configuration without a mapping (no `"->"`) is mapped to `"default"`
or `"compile"`. The `->` is only needed when mapping to a different
configuration than those. The ScalaTest dependency above can then be
shortened to:

```scala
libraryDependencies += "org.scalatest" %% "scalatest" % "$example_scalatest_version$" % "test"
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="例題でみる-sbt-1"><a class="header" href="#例題でみる-sbt-1">例題でみる sbt</a></h1>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>compile</code><br> <code>sbt</code> [<em>query</em> / ] <code>Test</code> / <code>compile</code><br></p>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>The <code>compile</code> task compiles the selected subprojects and their subproject dependencies. Since sbt 2.x, the compiled artifacts are cached automatically.</p>
<p>Compiling Scala code with the raw Scala compiler has been slow, so significant poriton of sbt's development efforts deal with various strategies for speeding up compilation.</p>
<h3 id="reduce-the-overhead-of-restarting-the-compiler"><a class="header" href="#reduce-the-overhead-of-restarting-the-compiler">Reduce the overhead of restarting the compiler</a></h3>
<p>sbt server stays up in the background, allowing Scala compilation to run the same Java virtual machine (JVM). Keeping the JVM warm makes compilation significantly faster because it takes a long time to classload the compiler and for the Just-in-Time compiler to optimize it.</p>
<h3 id="incremental-compilation"><a class="header" href="#incremental-compilation">Incremental compilation</a></h3>
<p>When a source file <code>A.scala</code> is modified, sbt goes to great effort to minimize the other source files recompiled due to <code>A.scala</code>'s change. This process of tracking dependencies between the language constructs and recompiling only the required sources is called <em>incremental compilation</em>.</p>
<h3 id="remote-caching-1"><a class="header" href="#remote-caching-1">(Remote) caching</a></h3>
<p>In sbt 2.x, compiled artifacts are not only cached across the sessions and builds, but can optionally be cached across different machines using Bazel-compatible remote cache. See <a href="reference/../concepts/caching.html">Caching</a> for details.</p>
<h3 id="test--compile"><a class="header" href="#test--compile">Test / compile</a></h3>
<p>Scoping the <code>compile</code> task with a configuration, like <code>Test / compile</code> will compile the test sources and their source dependencies.</p>
<h3 id="compilation-settings"><a class="header" href="#compilation-settings">Compilation settings</a></h3>
<h4 id="scalaversion"><a class="header" href="#scalaversion">scalaVersion</a></h4>
<p>The version of Scala used for compilation.</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<h4 id="scalacoptions"><a class="header" href="#scalacoptions">scalacOptions</a></h4>
<p>Options for the Scala compiler.</p>
<pre><code class="language-scala">Compile / scalacOptions += "-Werror"
</code></pre>
<h4 id="javacoptions"><a class="header" href="#javacoptions">javacOptions</a></h4>
<p>Options for the Java compiler.</p>
<pre><code class="language-scala">Compile / javacOptions ++= List("-Xlint", "-Xlint:-serial")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-run"><a class="header" href="#sbt-run">sbt run</a></h1>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>run</code> [<em>args</em>]</p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>The <code>run</code> task provides a means for running the user program.</p>
<p>In sbt 1.x and earlier, <code>run</code> task ran the user program in the same Java virtual machine (JVM) as the sbt server. sbt 2.x implements <em>client-side run</em>: the <code>run</code> task creates a sandbox environment that contains the program, sends the information back to sbtn, and sbtn launches the user program in a fresh JVM.</p>
<h3 id="motivations"><a class="header" href="#motivations">Motivations</a></h3>
<p>There are several motivations for the client-side run.</p>
<ol>
<li><strong>sys.exit support</strong>. User code can call <code>sys.exit</code>, which normally shuts down the JVM. In sbt 1.x, we needed to trap these <code>sys.exit</code> calls to prevent <code>run</code> from shutting down the sbt session, using the JDK SecurityManager; however, TrapExit was dropped in sbt 1.6.0 (2021) since JDK 17 deprecated SecurityManager feature. Because client-side run runs the user program in its own JVM, it can call <code>sys.exit</code>.</li>
<li><strong>Isolation</strong>. User code can also start threads, or otherwise allocate resources that can be left running after the main method returns. Running user code in a separate JVM gives isolation between the sbt server and the user code.</li>
<li><strong>sbt server availability</strong>. Since the program will run outside of the sbt server, it can become available to the more requests by other clients, for example test or IDE integration.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-test"><a class="header" href="#sbt-test">sbt test</a></h1>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>test</code> [<em>testname1</em> <em>testname2</em>] [ -- <em>options</em> ]</p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>The <code>test</code> task provides a means for compiling and running the tests.</p>
<p>By default, the <code>test</code> task in sbt 2.x:</p>
<ol>
<li><strong>Subproject parallelism</strong>. Performs compilation of the relevant subprojects in parallel, specified by the <a href="reference/../concepts/sbt-query.html">query</a>.</li>
<li><strong>Test suite parallelism</strong>. Maps discovered test suites, to tasks and executes them in parallel.</li>
<li><strong>Incremental test</strong>. Runs only the tests that either failed in the previous run, never run, or if sbt detects changes in the test or its dependencies.</li>
<li><strong>Cached</strong>. The test result is cached machine-wide, and optionally remote cached.</li>
</ol>
<p>The standard source locations for testing are:</p>
<ul>
<li>Scala sources in <code>src/test/scala/</code></li>
<li>Java sources in <code>src/test/java/</code></li>
<li>Resources for the test classpath in <code>src/test/resources/</code></li>
</ul>
<p>The resources may be accessed from tests by using the <code>getResource</code> methods of <code>java.lang.Class</code> or <code>java.lang.ClassLoader</code>.</p>
<h3 id="test-interfaces"><a class="header" href="#test-interfaces">Test interfaces</a></h3>
<p>sbt defines the common interface for JVM-based test frameworks, allowing automatic test suite discovery and parallel execution. By default sbt integrates with <a href="https://scalameta.org/munit/">MUnit</a>, <a href="https://www.scalatest.org/">ScalaTest</a>, <a href="https://hedgehogqa.github.io/scala-hedgehog/">Hedgehog</a>, <a href="https://scalacheck.org/">ScalaCheck</a>, <a href="https://etorreborre.github.io/specs2/">Specs2</a>, <a href="https://typelevel.org/weaver-test/">Weaver</a>, <a href="https://zio.dev/reference/test/">ZIO Test</a>, and <a href="https://github.com/sbt/junit-interface">JUnit 4</a>; this means you only need to add the test framework to the classpath to work with sbt. For example, MUnit may be used by declaring it as a <code>libraryDependency</code>:</p>
<pre><code class="language-scala">lazy val munit = "org.scalameta" %% "munit" % "1.2.0"

libraryDependencies += munit % Test
</code></pre>
<p>In the above, <code>Test</code> denotes the <code>Test</code> configuration, and means that MUnit will only be on the test classpath and it isn't needed by the main sources.</p>
<h4 id="junit"><a class="header" href="#junit">JUnit</a></h4>
<p>Support for JUnit 5 is provided by <a href="https://github.com/sbt/sbt-jupiter-interface">sbt-jupiter-interface</a>. To add JUnit Jupiter support into your project, add the jupiter-interface dependency in your project's main build.sbt file.</p>
<pre><code class="language-scala">libraryDependencies += "com.github.sbt.junit" % "jupiter-interface" % "0.15.1" % Test
</code></pre>
<p>and the sbt-jupiter-interface plugin to your <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">addSbtPlugin("com.github.sbt.junit" % "sbt-jupiter-interface" % "0.15.1")
</code></pre>
<p>Support for JUnit 4 is provided by <a href="https://github.com/sbt/junit-interface">junit-interface</a>. Add the junit-interface dependency in your project's main build.sbt file.</p>
<pre><code class="language-scala">libraryDependencies += "com.github.sbt" % "junit-interface" % "0.13.3" % Test
</code></pre>
<h3 id="test-filtering"><a class="header" href="#test-filtering">Test filtering</a></h3>
<p>In sbt 2.x, the <code>test</code> task accepts a whitespace separated list of test names to run. For example:</p>
<pre><code class="language-bash">&gt; test example.ExampleSuite example.ExampleSuite2
</code></pre>
<p>Here's an example output:</p>
<pre><code class="language-bash">&gt; test example.ExampleSuite example.ExampleSuite2
[info] compiling 1 Scala source to /tmp/foo/target/out/jvm/scala-3.7.2/foo/backend ...
[info] compiling 2 Scala sources to /tmp/foo/target/out/jvm/scala-3.7.2/foo/test-backend ...
example.ExampleSuite:
  + addition 0.003s
example.ExampleSuite2:
  + subtraction 0.003s
[info] Passed: Total 2, Failed 0, Errors 0, Passed 2
[success] elapsed time: 3 s, cache 49%, 25 disk cache hits, 26 onsite tasks
</code></pre>
<p>It supports wildcards as well:</p>
<pre><code>&gt; test *Example*
</code></pre>
<h3 id="incremental-testing"><a class="header" href="#incremental-testing">Incremental testing</a></h3>
<p>In addition to the explicit filter, the <code>test</code> task runs only the tests that satisfy one of the following conditions are run:</p>
<ul>
<li>The tests that failed in the previous run</li>
<li>The tests that were not run before</li>
<li>The tests that have one or more transitive dependencies, maybe in a different project, recompiled.</li>
</ul>
<h3 id="full-testing"><a class="header" href="#full-testing">Full testing</a></h3>
<p>To run, uncached full tests, like sbt 1.x, use the <code>testFull</code> task.</p>
<!--
### Tab completion

Tab completion is provided for test names based on the results of the
last `Test/compile`. This means that a new sources aren't available for
tab completion until they are compiled and deleted sources won't be
removed from tab completion until a recompile. A new test source can
still be manually written out and run using `test`.
-->
<h3 id="other-tasks"><a class="header" href="#other-tasks">Other tasks</a></h3>
<p>Tasks that are available for main sources are generally available for test sources, but are prefixed with <code>Test /</code> on the command line and are referenced in Scala code with <code>Test /</code> as well. These tasks include:</p>
<ul>
<li><code>Test / compile</code></li>
<li><code>Test / console</code></li>
<li><code>Test / consoleQuick</code></li>
<li><code>Test / run</code></li>
<li><code>Test / runMain</code></li>
</ul>
<p>See <a href="reference/./sbt-run.html">sbt run</a> for details on these tasks.</p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>By default, logging is buffered for each test source file until all tests for that file complete. This can be disabled by setting <code>logBuffered</code>:</p>
<pre><code class="language-scala">Test / logBuffered := false
</code></pre>
<h4 id="test-reports"><a class="header" href="#test-reports">Test Reports</a></h4>
<p>By default, sbt will generate JUnit XML test reports for all tests in the build, located in the <code>target/test-reports</code> directory for a project. This can be disabled by disabling the <code>JUnitXmlReportPlugin</code></p>
<pre><code class="language-scala">val myProject = (project in file(".")).disablePlugins(plugins.JUnitXmlReportPlugin)
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<h4 id="test-framework-arguments"><a class="header" href="#test-framework-arguments">Test framework arguments</a></h4>
<p>Arguments to the test framework may be provided on the command line to the <code>test</code> tasks following a <code>--</code> separator. For example:</p>
<pre><code>&gt; test org.example.MyTest -- -verbosity 1
</code></pre>
<p>To specify test framework arguments as part of the build, add options constructed by <code>Tests.Argument</code>:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Argument("-verbosity", "1")
</code></pre>
<p>To specify them for a specific test framework only:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Argument(TestFrameworks.ScalaCheck, "-verbosity", "1")
</code></pre>
<h4 id="setup-and-cleanup"><a class="header" href="#setup-and-cleanup">Setup and Cleanup</a></h4>
<p>Specify setup and cleanup actions using <code>Tests.Setup</code> and <code>Tests.Cleanup</code>. These accept either a function of type <code>() =&gt; Unit</code> or a function of type <code>ClassLoader =&gt; Unit</code>. The variant that accepts a ClassLoader is passed the class loader that is (or was) used for running the tests. It provides access to the test classes as well as the test framework classes.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-test.html#admonition-note"></a>
</div>
<div>
<p>When forking, the <code>ClassLoader</code> containing the test classes cannot be
provided because it is in another JVM. Only use the <code>() =&gt; Unit</code>
variants in this case.</p>
</div>
</div>
<p>Examples:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Setup( () =&gt; println("Setup") )
Test / testOptions += Tests.Cleanup( () =&gt; println("Cleanup") )
Test / testOptions += Tests.Setup( loader =&gt; ... )
Test / testOptions += Tests.Cleanup( loader =&gt; ... )
</code></pre>
<h4 id="disable-parallel-execution-of-test-suites"><a class="header" href="#disable-parallel-execution-of-test-suites">Disable parallel execution of test suites</a></h4>
<p>By default, sbt runs all tasks in parallel and within the same JVM as sbt itself. Because each test suite is mapped to a task, tests are also run in parallel by default. To make tests within a given project execute serially:</p>
<pre><code class="language-scala">Test / parallelExecution := false
</code></pre>
<p>Note that tests from different projects may still execute concurrently.</p>
<h4 id="filter-classes"><a class="header" href="#filter-classes">Filter classes</a></h4>
<p>If you want to only run test classes whose name ends with "Test", use <code>Tests.Filter</code>:</p>
<pre><code class="language-scala">Test / testOptions := Seq(Tests.Filter(s =&gt; s.endsWith("Test")))
</code></pre>
<h4 id="forking-tests"><a class="header" href="#forking-tests">Forking tests</a></h4>
<p>The setting:</p>
<pre><code class="language-scala">Test / fork := true
</code></pre>
<p>specifies that all tests will be executed in a single external JVM. <!-- See
[Forking][Forking] for configuring standard options for forking.
By default,
tests executed in a forked JVM are executed *sequentially*.
--></p>
<p>More control over how tests are assigned to JVMs and what options to pass to those is available with <code>testGrouping</code> key.</p>
<!--
For example in build.sbt:

```scala
import Tests._

{
  def groupByFirst(tests: Seq[TestDefinition]) =
    tests groupBy (_.name(0)) map {
      case (letter, tests) =>
        val options = ForkOptions().withRunJVMOptions(Vector("-Dfirst.letter"+letter))
        new Group(letter.toString, tests, SubProcess(options))
    } toSeq

    Test / testGrouping := groupByFirst( (Test / definedTests).value )
}
```


The tests in a single group are run sequentially.
-->
<p>Control the number of forked JVMs allowed to run at the same time by setting the limit on <code>Tags.ForkedTestGroup</code> tag, which is 1 by default. <code>Setup</code> and <code>Cleanup</code> actions cannot be provided with the actual test class loader when a group is forked.</p>
<!--
In addition, forked tests can optionally be run in parallel within the
forked JVM(s), using the following setting:

```scala
Test / testForkedParallel := true
```

<a name="additional-test-configurations"></a>

### Additional test configurations

You can add an additional test configuration to have a separate set of
test sources and associated compilation, packaging, and testing tasks
and settings. The steps are:

-   Define the configuration
-   Add the tasks and settings
-   Declare library dependencies
-   Create sources
-   Run tasks

The following two examples demonstrate this. The first example shows how
to enable integration tests. The second shows how to define a customized
test configuration. This allows you to define multiple types of tests
per project.

#### Custom test configuration

The previous example may be generalized to a custom test configuration.

```scala
lazy val scalatest = "org.scalatest" %% "scalatest" % "$example_scalatest_version$"
lazy val FunTest = config("fun") extend(Test)

ThisBuild / organization := "com.example"
ThisBuild / scalaVersion := "$example_scala_version$"
ThisBuild / version      := "0.1.0-SNAPSHOT"

lazy val root = (project in file("."))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testSettings),
    libraryDependencies += scalatest % FunTest
    // other settings here
  )
```

Instead of using the built-in configuration, we defined a new one:

```scala
lazy val FunTest = config("fun") extend(Test)
```

The `extend(Test)` part means to delegate to `Test` for undefined
`FunTest` settings. The line that adds the tasks and settings for the
new test configuration is:

```scala
settings(inConfig(FunTest)(Defaults.testSettings))
```

This says to add test and settings tasks in the `FunTest` configuration.
We could have done it this way for integration tests as well. In fact,
`Defaults.itSettings` is a convenience definition:
`val itSettings = inConfig(IntegrationTest)(Defaults.testSettings)`.

The comments in the integration test section hold, except with
`IntegrationTest` replaced with `FunTest` and `"it"` replaced with
`"fun"`. For example, test options can be configured specifically for
`FunTest`:

```scala
FunTest / testOptions += ...
```

Test tasks are run by prefixing them with `fun:`

```
> FunTest / test
```

#### Additional test configurations with shared sources

An alternative to adding separate sets of test sources (and
compilations) is to share sources. In this approach, the sources are
compiled together using the same classpath and are packaged together.
However, different tests are run depending on the configuration.

```scala
lazy val scalatest = "org.scalatest" %% "scalatest" % "$example_scalatest_version$"
lazy val FunTest = config("fun") extend(Test)

ThisBuild / organization := "com.example"
ThisBuild / scalaVersion := "$example_scala_version$"
ThisBuild / version      := "0.1.0-SNAPSHOT"

def itFilter(name: String): Boolean = name endsWith "ITest"
def unitFilter(name: String): Boolean = (name endsWith "Test") && !itFilter(name)

lazy val root = (project in file("."))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testTasks),
    libraryDependencies += scalatest % FunTest,
    Test / testOptions := Seq(Tests.Filter(unitFilter)),
    FunTest / testOptions := Seq(Tests.Filter(itFilter))
    // other settings here
  )
```

The key differences are:

-   We are now only adding the test tasks
    (inConfig(FunTest)(Defaults.testTasks)) and not compilation and
    packaging tasks and settings.
-   We filter the tests to be run for each configuration.

To run standard unit tests, run `test` (or equivalently, `Test / test`):

```
> test
```

To run tests for the added configuration (here, `"FunTest"`), prefix it with
the configuration name as before:

```
> FunTest / test
> FunTest / testOnly org.example.AFunTest
```

##### Application to parallel execution

One use for this shared-source approach is to separate tests that can
run in parallel from those that must execute serially. Apply the
procedure described in this section for an additional configuration.
Let's call the configuration `serial`:

```scala
lazy val Serial = config("serial") extend(Test)
```

Then, we can disable parallel execution in just that configuration
using:

```scala
Serial / parallelExecution := false
```

The tests to run in parallel would be run with `test` and the ones to
run in serial would be run with `Serial/test`.

### Extensions

This page describes adding support for additional testing libraries and
defining additional test reporters. You do this by implementing `sbt`
interfaces (described below). If you are the author of the testing
framework, you can depend on the test interface as a provided
dependency. Alternatively, anyone can provide support for a test
framework by implementing the interfaces in a separate project and
packaging the project as an sbt [Plugin][Plugins].

#### Custom Test Framework

The main Scala testing libraries have built-in support for sbt. To add
support for a different framework, implement the
[uniform test interface](https://github.com/sbt/test-interface).

#### Custom Test Reporters

Test frameworks report status and results to test reporters. You can
create a new test reporter by implementing either
[TestReportListener](../api/sbt/TestReportListener.html) or
[TestsListener](../api/sbt/TestsListener.html).

#### Using Extensions

To use your extensions in a project definition:

Modify the `testFrameworks` setting to reference your test framework:

```scala
testFrameworks += new TestFramework("custom.framework.ClassName")
```

Specify the test reporters you want to use by overriding the
`testListeners` setting in your project definition.

```scala
testListeners += customTestListener
```

where `customTestListener` is of type `sbt.TestReportListener`.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-inspect"><a class="header" href="#sbt-inspect">sbt inspect</a></h1>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5">Synopsis</a></h2>
<p><code>sbt</code> <code>inspect</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em><br> <code>sbt</code> <code>inspect actual</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em><br> <code>sbt</code> <code>inspect tree</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em></p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>The <code>inspect</code> command provides a means to inspect the task and setting graph. For instace, it can be used to determine which setting should be modified to affect another task.</p>
<h3 id="value-description-and-provided-by"><a class="header" href="#value-description-and-provided-by">Value, Description, and Provided By</a></h3>
<p>The first piece of information provided by <code>inspect</code> is the type of a task or the value and type of a setting.</p>
<p>For example,</p>
<pre><code class="language-bash">$ sbt inspect libraryDependencies
[info] Setting: interface scala.collection.immutable.Seq =
  List(org.scala-lang:scala3-library:3.7.2,
       org.typelevel:toolkit:0.1.29,
       org.typelevel:toolkit-test:0.1.29:test)
[info] Description:
[info]  Declares managed dependencies.
[info] Provided by:
[info]  ProjectRef(uri("file:/tmp/aaa/"), "aaa") / libraryDependencies
....
</code></pre>
<p>The following section of output is labeled "Provided by". This shows the actual scope where the setting is defined.</p>
<p>This shows that <code>libraryDependencies</code> has been defined on the current project (<code>ProjectRef(uri("file:/tmp/aaa/"), "aaa")</code>).</p>
<h3 id="related-settings"><a class="header" href="#related-settings">Related Settings</a></h3>
<p>The <em>Related</em> section of <code>inspect</code> output lists all of the definitions of a key. For example,</p>
<pre><code class="language-bash">&gt; inspect compile
...
[info] Related:
[info]  Test / compile
</code></pre>
<p>This shows that in addition to the requested <code>Compile / compile</code> task, there is also a <code>Test / compile</code> task.</p>
<h3 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h3>
<p>Forward dependencies show the other settings (or tasks) used to define a setting (or task). Reverse dependencies go the other direction, showing what uses a given setting. <code>inspect</code> provides this information based on either the requested dependencies or the actual dependencies. Requested dependencies are those that a setting directly specifies. Actual settings are what those dependencies get resolved to. This distinction is explained in more detail in the following sections.</p>
<h4 id="requested-dependencies"><a class="header" href="#requested-dependencies">Requested Dependencies</a></h4>
<p>As an example, we'll look at <code>console</code>:</p>
<pre><code class="language-bash">$ sbt inspect console
...
[info] Dependencies:
[info]  Compile / console / initialCommands
[info]  Compile / console / compilers
[info]  Compile / state
[info]  Compile / console / cleanupCommands
[info]  Compile / console / taskTemporaryDirectory
[info]  Compile / console / scalaInstance
[info]  Compile / console / scalacOptions
[info]  Compile / console / fullClasspath
[info]  Compile / fileConverter
[info]  Compile / console / streams

...
</code></pre>
<p>This shows the inputs to the <code>console</code> task. We can see that it gets its classpath and options from <code>Compile / console / fullClasspath</code> and <code>Compile / console / scalacOptions</code>. The information provided by the <code>inspect</code> command can thus assist in finding the right setting to change. The convention for keys, like <code>console</code> and <code>fullClasspath</code>, is that the Scala identifier is camel case, while the String representation is lowercase and separated by dashes. The Scala identifier for a configuration is uppercase to distinguish it from tasks like <code>compile</code> and <code>test</code>. For example, we can infer from the previous example how to add code to be run when the Scala interpreter starts up:</p>
<pre><code class="language-scala">&gt; set Compile / console / initialCommands := "import mypackage._"
&gt; console
...
import mypackage._
...
</code></pre>
<p><code>inspect</code> showed that <code>console</code> used the setting <code>Compile / console / initialCommands</code>. Translating the <code>initialCommands</code> string to the Scala identifier gives us <code>initialCommands</code>. <code>compile</code> indicates that this is for the main sources. <code>console /</code> indicates that the setting is specific to <code>console</code>. Because of this, we can set the initial commands on the <code>console</code> task without affecting the <code>consoleQuick</code> task, for example.</p>
<h4 id="actual-dependencies"><a class="header" href="#actual-dependencies">Actual Dependencies</a></h4>
<p><code>inspect actual &lt;scoped-key&gt;</code> shows the actual dependency used. This is useful because delegation means that the dependency can come from a scope other than the requested one. Using <code>inspect actual</code>, we see exactly which scope is providing a value for a setting. Combining <code>inspect actual</code> with plain <code>inspect</code>, we can see the range of scopes that will affect a setting. Returning to the example in Requested Dependencies,</p>
<pre><code class="language-bash">$ sbt inspect actual console
...
[info] Dependencies:
[info]  Compile / console / streams
[info]  Global / taskTemporaryDirectory
[info]  scalaInstance
[info]  Compile / scalacOptions
[info]  Global / initialCommands
[info]  Global / cleanupCommands
[info]  Compile / fullClasspath
[info]  console / compilers
...
</code></pre>
<p>For <code>initialCommands</code>, we see that it comes from the global scope (<code>Global</code>). Combining this with the relevant output from <code>inspect console</code>:</p>
<pre><code>Compile / console / initialCommands
</code></pre>
<p>we know that we can set <code>initialCommands</code> as generally as the global scope, as specific as the current project's <code>console</code> task scope, or anything in between. This means that we can, for example, set <code>initialCommands</code> for the whole project and will affect <code>console</code>:</p>
<pre><code class="language-scala">&gt; set initialCommands := "import mypackage._"
...
</code></pre>
<p>The reason we might want to set it here this is that other console tasks will use this value now. We can see which ones use our new setting by looking at the reverse dependencies output of <code>inspect actual</code>:</p>
<pre><code class="language-bash">$ sbt inspect actual Global/initialCommands
...
[info] Reverse dependencies:
[info]  Compile / console
[info]  consoleProject
[info]  Test / console
[info]  Test / consoleQuick
[info]  Compile / consoleQuick
...
</code></pre>
<p>We now know that by setting <code>initialCommands</code> on the whole project, we affect all console tasks in all configurations in that project. If we didn't want the initial commands to apply for <code>consoleProject</code>, which doesn't have our project's classpath available, we could use the more specific task axis:</p>
<pre><code class="language-scala">&gt; set console / initialCommands := "import mypackage._"
&gt; set consoleQuick / initialCommands := "import mypackage._"`
</code></pre>
<p>or configuration axis:</p>
<pre><code class="language-scala">&gt; set Compile/　initialCommands := "import mypackage._"
&gt; set Test / initialCommands := "import mypackage._"
</code></pre>
<p>The next part describes the Delegates section, which shows the chain of delegation for scopes.</p>
<h3 id="delegates"><a class="header" href="#delegates">Delegates</a></h3>
<p>A setting has a key and a scope. A request for a key in a scope A may be delegated to another scope if A doesn't define a value for the key. The delegation chain is well-defined and is displayed in the Delegates section of the <code>inspect</code> command. The Delegates section shows the order in which scopes are searched when a value is not defined for the requested key.</p>
<p>As an example, consider the initial commands for <code>console</code> again:</p>
<pre><code class="language-bash">$ sbt inspect console/initialCommands
...
[info] Delegates:
[info]  console / initialCommands
[info]  initialCommands
[info]  ThisBuild / console / initialCommands
[info]  ThisBuild / initialCommands
[info]  Zero / console / initialCommands
[info]  Global / initialCommands
...
</code></pre>
<p>This means that if there is no value specifically for <code>console/initialCommands</code>, the scopes listed under Delegates will be searched in order until a defined value is found.</p>
<h3 id="inspect-tree"><a class="header" href="#inspect-tree">Inspect tree</a></h3>
<p>In addition to displaying immediate forward and reverse dependencies as described in the previous section, the <code>inspect tree</code> command can display the full dependency tree for a task or setting. For example,</p>
<pre><code class="language-bash">$ sbt inspect tree console
[info] Compile / console = Task[void]
[info]   +-Global / cleanupCommands =
[info]   +-console / compilers = Task[class xsbti.compile.Compilers]
[info]   +-Compile / fullClasspath = Task[Seq[class sbt.internal.util.Attributed]]
[info]   +-Global / initialCommands =
[info]   +-scalaInstance = Task[class sbt.internal.inc.ScalaInstance]
[info]   +-Compile / scalacOptions = Task[Seq[class java.lang.String]]
[info]   +-Compile / console / streams = Task[interface sbt.std.TaskStreams]
[info]   | +-Global / streamsManager = Task[interface sbt.std.Streams]
[info]   |
[info]   +-Global / taskTemporaryDirectory = target/....
[info]   +-Global / fileConverter = sbt.internal.inc.MappedFileConverter@10095d95
[info]   +-Global / state = Task[class sbt.State]
[info]
[success] elapsed: 0 s
</code></pre>
<p>For each task, <code>inspect tree</code> show the type of the value generated by the task. For a setting, the <code>toString</code> of the setting is displayed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-publish"><a class="header" href="#sbt-publish">sbt publish</a></h1>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>publish</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishSigned</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishLocal</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishM2</code></p>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>The publish family of tasks provide means for compiling and publishing your project. <em>Publishing</em> in this context consists of uploading a descriptor, such as a Maven POM or <code>ivy.xml</code>, and artifacts, such as a JAR or <code>war</code> file, to a repository so that other projects can specify your project as a dependency.</p>
<ul>
<li>The <code>publish</code> task publishes your project to a remote repository, such as JFrog Artifactory or Sonatype Nexus instance.</li>
<li>The <code>publishSigned</code> task, enabled using <a href="https://github.com/sbt/sbt-pgp">sbt-pgp plugin</a>, is used to publish GPG-signed artifacts.</li>
<li>The <code>publishLocal</code> task publishes your project to the Ivy local file repository, which is usually located at <code>$HOME/.ivy2/local/</code>. You can then use this project from other projects on the same machine.</li>
<li>The <code>publishM2</code> task publishes your project to the local Maven repository.</li>
</ul>
<p>There's a specific recipe for <a href="reference/../recipes/central.html">publishing to the Central Repo</a>.</p>
<h3 id="skip-publishing"><a class="header" href="#skip-publishing">Skip publishing</a></h3>
<p>To avoid publishing a project, add the following setting to the subprojects that you want to skip:</p>
<pre><code class="language-scala">publish / skip := true
</code></pre>
<p>Common use case is to prevent publishing of the root project.</p>
<h3 id="define-the-repository"><a class="header" href="#define-the-repository">Define the repository</a></h3>
<p>To specify the repository, assign a repository to <code>publishTo</code> and optionally set the publishing style. For example, to upload to Nexus:</p>
<pre><code class="language-scala">publishTo := Some("Sonatype Snapshots Nexus" at "https://oss.sonatype.org/content/repositories/snapshots")
</code></pre>
<p>To publish to a local maven repository:</p>
<pre><code class="language-scala">publishTo := Some(MavenCache("local-maven", file("path/to/maven-repo/releases")))
</code></pre>
<p>To publish to a local Ivy repository:</p>
<pre><code class="language-scala">publishTo := Some(Resolver.file("local-ivy", file("path/to/ivy-repo/releases")))
</code></pre>
<p>If you're publishing the Central Repository, you will also have to select the right repository depending on your artifacts: SNAPSHOT versions go to the central-snapshots repository while other versions go to the local staging repository. Doing this selection can be done by using the value of the <code>version</code> setting:</p>
<pre><code class="language-scala">publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<h3 id="publishing-locally"><a class="header" href="#publishing-locally">Publishing locally</a></h3>
<p>The <code>publishLocal</code> task will publish to the "local" Ivy repository. By default, this is at <code>$HOME/.ivy2/local/</code>. Other builds on the same machine can then list the project as a dependency. For example, if the project you are publishing has configuration parameters like:</p>
<pre><code class="language-scala">organization := "com.example"
version := "0.1-SNAPSHOT"
name := "hello"
</code></pre>
<p>Then another build on the same machine can depend on it:</p>
<pre><code class="language-scala">libraryDependencies += "com.example" %% "hello" % "0.1-SNAPSHOT"
</code></pre>
<p>The version number you select must end with <code>SNAPSHOT</code>, or you must change the version number each time you publish to indicate that it's a changing artifact.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-publish.html#admonition-warning"></a>
</div>
<div>
<p>Generally the use of SNAPSHOT dependencies should be avoided beyond testing on a single machine
since it makes dependency resolution slower and the build non-repeatable.</p>
</div>
</div>
<p>Similar to <code>publishLocal</code>, <code>publishM2</code> task will publish the user's Maven local repository. This is at the location specified by <code>$HOME/.m2/settings.xml</code> or at <code>$HOME/.m2/repository/</code> by default. Another build would require <code>Resolver.mavenLocal</code> to resolve out of it:</p>
<pre><code class="language-scala">resolvers += Resolver.mavenLocal
</code></pre>
<!--
See [Resolvers][Resolvers] for more details.
-->
<h3 id="credentials"><a class="header" href="#credentials">Credentials</a></h3>
<p>There are two ways to specify credentials for such a repository.</p>
<p>The first and better way is to load them from a file, for example:</p>
<pre><code class="language-scala">credentials += Credentials(Path.userHome / ".sbt" / ".credentials")
</code></pre>
<p>The credentials file is a properties file with keys <code>realm</code>, <code>host</code>, <code>user</code>, and <code>password</code>. For example:</p>
<pre><code>realm=Sonatype Nexus Repository Manager
host=my.artifact.repo.net
user=admin
password=admin123
</code></pre>
<p>The second way is to specify them inline:</p>
<pre><code class="language-scala">credentials += Credentials("Sonatype Nexus Repository Manager", "my.artifact.repo.net", "admin", "admin123")
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-publish.html#admonition-note"></a>
</div>
<div>
<p>Credentials matching is done using both: <code>realm</code> and <code>host</code> keys.
The <code>realm</code> key is the HTTP <code>WWW-Authenticate</code> header's realm directive, which is
part of the response of HTTP servers for <a href="https://en.wikipedia.org/wiki/Basic_access_authentication#Server_side">HTTP Basic Authentication</a>.
For a given repository, this can be found by reading all the headers received.
For example:</p>
<pre><code class="language-bash">curl -D - my.artifact.repo.net
</code></pre>
</div>
</div>
<h3 id="cross-publishing"><a class="header" href="#cross-publishing">Cross-publishing</a></h3>
<p>To support multiple incompatible Scala versions, use projectMatrix and publish (see <a href="reference/./cross-building-setup.html">Cross building setup</a>).</p>
<h3 id="overriding-the-publishing-convention"><a class="header" href="#overriding-the-publishing-convention">Overriding the publishing convention</a></h3>
<p>By default sbt will publish your artifact with the binary version of Scala you're using. For example if your project is using Scala 2.13.x your example artifact would be published under <code>example_2.13</code>. This is often what you want, but if you're publishing a pure Java artifact or a compiler plugin you'll want to change the <code>CrossVersion</code>. See the <a href="reference/./cross-building-setup.html">Cross building setup</a> page for more details under the <em>Publishing convention</em> section.</p>
<h3 id="published-artifacts"><a class="header" href="#published-artifacts">Published artifacts</a></h3>
<p>By default, the main binary JAR, a sources JAR, and a API documentation JAR are published. You can declare other types of artifacts to publish and disable or modify the default artifacts. See the <a href="reference/./artifact.html">Artifact</a> page for details.</p>
<h3 id="version-scheme"><a class="header" href="#version-scheme">Version scheme</a></h3>
<p><code>versionScheme</code> setting tracks the version scheme of the build:</p>
<pre><code class="language-scala">versionScheme := Some("early-semver")
</code></pre>
<p>The supported values are <code>"early-semver"</code>, <code>"pvp"</code>, <code>"semver-spec"</code>, and <code>"strict"</code>. sbt will include this information into <code>pom.xml</code> and <code>ivy.xml</code> as a property.</p>
<ul>
<li><code>Some("early-semver")</code>: Early Semantic Versioning that would keep binary compatibility across patch updates within 0.Y.z (for instance 0.13.0 and 0.13.2). Once it goes 1.0.0, it follows the regular Semantic Versioning where 1.1.0 is bincompat with 1.0.0.</li>
<li><code>Some("semver-spec")</code>: Semantic Versioning where all 0.y.z are treated as initial development (no bincompat guarantees).</li>
<li><code>Some("pvp")</code>. Haskell Package Versioning Policy where X.Y are treated as major version.</li>
<li><code>Some("strict")</code>. Requires exact match of version.</li>
</ul>
<p>This information will be annotated into the <code>pom.xml</code> file, which helps downstream projects determine whether a version conflict is safe to resolve or not. See <a href="https://www.scala-lang.org/blog/2021/02/16/preventing-version-conflicts-with-versionscheme.html">Preventing version conflicts with versionScheme</a> (2021).</p>
<h3 id="modifying-the-generated-pom"><a class="header" href="#modifying-the-generated-pom">Modifying the generated POM</a></h3>
<p>When <code>publishMavenStyle</code> is <code>true</code>, a POM is generated by the <code>makePom</code> action and published to the repository instead of an Ivy file. This POM file may be altered by changing a few settings. Set <code>pomExtra</code> to provide XML (<code>scala.xml.NodeSeq</code>) to insert directly into the generated pom. For example:</p>
<pre><code class="language-scala">pomExtra := &lt;something&gt;&lt;/something&gt;
</code></pre>
<p>There is also a <code>pomPostProcess</code> setting that can be used to manipulate the final XML before it is written. It's type is <code>Node =&gt; Node</code>.</p>
<pre><code class="language-scala">pomPostProcess := { (node: Node) =&gt;
  ....
}
</code></pre>
<p><code>makePom</code> adds to the POM any Maven-style repositories you have declared. You can filter these by modifying <code>pomRepositoryFilter</code>, which by default excludes local repositories. To instead only include local repositories:</p>
<pre><code class="language-scala">pomIncludeRepository := { (repo: MavenRepository) =&gt;
  repo.root.startsWith("file:")
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-command"><a class="header" href="#watch-command">Watch command</a></h1>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7">Synopsis</a></h2>
<p><code>sbt</code> <code>~</code> <em>command1</em><br> <code>sbt</code> <code>~</code> <em>command1</em> [ <code>;</code> <em>command2</em> <code>;</code> ... ]</p>
<h2 id="descrption"><a class="header" href="#descrption">Descrption</a></h2>
<p>The watch command is denoted by <code>~</code> (tilde), and it provides the ability to monitor the input files for particular tasks and repeat the tasks when changes to those files occur.</p>
<p>Some example usages are described below:</p>
<h3 id="compile-1"><a class="header" href="#compile-1">Compile</a></h3>
<p>A common use-case is continuous compilation. The following commands will make sbt watch for source changes in the Test and Compile (default) configurations respectively and re-run the compile command.</p>
<pre><code class="language-bash">&gt; ~ Test / compile

&gt; ~ compile
</code></pre>
<p>Note that because <code>Test / compile</code> depends on <code>Compile / compile</code>, source changes in the main source directory will trigger recompilation of the test sources.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Triggered execution is often used when developing in a test driven development (TDD) style. The following command will monitor changes to both the main and test source sources for the build and re-run only the tests that reference classes that have been re-compiled since the last test run.</p>
<pre><code class="language-bash">&gt; ~ test
</code></pre>
<p>It is also possible to re-run only a particular test if its dependencies have changed.</p>
<pre><code class="language-bash">&gt; ~ test foo.BarTest
</code></pre>
<p>It is possible to always re-run a test when source changes are detected regardless of whether the test depends on any of the updated source files.</p>
<pre><code class="language-bash">&gt; ~ testOnly foo.BarTest
</code></pre>
<p>To run all of the tests in the project when any sources change, use</p>
<pre><code class="language-bash">&gt; ~ testFull
</code></pre>
<h3 id="running-multiple-commands"><a class="header" href="#running-multiple-commands">Running Multiple Commands</a></h3>
<p>The watch command supports watching multiple, semicolon separated, tasks. For example, the following command will monitor for source file changes and run <code>clean</code> and <code>test</code>:</p>
<pre><code class="language-bash">&gt; ~ clean; test
</code></pre>
<h3 id="build-sources"><a class="header" href="#build-sources">Build sources</a></h3>
<p>If the build is configured to automatically reload when build source changes are made by setting <code>Global / onChangedBuildSource := ReloadOnSourceChanges</code>, then sbt will monitor the build sources (i.e. <code>*.sbt</code> and <code>*.{java,scala}</code> files in the <code>project</code> directory). When build source changes are detected, the build will be reloaded and sbt will re-enter triggered execution mode when the reload completes.</p>
<!--
The following snippet can be added as a [global setting](../api/sbt/Global-Settings.html) to `~/.sbt/1.0/config.sbt` to enable `ReloadOnSourceChanges` for all sbt 1.3+ builds without breaking earlier versions:

```
Def.settings {
  try {
    val value = Class.forName("sbt.nio.Keys\$ReloadOnSourceChanges\$").getDeclaredField("MODULE\$").get(null)
    val clazz = Class.forName("sbt.nio.Keys\$WatchBuildSourceOption")
    val manifest = new scala.reflect.Manifest[AnyRef]{ def runtimeClass = clazz }
    Seq(
      Global / SettingKey[AnyRef]("onChangedBuildSource")(manifest, sbt.util.NoJsonWriter()) := value
    )
  } catch {
    case e: Throwable =>
      Nil
  }
}
```
-->
<h3 id="clearing-the-screen"><a class="header" href="#clearing-the-screen">Clearing the screen</a></h3>
<p>sbt can clear the console screen before it evaluates the task or after it triggers an event. To configure sbt to clear the screen after an event is triggered add</p>
<pre><code class="language-scala">ThisBuild / watchTriggeredMessage := Watch.clearScreenOnTrigger
</code></pre>
<p>to the build settings. To clear the screen before running the task, add</p>
<pre><code class="language-scala">ThisBuild  / watchBeforeCommand := Watch.clearScreen
</code></pre>
<p>to the build settings.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The behavior of triggered execution can be configured via a number of settings.</p>
<ul>
<li>
<p><code>watchTriggers: Seq[Glob]</code> adds search queries for files that should task trigger evaluation but that the task does not directly depend on. For example, if the project build.sbt file contains <code>foo / watchTriggers += baseDirectory.value.toGlob / "*.txt"</code>, then any modifications to files ending with the <code>txt</code> extension will cause the <code>foo</code> command to trigger when in triggered execution mode.</p>
</li>
<li>
<p><code>watchTriggeredMessage: (Int, Path, Seq[String]) =&gt; Option[String]</code> sets the message that is displayed when a file modification triggers a new build. Its input parameters are the current watch iteration count, the file that triggered the build and the command(s) that are going to be run. By default, it prints a message indicating what file triggered the build and what commands its going to run. No message is printed when the function returns <code>None</code>. To clear the screen before printing the message, just add <code>Watch.clearScreen()</code> inside of the task definition. This will ensure that the screen is cleared and that the message, if any is defined, will be printed after the screen clearing.</p>
</li>
<li>
<p><code>watchInputOptions: Seq[Watch.InputOption]</code> allows the build to override the default watch options. For example, to add the ability to reload the build by typing the 'l' key, add <code>ThisBuild / watchInputOptions += Watch.InputOption('l', "reload", Watch.Reload)</code> to the <code>build.sbt</code> file. When using the default <code>watchStartMessage</code>, this will also add the option to the list displayed by the '?' option.</p>
</li>
<li>
<p><code>watchBeforeCommand: () =&gt; Unit</code> provides a callback to run before evaluating the task.  It can be used to clear the console screen by adding <code>ThisBuild / watchBeforeCommand := Watch.clearScreen</code> to the project build.sbt file. By default it is no-op.</p>
</li>
<li>
<p><code>watchLogLevel</code> sets the logging level of the file monitoring system. This can be useful if the triggered execution is not being evaluated when source files or modified or if is unexpectedly triggering due to modifications to files that should not be monitored.</p>
</li>
<li>
<p><code>watchInputParser: Parser[Watch.Action]</code> changes how the monitor handles input events. For example, setting <code>watchInputParser := 'l' ^^^ Watch.Reload | '\r' ^^^ new Watch.Run("")</code> will make it so that typing the 'l' key will reload the build and typing a newline will return to the shell. By default this is automatically derived from the <code>watchInputOptions</code>.</p>
</li>
<li>
<p><code>watchStartMessage: (Int, ProjectRef, Seq[String]) =&gt; Option[String]</code> sets the banner that is printed while the watch process is waiting for file or input events. The inputs are the iteration count, the current project and the commands to run. The default message includes instructions for terminating the watch or displaying all available options. This banner is only displayed if <code>watchOnIteration</code> logs the result of <code>watchStartMessage</code>.</p>
</li>
<li>
<p><code>watchOnIteration: (Int, ProjectRef, Seq[String]) =&gt; Watch.Action</code> a function that is evaluated before waiting for source or input events. It can be used to terminate the watch early if, for example, a certain number of iterations have been reached. By default, it just logs the result of <code>watchStartMessage</code>.</p>
</li>
<li>
<p><code>watchForceTriggerOnAnyChange: Boolean</code> configures whether or not the contents of a source file must change in order to trigger a build. The default value is false.</p>
</li>
<li>
<p><code>watchPersistFileStamps: Boolean</code> toggles whether or not sbt will persist the file hashes computed for source files across multiple task evaluation runs. This can improve performance for projects with many source files. Because the file hashes are cached, it is possible for the evaluated task to read an invalid hash if many source files are being concurrently modified. The default value is false.</p>
</li>
<li>
<p><code>watchAntiEntropy: FiniteDuration</code> controls the time that must elapse before a build is re-triggered by the same file that previously triggered the build. This is intended to prevent spurious builds that can occur when a file is modified in short bursts. The default value is 500ms.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cached-task"><a class="header" href="#cached-task">Cached task</a></h1>
<p>This page covers the cached task details. See <a href="reference/../concepts/caching.html">Caching</a> for a general explanation.</p>
<h2 id="automatic-caching-1"><a class="header" href="#automatic-caching-1">Automatic caching</a></h2>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := name.value + version.value + "!"
</code></pre>
<p>In sbt 2.x, the task result will be automatically cached based on the two settings <code>name</code> and <code>version</code>. The first time we run the task it will be executed onsite, but the second time onward, it will use the disk cache:</p>
<pre><code>sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 0%, 1 onsite task
sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
</code></pre>
<h3 id="caching-is-serialization-hard-1"><a class="header" href="#caching-is-serialization-hard-1">Caching is serialization-hard</a></h3>
<p>To participate in the automatic caching, the input keys (e.g. <code>name</code> and <code>version</code>) must provide a given for <code>sjsonnew.HashWriter</code> typeclass and return type must provide a given for <code>sjsonnew.JsonFormat</code>. <a href="https://www.scala-sbt.org/contraband/">Contraband</a> can be used to generate sjson-new codecs.</p>
<h2 id="effect-tracking"><a class="header" href="#effect-tracking">Effect tracking</a></h2>
<h3 id="the-effect-of-file-creation-1"><a class="header" href="#the-effect-of-file-creation-1">The effect of file creation</a></h3>
<p>To cache the effect of file creation, not just returning the name of the file, we need to track the effect of file creation using <code>Def.declareOutput(vf)</code>.</p>
<pre><code class="language-scala">someKey := {
  val conv = fileConverter.value
  val out: java.nio.file.Path = createFile(...)
  val vf: xsbti.VirtualFile = conv.toVirtualFile(out)
  Def.declareOutput(vf)
  vf: xsbti.HashedVirtualFileRef
}
</code></pre>
<h2 id="opting-out-from-caching"><a class="header" href="#opting-out-from-caching">Opting out from caching</a></h2>
<h3 id="build-wide-opt-out"><a class="header" href="#build-wide-opt-out">Build-wide opt-out</a></h3>
<p>To opt out of by-default custom task caching, add the following to <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">Compile / scalacOptions += "-Xmacro-settings:sbt:no-default-task-cache"
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/cached-task.html#admonition-note"></a>
</div>
<div>
<p>This applies only to the custom tasks introduced in the build. Any cached tasks provided by sbt or plugins will remain cached.</p>
</div>
</div>
<h3 id="per-task-key-opt-out"><a class="header" href="#per-task-key-opt-out">Per-task-key opt-out</a></h3>
<p>Next, if you want to opt some task keys from caching, you can set the cache level as follows:</p>
<pre><code class="language-scala">@transient
val someKey = taskKey[String]("something")
</code></pre>
<p>or</p>
<pre><code class="language-scala">@cacheLevel(include = Array.empty)
val someKey = taskKey[String]("something")
</code></pre>
<h3 id="per-task-opt-out"><a class="header" href="#per-task-opt-out">Per-task opt-out</a></h3>
<p>To opt out of the cache individually, use <code>Def.uncached(...)</code> as follows:</p>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := Def.uncached {
  name.value + somethingUncachable.value + "!"
}
</code></pre>
<h2 id="remote-caching-2"><a class="header" href="#remote-caching-2">Remote caching</a></h2>
<p>sbt 2.x implements Bazel-compatible gRPC interface, which works with number of backend both open source and commercial. See <a href="reference/./remote-cache-setup.html">Remote cache setup</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-building-setup"><a class="header" href="#cross-building-setup">Cross building setup</a></h1>
<p>This page covers cross building setup. See <a href="reference/../concepts/cross-building.html">Cross building</a> for general explanation.</p>
<h2 id="using-cross-built-libraries-1"><a class="header" href="#using-cross-built-libraries-1">Using cross-built libraries</a></h2>
<p>To use a library built against multiple versions of Scala, double the first <code>%</code> in a ModuleID to be <code>%%</code>. This tells sbt that it should append the current version of Scala being used to build the library to the dependency’s name. For example:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" %% "cats-effect" % "3.5.4"
</code></pre>
<p>A nearly equivalent, manual alternative for a fixed version of Scala is:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" % "cats-effect_3" % "3.5.4"
</code></pre>
<h3 id="scala-3-specific-cross-versions"><a class="header" href="#scala-3-specific-cross-versions">Scala 3 specific cross-versions</a></h3>
<p>If you are developing an application in Scala 3, you can use Scala 2.13 libraries:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.for3Use2_13)
</code></pre>
<p>This is equivalent to using <code>%%</code> except it resolves the <code>_2.13</code> variant of the library  when <code>scalaVersion</code> is 3.x.y.</p>
<p>Conversely we have <code>CrossVersion.for2_13Use3</code> to use the <code>_3</code> variant of the library when <code>scalaVersion</code> is 2.13.x:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.for2_13Use3)
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/cross-building-setup.html#admonition-warning"></a>
</div>
<div>
<p><strong>Warning for library authors:</strong> It is generally not safe to publish a Scala 3 library that depends on a Scala 2.13 library or vice-versa. Doing so could introduce two versions of the same library like <code>scala-xml_2.13</code> and <code>scala-xml_3</code> on the end users' classpath.</p>
</div>
</div>
<h3 id="more-about-using-cross-built-libraries"><a class="header" href="#more-about-using-cross-built-libraries">More about using cross-built libraries</a></h3>
<p>You can have fine-grained control over the behavior for different Scala versions by using the <code>cross</code> method on <code>ModuleID</code> These are equivalent:</p>
<pre><code class="language-scala">"a" % "b" % "1.0"
("a" % "b" % "1.0").cross(CrossVersion.disabled)
</code></pre>
<p>These are equivalent:</p>
<pre><code class="language-scala">"a" %% "b" % "1.0"
("a" % "b" % "1.0").cross(CrossVersion.binary)
</code></pre>
<p>This overrides the defaults to always use the full Scala version instead of the binary Scala version:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.full)
</code></pre>
<p><code>CrossVersion.patch</code> sits between <code>CrossVersion.binary</code> and <code>CrossVersion.full</code> in that it strips off any trailing <code>-bin-...</code> suffix which is used to distinguish variant but binary compatible Scala toolchain builds.</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.patch)
</code></pre>
<p><code>CrossVersion.constant</code> fixes a constant value:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.constant("2.9.1"))
</code></pre>
<p>It is equivalent to:</p>
<pre><code class="language-scala">"a" % "b_2.9.1" % "1.0"
</code></pre>
<h2 id="project-matrix-1"><a class="header" href="#project-matrix-1">Project matrix</a></h2>
<p>sbt 2.x introduces project matrix, which enables cross building to happen in parallel.</p>
<pre><code class="language-scala">organization := "com.example"
scalaVersion := "3.7.3"
version      := "0.1.0-SNAPSHOT"

lazy val core = (projectMatrix in file("core"))
  .settings(
    name := "core"
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
<h2 id="publishing-convention"><a class="header" href="#publishing-convention">Publishing convention</a></h2>
<p>We use the Scala ABI (application binary interface) version as suffix to denote which version of Scala was used to compile a library. For example, the artifact name <code>cats-effect_2.13</code> means Scala 2.13.x was used. <code>cats-effect_3</code> means Scala 3.x was used. This fairly simple approach allows interoperability with users of Maven, Ant and other build tools. For pre-prelease versions of Scala, such as 2.13.0-RC1, full version will be considered the ABI version.</p>
<p><code>crossVersion</code> setting can be used to override the publishing convention:</p>
<ul>
<li><code>CrossVersion.disabled</code> (no suffix)</li>
<li><code>CrossVersion.binary</code> (<code>_&lt;scala-abi-version&gt;</code>)</li>
<li><code>CrossVersion.full</code> (<code>_&lt;scala-version&gt;</code>)</li>
</ul>
<p>The default is either <code>CrossVersion.binary</code> or <code>CrossVersion.disabled</code> depending on the value of <code>crossPaths</code>. Because (unlike Scala library) Scala compiler is not forward compatible among the patch releases, compiler plugins should use <code>CrossVersion.full</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-cache-setup"><a class="header" href="#remote-cache-setup">Remote cache setup</a></h1>
<p>This page covers remote caching setup. See <a href="reference/../concepts/caching.html">Caching</a> for general explanation of the caching system.</p>
<h2 id="grpc-remote-cache"><a class="header" href="#grpc-remote-cache">gRPC remote cache</a></h2>
<p>While there might be multiple remote cache store implemention in the future, sbt 2.0 ships with a gRPC client that is compatible with the Bazel remote cache backends. To configure sbt 2.x, add the following to <code>project/plugins.sbt</code></p>
<pre><code class="language-scala">addRemoteCachePlugin
</code></pre>
<p>There are many Bazel remote cache backends, both open source and commercial solutions. While this page documents is not an exhaustive list of all Bazel remote cache implementations, hopefully it shows how sbt 2.x can be set up for wide array of them.</p>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>There are a few flavors of <a href="https://grpc.io/docs/guides/auth/">gRPC authentication</a>, and Bazel remote cache backends use various kind of them:</p>
<ol>
<li>Unauthenticated. Useful for testing.</li>
<li>Default TLS/SSL.</li>
<li>TLS/SSL with custom server certificate.</li>
<li>TTL/SSL with custom server and client certificate, mTLS.</li>
<li>Default TLS/SSL with API token header.</li>
</ol>
<h3 id="bazel-remote-without-authentication"><a class="header" href="#bazel-remote-without-authentication">bazel-remote without authentication</a></h3>
<p>You can grab the code from <a href="https://github.com/buchgr/bazel-remote">buchgr/bazel-remote</a> and run it on a laptop using Bazel:</p>
<pre><code class="language-bash">bazel run :bazel-remote  -- --max_size 5 --dir $HOME/work/bazel-remote/temp \
  --http_address localhost:8000 \
  --grpc_address localhost:2024
</code></pre>
<p>To configure sbt 2.x, add the following to <code>project/plugins.sbt</code></p>
<pre><code class="language-scala">addRemoteCachePlugin
</code></pre>
<p>and append the following to <code>build.sbt</code>:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpc://localhost:2024"))
</code></pre>
<h3 id="bazel-remote-with-mtls"><a class="header" href="#bazel-remote-with-mtls">bazel-remote with mTLS</a></h3>
<p>In a real environment, mTLS can ensure that the transport is encrypted and mutually authenticated. bazel-remote can be started with something like the follows:</p>
<pre><code class="language-bash">bazel run :bazel-remote  -- --max_size 5 --dir $HOME/work/bazel-remote/temp \
  --http_address localhost:8000 \
  --grpc_address localhost:2024 \
  --tls_ca_file /tmp/sslcert/ca.crt \
  --tls_cert_file /tmp/sslcert/server.crt \
  --tls_key_file /tmp/sslcert/server.pem
</code></pre>
<p>sbt 2.x setting would look like this in this scenario:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://localhost:2024"))
Global / remoteCacheTlsCertificate := Some(file("/tmp/sslcert/ca.crt"))
Global / remoteCacheTlsClientCertificate := Some(file("/tmp/sslcert/client.crt"))
Global / remoteCacheTlsClientKey := Some(file("/tmp/sslcert/client.pem"))
</code></pre>
<p>Note the <code>grpcs://</code>, as opposed to <code>grpc://</code>.</p>
<h3 id="engflow"><a class="header" href="#engflow">EngFlow</a></h3>
<p><a href="https://www.engflow.com/">EngFlow GmbH</a> is a build solution company founded in 2020 by core members of Bazel team, providing build analytics and remote execution backend for Bazel, which includes remote cache.</p>
<p>After signing up for trial on <a href="https://my.engflow.com/">https://my.engflow.com/</a>, the page instructs you to start a trial cluster using a docker. If you followed the instruction, this should start a remote cache service on port 8080. The sbt 2.x configuration would look like this for the trial cluster:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpc://localhost:8080"))
</code></pre>
<h3 id="buildbuddy"><a class="header" href="#buildbuddy">BuildBuddy</a></h3>
<p><a href="https://www.buildbuddy.io/">BuildBuddy</a> is a build solution company founded by ex-Google engineers, providing build analytics and remote execution backend for Bazel. It's also available open source as <a href="https://github.com/buildbuddy-io/buildbuddy">buildbuddy-io/buildbuddy</a>.</p>
<p>After signing up, BuildBuddy Personal plan lets you use BuildBuddy across the Internet.</p>
<ol>
<li>From <a href="https://app.buildbuddy.io/">https://app.buildbuddy.io/</a>, go to Settings, and change the Organization URL to <code>&lt;something&gt;.buildbuddy.io</code>.</li>
<li>Next, go to Quickstart and take note of the URLs and <code>--remote_headers</code>.</li>
<li>Create a file called <code>$HOME/.sbt/buildbuddy_credential.txt</code> and put in the API key:</li>
</ol>
<pre><code>x-buildbuddy-api-key=*******
</code></pre>
<p>The sbt 2.x configuration would look like this:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://something.buildbuddy.io"))
Global / remoteCacheHeaders += IO.read(BuildPaths.defaultGlobalBase / "buildbuddy_credential.txt").trim
</code></pre>
<h3 id="nativelink"><a class="header" href="#nativelink">NativeLink</a></h3>
<p><a href="https://docs.nativelink.dev/">NativeLink</a> is an open-source Bazel remote execution backend implementated in Rust with emphasis on performance. As of June 2024, there's NativeLink Cloud in beta.</p>
<ol>
<li>From <a href="https://app.nativelink.com/">https://app.nativelink.com/</a>, go to Quickstart and take note of the URLs and <code>--remote_header</code>.</li>
<li>Create a file called <code>$HOME/.sbt/nativelink_credential.txt</code> and put in the API key:</li>
</ol>
<pre><code>x-nativelink-api-key=*******
</code></pre>
<p>The sbt 2.x configuration would look like this:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://something.build-faster.nativelink.net"))
Global / remoteCacheHeaders += IO.read(BuildPaths.defaultGlobalBase / "nativelink_credential.txt").trim
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifact"><a class="header" href="#artifact">Artifact</a></h1>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>An artifact is a single file ready for publishing a specific version of a subproject. This is a concept that originated in <a href="https://maven.apache.org/ref/3.9.11/maven-core/artifact-handlers.html">Apache Maven</a> and <a href="https://ant.apache.org/ivy/history/2.3.0/terminology.html#artifact">Ivy</a>.</p>
<p>In the JVM ecosystem, common artifacts are Java archives, or JAR files. Compressed package formats are often preferred because they are easier to manage, download, and store.</p>
<p>To illustrate, the following is a list of artifacts for a library, enumerated in an <code>ivy.xml</code> file:</p>
<pre><code class="language-xml">  &lt;publications&gt;
    &lt;artifact name="core_3" type="jar" ext="jar" conf="compile"/&gt;
    &lt;artifact e:classifier="sources" name="core_3" type="src" ext="jar" conf="sources"/&gt;
    &lt;artifact e:classifier="javadoc" name="core_3" type="doc" ext="jar" conf="docs"/&gt;
    &lt;artifact name="core_3" type="pom" ext="pom" conf="pom"/&gt;
  &lt;/publications&gt;
</code></pre>
<p>This shows that an artifact has a name, a type, and an extention, and optionally a classifier.</p>
<ul>
<li><strong>name</strong>. This is going to be the same as the subproject's module name.</li>
<li><strong>type</strong>. The functional category of the artifact, such as <code>jar</code>, <code>src</code>, and <code>doc</code>.</li>
<li><strong>extension</strong>. The file extention, such as <code>jar</code>, <code>war</code>, <code>zip</code>, <code>xml</code> etc.</li>
<li><strong>classifier</strong>. In Maven, classifier is an arbitrary string that can be appended for an alternative or secondary artifact.</li>
</ul>
<h3 id="selecting-default-artifacts"><a class="header" href="#selecting-default-artifacts">Selecting default artifacts</a></h3>
<p>By default, the published artifacts are:</p>
<ol>
<li>The main binary JAR</li>
<li>The JAR containing the main sources and resources</li>
<li>The JAR containing the API documentation</li>
</ol>
<p>You can add artifacts for the test classes, sources, or API or you can disable some of the main artifacts.</p>
<p>To add all <code>Test</code> artifacts:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    Test / publishArtifact := true,
  )
</code></pre>
<p>To add them individually:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // enable publishing the jar produced by `Test/package`
    Test / packageBin / publishArtifact := true,

    // enable publishing the test API jar
    Test / packageDoc / publishArtifact := true,

    // enable publishing the test sources jar
    Test / packageSrc / publishArtifact := true,
  )
</code></pre>
<p>To disable main artifacts individually:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // disable publishing the main jar produced by `package`
    Compile / packageBin / publishArtifact := false,

    // disable publishing the main API jar
    Compile / packageDoc / publishArtifact := false,

    // disable publishing the main sources jar
    Compile / packageSrc / publishArtifact := false,
  )
</code></pre>
<h3 id="modifying-default-artifacts"><a class="header" href="#modifying-default-artifacts">Modifying default artifacts</a></h3>
<p>Each built-in artifact has several configurable settings in addition to <code>publishArtifact</code>. The basic ones are <code>artifact</code> (of type <code>SettingKey[Artifact]</code>), <code>mappings</code> (of type <code>TaskKey[(File, String)]</code>), and <code>artifactPath</code> (of type <code>SettingKey[File]</code>). They are scoped by <code>(Config / &lt;task&gt;)</code> as indicated in the previous section.</p>
<p>To modify the type of the main artifact, for example:</p>
<pre><code class="language-scala">Compile / packageBin / artifact := {
  val prev: Artifact = (Compile / packageBin / artifact).value
  prev.withType("bundle")
}
</code></pre>
<p>The generated artifact name is determined by the <code>artifactName</code> setting. This setting is of type <code>(ScalaVersion, ModuleID, Artifact) =&gt; String</code>. The ScalaVersion argument provides the full Scala version String and the binary compatible part of the version String. The String result is the name of the file to produce. The default implementation is <code>Artifact.artifactName _</code>. The function may be modified to produce different local names for artifacts without affecting the published name, which is determined by the <code>artifact</code> definition combined with the repository pattern.</p>
<p>For example, to produce a minimal name without a classifier or cross path:</p>
<pre><code class="language-scala">artifactName := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =&gt;
  artifact.name + "-" + module.revision + "." + artifact.extension
}
</code></pre>
<p>(Note that in practice you rarely want to drop the classifier.)</p>
<p>Finally, you can get the <code>(Artifact, File)</code> pair for the artifact by mapping the <code>packagedArtifact</code> task. Note that if you don't need the <code>Artifact</code>, you can get just the File from the package task (<code>package</code>, <code>packageDoc</code>, or <code>packageSrc</code>). In both cases, mapping the task to get the file ensures that the artifact is generated first and so the file is guaranteed to be up-to-date.</p>
<p>For example:</p>
<pre><code class="language-scala">val myTask = taskKey[Unit]("My task.")

myTask :=  {
  val (art, file) = (Compile / packageBin / packagedArtifact).value
  println("Artifact definition: " + art)
  println("Packaged file: " + file.getAbsolutePath)
}
</code></pre>
<h3 id="defining-custom-artifacts"><a class="header" href="#defining-custom-artifacts">Defining custom artifacts</a></h3>
<p>In addition to configuring the built-in artifacts, you can declare other artifacts to publish. Multiple artifacts are allowed when using Ivy metadata, but a Maven POM file only supports distinguishing artifacts based on classifiers and these are not recorded in the POM.</p>
<p>Basic <code>Artifact</code> construction look like:</p>
<pre><code class="language-scala">Artifact("name", "type", "extension")
Artifact("name", "classifier")
Artifact("name", url: URL)
Artifact("name", Map("extra1" -&gt; "value1", "extra2" -&gt; "value2"))
</code></pre>
<p>For example:</p>
<pre><code class="language-scala">Artifact("myproject", "zip", "zip")
Artifact("myproject", "image", "jpg")
Artifact("myproject", "jdk15")
</code></pre>
<p>See the <a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency-artifact.html">Ivy documentation</a> for more details on artifacts. See the <a href="reference/../api/sbt/librarymanagement/Artifact$.html">Artifact API</a> for combining the parameters above and specifying [Configurations] and extra attributes.</p>
<p>To declare these artifacts for publishing, map them to the task that generates the artifact:</p>
<pre><code class="language-scala">val myImageTask = taskKey[File](...)

myImageTask := {
  val artifact: File = makeArtifact(...)
  artifact
}

addArtifact(Artifact("myproject", "image", "jpg"), myImageTask)
</code></pre>
<p><code>addArtifact</code> returns a sequence of settings (wrapped in a <a href="reference/../api/sbt/internal/util/Init$SettingsDefinition.html">SettingsDefinition</a>). In a full build configuration, usage looks like:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    addArtifact(...)
  )
</code></pre>
<h3 id="publishing-war-files"><a class="header" href="#publishing-war-files">Publishing .war files</a></h3>
<p>A common use case for web applications is to publish the <code>.war</code> file instead of the <code>.jar</code> file.</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // disable .jar publishing
    Compile / packageBin / publishArtifact := false,

    // create an Artifact for publishing the .war file
    Compile / packageWar / artifact := {
      val prev: Artifact = (Compile / packageWar / artifact).value
      prev.withType("war").withExtension("war")
    },

    // add the .war file to what gets published
    addArtifact(Compile / packageWar / artifact, packageWar),
  )
</code></pre>
<h3 id="using-dependencies-with-artifacts"><a class="header" href="#using-dependencies-with-artifacts">Using dependencies with artifacts</a></h3>
<p>To specify the artifacts to use from a dependency that has custom or multiple artifacts, use the <code>artifacts</code> method on your dependencies. For example:</p>
<pre><code class="language-scala">libraryDependencies += ("org" % "name" % "rev").artifacts(Artifact("name", "type", "ext"))
</code></pre>
<p>The <code>from</code> and <code>classifer</code> methods (described on the <a href="reference/./sbt-update.html">sbt update</a> page) are actually convenience methods that translate to <code>artifacts</code>:</p>
<pre><code class="language-scala">def from(url: String) = artifacts(Artifact(name, new URL(url)))
def classifier(c: String) = artifacts(Artifact(name, c))
</code></pre>
<p>That is, the following two dependency declarations are equivalent:</p>
<pre><code class="language-scala">libraryDependencies += ("org.testng" % "testng" % "5.7").classifier("jdk15")

libraryDependencies += ("org.testng" % "testng" % "5.7").artifacts(Artifact("testng", "jdk15"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-task"><a class="header" href="#input-task">Input task</a></h1>
<p>sbt provides a capability to define custom tasks that can parse user inputs and offer tab completion. The details of the parser will be covered in <a href="reference/tab-completion-parser.html">tab-completion parser</a> later.</p>
<p>This page describes how to hook those parser combinators into the input task system.</p>
<h2 id="input-keys"><a class="header" href="#input-keys">Input keys</a></h2>
<p>A key for an input task is of type <code>InputKey</code> and represents the input task like a <code>SettingKey</code> represents a setting or a <code>TaskKey</code> represents a task. Define a new input task key using the <code>inputKey.apply</code> factory method:</p>
<pre><code class="language-scala">// goes in project/Build.scala or in build.sbt
val demo = inputKey[Unit]("A demo input task.")
</code></pre>
<p>The definition of an input task is similar to that of a normal task, but it can also use the result of a</p>
<p><a href="reference/tab-completion-parser.html">Parser</a> applied to user input. Just as the special <code>value</code> method gets the value of a setting or task, the special <code>parsed</code> method gets the result of a <code>Parser</code>.</p>
<h2 id="basic-input-task-definition"><a class="header" href="#basic-input-task-definition">Basic input task definition</a></h2>
<p>The simplest input task accepts a space-delimited sequence of arguments. It does not provide useful tab completion and parsing is basic. The built-in parser for space-delimited arguments is constructed via the <code>spaceDelimited</code> method, which accepts as its only argument the label to present to the user during tab completion.</p>
<p>For example, the following task prints the current Scala version and then echoes the arguments passed to it on their own line.</p>
<pre><code class="language-scala">import complete.DefaultParsers.{ *, given }

demo := {
  // get the result of parsing
  val args: Seq[String] = spaceDelimited("&lt;arg&gt;").parsed
  // Here, we also use the value of the `scalaVersion` setting
  println("The current Scala version is " + scalaVersion.value)
  println("The arguments to demo were:")
  args.foreach(println(_))
}
</code></pre>
<h2 id="input-task-using-parsers"><a class="header" href="#input-task-using-parsers">Input task using Parsers</a></h2>
<p>The Parser provided by the <code>spaceDelimited</code> method does not provide any flexibility in defining the input syntax. Using a custom parser is just a matter of defining your own <code>Parser</code> as described on the <a href="reference/tab-completion-parser.html">Parsing Input</a> page.</p>
<h3 id="constructing-the-parser"><a class="header" href="#constructing-the-parser">Constructing the Parser</a></h3>
<p>The first step is to construct the actual <code>Parser</code> by defining a value of one of the following types:</p>
<ol>
<li><code>Parser[I]</code>: a basic parser that does not use any settings</li>
<li><code>Initialize[Parser[I]]</code>: a parser whose definition depends on one or more settings</li>
<li><code>Initialize[State =&gt; Parser[I]]</code>: a parser that is defined using both settings and the current <a href="reference/Build-State.html">state</a></li>
</ol>
<p>We already saw an example of the first case with <code>spaceDelimited</code>, which doesn't use any settings in its definition. As an example of the third case, the following defines a contrived <code>Parser</code> that uses the project's Scala and sbt version settings as well as the state. To use these settings, we need to wrap the Parser construction in <code>Def.setting</code> and get the setting values with the special <code>value</code> method:</p>
<pre><code class="language-scala">import sbt.complete.DefaultParsers.{ *, given }
import sbt.complete.Parser

val parser: Def.Initialize[State =&gt; Parser[(String,String)]] =
Def.setting {
  (state: State) =&gt;
    ( token("scala" &lt;~ Space) ~ token(scalaVersion.value) ) |
    ( token("sbt" &lt;~ Space) ~ token(sbtVersion.value) ) |
    ( token("commands" &lt;~ Space) ~
        token(state.remainingCommands.size.toString) )
}
</code></pre>
<p>This Parser definition will produce a value of type <code>(String,String)</code>. The input syntax defined isn't very flexible; it is just a demonstration. It will produce one of the following values for a successful parse (assuming the current Scala version is 3.7.3, the current sbt version is 2.0.0-RC6, and there are 3 commands left to run):</p>
<ul>
<li>(scala,3.7.3)</li>
<li>(sbt,2.0.0-RC6)</li>
<li>(commands,3)</li>
</ul>
<p>Again, we were able to access the current Scala and sbt version for the project because they are settings. Tasks cannot be used to define the parser.</p>
<h3 id="constructing-the-task"><a class="header" href="#constructing-the-task">Constructing the Task</a></h3>
<p>Next, we construct the actual task to execute from the result of the <code>Parser</code>. For this, we define a task as usual, but we can access the result of parsing via the special <code>parsed</code> method on <code>Parser</code>.</p>
<p>The following contrived example uses the previous example's output (of type <code>(String,String)</code>) and the result of the <code>package</code> task to print some information to the screen.</p>
<pre><code class="language-scala">demo := {
    val (tpe, value) = parser.parsed
    println("Type: " + tpe)
    println("Value: " + value)
    println("Packaged: " + packageBin.value.getAbsolutePath)
}
</code></pre>
<h2 id="the-inputtask-type"><a class="header" href="#the-inputtask-type">The InputTask type</a></h2>
<p>It helps to look at the <code>InputTask</code> type to understand more advanced usage of input tasks. The core input task type is:</p>
<pre><code class="language-scala">class InputTask[A1](val parser: State =&gt; Parser[Task[A1]])
</code></pre>
<p>Normally, an input task is assigned to a setting and you work with <code>Initialize[InputTask[A1]]</code>.</p>
<p>Breaking this down,</p>
<ol>
<li>You can use other settings (via Initialize) to construct an input task.</li>
<li>You can use the current State to construct the parser.</li>
<li>The parser accepts user input and provides tab completion.</li>
<li>The parser produces the task to run.</li>
</ol>
<p>So, you can use settings or <code>State</code> to construct the parser that defines an input task's command line syntax. This was described in the previous section. You can then use settings, <code>State</code>, or user input to construct the task to run. This is implicit in the input task syntax.</p>
<h2 id="using-other-input-tasks"><a class="header" href="#using-other-input-tasks">Using other input tasks</a></h2>
<p>The types involved in an input task are composable, so it is possible to reuse input tasks. The <code>.parsed</code> and <code>.evaluated</code> methods are defined on InputTasks to make this more convenient in common situations:</p>
<ul>
<li>Call <code>.parsed</code> on an <code>InputTask[A1]</code> or <code>Initialize[InputTask[A1]]</code> to get the <code>Task[A1]</code> created after parsing the command line</li>
<li>Call <code>.evaluated</code> on an <code>InputTask[A1]</code> or <code>Initialize[InputTask[A1]]</code> to get the value of type <code>A1</code> from evaluating that task</li>
</ul>
<p>In both situations, the underlying <code>Parser</code> is sequenced with other parsers in the input task definition. In the case of <code>.evaluated</code>, the generated task is evaluated.</p>
<p>The following example applies the <code>run</code> input task, a literal separator parser <code>--</code>, and <code>run</code> again. The parsers are sequenced in order of syntactic appearance, so that the arguments before <code>--</code> are passed to the first <code>run</code> and the ones after are passed to the second.</p>
<pre><code class="language-scala">val run2 = inputKey[Unit](
    "Runs the main class twice with different argument lists separated by --")

val separator: Parser[String] = "--"

run2 := {
   val one = (Compile / run).evaluated
   val sep = separator.parsed
   val two = (Compile / run).evaluated
}
</code></pre>
<p>For a main class Demo that echoes its arguments, this looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; run2 a b -- c d
[info] Running Demo c d
[info] Running Demo a b
c
d
a
b
</code></pre>
<h2 id="preapplying-input"><a class="header" href="#preapplying-input">Preapplying input</a></h2>
<p>Because <code>InputTasks</code> are built from <code>Parsers</code>, it is possible to generate a new <code>InputTask</code> by applying some input programmatically. (It is also possible to generate a <code>Task</code>, which is covered in the next section.) Two convenience methods are provided on <code>InputTask[T]</code> and <code>Initialize[InputTask[T]]</code> that accept the String to apply.</p>
<ul>
<li><code>partialInput</code> applies the input and allows further input, such as from the command line</li>
<li><code>fullInput</code> applies the input and terminates parsing, so that further input is not accepted</li>
</ul>
<p>In each case, the input is applied to the input task's parser. Because input tasks handle all input after the task name, they usually require initial whitespace to be provided in the input.</p>
<p>Consider the example in the previous section. We can modify it so that we:</p>
<ul>
<li>Explicitly specify all of the arguments to the first <code>run</code>. We use <code>name</code> and <code>version</code> to show that settings can be used to define and modify parsers.</li>
<li>Define the initial arguments passed to the second <code>run</code>, but allow further input on the command line.</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/input-task.html#admonition-note"></a>
</div>
<div>
<p>If the input derives from settings you need to use, for
example, <code>Def.taskDyn { ... }.value</code></p>
</div>
</div>
<pre><code class="language-scala">lazy val run2 = inputKey[Unit]("Runs the main class twice: " +
   "once with the project name and version as arguments"
   "and once with command line arguments preceded by hard coded values.")

// The argument string for the first run task is ' &lt;name&gt; &lt;version&gt;'
lazy val firstInput: Initialize[String] =
   Def.setting(s" ${name.value} ${version.value}")

// Make the first arguments to the second run task ' red blue'
lazy val secondInput: String = " red blue"

run2 := {
   val one = (Compile / run).fullInput(firstInput.value).evaluated
   val two = (Compile / run).partialInput(secondInput).evaluated
}
</code></pre>
<p>For a main class Demo that echoes its arguments, this looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; run2 green
[info] Running Demo demo 1.0
[info] Running Demo red blue green
demo
1.0
red
blue
green
</code></pre>
<h2 id="get-a-task-from-an-inputtask"><a class="header" href="#get-a-task-from-an-inputtask">Get a Task from an InputTask</a></h2>
<p>The previous section showed how to derive a new <code>InputTask</code> by applying input. In this section, applying input produces a <code>Task</code>. The <code>toTask</code> method on <code>Initialize[InputTask[A1]]</code> accepts the <code>String</code> input to apply and produces a task that can be used normally. For example, the following defines a plain task <code>runFixed</code> that can be used by other tasks or run directly without providing any input:</p>
<pre><code class="language-scala">lazy val runFixed = taskKey[Unit]("A task that hard codes the values to `run`")

runFixed := {
   val _ = (Compile / run).toTask(" blue green").value
   println("Done!")
}
</code></pre>
<p>For a main class Demo that echoes its arguments, running <code>runFixed</code> looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; runFixed
[info] Running Demo blue green
blue
green
Done!
</code></pre>
<p>Each call to <code>toTask</code> generates a new task, but each task is configured the same as the original <code>InputTask</code> (in this case, <code>run</code>) but with different input applied. For example:</p>
<pre><code class="language-scala">lazy val runFixed2 = taskKey[Unit]("A task that hard codes the values to `run`")

run / fork := true

runFixed2 := {
   val x = (Compile / run).toTask(" blue green").value
   val y = (Compile / run).toTask(" red orange").value
   println("Done!")
}
</code></pre>
<p>The different <code>toTask</code> calls define different tasks that each run the project's main class in a new jvm. That is, the <code>fork</code> setting configures both, each has the same classpath, and each run the same main class. However, each task passes different arguments to the main class. For a main class Demo that echoes its arguments, the output of running <code>runFixed2</code> might look like:</p>
<pre><code class="language-bash">$ sbt
&gt; runFixed2
[info] Running Demo blue green
[info] Running Demo red orange
blue
green
red
orange
Done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-completion-parser"><a class="header" href="#tab-completion-parser">Tab-completion parser</a></h1>
<p>This page describes the parser combinators in sbt. These parsers are used to parse user input and provide tab completion for <a href="reference/input-task.html">input tasks</a> and <a href="reference/../concepts/command.html">commands</a>.</p>
<!--
If you are already familiar with Scala's parser combinators, the methods
are mostly the same except that their arguments are strict. There are
two additional methods for controlling tab completion that are discussed
at the end of the section.
-->
<p>Parser combinators build up a parser from smaller parsers. A <code>Parser[A]</code> in its most basic usage is a function <code>String =&gt; Option[A]</code>. It accepts a <code>String</code> to parse and produces a value wrapped in <code>Some</code> if parsing succeeds or <code>None</code> if it fails. Error handling and tab completion make this picture more complicated, but we'll stick with <code>Option</code> for this discussion.</p>
<h2 id="basic-parsers"><a class="header" href="#basic-parsers">Basic parsers</a></h2>
<p>The simplest parser combinators match exact inputs:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the input is 'x', returning the Char 'x'
//  and failing otherwise
val singleChar: Parser[Char] = 'x'

// A parser that succeeds if the input is "blue", returning the String "blue"
//   and failing otherwise
val litString: Parser[String] = "blue"
</code></pre>
<p>In these examples, implicit conversions produce a literal <code>Parser</code> from a <code>Char</code> or <code>String</code>. Other basic parser constructors are the <code>charClass</code>, <code>success</code> and <code>failure</code> methods:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the character is a digit, returning the matched Char
//   The second argument, "digit", describes the parser and is used in error messages
val digit: Parser[Char] = charClass((c: Char) =&gt; c.isDigit, "digit")

// A parser that produces the value 3 for an empty input string, fails otherwise
val alwaysSucceed: Parser[Int] = success(3)

// Represents failure (always returns None for an input String).
//  The argument is the error message.
val alwaysFail: Parser[Nothing] = failure("Invalid input.")
</code></pre>
<h2 id="built-in-parsers"><a class="header" href="#built-in-parsers">Built-in parsers</a></h2>
<p>sbt comes with several built-in parsers defined in <code>sbt.complete.DefaultParsers</code>. <!-- ../api/sbt/internal/util/complete/DefaultParsers$.html --></p>
<p>Some commonly used built-in parsers are:</p>
<ul>
<li><code>Space</code>, <code>NotSpace</code>, <code>OptSpace</code>, and <code>OptNotSpace</code> for parsing spaces or non-spaces, required or not.</li>
<li><code>StringBasic</code> for parsing text that may be quoted.</li>
<li><code>IntBasic</code> for parsing a signed Int value.</li>
<li><code>Digit</code> and <code>HexDigit</code> for parsing a single decimal or hexadecimal digit.</li>
<li><code>Bool</code> for parsing a <code>Boolean</code> value</li>
</ul>
<p>See the <a href="reference/../api/sbt/internal/util/complete/DefaultParsers$.html">DefaultParsers API</a> for details.</p>
<h2 id="combining-parsers"><a class="header" href="#combining-parsers">Combining parsers</a></h2>
<p>We build on these basic parsers to construct more interesting parsers. We can combine parsers in a sequence, choose between parsers, or repeat a parser.</p>
<pre><code class="language-scala">// A parser that succeeds if the input is "blue" or "green",
//  returning the matched input
val color: Parser[String] = "blue" | "green"

// A parser that matches either "fg" or "bg"
val select: Parser[String] = "fg" | "bg"

// A parser that matches "fg" or "bg", a space, and then the color, returning the matched values.
val setColor: Parser[(String, Char, String)] =
  select ~ ' ' ~ color

// Often, we don't care about the value matched by a parser, such as the space above
//  For this, we can use ~&gt; or &lt;~, which keep the result of
//  the parser on the right or left, respectively
val setColor2: Parser[(String, String)]  =  select ~ (' ' ~&gt; color)

// Match one or more digits, returning a list of the matched characters
val digits: Parser[Seq[Char]] = charClass(_.isDigit, "digit").+

// Match zero or more digits, returning a list of the matched characters
val digits0: Parser[Seq[Char]] = charClass(_.isDigit, "digit").*

// Optionally match a digit
val optDigit: Parser[Option[Char]] = charClass(_.isDigit, "digit").?
</code></pre>
<h2 id="transforming-results"><a class="header" href="#transforming-results">Transforming results</a></h2>
<p>A key aspect of parser combinators is transforming results along the way into more useful data structures. The fundamental methods for this are <code>map</code> and <code>flatMap</code>. Here are examples of <code>map</code> and some convenience methods implemented on top of <code>map</code>.</p>
<pre><code class="language-scala">// Apply the `digits` parser and apply the provided function to the matched
//   character sequence
val num: Parser[Int] = digits.map: (chars: Seq[Char]) =&gt;
  chars.mkString.toInt }

// Match a digit character, returning the matched character or return '0' if the input is not a digit
val digitWithDefault: Parser[Char] = charClass(_.isDigit, "digit") ?? '0'

// The previous example is equivalent to:
val digitDefault: Parser[Char] =
  charClass(_.isDigit, "digit").?.map: (d: Option[Char]) =&gt;
    d.getOrElse('0')

// Succeed if the input is "blue" and return the value 4
val blue = "blue" ^^^ 4

// The above is equivalent to:
val blueM = "blue".map((s: String) =&gt; 4)
</code></pre>
<h2 id="controlling-tab-completion"><a class="header" href="#controlling-tab-completion">Controlling tab completion</a></h2>
<p>Most parsers have reasonable default tab completion behavior. For example, the string and character literal parsers will suggest the underlying literal for an empty input string. However, it is impractical to determine the valid completions for <code>charClass</code>, since it accepts an arbitrary predicate. The <code>examples</code> method defines explicit completions for such a parser:</p>
<pre><code class="language-scala">val digit = charClass(_.isDigit, "digit").examples("0", "1", "2")
</code></pre>
<p>Tab completion will use the examples as suggestions. The other method controlling tab completion is <code>token</code>. The main purpose of <code>token</code> is to determine the boundaries for suggestions. For example, if your parser is:</p>
<pre><code class="language-scala">("fg" | "bg") ~ ' ' ~ ("green" | "blue")
</code></pre>
<p>then the potential completions on empty input are: <code>console fg green fg blue bg green bg blue</code></p>
<p>Typically, you want to suggest smaller segments or the number of suggestions becomes unmanageable. A better parser is:</p>
<pre><code class="language-scala">token( ("fg" | "bg") ~ ' ') ~ token("green" | "blue")
</code></pre>
<p>Now, the initial suggestions would be (with <code>_</code> representing a space): <code>console fg_ bg_</code></p>
<p>Be careful not to overlap or nest tokens, as in <code>token("green" ~ token("blue"))</code>. The behavior is unspecified (and should generate an error in the future), but typically the outer most token definition will be used.</p>
<h2 id="dependent-parsers"><a class="header" href="#dependent-parsers">Dependent parsers</a></h2>
<p>Sometimes a parser must analyze some data and then more data needs to be parsed, and it is dependent on the previous one. The key for obtaining this behaviour is to use the <code>flatMap</code> function.</p>
<p>As an example, it will shown how to select several items from a list of valid ones with completion, but no duplicates are possible.  A space is used to separate the different items.</p>
<pre><code class="language-scala">def select1(items: Iterable[String]) =
  token(Space ~&gt; StringBasic.examples(FixedSetExamples(items)))

def selectSome(items: Seq[String]): Parser[Seq[String]] = {
   select1(items).flatMap: v =&gt;
     val remaining = items.filter(_ != v)
     if remaining.size == 0 then success(v :: Nil)
     else selectSome(remaining).?.map(v +: _.getOrElse(Seq()))
 }
</code></pre>
<p>As you can see, the <code>flatMap</code> function provides the previous value.  With this info, a new parser is constructed for the remaining items.  The <code>map</code> combinator is also used in order to transform the output of the parser.</p>
<p>The parser is called recursively, until it is found the trivial case of no possible choices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-plugins"><a class="header" href="#community-plugins">Community Plugins</a></h1>
<h3 id="the-github-sbt-organization"><a class="header" href="#the-github-sbt-organization">The GitHub sbt Organization</a></h3>
<p>The <a href="https://github.com/sbt">sbt organization</a> is available for use by any sbt plugin. Developers who contribute their plugins into the community organization will still retain control over their repository and its access. The goal of the sbt organization is to organize sbt software into one central location.</p>
<p>A side benefit to using the sbt organization for projects is that you can use gh-pages to host websites under the https://www.scala-sbt.org domain.</p>
<p>The <a href="https://github.com/sbt/sbt-autoplugin.g8">sbt autoplugin giter8 template</a> is a good place to start. This sets up a new sbt plugin project appropriately. The generated <code>README</code> includes a summary of the steps for publishing a new community plugin.</p>
<div id="admonition-plugins-available-for-sbt-2x" class="admonition admonish-note" role="note" aria-labelledby="admonition-plugins-available-for-sbt-2x-title">
<div class="admonition-title">
<div id="admonition-plugins-available-for-sbt-2x-title">
<p>Plugins available for sbt 2.x</p>
</div>
<a class="admonition-anchor-link" href="community-plugins.html#admonition-plugins-available-for-sbt-2x"></a>
</div>
<div>
<p><a href="https://github.com/sbt/website/edit/develop/src/reference/community-plugins.md">[Edit]</a> this page to
submit a pull request that adds
your plugin to the list.</p>
</div>
</div>
<div style="display: none;">
### Code formatter plugins
<ul>
<li><a href="https://scalameta.org/scalafmt/">sbt-scalafmt</a>: code formatting using Scalafmt. <!-- 829 stars --></li>
<li><a href="https://github.com/sbt/sbt-scalariform">sbt-scalariform</a>: code formatting using Scalariform. <!-- 218 stars --></li>
<li><a href="https://github.com/lucidsoftware/neo-sbt-scalafmt">neo-sbt-scalafmt</a>: code formatting using Scalafmt. <!-- 80 stars --></li>
<li><a href="https://github.com/sbt/sbt-java-formatter">sbt-java-formatter</a>: code formatting for Java sources. <!-- 8 stars --></li>
<li><a href="https://github.com/swoval/sbt-source-format">sbt-source-format</a>: code formatting for Java and clang (c/c++/objc) sources. <!-- 1 stars --></li>
<li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of style rules across your company</li>
</ul>
</div>
<div style="display: none;">
<h3 id="one-jar-plugins"><a class="header" href="#one-jar-plugins">One jar plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a>: create über JARs.<!-- 1136 stars --></li>
</ul>
</div>
<div style="display: none;">
<h3 id="verification-plugins"><a class="header" href="#verification-plugins">Verification plugins</a></h3>
<ul>
<li><a href="https://github.com/NiceKingWei/sbt-stainless">sbt-stainless</a>: verify Scala or Dotty code using stainless. <!-- 1 star --></li>
</ul>
<h3 id="language-support-plugins"><a class="header" href="#language-support-plugins">Language support plugins</a></h3>
<ul>
<li><a href="https://github.com/earldouglas/sbt-frege">sbt-frege</a>: build Frege code with sbt. <!-- 47 stars --></li>
<li><a href="https://github.com/tnakamot/sbt-cc">sbt-cc</a>: compile C and C++ source files with sbt.</li>
</ul>
</div>
<h3 id="release-plugins"><a class="header" href="#release-plugins">Release plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-native-packager">sbt-native-packager</a> (<a href="https://sbt-native-packager.readthedocs.io/en/stable/">docs</a>): build native packages (RPM, .deb etc) for your projects. <!-- 1602 stars --></li>
<li><a href="https://github.com/sbt/sbt-release">sbt-release</a>: create a customizable release process. <!-- 652 stars --></li>
<li><a href="https://github.com/sbt/sbt-ci-release">sbt-ci-release</a>: automate Central Repo releases from GitHub Actions. <!-- 302 stars --></li>
<li><a href="https://github.com/sbt/sbt-pgp">sbt-pgp</a>: sign artifacts using PGP/GPG and manage signing keys. <!-- 149 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/xerial/sbt-pack">sbt-pack</a>: create runnable distributions for your projects. <!-- 302 stars --></p>
</li>
<li>
<p><a href="https://github.com/marcuslonnberg/sbt-docker">sbt-docker</a>: create and push Docker images. <!-- 72 stars --></p>
</li>
<li>
<p><a href="https://github.com/arktekk/sbt-aether-deploy">sbt-aether-deploy</a>: publish artefacts using Eclipse Aether. <!-- 59 stars --></p>
</li>
<li>
<p><a href="https://github.com/Verizon/sbt-rig">sbt-rig</a>: opinionated common release steps. <!-- 50 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-s3">sbt-s3</a>: manage objects on Amazon S3.<!-- 36 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-osgi">sbt-osgi</a>: create OSGi bundles.<!-- 32 stars --></p>
</li>
<li>
<p><a href="https://github.com/ohnosequences/sbt-github-release">sbt-github-release</a>: publish Github releases. <!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/Tapad/sbt-hadoop-oss">sbt-hadoop</a>: publish artifacts to the <a href="https://hadoop.apache.org">Hadoop</a> Distributed File System (HDFS).<!-- 6 stars --></p>
</li>
<li>
<p><a href="https://github.com/laughedelic/sbt-publish-more">sbt-publish-more</a>: publish artifacts to several repositories <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/amanjpro/sbt-deploy-plugin">sbt-deploy</a>: create deployable fat JARs. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://chiselapp.com/user/twenstar/repository/sbt-release-fossil">sbt-release-fossil</a>: enhances <a href="https://github.com/sbt/sbt-release">sbt-release</a> to support <a href="https://fossil-scm.org">Fossil</a> repositories</p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-autoversion">sbt-autoversion</a>: automatically set your next version bump based on patterns of your commit message since last release. <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/saint1991/sbt-gcs">sbt-gcs</a>: manage objects on Google Cloud Storage. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/kotobotov/sbt-sourcebundler">sbt-sourcebundler</a>: merge all source code into one scala file. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/vaslabs/sbt-kubeyml">sbt-kubeyml</a>: Create a typesafe kubernetes Deployment based on your project settings</p>
</li>
<li>
<p><a href="https://github.com/hnaderi/sbt-k8s">sbt-k8s</a>: Create any manifest or use provided cookbooks using <a href="https://github.com/hnaderi/scala-k8s">scala-k8s</a> library</p>
</li>
<li>
<p><a href="https://github.com/AmadeusITGroup/sbt-release-notes">sbt-release-notes</a>: provide a Release Step for <a href="https://github.com/sbt/sbt-release">sbt-release</a> to automatically update the release notes file.</p>
</li>
</ul>
</div>
<div style="display: none;">
<h3 id="deployment-integration-plugins"><a class="header" href="#deployment-integration-plugins">Deployment integration plugins</a></h3>
<ul>
<li><a href="https://github.com/heroku/heroku-sbt-plugin">sbt-heroku</a>: deploy applications directly to Heroku. <!-- 86 stars --></li>
<li><a href="https://github.com/Tapad/sbt-docker-compose">sbt-docker-compose</a>: launch Docker images using docker compose. <!-- 86 stars --></li>
<li><a href="https://github.com/sbt/sbt-appengine">sbt-appengine</a> deploy your webapp to Google App Engine. <!-- 65 stars --></li>
<li><a href="https://github.com/Tapad/sbt-marathon">sbt-marathon</a>: deploy applications on Apache Mesos using the <a href="https://mesosphere.github.io/marathon">Marathon</a> framework. <!-- 19 stars --></li>
<li><a href="https://github.com/riot-framework/sbt-riotctl">sbt-riotctl</a>: deploy applications as systemd services directly to a Raspberry Pi, ensuring dependencies (e.g. wiringpi) are met.</li>
<li><a href="https://github.com/tirithel/sbt-kind">sbt-kind</a>: load built docker images into a <a href="https://kind.sigs.k8s.io/">kind</a> cluster.</li>
</ul>
</div>
<h3 id="ide-integration-plugins"><a class="header" href="#ide-integration-plugins">IDE integration plugins</a></h3>
<ul>
<li><a href="https://github.com/JetBrains/sbt-structure">sbt-structure</a>: extract project structure in XML for IntelliJ Scala plugin. <!-- 74 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/sbt/sbteclipse">sbteclipse</a>: Eclipse project definition generator. <!-- 672 stars --></li>
<li><a href="https://github.com/orrsella/sbt-sublime">sbt-sublime</a>: Sublime Text project generator. <!-- 145 stars --></li>
</ul>
</div>
<h3 id="test-plugins"><a class="header" href="#test-plugins">Test plugins</a></h3>
<ul>
<li><a href="https://github.com/stryker-mutator/stryker4s">sbt-stryker4s</a>: Test your tests with mutation testing. <!-- 202 stars --></li>
<li><a href="https://github.com/tkawachi/sbt-doctest">sbt-doctest</a>: generate and run tests from Scaladoc comments. <!-- 120 stars --></li>
<li><a href="https://github.com/xuwei-k/test-times-reporter">test-times-reporter</a>: report slow tests. <!-- 3 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="Testing-sbt-plugins.html">scripted</a>: integration testing for sbt plugins.</li>
<li><a href="https://github.com/ktoso/sbt-jmh">sbt-jmh</a>: run Java Microbenchmark Harness (JMH) benchmarks from sbt. <!-- 403 stars --></li>
<li><a href="https://github.com/gatling/gatling-sbt">gatling-sbt</a>: performance and load-testing using Gatling. <!-- 79 stars --></li>
<li><a href="https://github.com/sbt/sbt-multi-jvm">sbt-multi-jvm</a>: run tests using multiple JVMs. <!-- 36 stars --></li>
<li><a href="https://github.com/scalaprops/sbt-scalaprops">sbt-scalaprops</a>: scalaprops property-based testing integration. <!-- 10 stars --></li>
<li><a href="https://github.com/sbt/sbt-testng">sbt-testng</a>: TestNG framework integration. <!-- 8 stars --></li>
<li><a href="https://github.com/ktoso/sbt-jcstress">sbt-jcstress</a>: Java Concurrency Stress Test (jcstress) integration. <!-- 8 stars --></li>
<li><a href="https://github.com/OlegYch/sbt-cached-ci">sbt-cached-ci</a>: Incremental sbt builds for CI environments. <!-- 0 stars --></li>
</ul>
</div>
<h3 id="library-dependency-plugins"><a class="header" href="#library-dependency-plugins">Library dependency plugins</a></h3>
<ul>
<li><a href="https://github.com/xuwei-k/sbt-conflict-classes">sbt-conflict-classes</a>: show conflict classes in the classpath. <!-- 16 stars --></li>
<li><a href="https://github.com/johanandren/sbt-akka-version-check">sbt-akka-version-check</a>: detect Akka module mismatches and fail build. <!-- 10 stars --></li>
<li><a href="https://github.com/philippus/sbt-license-check">sbt-license-check</a>: check and report on licenses used, fail build for disallowed licenses. <!-- 9 stars --></li>
<li><a href="https://github.com/philippus/sbt-pekko-version-check">sbt-pekko-version-check</a>: check if the Apache Pekko modules match. <!-- 5 stars --></li>
<li><a href="https://github.com/philippus/sbt-jackson-version-check">sbt-jackson-version-check</a>: check if the Jackson modules match. <!-- 3 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/rtimush/sbt-updates">sbt-updates</a>: list updated versions of dependencies. <!-- 361 stars --></li>
<li><a href="https://github.com/frugalmechanic/fm-sbt-s3-resolver">fm-sbt-s3-resolver</a>: resolve and publish artefacts using Amazon S3. <!-- 79 stars --></li>
<li><a href="https://github.com/ohnosequences/sbt-s3-resolver">sbt-s3-resolver</a>: resolve dependencies using Amazon S3. <!-- 73 stars --></li>
<li><a href="https://github.com/albuch/sbt-dependency-check">sbt-dependency-check</a>: check dependencies for known vulnerabilities/CVEs. <!-- 56 stars --></li>
<li><a href="https://github.com/tkawachi/sbt-lock">sbt-lock</a>: create a lock file containing explicit sbt dependencies. <!-- 33 stars --></li>
<li><a href="https://github.com/sbt/sbt-license-report">sbt-license-report</a>: generate reports of licenses used by dependencies. <!-- 25 stars --></li>
<li><a href="https://github.com/sbt/sbt-duplicates-finder">sbt-duplicates-finder</a>: detect class and resources conflicting in your project's classpath. <!-- 13 stars --></li>
<li><a href="https://github.com/lightbend/sbt-google-cloud-storage">sbt-google-cloud-storage</a>: resolver and publisher for Google Cloud Storage.</li>
<li><a href="https://github.com/delprks/sbt-trace">sbt-trace</a>: find traces of the client or library usage in other projects. <!-- 3 stars --></li>
<li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of specified versions of dependencies across your company</li>
<li><a href="https://stringbean.github.io/sbt-dependency-lock">sbt-dependency-lock</a>: generate dependency lockfiles and check for changes at build time.</li>
<li><a href="https://github.com/djice/sbt-unzip-plugin">sbt-unzip</a>: Extract zip dependencies where you want in your project.</li>
</ul>
</div>
<h3 id="web-and-frontend-development-plugins"><a class="header" href="#web-and-frontend-development-plugins">Web and frontend development plugins</a></h3>
<ul>
<li><a href="https://github.com/earldouglas/sbt-war">sbt-war</a>: package and run WAR files <!-- 381 stars --></li>
<li><a href="https://github.com/sbt/sbt-web">sbt-web</a>: library for building sbt plugins for the web. <!-- 314 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://www.playframework.com">Play Framework</a>: reactive web framework for Scala and Java. <!-- 9727 stars --></p>
</li>
<li>
<p><a href="https://www.scala-js.org">Scala.js</a>: Scala to JavaScript compiler.<!-- 3113 stars --></p>
</li>
<li>
<p><a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a>: Servlet support. <!-- 379 stars --></p>
</li>
<li>
<p><a href="https://github.com/vmunier/sbt-web-scalajs">sbt-web-scalajs</a>: use Scala.js with any web server. <!-- 148 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-less">sbt-less</a>: Less CSS compilation support.<!-- 34 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-js-engine">sbt-js-engine</a>: support for sbt plugins that use JavaScript. <!-- 33 stars --></p>
</li>
<li>
<p><a href="https://github.com/joost-de-vries/sbt-typescript">sbt-typescript</a>: TypeScript compilation support. <!-- 25 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-uglify">sbt-uglify</a>: JavaScript minifier using UglifyJS. <!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/andriimartynov/sbt-terser">sbt-terser</a>: JavaScript (ES6+) minifier using terser. <!-- 0 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-digest">sbt-digest</a>: generate checksums of assets. <!-- 18 stars --></p>
</li>
<li>
<p><a href="https://github.com/scalatra/sbt-scalatra">sbt-scalatra</a>: build and run Scalatra apps. <!-- 17 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-scala-js-map">sbt-scala-js-map</a>: Configure source mapping for Scala.js projects hosted on Github. <!-- 16 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-gzip">sbt-gzip</a>: gzip compressor for assets.<!-- 15 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-stylus">sbt-stylus</a>: Stylus stylesheet compiler.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/sake92/sbt-hepek">sbt-hepek</a>: Render static websites directly from Scala code.<!-- 5 stars --></p>
</li>
<li>
<p><a href="https://chiselapp.com/user/twenstar/repository/sbt-puresass">sbt-puresass</a>: <a href="https://github.com/sbt/sbt-web">sbt-web</a> plugin for Sass styles compilation.</p>
</li>
<li>
<p><a href="https://github.com/swachter/scala-ts">sbt-scala-ts</a>; generates TypeScript declaration files from ScalaJS sources and outputs Node modules.</p>
</li>
</ul>
</div>
<h3 id="database-plugins"><a class="header" href="#database-plugins">Database plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/flyway-sbt">flyway-sbt</a> Flyway database migration. <!-- 131 stars --></li>
<li><a href="https://github.com/sbt-dao-generator/sbt-dao-generator">sbt-dao-generator</a> generate code for O/R Mapper Free <!-- 14 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/scalikejdbc/scalikejdbc">scalikejdbc-mapper-generator</a>: Scala code generator from database schema. <!-- 802 stars --></li>
<li><a href="https://github.com/localytics/sbt-dynamodb">sbt-dynamodb</a>: run a local Amazon DynamoDB test instance from sbt. <!-- 41 stars --></li>
<li><a href="https://github.com/LeonhardtDavid/migrations">sbt-migrations</a>: database migrations manager.</li>
</ul>
</div>
<h3 id="code-generator-plugins"><a class="header" href="#code-generator-plugins">Code generator plugins</a></h3>
<ul>
<li>
<p><a href="https://github.com/sbt/sbt-buildinfo">sbt-buildinfo</a>: generate Scala code from sbt setting keys. <!-- 559 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-github-actions">sbt-github-actions</a>: generate GitHub Actions YAML <!-- 197 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-protobuf">sbt-protobuf</a>: protobuf code generator.<!-- 173 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt-teavm/sbt-teavm">sbt-teavm</a>: generate JavaScript and WebAssembly from Java bytecode <!-- 11 stars --></p>
</li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/eed3si9n/scalaxb">sbt-scalaxb</a>: generate model classes from XML schemas and WSDL. <!-- 243 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-header">sbt-header</a>: auto-generate source code file headers (such as copyright notices). <!-- 111 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-boilerplate">sbt-boilerplate</a>: TupleX and FunctionX boilerplate code generator. <!-- 78 stars --></p>
</li>
<li>
<p><a href="https://github.com/cavorite/sbt-avro">sbt-avro</a>: Apache Avro schema and protocol generator. <!-- 66 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-aspectj">sbt-aspectj</a>: AspectJ weaving for sbt.<!-- 62 stars --></p>
</li>
<li>
<p><a href="https://github.com/thesamet/sbt-protoc">sbt-protoc</a>: protobuf code generator using protoc. <!-- 35 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/contraband">sbt-contraband</a> (<a href="https://www.scala-sbt.org/contraband">docs</a>): generate pseudo-case classes from GraphQL schemas. <!-- 34 stars --></p>
</li>
<li>
<p><a href="https://github.com/ihji/sbt-antlr4">sbt-antlr4</a>: run ANTLR v4 from sbt.<!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/xerial/sbt-sql">sbt-sql</a>: generate model classes from SQL. <!-- 15 stars --></p>
</li>
<li>
<p><a href="https://github.com/fiadliel/sbt-partial-unification">sbt-partial-unification</a>: enable partial unification support in Scala (SI-2712). <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/ant8e/sbt-i18n">sbt-i18n</a>: transform your i18n bundles into Scala code. <!-- 1 stars --></p>
</li>
<li>
<p><a href="https://github.com/earldouglas/sbt-lit">sbt-lit</a>: build literate code with sbt.</p>
</li>
<li>
<p><a href="https://github.com/yurique/embedded-files">sbt-embedded-files</a>: generate Scala objects containing the contents of glob-specified files as strings or byte-arrays.</p>
</li>
<li>
<p><a href="https://github.com/scala-ts/scala-ts/">sbt-scala-ts</a>: generate TypeScript code according compiled Scala types (case class, trait, object, ...). <!-- 149 stars --></p>
</li>
</ul>
</div>
<h3 id="static-code-analysis-plugins"><a class="header" href="#static-code-analysis-plugins">Static code analysis plugins</a></h3>
<ul>
<li><a href="https://github.com/wartremover/wartremover">wartremover</a>: flexible Scala linting tool. <!-- 728 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/scalastyle/scalastyle-sbt-plugin">scalastyle-sbt-plugin</a>: code style checking using Scalastyle. <!-- 114 stars --></li>
<li><a href="https://github.com/sksamuel/sbt-scapegoat">sbt-scapegoat</a>: static analysis using Scapegoat. <!-- 63 stars --></li>
<li><a href="https://github.com/orrsella/sbt-stats">sbt-stats</a>: generate source code statistics (lines of code etc). <!-- 53 stars --></li>
<li><a href="https://scalacenter.github.io/scalafix/">sbt-scalafix</a>: refactoring and linting tool for Scala using Scalafix. <!-- 24 stars --></li>
<li><a href="https://github.com/cb372/sbt-explicit-dependencies">sbt-explicit-dependencies</a>: check that you have declared all your library dependencies correctly <!-- 12 stars --></li>
<li><a href="https://github.com/johanandren/sbt-taglist">sbt-taglist</a>: find tags within source files (such as TODO and FIXME). <!-- 11 stars --></li>
<li><a href="https://github.com/rtimush/sbt-rewarn">sbt-rewarn</a>: always display compilation warnings, despite the incremental compilation. <!-- 11 stars --></li>
<li><a href="https://github.com/xerial/sbt-jcheckstyle">sbt-jcheckstyle</a>: Java code style checking using Checkstyle. <!-- 6 stars --></li>
<li><a href="https://github.com/mwz/sbt-sonar">sbt-sonar</a>: integration with <a href="https://www.sonarqube.org">SonarQube</a>. <!-- 2 stars --></li>
<li><a href="https://github.com/BotTech/scala2plantuml">sbt-scala2plantuml</a>: generates <a href="https://plantuml.com/">PlantUML</a> diagrams from Scala code.</li>
</ul>
</div>
<h3 id="utility-and-system-plugins"><a class="header" href="#utility-and-system-plugins">Utility and system plugins</a></h3>
<ul>
<li>
<p><a href="https://github.com/sbt/sbt-git">sbt-git</a>: run git commands from sbt.<!-- 233 stars --></p>
</li>
<li>
<p><a href="https://github.com/philippus/sbt-dotenv">sbt-dotenv</a>: load environment variables from .env into the JVM System Environment for local development. <!-- 189 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-dynver">sbt-dynver</a>: set project version dynamically from git metadata. <!-- 87 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-nocomma">sbt-nocomma</a>: reduce commas. <!-- 13 stars --></p>
</li>
<li>
<p><a href="https://github.com/xuwei-k/sbt-jshell">sbt-jshell</a>: Java REPL for sbt.<!-- 10 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-vimquit">sbt-vimquit</a>: adds <code>:q</code> command. <!-- 6 stars --></p>
</li>
</ul>
<div style="display: none;">
- [sbt-revolver](https://github.com/spray/sbt-revolver): auto-restart forked
  JVMs on update. <!-- 563 stars -->
- [sbt-conscript](https://github.com/foundweekends/conscript)
  ([docs](https://www.foundweekends.org/conscript/)): distribute apps using
  GitHub and Maven Central. <!-- 467 stars -->
- [sbt-errors-summary](https://github.com/Duhemm/sbt-errors-summary): show a
  summary of compilation errors. <!-- 145 stars -->
- [MiMa](https://github.com/lightbend/mima): binary
  compatibility management for Scala libraries. <!-- 134 stars -->
- [sbt-groll](https://github.com/sbt/sbt-groll): navigate git history inside
  sbt. <!-- 100 stars -->
- [sbt-prompt](https://github.com/agemooij/sbt-prompt): add promptlets and
  themes to your sbt prompt. <!-- 75 stars -->
- [sbt-crossproject](https://github.com/portable-scala/sbt-crossproject):
  cross-build Scala, Scala.js and Scala Native. <!-- 66 stars -->
- [sbt-proguard](https://github.com/sbt/sbt-proguard): run ProGuard on
  compiled sources. <!-- 63 stars -->
- [sbt-jni](https://github.com/sbt/sbt-jni): helpers for working with
  projects that use JNI. <!-- 51 stars -->
- [sbt-jol](https://github.com/ktoso/sbt-jol): inspect OpenJDK Java Object
  Layout from sbt. <!-- 48 stars -->
- [sbt-musical](https://github.com/tototoshi/sbt-musical): control iTunes
  from sbt (Mac only). <!-- 47 stars -->
- [sbt-travisci](https://github.com/dwijnand/sbt-travisci): integration
  with Travis CI. <!-- 33 stars -->
- [horder](https://github.com/romanowski/hoarder): cache compilation
  artefacts for future builds. <!-- 31 stars -->
- [sbt-javaagent](https://github.com/sbt/sbt-javaagent): add Java agents to
  projects. <!-- 13 stars -->
<ul>
<li>
<p><a href="https://github.com/jeffreyolchovy/sbt-check">sbt-check</a>: compile up to, and including, the typer phase. <!-- 10 stars --></p>
</li>
<li>
<p><a href="https://github.com/ChristopherDavenport/sbt-mima-version-check">sbt-mima-version-check</a>: Automate which Mima Versions to Check <!-- 6 stars --></p>
</li>
<li>
<p><a href="https://github.com/cuzfrog/sbt-tmpfs">sbt-tmpfs</a>: utilize tmpfs to speed up builds. <!-- 4 stars --></p>
</li>
<li>
<p><a href="https://github.com/melezov/sbt-sh">sbt-sh</a>: run shell commands from sbt.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-ammonite-classpath">sbt-ammonite-classpath</a>: export classpath for <a href="https://ammonite.io/">Ammonite</a> and <a href="https://almond.sh/">Almond</a>.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/isomarcte/sbt-version-scheme-enforcer">sbt-version-scheme-enforcer-plugin</a>: Derive Mima settings for your library from your declared <code>versionScheme</code>. This supports Early SemVer, Strict SemVer, and Package Versioning Policy (PVP).</p>
</li>
</ul>
</div>
<h3 id="documentation-plugins"><a class="header" href="#documentation-plugins">Documentation plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-unidoc">sbt-unidoc</a>: create unified API documentation across subprojects. <!-- 126 stars --></li>
<li><a href="https://github.com/xuwei-k/sbt-class-diagram">sbt-class-diagram</a>: generate class diagrams from Scala source code. <!-- 100 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/tpolecat/tut">tut</a>: documentation and tutorial generator.<!-- 409  stars --></p>
</li>
<li>
<p><a href="https://github.com/planet42/Laika">Laika</a>: Transform Markdown or reStructuredText into HTML or PDF with Templating.<!-- 161 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-site">sbt-site</a>: site generator.<!-- 131 stars --></p>
</li>
<li>
<p><a href="https://github.com/47degrees/sbt-microsites">sbt-microsites</a>: generate and publish microsites using Jekyll. <!-- 125 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-ghpages">sbt-ghpages</a>: publish generated sites to GitHub pages. <!-- 71 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-api-mappings">sbt-api-mappings</a>: generate Scaladoc <code>apiMappings</code> for common Scala libraries. <!-- 49 stars --></p>
</li>
<li>
<p><a href="https://github.com/laughedelic/literator">literator</a>: generate literate-style markdown docs from your sources. <!-- 33 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-example">sbt-example</a>: generate ScalaTest test suites from examples in Scaladoc. <!-- 17 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-delombok">sbt-delombok</a>: delombok Java sources files that contain Lombok annotations to make Javadoc contain Lombok-generated classes and methods. <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/glngn/sbt-alldocs">sbt-alldocs</a>: collect all the docs for a project and dependencies into a single folder.</p>
</li>
<li>
<p><a href="https://github.com/valydia/sbt-apidoc">sbt-apidoc</a>: A port of <a href="https://apidocjs.com">apidocjs</a> to sbt, to document REST Api. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/Kevin-Lee/sbt-github-pages">sbt-github-pages</a> (<a href="https://kevin-lee.github.io/sbt-github-pages">docs</a>): publish a website to GitHub Pages with minimal effort - works well with GitHub Actions.</p>
</li>
<li>
<p><a href="https://github.com/Kevin-Lee/sbt-docusaur">sbt-docusaur</a> (<a href="https://kevin-lee.github.io/sbt-docusaur">docs</a>): build a website using Docusaurus and publish to GitHub Pages with minimal effort - works well with GitHub Actions.</p>
</li>
<li>
<p><a href="https://github.com/cchantep/sbt-hl-compiler/">sbt-hl-compiler</a>: compile the code snippets from documentation (to keep it consistent). <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/cchantep/sbt-scaladoc-compiler/">sbt-scaladoc-compiler</a>: compile the code snippets included in Scaladoc comments. <!-- 2 stars --></p>
</li>
</ul>
</div>
<div style="display: none;">
### Code coverage plugins
<ul>
<li><a href="https://github.com/scoverage/sbt-scoverage">sbt-scoverage</a>: Scala code coverage using Scoverage. <!-- 347 stars --></li>
<li><a href="https://github.com/sbt/sbt-jacoco">sbt-jacoco</a>: Scala and Java code coverage using JaCoCo. <!-- 76 stars --></li>
</ul>
<h3 id="create-new-project-plugins"><a class="header" href="#create-new-project-plugins">Create new project plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-fresh">sbt-fresh</a>: create an opinionated fresh sbt project. <!-- 177 stars --></li>
</ul>
</div>
<div style="display: none;">
<h3 id="framework-specific-plugins"><a class="header" href="#framework-specific-plugins">Framework-specific plugins</a></h3>
<ul>
<li><a href="https://github.com/gilt/sbt-newrelic">sbt-newrelic</a>: NewRelic support for artefacts built with sbt-native-packager. <!-- 73 stars --></li>
<li><a href="https://github.com/alonsodomin/sbt-spark">sbt-spark</a>: Spark application configurator. <!-- 7 stars --></li>
<li><a href="https://github.com/sirocchj/sbt-api-builder">sbt-api-builder</a>: support for ApiBuilder from within sbt's shell. <!-- 1 star --></li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>The recipe section of the documentation focuses on the objectives with minimal explanations.</p>
<p>If you are new to sbt, see <a href="recipes/../sbt-by-example.html">sbt by example</a> and <a href="recipes/../guide/index.html">Getting Started</a> section first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-hello-world"><a class="header" href="#how-to-write-hello-world">How to write hello world</a></h1>
<h2 id="objective"><a class="header" href="#objective">Objective</a></h2>
<p>I want to write a hello world program in Scala, and run it.</p>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Create a fresh directory, like <code>hello_scala/</code></p>
</li>
<li>
<p>Create a directory named <code>project/</code> under <code>hello_scala/</code>, and create <code>project/build.properties</code> with</p>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
</li>
<li>
<p>Under <code>hello_scala/</code>, create <code>build.sbt</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
</li>
<li>
<p>Under <code>hello_scala/</code>, create <code>Hello.scala</code>:</p>
<pre><code class="language-scala"> @main def main(args: String*): Unit =
   println(s"Hello ${args.mkString}")
</code></pre>
</li>
<li>
<p>Navigate to <code>hello_scala/</code> from the terminal, and run <code>sbt</code>:</p>
<pre><code class="language-bash">$ sbt
</code></pre>
</li>
<li>
<p>When the prompt appears, type <code>run</code>:</p>
<pre><code class="language-scala">sbt:hello_scala&gt; run
</code></pre>
</li>
<li>
<p>Type <code>exit</code> to exit the sbt shell:</p>
<pre><code class="language-scala">sbt:hello_scala&gt; exit
</code></pre>
</li>
</ol>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>When you're in a hurry, you can run <code>sbt init</code> in a fresh directory, and select the first template.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-to-the-central-repo"><a class="header" href="#publishing-to-the-central-repo">Publishing to the Central Repo</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/central.html#admonition-note"></a>
</div>
<div>
<p>The recipe section of the documentation focuses on the objectives
with minimal explanations.</p>
<p>See also Sonatype's [Publish guides][sonatype-central-portal-register] for general concepts around publishing to the Central Portal.</p>
</div>
</div>
<h2 id="objective-1"><a class="header" href="#objective-1">Objective</a></h2>
<p>I want to publish my project to the Central Repository.</p>
<h2 id="steps-1"><a class="header" href="#steps-1">Steps</a></h2>
<h3 id="preliminary-1-central-portal-registration"><a class="header" href="#preliminary-1-central-portal-registration">Preliminary 1: Central Portal registration</a></h3>
<p>Create a Central Portal account, following Sonatype's <a href="https://central.sonatype.org/register/central-portal/">Publish guides</a>.</p>
<ul>
<li>If you had an OSSRH account, use <strong>Forgot password</strong> flow to convert the account to the new Central Portal, which lets you keep the previous namespace associations.</li>
<li>If you authenticate via GitHub, <code>io.github.&lt;user_name&gt;</code> will automatically be associated with the account.</li>
</ul>
<p>Follow the steps described in <a href="https://central.sonatype.org/register/namespace/">register a namespace</a> guide to associate a domain name with your account.</p>
<h4 id="preliminary-2-pgp-key-pair"><a class="header" href="#preliminary-2-pgp-key-pair">Preliminary 2: PGP key pair</a></h4>
<p>Follow the Sonatype's <a href="https://central.sonatype.org/publish/requirements/gpg/">GPG guide</a> to generate a PGP key pair.</p>
<p><a href="https://www.gnupg.org/download/">Install GnuPG</a>, and verify the version:</p>
<pre><code class="language-bash">$ gpg --version
gpg (GnuPG/MacGPG2) 2.2.8
libgcrypt 1.8.3
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;
</code></pre>
<p>Next generate a key:</p>
<pre><code>$ gpg --gen-key
</code></pre>
<p>List the keys:</p>
<pre><code>$ gpg --list-keys

/home/foo/.gnupg/pubring.gpg
------------------------------

pub   rsa4096 2018-08-22 [SC]
      1234517530FB96F147C6A146A326F592D39AAAAA
uid           [ultimate] your name &lt;you@example.com&gt;
sub   rsa4096 2018-08-22 [E]
</code></pre>
<p>Distribute the key:</p>
<pre><code>$ gpg --keyserver keyserver.ubuntu.com --send-keys 1234517530FB96F147C6A146A326F592D39AAAAA
</code></pre>
<h3 id="step-1-sbt-pgp"><a class="header" href="#step-1-sbt-pgp">Step 1: sbt-pgp</a></h3>
<p>The <a href="https://github.com/sbt/sbt-pgp#sbt-pgp">sbt-pgp plugin</a> can sign the published artifacts with GPG/PGP. (Optionally <a href="https://github.com/sbt/sbt-ci-release">sbt-ci-release</a> can automate the publishing process.)</p>
<p>Add the following line to your <code>project/plugins.sbt</code> file to enable it for your build:</p>
<pre><code class="language-scala">addSbtPlugin("com.github.sbt" % "sbt-pgp" % "2.3.1")
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/central.html#admonition-note-1"></a>
</div>
<div>
<p>Make sure that the <code>gpg</code> command is in PATH available to the sbt.</p>
</div>
</div>
<h3 id="step-2-credentials"><a class="header" href="#step-2-credentials">Step 2: Credentials</a></h3>
<p>Generate a user token from the portal to be used for the credentials. The token must be stored somewhere safe (NOT in the repository).</p>
<p>sbt 2.x can also reads from the environment variables <code>SONATYPE_USERNAME</code> and <code>SONATYPE_PASSWORD</code> and appends a credential for <code>central.sonatype.com</code> out-of-box, which might be useful for automatic publishing from the CI environment, such as GitHub Actions.</p>
<pre><code class="language-yaml">- run: sbt ci-release
  env:
    PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
    PGP_SECRET: ${{ secrets.PGP_SECRET }}
    SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
    SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}
</code></pre>
<p>On a local machine, a common convention is a <code>$HOME/.sbt/2/credentials.sbt</code> file, with the following:</p>
<pre><code class="language-scala">credentials += Credentials(Path.userHome / ".sbt" / "sonatype_central_credentials")
</code></pre>
<p>Next create a file <code>$HOME/.sbt/sonatype_central_credentials</code>:</p>
<pre><code class="language-property">host=central.sonatype.com
user=&lt;your username&gt;
password=&lt;your password&gt;
</code></pre>
<h3 id="step-3-configure-buildsbt"><a class="header" href="#step-3-configure-buildsbt">Step 3: Configure build.sbt</a></h3>
<p>To publish to a Maven repository, you'll need to configure a few settings so that the correct metadata is generated.</p>
<p><strong>Note</strong>: To publish to the Central Portal, <code>publishTo</code> must be set to the <code>localStaging</code> repository:</p>
<pre><code class="language-scala">// new setting for the Central Portal
publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<p>Add these settings at the end of <code>build.sbt</code> or a separate <code>publish.sbt</code>:</p>
<pre><code class="language-scala">organization := "com.example.project2"
organizationName := "example"
organizationHomepage := Some(url("http://example.com/"))

scmInfo := Some(
  ScmInfo(
    url("https://github.com/your-account/your-project"),
    "scm:git@github.com:your-account/your-project.git"
  )
)
developers := List(
  Developer(
    id = "Your identifier",
    name = "Your Name",
    email = "your@email",
    url = url("http://your.url")
  )
)

description := "Some description about your project."
licenses := List(License.Apache2)
homepage := Some(url("https://github.com/example/project"))

// Remove all additional repository other than Maven Central from POM
pomIncludeRepository := { _ =&gt; false }
publishMavenStyle := true

// new setting for the Central Portal
publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<p>The full format of a <code>pom.xml</code> (an end product of the project configuration used by Maven) file is outlined in <a href="https://maven.apache.org/pom.html">POM Reference</a>. You can add more data to it with the <code>pomExtra</code> option in <code>build.sbt</code>.</p>
<h3 id="step-4-stage-the-artifacts"><a class="header" href="#step-4-stage-the-artifacts">Step 4: Stage the artifacts</a></h3>
<p>From sbt shell run:</p>
<pre><code class="language-bash">&gt; publishSigned
</code></pre>
<h3 id="step-5-upload-or-release-the-bundle"><a class="header" href="#step-5-upload-or-release-the-bundle">Step 5: Upload or release the bundle</a></h3>
<p>From sbt shell run:</p>
<pre><code class="language-bash">&gt; sonaUpload
</code></pre>
<p>This will upload the bundle to the <a href="https://central.sonatype.com/">Central Portal</a>. Hit the "Publish" button to publish to the Central Repository.</p>
<p>If you want to automate the publishing, run:</p>
<pre><code class="language-bash">&gt; sonaRelease
</code></pre>
<p>It might take 10 minutes to a few hours for the published artifacts to be visible on the Central Repository <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a>.</p>
<!--
### Optional steps

#### Publishing SNAPSHOTs

In general, the use of SNAPSHOT artifacts should be limited to short-term testing,
and we do not recommend publishing SNAPSHOTs publicly.
However, should you decide to publish SNAPSHOTs, you can enable it from the Central Portal per namespace.
See Sonatype's [Publishing -SNAPSHOT Releases][publish-portal-snapshots] guide for details.

#### Tag-based publishing via sbt-ci-release

You can further optimize the publishing flow by using the [sbt-ci-release][sbt-ci-release] plugin.

Once you set it up, all you have to do is push a git tag to trigger a release.

#### Integrate with the release process

To automate the publishing approach above with the [sbt-release plugin]
[sbt-release], you should simply add the publishing commands as steps in the
`releaseProcess` task:

```
...
releaseStepCommand("sonatypeOpen \"your groupId\" \"Some staging name\""),
...
releaseStepCommand("publishSigned"),
...
releaseStepCommand("sonaRelease"),
...
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-sbt-as-metals-build-server"><a class="header" href="#use-sbt-as-metals-build-server">Use sbt as Metals build server</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="recipes/use-sbt-as-metals-build-server.html#admonition-warning"></a>
</div>
<div>
<p>This is a draft documentation of sbt 2.x that is yet to be released.
This is a placeholder, copied from sbt 1.x.</p>
</div>
</div>
<h2 id="objective-2"><a class="header" href="#objective-2">Objective</a></h2>
<p>I want to use <a href="https://scalameta.org/metals/">Metals</a> on VS Code with sbt as the build server.</p>
<h2 id="steps-2"><a class="header" href="#steps-2">Steps</a></h2>
<p>To use Metals on VS Code:</p>
<ol>
<li>Install Metals from Extensions tab:<br> <img src="recipes/../files/metals0.png" alt="Metals" /></li>
<li>Open a directory containing a <code>build.sbt</code> file.</li>
<li>From the menubar, run View &gt; Command Palette... (<code>Cmd-Shift-P</code> on macOS) "Metals: Switch build server", and select "sbt"<br> <img src="recipes/../files/metals2.png" alt="Metals" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works:<br> <img src="recipes/../files/metals3.png" alt="Metals" /></li>
</ol>
<p>Use the following setting to opt-out some of the subprojects from BSP.</p>
<pre><code class="language-scala">bspEnabled := false
</code></pre>
<p>When you make changes to the code and save them (<code>Cmd-S</code> on macOS), Metals will invoke sbt to do the actual building work.</p>
<h4 id="interactive-debugging-on-vs-code"><a class="header" href="#interactive-debugging-on-vs-code">Interactive debugging on VS Code</a></h4>
<ol>
<li>Metals supports interactive debugging by setting break points in the code:<br> <img src="recipes/../files/metals4.png" alt="Metals" /></li>
<li>Interactive debugging can be started by right-clicking on an unit test, and selecting "Debug Test." When the test hits a break point, you can inspect the values of the variables:<br> <img src="recipes/../files/metals5.png" alt="Metals" /></li>
</ol>
<p>See <a href="https://code.visualstudio.com/docs/editor/debugging">Debugging</a> page on VS Code documentation for more details on how to navigate an interactive debugging session.</p>
<h4 id="logging-into-sbt-session"><a class="header" href="#logging-into-sbt-session">Logging into sbt session</a></h4>
<p>While Metals uses sbt as the build server, we can also log into the same sbt session using a thin client.</p>
<ul>
<li>From Terminal section, type in <code>sbt --client</code><br> <img src="recipes/../files/metals6.png" alt="Metals" /></li>
</ul>
<p>This lets you log into the sbt session Metals has started. In there you can call <code>testOnly</code> and other tasks with the code already compiled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-to-intellij-idea"><a class="header" href="#import-to-intellij-idea">Import to IntelliJ IDEA</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="recipes/import-to-intellij.html#admonition-warning"></a>
</div>
<div>
<p>This is a draft documentation of sbt 2.x that is yet to be released.
This is a placeholder, copied from sbt 1.x.</p>
</div>
</div>
<h2 id="objective-3"><a class="header" href="#objective-3">Objective</a></h2>
<p>I want to import sbt build to IntelliJ IDEA.</p>
<h2 id="steps-3"><a class="header" href="#steps-3">Steps</a></h2>
<p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is an IDE created by JetBrains, and the Community Edition is open source under Apache v2 license. IntelliJ integrates with many build tools, including sbt, to import the project.</p>
<p>To import a build to IntelliJ IDEA:</p>
<ol>
<li>Install Scala plugin on the Plugins tab:<br> <img src="recipes/../files/intellij1.png" alt="IntelliJ" /></li>
<li>From Projects, open a directory containing a <code>build.sbt</code> file.<br> <img src="recipes/../files/intellij2.png" alt="IntelliJ" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works.</li>
</ol>
<p>IntelliJ Scala plugin uses its own lightweight compilation engine to detect errors, which is fast but sometimes incorrect. Per <a href="https://blog.jetbrains.com/scala/2021/07/27/intellij-scala-plugin-2021-2/#Compiler-based_highlighting">compiler-based highlighting</a>, IntelliJ can be configured to use the Scala compiler for error highlighting.</p>
<h3 id="interactive-debugging-with-intellij-idea"><a class="header" href="#interactive-debugging-with-intellij-idea">Interactive debugging with IntelliJ IDEA</a></h3>
<ol>
<li>IntelliJ supports interactive debugging by setting break points in the code:<br> <img src="recipes/../files/intellij4.png" alt="IntelliJ" /></li>
<li>Interactive debugging can be started by right-clicking on an unit test, and selecting "Debug '&lt;test name&gt;'." Alternatively, you can click the green "run" icon on the left part of the editor near the unit test. When the test hits a break point, you can inspect the values of the variables:<br> <img src="recipes/../files/intellij5.png" alt="IntelliJ" /></li>
</ol>
<p>See <a href="https://www.jetbrains.com/help/idea/debugging-code.html">Debug Code</a> page on IntelliJ documentation for more details on how to navigate an interactive debugging session.</p>
<h2 id="alternative"><a class="header" href="#alternative">Alternative</a></h2>
<h3 id="using-sbt-as-intellij-idea-build-server-advanced"><a class="header" href="#using-sbt-as-intellij-idea-build-server-advanced">Using sbt as IntelliJ IDEA build server (advanced)</a></h3>
<p>Importing the build to IntelliJ means that you're effectively using IntelliJ as the build tool and the compiler while you code (see also <a href="https://blog.jetbrains.com/scala/2021/07/27/intellij-scala-plugin-2021-2/#Compiler-based_highlighting">compiler-based highlighting</a>). While many users are happy with the experience, depending on the code base some of the compilation errors may be false, it may not work well with plugins that generate sources, and generally you might want to code with the identical build semantics as sbt. Thankfully, modern IntelliJ supports alternative <em>build servers</em> including sbt via the <a href="https://build-server-protocol.github.io/">Build Server Protocol</a> (BSP).</p>
<p>The benefit of using BSP with IntelliJ is that you're using sbt to do the actual build work, so if you are the kind of programmer who had sbt session up on the side, this avoids double compilation.</p>
<table class="table table-striped">
  <tr>
    <th><nobr></th>
    <th>Import to IntelliJ</th>
    <th>BSP with IntelliJ</th>
  </tr>
  <tr>
    <td>Reliability</td>
    <td>✅ Reliable behavior</td>
    <td>⚠️ Less mature. Might encounter UX issues.</td>
  </tr>
  <tr>
    <td>Responsiveness</td>
    <td>✅</td>
    <td>⚠️</td>
  </tr>
  <tr>
    <td>Correctness</td>
    <td>⚠️ Uses its own compiler for type checking, but can be configured to use scalac</td>
    <td>✅ Uses Zinc + Scala compiler for type checking</td>
  </tr>
  <tr>
    <td>Generated source</td>
    <td>❌ Generated source requires resync</td>
    <td>✅</td>
  </tr>
  <tr>
    <td>Build reuse</td>
    <td>❌ Using sbt side-by-side requires double build</td>
    <td>✅</td>
  </tr>
</table>
<p>To use sbt as build server on IntelliJ:</p>
<ol>
<li>Install Scala plugin on the Plugins tab.</li>
<li>To use the BSP approach, do not use Open button on the Project tab:<br> <img src="recipes/../files/intellij7.png" alt="IntelliJ" /></li>
<li>From menubar, click New &gt; "Project From Existing Sources", or Find Action (<code>Cmd-Shift-P</code> on macOS) and type "Existing" to find "Import Project From Existing Sources":<br> <img src="recipes/../files/intellij8.png" alt="IntelliJ" /></li>
<li>Open a <code>build.sbt</code> file. Select <strong>BSP</strong> when prompted:<br> <img src="recipes/../files/intellij9.png" alt="IntelliJ" /></li>
<li>Select <strong>sbt (recommended)</strong> as the tool to import the BSP workspace:<br> <img src="recipes/../files/intellij10.png" alt="IntelliJ" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works:<br> <img src="recipes/../files/intellij11.png" alt="IntelliJ" /></li>
</ol>
<p>Use the following setting to opt-out some of the subprojects from BSP.</p>
<pre><code class="language-scala">bspEnabled := false
</code></pre>
<ul>
<li>Open Preferences, search BSP and check "build automatically on file save", and uncheck "export sbt projects to Bloop before import":<br> <img src="recipes/../files/intellij12.png" alt="IntelliJ" /></li>
</ul>
<p>When you make changes to the code and save them (<code>Cmd-S</code> on macOS), IntelliJ will invoke sbt to do the actual building work.</p>
<p>See also Igal Tabachnik's <a href="https://hmemcpy.com/2021/09/bsp-and-intellij/">Using BSP effectively in IntelliJ and Scala</a> for more details.</p>
<h4 id="logging-into-sbt-session-1"><a class="header" href="#logging-into-sbt-session-1">Logging into sbt session</a></h4>
<p>We can also log into the existing sbt session using the thin client.</p>
<ul>
<li>From Terminal section, type in <code>sbt --client</code> <img src="recipes/../files/intellij6.png" alt="IntelliJ" /></li>
</ul>
<p>This lets you log into the sbt session IntelliJ has started. In there you can call <code>testOnly</code> and other tasks with the code already compiled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-dependency-plugin"><a class="header" href="#source-dependency-plugin">Source dependency plugin</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/source-dependency-plugin.html#admonition-note"></a>
</div>
<div>
<p>The recipe section of the documentation focuses on the objectives
with minimal explanations.</p>
</div>
</div>
<h2 id="objective-4"><a class="header" href="#objective-4">Objective</a></h2>
<p>I want to use a plugin hosted on a git repository, without publishing to the Central Repo.</p>
<h2 id="steps-4"><a class="header" href="#steps-4">Steps</a></h2>
<ol>
<li>
<p>Host an sbt 2.x plugin on a git repository, built using sbt 2.x.</p>
</li>
<li>
<p>Add the following to <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">// In project/plugins.sbt
lazy val jmhRef = ProjectRef(
  uri("https://github.com/eed3si9n/sbt-jmh.git#303c3e98e1d1523e6a4f99abe09c900165028edb"),
  "plugin")
BareBuildSyntax.dependsOn(jmhRef)
</code></pre>
</li>
<li>
<p>When you start sbt, it will automatically clone the repository under <code>$HOME/.sbt/2/staging/</code>.</p>
</li>
</ol>
<p>In the above, <code>https://github.com/eed3si9n/sbt-jmh.git</code> is the HTTP endpoint for a plugin hosted on GitHub, and <code>303c3e98e1d1523e6a4f99abe09c900165028edb</code> is a commit id on the default branch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="symbols"><a class="header" href="#symbols">Symbols</a></h2>
<h3 id="--"><a class="header" href="#--"><code>:=</code>, <code>+=</code>, <code>++=</code></a></h3>
<p>These construct a <a href="appendix/../../../../1.x/api/sbt/internal/util/Init$Setting.html">Setting</a>, which is the fundamental type in the <a href="appendix/../guide/build-definition-basics.html">settings</a> system.</p>
<h3 id=""><a class="header" href="#"><code>%</code></a></h3>
<p>This is used to build up a <a href="appendix/../../../../1.x/api/sbt/librarymanagement/ModuleID.html">ModuleID</a>.</p>
<h3 id="-1"><a class="header" href="#-1"><code>%%</code></a></h3>
<p>This is similar to <code>%</code> except that it identifies a dependency that has been <a href="appendix/../concepts/cross-building.html">cross built</a>.</p>
<h3 id="-2"><a class="header" href="#-2"><code>%%%</code></a></h3>
<p>This is defined in <a href="https://github.com/portable-scala/sbt-platform-deps">sbt-platform-deps</a> in sbt 1.x.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<h3 id="command-1"><a class="header" href="#command-1">Command</a></h3>
<p>A system-level building block of sbt, often used to capture user interaction or IDE interaction. See <a href="appendix/../concepts/command.html">Command</a>.</p>
<h3 id="cross-building-1"><a class="header" href="#cross-building-1">Cross building</a></h3>
<p>The idea of building multiple targets from the same set of source file. This includes Scala cross building, targetting multiple versions of Scala releases; platform cross building, targetting JVM, Scala.JS, and Scala Native; and custom virtual axis like Spark versions.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<h3 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency resolution</a></h3>
<p>During library management, when multiple version candidates (e.g. <code>foo:2.2.0</code> and <code>foo:3.0.0</code>) are found for a library <code>foo</code> within a dependency graph, it is called a <em>dependency conflict</em>. The process of mediating the conflict into a single version is called <em>dependency resolution</em>. Often, this would result in the older version beging removed from the dependency graph, which is called an <em>eviction</em> of <code>foo:2.2.0</code>. In some cases, an eviction is considered unsafe because the candidates are not replacable. See <a href="appendix/../reference/sbt-update.html">sbt update</a>.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<h3 id="eviction"><a class="header" href="#eviction">Eviction</a></h3>
<p>See <a href="appendix/glossary.html#dependency-resolution">dependency resolution</a>.</p>
<h2 id="v"><a class="header" href="#v">V</a></h2>
<h3 id="value"><a class="header" href="#value"><code>value</code></a></h3>
<p><code>.value</code> is used to denote a happens-before relationship from one task or setting to another. This method is special (it is a macro) and cannot be used except in <code>:=</code> or in the standalone construction methods <code>Def.setting</code> and <code>Def.task</code>.</p>
<!--
This is an index of common methods, types, and values you might find in
an sbt build definition. For command names, see
[Running][Running]. For available plugins, see
[the plugins list][Community-Plugins].
-->
<!--
#### Dependency Management

-   [ModuleID](../api/sbt/librarymanagement/ModuleID.html) is the type of a dependency
    definition. See
    [Library Management][Library-Management].
-   [Artifact](../api/sbt/librarymanagement/Artifact.html) represents a single artifact
    (such as a jar or a pom) to be built and published. See
    [Library Management][Library-Management] and [Artifacts][Artifacts].
-   A [Resolver](../api/sbt/librarymanagement/Resolver.html) can resolve and retrieve
    dependencies. Many types of Resolvers can publish dependencies as
    well. A repository is a closely linked idea that typically refers to
    the actual location of the dependencies. However, sbt is not very
    consistent with this terminology and repository and resolver are
    occasionally used interchangeably.
-   A [ModuleConfiguration](../api/sbt/librarymanagement/ModuleConfiguration.html) defines
    a specific resolver to use for a group of dependencies.
-   A [Configuration](../api/sbt/librarymanagement/Configuration.html) is a useful Ivy
    construct for grouping dependencies. See ivy-configurations. It is
    also used for [scoping settings][Scopes].
-   `Compile`, `Test`, `Runtime`, `Provided`, and `Optional` are
    predefined [configurations][ivy-configurations].
-->
<!--
#### Settings and Tasks

-   A [Setting](../api/sbt/internal/util/Init\$Setting.html) describes how to
    initialize a specific setting in the build. It can use the values of
    other settings or the previous value of the setting being
    initialized.
-   A [SettingsDefinition](../api/sbt/internal/util/Init\$SettingsDefinition.html)
    is the actual type of an expression in a build.sbt. This allows
    either a single [Setting](../api/sbt/internal/util/Init\$Setting.html) or a
    sequence of settings
    ([SettingList](../api/sbt/internal/util/Init\$SettingList.html)) to be defined at
    once. The types in a [.scala build definition][Full-Def] always use just a
    plain [Setting](../api/sbt/internal/util/Init\$Setting.html).
-   [Initialize](../api/sbt/internal/util/Init\$Initialize.html) describes how to
    initialize a setting using other settings, but isn't bound to a
    particular setting yet. Combined with an initialization method and a
    setting to initialize, it produces a full
    [Setting](../api/sbt/internal/util/Init\$Setting.html).
-   [TaskKey](../api/sbt/TaskKey.html),
    [SettingKey](../api/sbt/SettingKey.html), and
    [InputKey](../api/sbt/InputKey.html) are keys that represent a task
    or setting. These are not the actual tasks, but keys that are used
    to refer to them. They can be scoped to produce
    [ScopedTask](../api/sbt/ScopedTask.html),
    [ScopedSetting](../api/sbt/ScopedSetting.html), and
    [ScopedInput](../api/sbt/ScopedInput.html). These form the base
    types that provide the Settings methods.
-   [InputTask](../api/sbt/InputTask.html) parses and tab completes
    user input, producing a task to run.
-   [Task](../api/sbt/Task.html) is the type of a task. A task is an
    action that runs on demand. This is in contrast to a setting, which
    is run once at project initialization.
-->
<!--
#### Build Structure

-   [AutoPlugin](../api/sbt/AutoPlugin.html) is the trait implemented for sbt
    [plugins][Using-Plugins].
-   [Project](../api/sbt/Project.html) is both a trait and a
    companion object that declares a single module in a build. See
    [.scala build definition][Full-Def].
-   [Keys](../api/sbt/Keys\$.html) is an object that provides all of
    the built-in keys for settings and tasks.
-   [State](../api/sbt/State.html) contains the full state for a
    build. It is mainly used by [Commands][Commands] and sometimes
    [Input Tasks][Input-Tasks]. See also [State and Actions][Build-State].

-->
<!--
#### Settings and Tasks

See the [Getting Started Guide][Basic-Def] for
details.

-   `in` specifies the [Scope](../api/sbt/Scope.html) or part of the
    [Scope](../api/sbt/Scope.html) of a setting being referenced. See
    [scopes][Scopes].
-->
<!--
#### File and IO

See [RichFile](../api/sbt/io/RichFile.html),
[PathFinder](../api/sbt/io/PathFinder.html), and
[Paths][Paths] for the full documentation.

-   `/` When called on a single File, this is `new File(x,y)`. For
    Seq[File], this is applied for each member of the sequence..
-   `*` and `**` are methods for selecting children (`*`) or descendants
    (`**`) of a File or Seq[File] that match a filter.
-   `|`, `||`, `&&`, `&`, `-`, and `--` are methods for combining
    filters, which are often used for selecting Files. See
    [NameFilter](../api/sbt/io/NameFilter.html) and
    [FileFilter](../api/sbt/io/FileFilter.html). Note that methods with
    these names also exist for other types, such as collections (like
    Seq) and [Parser](../api/sbt/internal/util/complete/Parser.html) (see
    [Parsing Input][Parsing-Input]).
-   `pair` Used to construct mappings from a `File` to another `File` or
    to a String. See [Mapping Files][Mapping-Files].
-   `get` forces a [PathFinder](../api/sbt/io/PathFinder.html) (a
    call-by-name data structure) to a strict `Seq[File]` representation.
    This is a common name in Scala, used by types like Option.
-->
<!--
#### Dependency Management

See [Library Management][Library-Management] for full documentation.

-   `from` Used to specify the fallback URL for a dependency
-   `classifier` Used to specify the classifier for a dependency.
-   `at` Used to define a Maven-style resolver.
-   `intransitive` Marks a [dependency](../api/sbt/librarymanagement/ModuleID.html) or
    [Configuration](../api/sbt/librarymanagement/Configuration.html) as being
    intransitive.
-   `hide` Marks a [Configuration](../api/sbt/librarymanagement/Configuration.html) as
    internal and not to be included in the published metadata.
-->
<!--
#### Parsing

These methods are used to build up
[Parser](../api/sbt/internal/util/complete/Parser.html)s from smaller
[Parser](../api/sbt/internal/util/complete/Parser.html)s. They closely follow the
names of the standard library's parser combinators. See
[Parsing Input][Parsing-Input] for the full documentation. These are
used for
[Input Tasks][Input-Tasks] and
[Commands][Commands].

-   `~`, `~>`, `<~` Sequencing methods.
-   `??`, `?` Methods for making a Parser optional. `?` is postfix.
-   `id` Used for turning a Char or String literal into a Parser. It is
    generally used to trigger an implicit conversion to a Parser.
-   `|`, `||` Choice methods. These are common method names in Scala.
-   `^^^` Produces a constant value when a Parser matches.
-   `+`, `*` Postfix repetition methods. These are common method names
    in Scala.
-   `map`, `flatMap` Transforms the result of a Parser. These are common
    method names in Scala.
-   `filter` Restricts the inputs that a Parser matches on. This is a
    common method name in Scala.
-   `-` Prefix negation. Only matches the input when the original parser
    doesn't match the input.
-   `examples`, `token` Tab completion
-   `!!!` Provides an error message to use when the original parser
    doesn't match the input.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-notes"><a class="header" href="#setup-notes">Setup Notes</a></h1>
<p>See <a href="appendix/Setup.html">Installing sbt runner</a> for the instruction on general setup. Using Coursier or SDKMAN has two advantages.</p>
<ol>
<li>They will install the official packaging by Eclipse Adoptium etc, as opposed to the <a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2019-May/009330.html">"mystery meat OpenJDK builds"</a>.</li>
<li>They will install <code>tgz</code> packaging of sbt that contains all JAR files. (DEB and RPM packages do not to save bandwidth)</li>
</ol>
<p>This page describes alternative ways of installing the sbt runner. Note that some of the third-party packages may not provide the latest version.</p>
<h2 id="os-specific-setup"><a class="header" href="#os-specific-setup">OS specific setup</a></h2>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<h4 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h4>
<pre><code class="language-bash">$ brew install sbt
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="appendix/setup-notes.html#admonition-warning"></a>
</div>
<div>
<p>Homebrew maintainers have added a dependency to JDK 13 because they want to use more brew dependencies (<a href="https://github.com/Homebrew/homebrew-core/issues/50649">brew#50649</a>). This causes sbt to use JDK 13 even when <code>java</code> available on PATH is JDK 8 or 11. To prevent <code>sbt</code> from running on JDK 13, install <a href="https://www.jenv.be/">jEnv</a> or switch to using <a href="https://sdkman.io/">SDKMAN</a>.</p>
</div>
</div>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt/releases/download/v/sbt-.msi">sbt-.msi</a></li>
</ul>
<h4 id="chocolatey"><a class="header" href="#chocolatey"><a href="https://chocolatey.org/packages/sbt">Chocolatey</a></a></h4>
<pre><code>&gt; choco install sbt
</code></pre>
<h4 id="scoop"><a class="header" href="#scoop"><a href="https://scoop.sh/">Scoop</a></a></h4>
<pre><code>&gt; scoop install sbt
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<h4 id="ubuntu-and-other-debian-based-distributions"><a class="header" href="#ubuntu-and-other-debian-based-distributions">Ubuntu and other Debian-based distributions</a></h4>
<p><a href="appendix/$sbt_deb_package_base$sbt-$app_version$.deb">DEB</a> package is officially supported by sbt, but it does not contain JAR files to save bandwidth.</p>
<p>Ubuntu and other Debian-based distributions use the DEB format, but usually you don't install your software from a local DEB file. Instead they come with package managers both for the command line (e.g. <code>apt-get</code>, <code>aptitude</code>) or with a graphical user interface (e.g. Synaptic). Run the following from the terminal to install <code>sbt</code> (You'll need superuser privileges to do so, hence the <code>sudo</code>).</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install apt-transport-https curl gnupg -yqq
echo "deb https://repo.scala-sbt.org/scalasbt/debian all main" | sudo tee /etc/apt/sources.list.d/sbt.list
echo "deb https://repo.scala-sbt.org/scalasbt/debian /" | sudo tee /etc/apt/sources.list.d/sbt_old.list
curl -sL "https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823" | sudo -H gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/scalasbt-release.gpg --import
sudo chmod 644 /etc/apt/trusted.gpg.d/scalasbt-release.gpg
sudo apt-get update
sudo apt-get install sbt
</code></pre>
<p>Package managers will check a number of configured repositories for packages to offer for installation. You just have to add the repository to the places your package manager will check.</p>
<p>Once <code>sbt</code> is installed, you'll be able to manage the package in <code>aptitude</code> or Synaptic after you updated their package cache. You should also be able to see the added repository at the bottom of the list in System Settings -&gt; Software &amp; Updates -&gt; Other Software:</p>
<p><img src="appendix//files/ubuntu-sources.png" alt="Ubuntu Software &amp; Updates Screenshot" title="Ubuntu Software &amp; Updates Screenshot" /></p>
<p><code>sudo apt-key adv --keyserver hkps://keyserver.ubuntu.com:443 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823</code> may not work on Ubuntu Bionic LTS (18.04) since it's using a buggy GnuPG, so we are advising to use web API to download the public key in the above.</p>
<h4 id="red-hat-enterprise-linux-and-other-rpm-based-distributions"><a class="header" href="#red-hat-enterprise-linux-and-other-rpm-based-distributions">Red Hat Enterprise Linux and other RPM-based distributions</a></h4>
<p><a href="appendix/$sbt_rpm_package_base$sbt-$app_version$.rpm">RPM</a> package is officially supported by sbt, but it does not contain JAR files to save bandwidth.</p>
<p>Red Hat Enterprise Linux and other RPM-based distributions use the RPM format. Run the following from the terminal to install <code>sbt</code> (You'll need superuser privileges to do so, hence the <code>sudo</code>).</p>
<pre><code class="language-bash"># remove old Bintray repo file
sudo rm -f /etc/yum.repos.d/bintray-rpm.repo
curl -L https://www.scala-sbt.org/sbt-rpm.repo &gt; sbt-rpm.repo
sudo mv sbt-rpm.repo /etc/yum.repos.d/
sudo yum install sbt
</code></pre>
<p>On Fedora (31 and above), use <code>sbt-rpm.repo</code>:</p>
<pre><code class="language-bash"># remove old Bintray repo file
sudo rm -f /etc/yum.repos.d/bintray-rpm.repo
curl -L https://www.scala-sbt.org/sbt-rpm.repo &gt; sbt-rpm.repo
sudo mv sbt-rpm.repo /etc/yum.repos.d/
sudo dnf install sbt
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>