<!DOCTYPE HTML>
<html lang="zh-cn" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of sbt</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/reference/custom-202509.css">
        <link rel="stylesheet" href="src/reference/mdbook-admonish.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            
            // var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
            var default_theme = "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of sbt</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-cn">Chinese Simplified (中文)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (日本語)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-cn");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                            lang.href = `${full_path_to_root}${lang.id}/${path}`;
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sbt-之书-草稿"><a class="header" href="#sbt-之书-草稿">sbt 之书 (草稿)</a></h1>
<p>这是关于 sbt 2.x 的草稿文档，目前尚未发布。虽然总体概念可以应用到 sbt 1.x，但 2.x 及本文档的详细内容可能会有所变动。</p>
<p><img src="files/sbt-logo.svg" alt="sbt logo" /></p>
<p>sbt 是一个用于 Scala 和 Java 的简单构建工具。 sbt 通过 Coursier 下载您的库依赖， 增量编译和测试项目， 并与 IntelliJ 和 VS Code 等 IDE 集成， 打包 JAR 文件并发布到 <a href="https://central.sonatype.com/">Central repo</a>， 这是 JVM 社区的包注册表。</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<p>您只需要在 <code>build.sbt</code> 中添加一行代码即可开始使用 Scala。</p>
<h2 id="链接"><a class="header" href="#链接">链接</a></h2>
<ul>
<li>此文档的源代码托管在 <a href="https://github.com/sbt/website/">sbt/website</a></li>
<li><a href="https://www.scala-sbt.org/1.x/docs/zh-cn/Getting-Started.html">sbt 1.x 的文档</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-sbt-runner"><a class="header" href="#安装-sbt-runner">安装 sbt runner</a></h1>
<p>要构建 sbt 工程，你需要经过以下几步：</p>
<ul>
<li>安装 JDK（建议使用 Eclipse Adoptium 的 Temurin JDK 8、11 或 17，或者适用于 ARM 芯片的 macOS 的 Zulu JDK 8）。</li>
<li>安装 sbt runner。</li>
</ul>
<p>sbt runner 是一个 shell 脚本，它会在必要时提前下载指定版本的 sbt 并调用它。通过这种机制，构建作者可以精确控制 sbt 的版本，而不是依赖用户的机器环境。</p>
<h3 id="软件需求"><a class="header" href="#软件需求">软件需求</a></h3>
<p>sbt 可在所有主流操作系统上运行；但是，运行它需要 JDK 8 或更高版本。</p>
<pre><code class="language-bash">java -version
# openjdk version "1.8.0_352"
</code></pre>
<h3 id="通过-sdkman-安装"><a class="header" href="#通过-sdkman-安装">通过 SDKMAN 安装</a></h3>
<p>要同时安装 JDK 和 sbt，可以考虑使用 <a href="https://sdkman.io/">SDKMAN</a>。</p>
<pre><code class="language-bash">sdk install java $(sdk list java | grep -o "\b8\.[0-9]*\.[0-9]*\-tem" | head -1)
sdk install sbt
</code></pre>
<h3 id="通用的包安装"><a class="header" href="#通用的包安装">通用的包安装</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.7/sbt-1.11.7.zip">sbt-1.11.7.zip</a></li>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.7/sbt-1.11.7.tgz">sbt-1.11.7.tgz</a></li>
<li><a href="https://github.com/sbt/sbt/releases/download/v1.11.7/sbt-1.11.7.msi">sbt-1.11.7.msi</a></li>
</ul>
<h2 id="验证-sbt-runner"><a class="header" href="#验证-sbt-runner">验证 sbt runner</a></h2>
<pre><code class="language-bash">sbt --script-version
# 1.11.7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-示例教程"><a class="header" href="#sbt-示例教程">sbt 示例教程</a></h1>
<p>本页面假设您已经安装了 <a href="Setup.html">sbt runner</a>。</p>
<p>让我们从示例开始，而不是解释 sbt 如何工作或为什么这样工作。</p>
<h3 id="创建一个最小的-sbt-构建"><a class="header" href="#创建一个最小的-sbt-构建">创建一个最小的 sbt 构建</a></h3>
<pre><code class="language-bash">mkdir foo-build
cd foo-build
touch build.sbt
mkdir project
echo "sbt.version=2.0.0-RC6" &gt; project/build.properties
</code></pre>
<h3 id="启动-sbt-shell"><a class="header" href="#启动-sbt-shell">启动 sbt shell</a></h3>
<pre><code class="language-bash">$ sbt
[info] welcome to sbt 2.0.0-RC6 (Azul Systems, Inc. Java)
....
[info] started sbt server
sbt:foo-build&gt;
</code></pre>
<h3 id="退出-sbt-shell"><a class="header" href="#退出-sbt-shell">退出 sbt shell</a></h3>
<p>要退出 sbt shell，请输入 <code>exit</code> 或使用 Ctrl+D（Unix）或 Ctrl+Z（Windows）。</p>
<pre><code>sbt:foo-build&gt; exit
</code></pre>
<h3 id="编译一个项目"><a class="header" href="#编译一个项目">编译一个项目</a></h3>
<p>按照惯例，我们将使用 <code>sbt:...&gt;</code> 或 <code>&gt;</code> 提示符来表示我们正在 sbt 交互式 shell 中。</p>
<pre><code class="language-bash">$ sbt
sbt:foo-build&gt; compile
[success] elapsed time: 0 s, cache 0%, 1 onsite task
</code></pre>
<h3 id="代码更改时重新编译"><a class="header" href="#代码更改时重新编译">代码更改时重新编译</a></h3>
<p>在 <code>compile</code> 命令（或任何其他命令）前加上 <code>~</code> 会导致该命令在项目中的源文件被修改时自动重新执行。例如:</p>
<pre><code>sbt:foo-build&gt; ~compile
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
[info] 1. Monitoring source files for foo-build/compile...
[info]    Press &lt;enter&gt; to interrupt or '?' for more options.
</code></pre>
<h3 id="创建一个源文件"><a class="header" href="#创建一个源文件">创建一个源文件</a></h3>
<p>保持前一个命令运行。从另一个 shell 或在您的文件管理器中，在 foo-build 目录下创建以下嵌套目录：<code>src/main/scala/example</code>。然后，使用您喜欢的编辑器在 <code>example</code> 目录中创建 <code>Hello.scala</code>，内容如下：</p>
<pre><code class="language-scala">package example

@main def main(args: String*): Unit =
  println(s"Hello ${args.mkString}")
</code></pre>
<p>运行中的命令应该会检测到这个新文件：</p>
<pre><code>[info] Build triggered by /tmp/foo-build/src/main/scala/example/Hello.scala. Running 'compile'.
[info] compiling 1 Scala source to /tmp/foo-build/target/out/jvm/scala-3.3.3/foo/backend ...
[success] elapsed time: 1 s, cache 0%, 1 onsite task
[info] 2. Monitoring source files for foo-build/compile...
[info]    Press &lt;enter&gt; to interrupt or '?' for more options.
</code></pre>
<p>按 <code>Enter</code> 键退出 <code>~compile</code>。</p>
<h3 id="运行先前的命令"><a class="header" href="#运行先前的命令">运行先前的命令</a></h3>
<p>在 sbt shell 中，按两次向上箭头键找到您在开始时执行的 <code>compile</code> 命令。</p>
<pre><code>sbt:foo-build&gt; compile
</code></pre>
<h3 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h3>
<p>使用 <code>help</code> 命令获取关于可用命令的基本帮助。</p>
<pre><code>sbt:foo-build&gt; help

  &lt;command&gt; (; &lt;command&gt;)*                       Runs the provided semicolon-separated commands.
  about                                          Displays basic information about sbt and the build.
  tasks                                          Lists the tasks defined for the current project.
  settings                                       Lists the settings defined for the current project.
  reload                                         (Re)loads the current project or changes to plugins project or returns from it.
  new                                            Creates a new sbt build.
  new                                            Creates a new sbt build.
  projects                                       Lists the names of available projects or temporarily adds/removes extra builds to the session.

....
</code></pre>
<p>显示特定任务的描述：</p>
<pre><code>sbt:foo-build&gt; help run
Runs a main class, passing along arguments provided on the command line.
</code></pre>
<h3 id="运行您的应用"><a class="header" href="#运行您的应用">运行您的应用</a></h3>
<pre><code>sbt:foo-build&gt; run
[info] running example.main
Hello
[success] elapsed time: 0 s, cache 50%, 1 disk cache hit, 1 onsite task
</code></pre>
<h3 id="从-sbt-shell-设置-scalaversion"><a class="header" href="#从-sbt-shell-设置-scalaversion">从 sbt shell 设置 scalaVersion</a></h3>
<pre><code>sbt:foo-build&gt; set scalaVersion := "3.7.3"
[info] Defining scalaVersion
[info] The new value will be used by Compile / bspBuildTarget, Compile / dependencyTreeCrossProjectId and 51 others.
[info]  Run `last` for details.
[info] Reapplying settings...
[info] set current project to foo (in build file:/tmp/foo-build/)
</code></pre>
<p>检查 <code>scalaVersion</code> 设置：</p>
<pre><code>sbt:foo-build&gt; scalaVersion
[info] 3.7.3
</code></pre>
<h3 id="将会话保存到-buildsbt"><a class="header" href="#将会话保存到-buildsbt">将会话保存到 build.sbt</a></h3>
<p>我们可以使用 <code>session save</code> 保存临时设置。</p>
<pre><code>sbt:foo-build&gt; session save
[info] Reapplying settings...
[info] set current project to foo-build (in build file:/tmp/foo-build/)
[warn] build source files have changed
[warn] modified files:
[warn]   /tmp/foo-build/build.sbt
[warn] Apply these changes by running `reload`.
[warn] Automatically reload the build when source changes are detected by setting `Global / onChangedBuildSource := ReloadOnSourceChanges`.
[warn] Disable this warning by setting `Global / onChangedBuildSource := IgnoreSourceChanges`.
</code></pre>
<p><code>build.sbt</code> 文件现在应该包含：</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

</code></pre>
<h3 id="命名您的项目"><a class="header" href="#命名您的项目">命名您的项目</a></h3>
<p>使用编辑器，按如下方式更改 <code>build.sbt</code>：</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
</code></pre>
<h3 id="重新加载构建"><a class="header" href="#重新加载构建">重新加载构建</a></h3>
<p>使用 <code>reload</code> 命令重新加载构建。该命令会导致 <code>build.sbt</code> 文件被重新读取，并应用其设置。</p>
<pre><code>sbt:foo-build&gt; reload
[info] welcome to sbt 2.x (Azul Systems, Inc. Java)
[info] loading project definition from /tmp/foo-build/project
[info] loading settings for project hello from build.sbt ...
[info] set current project to Hello (in build file:/tmp/foo-build/)
sbt:Hello&gt;
</code></pre>
<p>请注意，提示符现在已更改为 <code>sbt:Hello&gt;</code>。</p>
<h3 id="将-toolkit-test-添加到-librarydependencies"><a class="header" href="#将-toolkit-test-添加到-librarydependencies">将 toolkit-test 添加到 libraryDependencies</a></h3>
<p>使用编辑器，按如下方式更改 <code>build.sbt</code>：</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
libraryDependencies += "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test
</code></pre>
<p>使用 <code>reload</code> 命令使 <code>build.sbt</code> 中的更改生效。</p>
<pre><code>sbt:Hello&gt; reload
</code></pre>
<h3 id="运行增量测试"><a class="header" href="#运行增量测试">运行增量测试</a></h3>
<pre><code>sbt:Hello&gt; test
</code></pre>
<h3 id="持续运行增量测试"><a class="header" href="#持续运行增量测试">持续运行增量测试</a></h3>
<pre><code>sbt:Hello&gt; ~test
</code></pre>
<h3 id="编写测试"><a class="header" href="#编写测试">编写测试</a></h3>
<p>保持前一个命令运行，使用编辑器创建一个名为 <code>src/test/scala/example/HelloSuite.scala</code> 的文件:</p>
<pre><code class="language-scala">package example

class HelloSuite extends munit.FunSuite:
  test("Hello should start with H") {
    assert("hello".startsWith("H"))
  }
end HelloSuite
</code></pre>
<p><code>~test</code> 应该会检测到更改:</p>
<pre><code>example.HelloSuite:
==&gt; X example.HelloSuite.Hello should start with H  0.012s munit.FailException: /tmp/foo-build/src/test/scala/example/HelloSuite.scala:5 assertion failed
4:  test("Hello should start with H") {
5:    assert("hello".startsWith("H"))
6:  }
    at munit.FunSuite.assert(FunSuite.scala:11)
    at example.HelloSuite.$init$$$anonfun$1(HelloSuite.scala:5)
[error] Failed: Total 1, Failed 1, Errors 0, Passed 0
[error] Failed tests:
[error]   example.HelloSuite
[error] (Test / testQuick) sbt.TestsFailedException: Tests unsuccessful
[error] elapsed time: 1 s, cache 50%, 3 disk cache hits, 3 onsite tasks
</code></pre>
<h3 id="使测试通过"><a class="header" href="#使测试通过">使测试通过</a></h3>
<p>使用编辑器，将 <code>src/test/scala/example/HelloSuite.scala</code> 更改为:</p>
<pre><code class="language-scala">package example

class HelloSuite extends munit.FunSuite:
  test("Hello should start with H") {
    assert("Hello".startsWith("H"))
  }
end HelloSuite
</code></pre>
<p>确认测试通过，然后按 <code>Enter</code> 键退出持续测试。</p>
<h3 id="添加库依赖"><a class="header" href="#添加库依赖">添加库依赖</a></h3>
<p>使用编辑器，按如下方式更改 <code>build.sbt</code>：</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"
name := "Hello"
libraryDependencies ++= Seq(
  "org.scala-lang" %% "toolkit" % "0.1.7",
  "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test,
)
</code></pre>
<p>使用 <code>reload</code> 命令使 <code>build.sbt</code> 中的更改生效。</p>
<h3 id="使用-scala-repl"><a class="header" href="#使用-scala-repl">使用 Scala REPL</a></h3>
<p>我们可以查询纽约的当前天气。</p>
<pre><code class="language-scala">sbt:Hello&gt; console
Welcome to Scala 3.3.3 (1.8.0_402, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.

scala&gt;
import sttp.client4.quick.*
import sttp.client4.Response

val newYorkLatitude: Double = 40.7143
val newYorkLongitude: Double = -74.006
val response: Response[String] = quickRequest
  .get(
    uri"https://api.open-meteo.com/v1/forecast?latitude=\$newYorkLatitude&amp;longitude=\$newYorkLongitude&amp;current_weather=true"
  )
  .send()

println(ujson.read(response.body).render(indent = 2))

// press Ctrl+D

// Exiting paste mode, now interpreting.

{
  "latitude": 40.710335,
  "longitude": -73.99307,
  "generationtime_ms": 0.36704540252685547,
  "utc_offset_seconds": 0,
  "timezone": "GMT",
  "timezone_abbreviation": "GMT",
  "elevation": 51,
  "current_weather": {
    "temperature": 21.3,
    "windspeed": 16.7,
    "winddirection": 205,
    "weathercode": 3,
    "is_day": 1,
    "time": "2023-08-04T10:00"
  }
}
import sttp.client4.quick._
import sttp.client4.Response
val newYorkLatitude: Double = 40.7143
val newYorkLongitude: Double = -74.006
val response: sttp.client4.Response[String] = Response({"latitude":40.710335,"longitude":-73.99307,"generationtime_ms":0.36704540252685547,"utc_offset_seconds":0,"timezone":"GMT","timezone_abbreviation":"GMT","elevation":51.0,"current_weather":{"temperature":21.3,"windspeed":16.7,"winddirection":205.0,"weathercode":3,"is_day":1,"time":"2023-08-04T10:00"}},200,,List(:status: 200, content-encoding: deflate, content-type: application/json; charset=utf-8, date: Fri, 04 Aug 2023 10:09:11 GMT),List(),RequestMetadata(GET,https://api.open-meteo.com/v1/forecast?latitude=40.7143&amp;longitude...

scala&gt; :q // to quit
</code></pre>
<h3 id="创建子项目"><a class="header" href="#创建子项目">创建子项目</a></h3>
<p>按如下方式更改 <code>build.sbt</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

lazy val hello = project
  .in(file("."))
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      "org.scala-lang" %% "toolkit-test" % "0.1.7" % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core"
  )
</code></pre>
<p>使用 <code>reload</code> 命令使 <code>build.sbt</code> 中的更改生效。</p>
<h3 id="列出所有子项目"><a class="header" href="#列出所有子项目">列出所有子项目</a></h3>
<pre><code>sbt:Hello&gt; projects
[info] In file:/tmp/foo-build/
[info]   * hello
[info]     helloCore
</code></pre>
<h3 id="编译子项目"><a class="header" href="#编译子项目">编译子项目</a></h3>
<pre><code>sbt:Hello&gt; helloCore/compile
</code></pre>
<h3 id="将-toolkit-test-添加到子项目"><a class="header" href="#将-toolkit-test-添加到子项目">将 toolkit-test 添加到子项目</a></h3>
<p>按如下方式更改 <code>build.sbt</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      toolkitTest % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<h3 id="广播命令"><a class="header" href="#广播命令">广播命令</a></h3>
<p>设置 aggregate 以便发送到 <code>hello</code> 的命令也会广播到 <code>helloCore</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .aggregate(helloCore)
  .settings(
    name := "Hello",
    libraryDependencies ++= Seq(
      "org.scala-lang" %% "toolkit" % "0.1.7",
      toolkitTest % Test
    )
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<p><code>reload</code> 之后，<code>~test</code> 现在会在两个子项目上运行:</p>
<pre><code class="language-scala">sbt:Hello&gt; ~test
</code></pre>
<p>按 <code>Enter</code> 键退出持续测试。</p>
<h3 id="使-hello-依赖于-hellocore"><a class="header" href="#使-hello-依赖于-hellocore">使 hello 依赖于 helloCore</a></h3>
<p>使用 <code>.dependsOn(...)</code> 添加对其他子项目的依赖。同时，让我们将 toolkit 依赖移至 <code>helloCore</code>。</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
organization := "com.example"

val toolkitTest = "org.scala-lang" %% "toolkit-test" % "0.1.7"

lazy val hello = project
  .in(file("."))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := "Hello",
    libraryDependencies += toolkitTest % Test
  )

lazy val helloCore = project
  .in(file("core"))
  .settings(
    name := "Hello Core",
    libraryDependencies += "org.scala-lang" %% "toolkit" % "0.1.7",
    libraryDependencies += toolkitTest % Test
  )
</code></pre>
<h3 id="使用-ujson-解析-json"><a class="header" href="#使用-ujson-解析-json">使用 uJson 解析 JSON</a></h3>
<p>让我们在 <code>helloCore</code> 中使用 toolkit 中的 uJson。</p>
<p>添加 <code>core/src/main/scala/example/core/Weather.scala</code>:</p>
<pre><code class="language-scala">package example.core

import sttp.client4.quick._
import sttp.client4.Response

object Weather:
  def temp() =
    val response: Response[String] = quickRequest
      .get(
        uri"https://api.open-meteo.com/v1/forecast?latitude=40.7143&amp;longitude=-74.006&amp;current_weather=true"
      )
      .send()
    val json = ujson.read(response.body)
    json.obj("current_weather")("temperature").num
end Weather
</code></pre>
<p>接下来，按如下方式更改 <code>src/main/scala/example/Hello.scala</code>:</p>
<pre><code class="language-scala">package example

import example.core.Weather

@main def main(args: String*): Unit =
  val temp = Weather.temp()
  println(s"Hello! The current temperature in New York is $temp C.")
</code></pre>
<p>让我们运行应用，看看它是否正常工作:</p>
<pre><code>sbt:Hello&gt; run
[info] compiling 1 Scala source to /tmp/foo-build/core/target/scala-2.13/classes ...
[info] compiling 1 Scala source to /tmp/foo-build/target/scala-2.13/classes ...
[info] running example.Hello
Hello! The current temperature in New York is 22.7 C.
</code></pre>
<!--
### Add sbt-native-packager plugin

Using an editor, create `project/plugins.sbt`:

@@snip [example-weather-plugins]($root$/src/sbt-test/ref/example-weather/changes/plugins.sbt) {}

Next change `build.sbt` as follows to add `JavaAppPackaging`:

@@snip [example-weather-build2]($root$/src/sbt-test/ref/example-weather/changes/build.sbt) {}

### Reload and create a .zip distribution

```
sbt:Hello> reload
...
sbt:Hello> dist
[info] Wrote /private/tmp/foo-build/target/scala-2.13/hello_2.13-0.1.0-SNAPSHOT.pom
[info] Main Scala API documentation to /tmp/foo-build/target/scala-2.13/api...
[info] Main Scala API documentation successful.
[info] Main Scala API documentation to /tmp/foo-build/core/target/scala-2.13/api...
[info] Wrote /tmp/foo-build/core/target/scala-2.13/hello-core_2.13-0.1.0-SNAPSHOT.pom
[info] Main Scala API documentation successful.
[success] All package validations passed
[info] Your package is ready in /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
```

Here's how you can run the packaged app:

```
$ /tmp/someother
$ cd /tmp/someother
$ unzip -o -d /tmp/someother /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
$ ./hello-0.1.0-SNAPSHOT/bin/hello
Hello! The current temperature in New York is 22.7 C.
```

### Dockerize your app

_Note that a Docker daemon will need to be running in order for this to work._

```
sbt:Hello> Docker/publishLocal
....
[info] Built image hello with tags [0.1.0-SNAPSHOT]
```

Here's how to run the Dockerized app:

```
$ docker run hello:0.1.0-SNAPSHOT
Hello! The current temperature in New York is 22.7 C.
```

### Set the version

Change `build.sbt` as follows:

@@snip [example-weather-build3]($root$/src/sbt-test/ref/example-weather/changes/build3.sbt) {}

-->
<h3 id="临时切换-scalaversion"><a class="header" href="#临时切换-scalaversion">临时切换 scalaVersion</a></h3>
<pre><code>sbt:Hello&gt; ++3.3.3!
[info] Forcing Scala version to 3.3.3 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
</code></pre>
<p>检查 <code>scalaVersion</code> 设置：</p>
<pre><code>sbt:Hello&gt; scalaVersion
[info] helloCore / scalaVersion
[info]  3.3.3
[info] scalaVersion
[info]  3.3.3
</code></pre>
<p>此设置将在 <code>reload</code> 之后消失。</p>
<!--
### Inspect the dist task

To find out more about `dist`, try `help` and `inspect`.

```scala
sbt:Hello> help dist
Creates the distribution packages.
sbt:Hello> inspect dist
```

To call inspect recursively on the dependency tasks use `inspect tree`.

```scala
sbt:Hello> inspect tree dist
[info] dist = Task[java.io.File]
[info]   +-Universal / dist = Task[java.io.File]
....
```

-->
<h3 id="批处理模式"><a class="header" href="#批处理模式">批处理模式</a></h3>
<p>您也可以在批处理模式下运行 sbt，直接从终端传递 sbt 命令。</p>
<pre><code>$ sbt clean "testOnly HelloSuite"
</code></pre>
<h3 id="sbt-new-命令"><a class="header" href="#sbt-new-命令">sbt new 命令</a></h3>
<p>您可以使用 sbt <code>new</code> 命令快速设置一个简单的 "Hello world" 构建。</p>
<pre><code>$ sbt new scala/scala-seed.g8
....
A minimal Scala project.

name [My Something Project]: hello

Template applied in ./hello
</code></pre>
<p>当提示输入项目名称时，请输入 <code>hello</code>。</p>
<p>这将在名为 <code>hello</code> 的目录下创建一个新项目。</p>
<h3 id="致谢"><a class="header" href="#致谢">致谢</a></h3>
<p>本页面基于 William "Scala William" Narmontas 编写的 <a href="https://www.scalawilliam.com/essential-sbt/">Essential sbt</a> 教程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-入门"><a class="header" href="#sbt-入门">sbt 入门</a></h1>
<p>sbt 使用少数的几个概念来支撑它灵活并且强大的构建定义。其实没有太多的概念，但是 sbt 并不完全像其他的构建体系，而且如果您没有看过文档的话，您偶尔将会遇到一些细节问题。</p>
<p>这篇入门指南覆盖了一些您在创建和维护一个 sbt 构建定义时需要知道的概念。</p>
<p>强烈建议看完该入门指南。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-的存在理由"><a class="header" href="#sbt-的存在理由">sbt 的存在理由</a></h1>
<h2 id="预备知识"><a class="header" href="#预备知识">预备知识</a></h2>
<p>在 Scala 中，库或程序使用 Scala 编译器 <code>scalac</code> 进行编译，正如 <a href="https://docs.scala-lang.org/scala3/book/taste-hello-world.html">Scala 3 Book</a> 中所记录的:</p>
<pre><code class="language-scala">@main def hello() = println("Hello, World!")
</code></pre>
<pre><code class="language-bash">$ scalac hello.scala
$ scala hello
Hello, World!
</code></pre>
<p>如果我们直接调用 <code>scalac</code>，这个过程会变得乏味且缓慢，因为我们必须传递所有 Scala 源文件名。</p>
<p>此外，大多数非平凡的程序可能会有库依赖，因此也会传递性地依赖于它们的依赖项。对于 Scala 生态系统来说，这更加复杂，因为我们有 Scala 2.12，2.13 生态系统，Scala 3.x 生态系统，以及 JVM，JS 和 Native 平台。</p>
<p>与其使用 JAR 文件和 <code>scalac</code>，我们可以通过引入更高级别的子项目抽象概念并使用构建工具来避免手动劳作。</p>
<h2 id="sbt"><a class="header" href="#sbt">sbt</a></h2>
<p><em>sbt</em> 是为 Scala 和 Java 创建的简单构建工具。它允许我们声明子项目及其各种依赖项和自定义任务，以确保我们始终能获得快速，可重复的构建。</p>
<p>为了实现这一目标，sbt 做了几件事:</p>
<ul>
<li>sbt 本身的版本记录在 <code>project/build.properties</code> 中。</li>
<li>定义了一种称为 <strong>build.sbt DSL</strong> 的领域特定语言，可以在 <code>build.sbt</code> 中声明 Scala 版本和其他子项目信息。</li>
<li>使用 Coursier 获取子项目依赖及其依赖项。</li>
<li>调用 Zinc 增量编译 Scala 和 Java 源代码。</li>
<li>在可能的情况下自动并行运行任务。</li>
<li>定义了如何将包发布到 Maven 仓库的约定，以便与更广泛的 JVM 生态系统进行互操作。</li>
</ul>
<p>在很大程度上，sbt 标准化了构建给定程序或库所需的命令。</p>
<h2 id="buildsbt-dsl-的必要性"><a class="header" href="#buildsbt-dsl-的必要性">build.sbt DSL 的必要性</a></h2>
<p>sbt 采用基于 Scala 的 build.sbt DSL 来声明子项目和任务图。如今，使用 DSL 而非 YAML 和 XML 等配置格式几乎不再是 sbt 的独特之处。许多构建工具，如 Gradle，Google 的 Bazel，Meta 的 Buck 以及 Apple 的 SwiftPM 都使用 DSL 来定义子项目。</p>
<p><code>build.sbt</code> 最初几乎可以像 YAML 文件一样，仅声明 <code>scalaVersion</code> 和 <code>libraryDependencies</code>，但随着您对构建系统需求的增长，它可以进行扩展:</p>
<ul>
<li>为了避免重复相同的信息，例如库的版本号，<code>build.sbt</code> 可以使用 <code>val</code> 声明变量。</li>
<li>在需要时使用 Scala 语言结构（如 <code>if</code>）来定义设置和任务。</li>
<li>静态类型的设置和任务，可在构建开始前捕获拼写错误和类型错误。类型还有助于将数据从一个任务传递到另一个任务。</li>
<li>通过 <code>Initialized[Task[A]]</code> 提供<strong>结构化并发</strong>。DSL 使用所谓的<strong>直接风格</strong> <code>.value</code> 语法来简洁地定义任务图。</li>
<li>使社区能够通过插件扩展 sbt，这些插件提供自定义任务或语言扩展，如 Scala.JS。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建新的构建"><a class="header" href="#创建新的构建">创建新的构建</a></h1>
<p>要使用 <code>sbt</code> 开始新的构建，请使用 <code>sbt new</code>。</p>
<pre><code class="language-bash">$ mkdir /tmp/foo
$ cd /tmp/foo
$ sbt new

Welcome to sbt new!
Here are some templates to get started:
 a) scala/toolkit.local               - Scala Toolkit (beta) by Scala Center and VirtusLab
 b) typelevel/toolkit.local           - Toolkit to start building Typelevel apps
 c) sbt/cross-platform.local          - A cross-JVM/JS/Native project
 d) scala/scala3.g8                   - Scala 3 seed template
 e) scala/scala-seed.g8               - Scala 2 seed template
 f) playframework/play-scala-seed.g8  - A Play project in Scala
 g) playframework/play-java-seed.g8   - A Play project in Java
 i) softwaremill/tapir.g8             - A tapir project using Netty
 m) scala-js/vite.g8                  - A Scala.JS + Vite project
 n) holdenk/sparkProjectTemplate.g8   - A Scala Spark project
 o) spotify/scio.g8                   - A Scio project
 p) disneystreaming/smithy4s.g8       - A Smithy4s project
 q) quit
Select a template:
</code></pre>
<p>如果您选择 "a"，您将会收到更多问题的提示:</p>
<pre><code class="language-bash">Select a template: a
Scala version (default: 3.3.0):
Scala Toolkit version (default: 0.2.0):
</code></pre>
<p>按回车键选择默认值。</p>
<pre><code>[info] Updated file /private/tmp/bar/project/build.properties: set sbt.version to 1.9.8
[info] welcome to sbt 1.9.8 (Azul Systems, Inc. Java 1.8.0_352)
....
[info] set current project to bar (in build file:/private/tmp/foo/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/d0ac1409c0117a949d47/sock
[info] started sbt server
sbt:bar&gt; exit
[info] shutting down sbt server
</code></pre>
<p>以下是此模板创建的文件:</p>
<pre><code class="language-bash">.
├── build.sbt
├── project
│   └── build.properties
├── src
│   ├── main
│   │   └── scala
│   │       └── example
│   │           └── Main.scala
│   └── test
│       └── scala
│           └── example
│               └── ExampleSuite.scala
└── target
</code></pre>
<p>让我们看一下 <code>build.sbt</code> 文件:</p>
<pre><code class="language-scala">val toolkitV = "0.2.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV

scalaVersion := "3.3.0"
libraryDependencies += toolkit
libraryDependencies += (toolkitTest % Test)
</code></pre>
<p>这被称为<strong>构建定义</strong>，它包含 sbt 编译项目所需的信息。这是用 <code>.sbt</code> 格式编写的，它是 Scala 语言的一个子集。</p>
<p>以下是 <code>src/main/scala/example/Main.scala</code> 中的内容:</p>
<pre><code class="language-scala">package example

@main def main(args: String*): Unit =
  println(s"Hello ${args.mkString}")
</code></pre>
<p>这是一个 Hello world 模板。我们可以通过启动 <code>sbt --client</code> 并在 shell 中输入 <code>run &lt;您的名字&gt;</code> 来从 sbt shell 运行它:</p>
<pre><code>$ sbt --client
[info] entering *experimental* thin client - BEEP WHIRR
[info] server was not detected. starting an instance
....
info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:bar&gt; run Raj
[info] running example.main Raj
Hello Raj
[success] Total time: 0 s, completed Feb 18, 2024 2:38:10 PM
</code></pre>
<h3 id="giter8-模板"><a class="header" href="#giter8-模板">Giter8 模板</a></h3>
<p>除了几个 <code>.local</code> 模板外，<code>sbt new</code> 还与 <a href="https://www.foundweekends.org/giter8/">Giter8</a> 集成，这是一个使用 GitHub 托管模板的开放模板系统。例如，<code>scala/scala3.g8</code> 由 Scala 团队维护，用于创建新的 Scala 3 构建:</p>
<pre><code>$ /tmp
$ sbt new scala/scala3.g8
</code></pre>
<p><a href="https://github.com/foundweekends/giter8/wiki/giter8-templates">Giter8 wiki</a> 列出了 100 多个可以快速启动您新构建的模板。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-components"><a class="header" href="#sbt-components">sbt components</a></h1>
<h2 id="sbt-runner"><a class="header" href="#sbt-runner">sbt runner</a></h2>
<p>An sbt build is executed using <code>sbt</code> runner, also called "sbt-the-shell-script" to distinguish from other components. It's important to note is that sbt runner is designed to run <strong>any version</strong> of sbt.</p>
<h3 id="specifying-sbt-version-with-projectbuildproperties"><a class="header" href="#specifying-sbt-version-with-projectbuildproperties">Specifying sbt version with project/build.properties</a></h3>
<p>sbt runner executes a subcomponent called sbt launcher, which reads <code>project/build.properties</code> to determine the sbt version for the build, and downloads the artifacts if they haven't been cached:</p>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
<p>This means that:</p>
<ul>
<li>Anyone who checkouts your build would get the same sbt version, regardless of <em>sbt runner</em> they may have installed on their machines.</li>
<li>The change of sbt version can be tracked in a version control system, like git.</li>
</ul>
<h3 id="sbtn-sbt---client"><a class="header" href="#sbtn-sbt---client">sbtn (<code>sbt --client</code>)</a></h3>
<p>sbtn (native thin client) is a subcomponent of sbt runner, called when you pass <code>--client</code> flag to sbt runner, and is used to send commands to sbt server. It is called sbtn because it is compiled to native code using GraalVM native-image. The protocol between sbtn and sbt server is stable enough that it should work between <strong>most recent versions</strong> of sbt.</p>
<h2 id="sbt-server-sbt---server"><a class="header" href="#sbt-server-sbt---server">sbt server (<code>sbt --server</code>)</a></h2>
<p>sbt server is the actual build tool whose version is specified using <code>project/build.properties</code>. sbt server acts as a cashier to take commands from sbtn and editors.</p>
<h3 id="coursier"><a class="header" href="#coursier">Coursier</a></h3>
<p>sbt server runs <a href="https://get-coursier.io/">Couriser</a> as a subcomponent to resolve Scala library, Scala compiler, and any other library dependencies your build needs.</p>
<h3 id="zinc"><a class="header" href="#zinc">Zinc</a></h3>
<p>Zinc is the incremental compiler for Scala, developed and maintained by sbt project. An often overlooked aspect of Zinc is that Zinc provides a stable API to invoke <strong>any modern versions</strong> of Scala compiler. Combined with the fact that Coursier can resolve any Scala version, with sbt we can invoke any modern versions of Scala just by writing a single line <code>build.sbt</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<h3 id="bsp-server"><a class="header" href="#bsp-server">BSP server</a></h3>
<p>sbt server supports <a href="https://build-server-protocol.github.io/">Build Server Protocol (BSP)</a> to list build targets, build them, etc. This allows IDEs like IntelliJ and Metals to communicate with a running sbt server programmatically.</p>
<h2 id="connecting-to-sbt-server"><a class="header" href="#connecting-to-sbt-server">Connecting to sbt server</a></h2>
<p>Let's look at three ways of connecting to sbt server.</p>
<h3 id="sbt-shell-using-sbtn"><a class="header" href="#sbt-shell-using-sbtn">sbt shell using sbtn</a></h3>
<p>Run <code>sbt</code> in the working directory of your build:</p>
<pre><code class="language-bash">sbt
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/sbt-components.html#admonition-note"></a>
</div>
<div>
<p>In sbt 1.x, equivalent command was <code>sbt --client</code></p>
</div>
</div>
<p>This should display something like the following:</p>
<pre><code class="language-bash">$ sbt
[info] server was not detected. starting an instance
[info] welcome to sbt 2.0.0-alpha7 (Azul Systems, Inc. Java 1.8.0_352)
[info] loading project definition from /private/tmp/bar/project
[info] loading settings for project bar from build.sbt ...
[info] set current project to bar (in build file:/private/tmp/bar/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/2.0.0-alpha7/server/d0ac1409c0117a949d47/sock
[info] started sbt server
[info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:bar&gt;
</code></pre>
<p>Running sbt with no command line arguments starts sbt shell. sbt shell has a command prompt (with tab completion and history!).</p>
<p>For example, you could type <code>compile</code> at the sbt shell:</p>
<pre><code class="language-bash">sbt:bar&gt; compile
</code></pre>
<p>To <code>compile</code> again, press up arrow and then enter.</p>
<p>To leave sbt shell, type <code>exit</code> or use <code>Ctrl-D</code> (Unix) or <code>Ctrl-Z</code> (Windows).</p>
<h3 id="batch-mode-using-sbtn"><a class="header" href="#batch-mode-using-sbtn">Batch mode using sbtn</a></h3>
<p>You can also run sbt in batch mode:</p>
<pre><code class="language-bash">sbt compile
sbt testOnly TestA
</code></pre>
<pre><code class="language-bash">$ sbt compile
&gt; compile
</code></pre>
<h3 id="shutting-down-sbt-server"><a class="header" href="#shutting-down-sbt-server">Shutting down sbt server</a></h3>
<p>Run the following to shutdown all sbt servers on your machine:</p>
<pre><code class="language-bash">sbt shutdownall
</code></pre>
<p>Or the following to shutdown just the current one:</p>
<pre><code class="language-bash">sbt shutdown
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-tasks"><a class="header" href="#basic-tasks">Basic tasks</a></h1>
<p>This page describes how to use sbt once you have set up your project. This page assumes you've read <a href="guide/./sbt-components.html">sbt components</a>.</p>
<p>If you pull a repository that uses sbt, it's fairly easy to get started. First, get the package from GitHub, or some other repository.</p>
<pre><code class="language-bash">$ git clone https://github.com/scalanlp/breeze.git
$ cd breeze
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/basic-tasks.html#admonition-note"></a>
</div>
<div>
<p>scalanlp/breeze is on sbt 1.x, but we'll write this section as if it is an sbt 2.x build.</p>
</div>
</div>
<h3 id="sbt-shell-with-sbtn"><a class="header" href="#sbt-shell-with-sbtn">sbt shell with sbtn</a></h3>
<p>As mentioned in <a href="guide/./sbt-components.html">sbt components</a>, start an sbt shell:</p>
<pre><code>$ sbt
</code></pre>
<p>This should display something like the following:</p>
<pre><code class="language-bash">$ sbt
[info] entering *experimental* thin client - BEEP WHIRR
[info] server was not detected. starting an instance
[info] welcome to sbt 1.5.5 (Azul Systems, Inc. Java 1.8.0_352)
[info] loading global plugins from /Users/eed3si9n/.sbt/1.0/plugins
[info] loading settings for project breeze-build from plugins.sbt ...
[info] loading project definition from /private/tmp/breeze/project
Downloading https://repo1.maven.org/maven2/org/scalanlp/sbt-breeze-expand-codegen_2.12_1.0/0.2.1/sbt-breeze-expand-codegen-0.2.1.pom
....
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/dd982e07e85c7de1b618/sock
[info] terminate the server with `shutdown`
[info] disconnect from the server with `exit`
sbt:breeze-parent&gt;
</code></pre>
<h2 id="projects-command"><a class="header" href="#projects-command">projects command</a></h2>
<p>Let's explore the build by listing out the subprojects with <code>projects</code> command:</p>
<pre><code>sbt:breeze-parent&gt; projects
[info] In file:/private/tmp/breeze/
[info]     benchmark
[info]     macros
[info]     math
[info]     natives
[info]   * root
[info]     viz
</code></pre>
<p>This shows that this build has 6 subprojects, including the current subproject called <code>root</code>.</p>
<h2 id="tasks-command"><a class="header" href="#tasks-command">tasks command</a></h2>
<p>Similarly, we can list the tasks availble to this build using <code>tasks</code> command:</p>
<pre><code>sbt:breeze-parent&gt; tasks

This is a list of tasks defined for the current project.
It does not list the scopes the tasks are defined in; use the 'inspect' command for that.
Tasks produce values.  Use the 'show' command to run the task and print the resulting value.

  bgRun            Start an application's default main class as a background job
  bgRunMain        Start a provided main class as a background job
  clean            Deletes files produced by the build, such as generated sources, compiled classes, and task caches.
  compile          Compiles sources.
  console          Starts the Scala interpreter with the project classes on the classpath.
  consoleProject   Starts the Scala interpreter with the sbt and the build definition on the classpath and useful imports.
  consoleQuick     Starts the Scala interpreter with the project dependencies on the classpath.
  copyResources    Copies resources to the output directory.
  doc              Generates API documentation.
  package          Produces the main artifact, such as a binary jar.  This is typically an alias for the task that actually does the packaging.
  packageBin       Produces a main artifact, such as a binary jar.
  packageDoc       Produces a documentation artifact, such as a jar containing API documentation.
  packageSrc       Produces a source artifact, such as a jar containing sources and resources.
  publish          Publishes artifacts to a repository.
  publishLocal     Publishes artifacts to the local Ivy repository.
  publishM2        Publishes artifacts to the local Maven repository.
  run              Runs a main class, passing along arguments provided on the command line.
  runMain          Runs the main class selected by the first argument, passing the remaining arguments to the main method.
  test             Executes all tests.
  testOnly         Executes the tests provided as arguments or all tests if no arguments are provided.
  testQuick        Executes the tests that either failed before, were not run or whose transitive dependencies changed, among those provided as arguments.
  update           Resolves and optionally retrieves dependencies, producing a report.

More tasks may be viewed by increasing verbosity.  See 'help tasks'
</code></pre>
<h3 id="compile"><a class="header" href="#compile">compile</a></h3>
<p>The <code>compile</code> tasks compiles the sources, after resolving and downloading the library dependendies.</p>
<pre><code>&gt; compile
</code></pre>
<p>This should display something like the following:</p>
<pre><code>sbt:breeze-parent&gt; compile
[info] compiling 341 Scala sources and 1 Java source to /private/tmp/breeze/math/target/scala-3.1.3/classes ...
  | =&gt; math / Compile / compileIncremental 51s
</code></pre>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p>The <code>run</code> task runs the main class for the subproject. In the sbt shell, type <code>math/run</code>:</p>
<pre><code>&gt; math/run
</code></pre>
<p><code>math/run</code> means <code>run</code> task, scoped to <code>math</code> subproject. This should display something like the following:</p>
<pre><code>sbt:breeze-parent&gt; math/run
[info] Scala version: 3.1.3 true
....

Multiple main classes detected. Select one to run:
 [1] breeze.optimize.linear.NNLS
 [2] breeze.optimize.proximal.NonlinearMinimizer
 [3] breeze.optimize.proximal.QuadraticMinimizer
 [4] breeze.util.UpdateSerializedObjects

Enter number:
</code></pre>
<p>Enter <code>1</code> at the prompt.</p>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p>The <code>test</code> task tests either the tests that failed before, were not run, or whose transitive dependencies changed.</p>
<pre><code>&gt; math/test
</code></pre>
<p>This should display something like the following:</p>
<pre><code>sbt:breeze-parent&gt; math/testQuick
[info] FeatureVectorTest:
[info] - axpy fv dv (1 second, 106 milliseconds)
[info] - axpy fv vb (9 milliseconds)
[info] - DM mult (19 milliseconds)
[info] - CSC mult (32 milliseconds)
[info] - DM trans mult (4 milliseconds)
....
[info] Run completed in 58 seconds, 183 milliseconds.
[info] Total number of tests run: 1285
[info] Suites: completed 168, aborted 0
[info] Tests: succeeded 1285, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 130 s (02:10), completed Feb 19, 2024
</code></pre>
<h2 id="watch-tilde-command"><a class="header" href="#watch-tilde-command">Watch (tilde) command</a></h2>
<p>To speed up your edit-compile-test cycle, you can ask sbt to automatically recompile or run tests whenever you save a source file.</p>
<p>Make a command run when one or more source files change by prefixing the command with <code>~</code>. For example, in sbt shell try:</p>
<pre><code>&gt; ~test
</code></pre>
<p>Press enter to stop watching for changes. You can use the <code>~</code> prefix with either sbt shell or batch mode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-definition-basics"><a class="header" href="#build-definition-basics">Build definition basics</a></h1>
<p>This page discusses the <code>build.sbt</code> build definition.</p>
<h3 id="what-is-a-build-definition"><a class="header" href="#what-is-a-build-definition">What is a build definition?</a></h3>
<p>A <em>build definition</em> is defined in <code>build.sbt</code>, and it consists of a set of projects (of type <a href="guide/../api/sbt/Project.html"><code>Project</code></a>). Because the term <em>project</em> can be ambiguous, we often call it a <em>subproject</em> in this guide.</p>
<p>For instance, in <code>build.sbt</code> you define the subproject located in the current directory like this:</p>
<pre><code class="language-scala">scalaVersion := "3.3.3"
name := "Hello"
</code></pre>
<p>or more explicitly:</p>
<pre><code class="language-scala">lazy val root = (project in file("."))
  .settings(
    scalaVersion := "3.3.3",
    name := "Hello",
  )
</code></pre>
<p>Each subproject is configured by key-value pairs. For example, one key is <code>name</code> and it maps to a string value, the name of your subproject. The key-value pairs are listed under the <code>.settings(...)</code> method.</p>
<h2 id="buildsbt-dsl"><a class="header" href="#buildsbt-dsl">build.sbt DSL</a></h2>
<p><code>build.sbt</code> defines subprojects using a DSL called build.sbt DSL, which is based on Scala. Initially you can use build.sbt DSL, like a YAML file, declaring just <code>scalaVersion</code> and <code>libraryDependencies</code>, but it can supports more features to keep the build definition organized as the build grows larger.</p>
<h3 id="typed-setting-expression"><a class="header" href="#typed-setting-expression">Typed setting expression</a></h3>
<p>Let's take a closer look at the <code>build.sbt</code> DSL:</p>
<pre><code class="language-scala">organization  :=         "com.example"
^^^^^^^^^^^^  ^^^^^^^^   ^^^^^^^^^^^^^
key           operator   (setting/task) body
</code></pre>
<p>Each entry is called a <em>setting expression</em>. Some among them are also called task expressions. We will see more on the difference later in this page.</p>
<p>A setting expression consists of three parts:</p>
<ol>
<li>Left-hand side is a <em>key</em>.</li>
<li><em>Operator</em>, which in this case is <code>:=</code></li>
<li>Right-hand side is called the <em>body</em>, or the <em>setting/task body</em>.</li>
</ol>
<p>On the left-hand side, <code>name</code>, <code>version</code>, and <code>scalaVersion</code> are <em>keys</em>. A key is an instance of <a href="guide/../../api/sbt/SettingKey.html"><code>SettingKey[A]</code></a>, <a href="guide/../../api/sbt/TaskKey.html"><code>TaskKey[A]</code></a>, or <a href="guide/../../api/sbt/InputKey.html"><code>InputKey[A]</code></a> where <code>A</code> is the expected value type.</p>
<p>Because key <code>name</code> is typed to <code>SettingKey[String]</code>, the <code>:=</code> operator on <code>name</code> is also typed specifically to <code>String</code>. If you use the wrong value type, the build definition will not compile:</p>
<pre><code class="language-scala">name := 42 // will not compile
</code></pre>
<h3 id="vals-and-lazy-vals"><a class="header" href="#vals-and-lazy-vals"><code>val</code>s and <code>lazy val</code>s</a></h3>
<p>To avoid repeating the same information, like the version number for a library, <code>build.sbt</code> may be interspersed with <code>val</code>s, <code>lazy val</code>s, and <code>def</code>s.</p>
<pre><code class="language-scala">val toolkitV = "0.2.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV

scalaVersion := "3.7.3"
libraryDependencies += toolkit
libraryDependencies += (toolkitTest % Test)
</code></pre>
<p>In the above, <code>val</code> defines a variable, which are initialized from the top to bottom. This means that <code>toolkitV</code> must be defined before it is referenced.</p>
<p>Here's a bad example:</p>
<pre><code class="language-scala">// bad example
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV // uninitialized reference!
val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV // uninitialized reference!
val toolkitV = "0.2.0"
</code></pre>
<p>sbt will fail to load with <code>java.lang.ExceptionInInitializerError</code> cased by a <code>NullPointerException</code> if your build.sbt contains an uninitialized forward reference. One way to let the compiler fix this is to define the variables as <code>lazy</code>:</p>
<pre><code class="language-scala">lazy val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
lazy val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV
lazy val toolkitV = "0.2.0"
</code></pre>
<p>Some frown upon gratuitous <code>lazy val</code>s, but Scala 3 lazy vals are efficient, and we think it makes the build definition more robust for copy-pasting.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/build-definition-basics.html#admonition-note"></a>
</div>
<div>
<p>Top-level objects and classes are not allowed in <code>build.sbt</code>.
Those should go in the <code>project/</code> directory as Scala source files.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="library-dependency-basics"><a class="header" href="#library-dependency-basics">Library dependency basics</a></h1>
<p>This page explains the basics of library dependency management using sbt.</p>
<p>sbt uses <a href="https://get-coursier.io/">Coursier</a> to implement managed dependencies, so if you're familiar with package managers like Coursier, npm, PIP, etc you won't have much trouble.</p>
<div id="admonition-whats-a-managed-dependency" class="admonition admonish-note" role="note" aria-labelledby="admonition-whats-a-managed-dependency-title">
<div class="admonition-title">
<div id="admonition-whats-a-managed-dependency-title">
<p>What's a managed dependency?</p>
</div>
<a class="admonition-anchor-link" href="guide/library-dependency-basics.html#admonition-whats-a-managed-dependency"></a>
</div>
<div>
<p>As opposed to downloading required JAR files by hand (<em>unmanaged</em> dependencies), a <em>managed</em> dependency system automates fetching external libraries for a subproject. Tools like Coursier interpret the declared <code>ModuleID</code>, perform dependency resolution (expand all the transitive dependencies, and resolve any version conflicts to determine the exact versions), and download and cache the resulting artifacts, ensuring consistent JAR management.</p>
</div>
</div>
<h2 id="the-librarydependencies-key"><a class="header" href="#the-librarydependencies-key">The <code>libraryDependencies</code> key</a></h2>
<p>Declaring a dependency looks like this, where <code>groupId</code>, <code>artifactId</code>, and <code>revision</code> are strings:</p>
<pre><code class="language-scala">libraryDependencies += groupID % artifactID % revision
</code></pre>
<p>or like this, where <code>configuration</code> can be a string or a <code>Configuration</code> value (such as <code>Test</code>):</p>
<pre><code class="language-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre>
<p>When you run:</p>
<pre><code>&gt; compile
</code></pre>
<p>sbt will automatically resolve the dependencies and download the JAR files.</p>
<h3 id="getting-the-right-scala-version-with-"><a class="header" href="#getting-the-right-scala-version-with-">Getting the right Scala version with <code>%%</code></a></h3>
<p>If you use <code>organization %% moduleName % version</code> rather than <code>organization % moduleName % version</code> (the difference is the double <code>%%</code> after the <code>organization</code>), sbt will add your project's binary Scala version to the artifact name. This is just a shortcut. You could write this without the <code>%%</code>:</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-lang" % "toolkit_3" % "0.2.0"
</code></pre>
<p>Assuming the <code>scalaVersion</code> for your build is 3.x, the following is identical (note the double <code>%%</code> after <code>"org.scala-lang"</code>):</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-lang" %% "toolkit" % "0.2.0"
</code></pre>
<p>The idea is that many dependencies are compiled for multiple Scala versions, and you'd like to get the one that matches your project to ensure binary compatibility.</p>
<h2 id="tracking-dependencies-in-one-place"><a class="header" href="#tracking-dependencies-in-one-place">Tracking dependencies in one place</a></h2>
<p><code>.scala</code> files under <code>project</code> becomes part of the build definition, which we can use to track dependencies in one place by creating a file named <code>project/Dependencies.scala</code>.</p>
<pre><code class="language-scala">// place this file at project/Dependencies.scala

import sbt.*

object Dependencies:
  // versions
  lazy val toolkitV = "0.2.0"

  // libraries
  val toolkit = "org.scala-lang" %% "toolkit" % toolkitV
  val toolkitTest = "org.scala-lang" %% "toolkit-test" % toolkitV
end Dependencies
</code></pre>
<p>The <code>Dependencies</code> object will be available in <code>build.sbt</code>. To make it easier to use the <code>val</code>s defined in it, import <code>Dependencies.*</code> in your build.sbt file.</p>
<pre><code class="language-scala">import Dependencies.*

scalaVersion := "3.7.3"
name := "something"
libraryDependencies += toolkit
libraryDependencies += toolkitTest % Test
</code></pre>
<h2 id="viewing-library-dependencies"><a class="header" href="#viewing-library-dependencies">Viewing library dependencies</a></h2>
<p>Type in <code>Compile/dependencyTree</code> in the sbt shell to show the library dependency tree, including the transitive dependencies:</p>
<pre><code>&gt; Compile/dependencyTree
</code></pre>
<p>This should display something like the following:</p>
<pre><code>sbt:bar&gt; Compile/dependencyTree
[info] default:bar_3:0.1.0-SNAPSHOT
[info]   +-org.scala-lang:scala3-library_3:3.3.1 [S]
[info]   +-org.scala-lang:toolkit_3:0.2.0
[info]     +-com.lihaoyi:os-lib_3:0.9.1
[info]     | +-com.lihaoyi:geny_3:1.0.0
[info]     | | +-org.scala-lang:scala3-library_3:3.1.3 (evicted by: 3.3.1)
[info]     | | +-org.scala-lang:scala3-library_3:3.3.1 [S]
....
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-project-basics"><a class="header" href="#multi-project-basics">Multi project basics</a></h1>
<p>While a simple program can start out as a single-project build, it's more common for a build to split into smaller, multiple subprojects.</p>
<p>Each subproject in a build has its own source directories, generates its own JAR file when you run <code>packageBin</code>, and in general works like any other project.</p>
<p>A <strong>subproject</strong> is defined by declaring a <code>lazy val</code> of type <a href="guide/../../api/sbt/Project.html">Project</a>. For example, :</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
LocalRootProject / publish / skip := true

lazy val core = (project in file("core"))
  .settings(
    name := "core",
  )

lazy val util = (project in file("util"))
  .dependsOn(core)
  .settings(
    name := "util",
  )
</code></pre>
<p>The name of the <code>val</code> is used as the subproject's ID, which is used to refer to the subproject in the sbt shell.</p>
<p>sbt will always define a root project, so in the above build definition, we will have total of three subprojects.</p>
<h2 id="subproject-dependency"><a class="header" href="#subproject-dependency">Subproject dependency</a></h2>
<p>A subproject may depend on the code from another subproject. This is done by declaring <code>dependsOn(...)</code>. For example, if <code>util</code> needed <code>util</code> on its classpath, you would define <code>util</code> as:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .dependsOn(core)
</code></pre>
<h2 id="task-aggregation"><a class="header" href="#task-aggregation">Task aggregation</a></h2>
<p>Task aggregation means that running a task on the aggregate subproject will also run on the aggregated subprojects.</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val root = (project in file("."))
  .autoAggregate
  .settings(
    publish / skip := true
  )

lazy val util = (project in file("util"))

lazy val core = (project in file("core"))
</code></pre>
<p>In the above example, the root subproject aggregates <code>util</code> and <code>core</code>. When you type <code>compile</code> in the sbt shell, all tree subprojects are compiled in parallel.</p>
<h2 id="root-project"><a class="header" href="#root-project">Root project</a></h2>
<p>The subproject at the root of the build is called a <strong>root project</strong>, and often plays a special role in the build. If a subproject is not defined at the root directory of the build, sbt automatically creates a default one that aggregates all other subprojects in the build.</p>
<h2 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h2>
<p>In sbt 2.x, bare settings that are written directly in <code>build.sbt</code> without <code>settings(...)</code> are <strong>common settings</strong> that are injected to all subprojects.</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)
</code></pre>
<p>In the above, the <code>scalaVersion</code> setting is applied to the default root subproject, <code>core</code>, and <code>util</code>.</p>
<p>One exception to this rule is settings that are already scoped to a subproject.</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)

// This is applied only to app
app / name := "app1"
</code></pre>
<p>We can take advantage of this exception to add some settings that only apply to the default root project as follows:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val core = (project in file("core"))

lazy val app = (project in file("app"))
  .dependsOn(core)

// These are applied only to root
LocalRootProject / name := "root"
LocalRootProject / publish / skip := true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-basics"><a class="header" href="#plugin-basics">Plugin basics</a></h1>
<!--
Please read the earlier pages in the Getting Started Guide first, in
particular you need to understand [build.sbt][Basic-Def], [task graph][Task-Graph],
[library dependencies][Library-Dependencies], before reading this page.
-->
<h2 id="what-is-a-plugin"><a class="header" href="#what-is-a-plugin">What is a plugin?</a></h2>
<p>A plugin extends the build definition, most commonly by adding new settings and tasks. For example, a plugin could add <code>githubWorkflowGenerate</code> task to generate GitHub Actions YAML.</p>
<!--
For example, a plugin
could add a `codeCoverage` task which would generate a test coverage report.
-->
<h2 id="finding-the-plugin-versions-using-scaladex"><a class="header" href="#finding-the-plugin-versions-using-scaladex">Finding the plugin versions using Scaladex</a></h2>
<p>You can use <a href="https://index.scala-lang.org/search?platform=sbt2">Scaladex</a> to search for plugins, and find out the latest version of the plugin.</p>
<h2 id="declaring-a-plugin"><a class="header" href="#declaring-a-plugin">Declaring a plugin</a></h2>
<p>If your project is in directory <code>hello</code>, and if you are adding sbt-github-actions to the build definition, create <code>hello/project/plugins.sbt</code> and declare the plugin dependency by passing the plugin's module ID to <code>addSbtPlugin(...)</code>:</p>
<pre><code class="language-scala">// In project/plugins.sbt

addSbtPlugin("com.github.sbt" % "sbt-github-actions" % "0.28.0")
</code></pre>
<p>If you're adding sbt-assembly, add the following:</p>
<pre><code class="language-scala">// In project/plugins.sbt

addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "2.3.1")
</code></pre>
<p>See <a href="guide/../recipes/source-dependency-plugin.html">Source dependency plugin</a> recipe for an experimental technique of using plugins hosted on git repos.</p>
<p>Plugins usually provide settings and tasks that get added to a subproject to enable the plugin's functionality. This is described in the next section.</p>
<h2 id="enabling-and-disabling-auto-plugins"><a class="header" href="#enabling-and-disabling-auto-plugins">Enabling and disabling auto plugins</a></h2>
<p>A plugin can declare that its settings be automatically added to the build definition, in which case you don't have to do anything to add them.</p>
<p>The <!-- [auto plugins][Plugins] --> auto plugins feature enables plugins to automatically, and safely, ensure their settings and dependencies are on a project. Many auto plugins should have their default settings automatically.</p>
<p>If you're using an auto plugin that requires explicit enablement, then you have to add the following to your <code>build.sbt</code>:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .enablePlugins(FooPlugin, BarPlugin)
  .settings(
    name := "hello-util"
  )
</code></pre>
<p>The <code>enablePlugins</code> method allows projects to explicitly define the auto plugins they wish to consume.</p>
<p>Projects can also exclude plugins using the <code>disablePlugins</code> method. For example, if we wish to remove the <code>IvyPlugin</code> settings from <code>util</code>, we modify our <code>build.sbt</code> as follows:</p>
<pre><code class="language-scala">lazy val util = (project in file("util"))
  .enablePlugins(FooPlugin, BarPlugin)
  .disablePlugins(plugins.IvyPlugin)
  .settings(
    name := "hello-util"
  )
</code></pre>
<p>Auto plugins should document whether they need to be explicitly enabled. If you're curious which auto plugins are enabled for a given project, just run the <code>plugins</code> command on the sbt console.</p>
<pre><code class="language-scala">sbt:hello&gt; plugins
In build /tmp/hello/:
  Enabled plugins in hello:
    sbt.plugins.CorePlugin
    sbt.plugins.DependencyTreePlugin
    sbt.plugins.Giter8TemplatePlugin
    sbt.plugins.IvyPlugin
    sbt.plugins.JUnitXmlReportPlugin
    sbt.plugins.JvmPlugin
    sbt.plugins.SemanticdbPlugin
Plugins that are loaded to the build but not enabled in any subprojects:
  sbt.ScriptedPlugin
  sbt.plugins.SbtPlugin
</code></pre>
<p>Here, the <code>plugins</code> output is showing that the sbt default plugins are all enabled. sbt's default settings are provided via 7 plugins:</p>
<ol>
<li><code>CorePlugin</code>: Provides the core parallelism controls for tasks.</li>
<li><code>DependencyTreePlugin</code>: Provides dependency tree tasks.</li>
<li><code>Giter8TemplatePlugin</code>: Provides <code>sbt new</code> support.</li>
<li><code>IvyPlugin</code>: Provides the mechanisms to publish/resolve modules.</li>
<li><code>JUnitXmlReportPlugin</code>: Provides support for generating junit-xml.</li>
<li><code>JvmPlugin</code>: Provides the mechanisms to compile/test/run/package Java/Scala projects.</li>
<li><code>SemanticdbPlugin</code>: Provides support for generating SemanticDB.</li>
</ol>
<!--
### Global plugins

Plugins can be installed for all your projects at once by declaring them
in `$global_plugins_base$`. `$global_plugins_base$` is an sbt project whose
classpath is exported to all sbt build definition projects. Roughly
speaking, any `.sbt` or `.scala` files in `$global_plugins_base$` behave as if
they were in the `project/` directory for all projects.

You can create `$global_plugins_base$build.sbt` and put `addSbtPlugin()`
expressions in there to add plugins to all your projects at once.
Because doing so would increase the dependency on the machine environment,
this feature should be used sparingly. See
[Best Practices][global-vs-local-plugins].
-->
<h2 id="available-plugins"><a class="header" href="#available-plugins">Available plugins</a></h2>
<p>In addition to <a href="https://index.scala-lang.org/search?platform=sbt2">Scaladex</a>, there's also <a href="guide/../community-plugins.html">a list of available plugins</a>.</p>
<!--
For more details, including ways of developing plugins, see
[Plugins][Plugins].
For best practices, see
[Plugins-Best-Practices][Plugins-Best-Practices].
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-layout"><a class="header" href="#build-layout">Build layout</a></h1>
<p>sbt uses conventions for file placement to make it easy to dive into a new sbt build:</p>
<pre><code>.
├── build.sbt
├── project/
│   ├── build.properties
│   ├── Dependencies.scala
│   └── plugins.sbt
├── src/
│   ├── main/
│   │   ├── java/
│   │   ├── resources/
│   │   ├── scala/
│   │   └── scala-2.13/
│   └── test/
│       ├── java/
│       ├── resources/
│       ├── scala/
│       └── scala-2.13/
├── subproject-core/
│   └── src/
│       ├── main/
│       └── test/
├─── subproject-util/
│   └── src/
│       ├── main/
│       └── test/
└── target/
</code></pre>
<ul>
<li>The local root directory <code>.</code> is the starting point of your build.</li>
<li>In sbt's terminology, the <em>base directory</em> is the directory containing the subproject. In the above, <code>.</code>, <code>subproject-core</code>, and <code>subproject-util</code> are base directories.</li>
<li>The build definition is described in <code>build.sbt</code> (actually any files named <code>*.sbt</code>) in the local root directory.</li>
<li>The sbt version is tracked in <code>project/build.properties</code>.</li>
<li>Generated files (compiled classes, packaged jars, managed files, caches, and documentation) will be written to the <code>target</code> directory by default.</li>
</ul>
<h3 id="build-support-files"><a class="header" href="#build-support-files">Build support files</a></h3>
<p>In addition to <code>build.sbt</code>, <code>project</code> directory can contain <code>.scala</code> files that define helper objects and one-off plugins.</p>
<!--
See [organizing the build][Organizing-Build] for more.
-->
<pre><code>.
├── build.sbt
├── project/
│   ├── build.properties
│   ├── Dependencies.scala
│   └── plugins.sbt
....
</code></pre>
<p>You may see <code>.sbt</code> files inside <code>project/</code>, which is typically used to declare plugins. See <a href="guide/./plugin-basics.html">Plugin basics</a>.</p>
<h3 id="source-code"><a class="header" href="#source-code">Source code</a></h3>
<p>sbt uses the same directory structure as <a href="https://maven.apache.org/">Maven</a> for source files by default (all paths are relative to the base directory):</p>
<pre><code>....
├── src/
│   ├── main/
│   │   ├── java/        &lt;main Java sources&gt;
│   │   ├── resources/   &lt;files to include in main JAR&gt;
│   │   ├── scala/       &lt;main Scala sources&gt;
│   │   └── scala-2.13/  &lt;main Scala 2.13 specific sources&gt;
│   └── test/
│       ├── java/        &lt;test Java sources&gt;
│       ├── resources/   &lt;files to include in test JAR&gt;
│       ├── scala/       &lt;test Scala sources&gt;
│       └── scala-2.13/  &lt;test Scala 2.13 specific sources&gt;
....
</code></pre>
<p>Other directories in <code>src/</code> will be ignored. Additionally, all hidden directories will be ignored.</p>
<p>Source code can be placed in the project's base directory as <code>hello/app.scala</code>, which may be OK for small projects, though for normal projects people tend to keep the projects in the <code>src/main/</code> directory to keep things neat.</p>
<!--
The fact that you can place `*.scala` source code in the base directory might seem like
an odd trick, but this fact becomes relevant [later][Organizing-Build].
-->
<h3 id="configuring-version-control"><a class="header" href="#configuring-version-control">Configuring version control</a></h3>
<p>Your <code>.gitignore</code> (or equivalent for other version control systems) should contain:</p>
<pre><code>target/
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/build-layout.html#admonition-note"></a>
</div>
<div>
<p>Note that this deliberately has a trailing <code>/</code> (to match only directories)
and it deliberately has no leading <code>/</code> (to match <code>project/target/</code> in
addition to plain <code>target/</code>).</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-with-ides"><a class="header" href="#sbt-with-ides">sbt with IDEs</a></h1>
<p>While it's possible to code Scala with just an editor and sbt, most programmers today use an Integrated Development Environment, or IDE for short. Two of the popular IDEs in Scala are <a href="https://scalameta.org/metals/">Metals</a> and <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>, and they both integrate with sbt builds.</p>
<p>A few of the advantages of using the IDEs are:</p>
<ul>
<li>Jump to definition</li>
<li>Code completion based on static types</li>
<li>Listing compilation errors, and jumping to the error positions</li>
<li>Interactive debugging</li>
</ul>
<p>Here are a few recipes on how to configure the IDEs to integrate with sbt:</p>
<ul>
<li><a href="guide/../recipes/use-sbt-as-metals-build-server.html">Use sbt as Metals build server</a></li>
<li><a href="guide/../recipes/import-to-intellij.html">Import to IntelliJ IDEA</a></li>
<li><a href="guide/../recipes/use-neovim.html">Use Neovim</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changes"><a class="header" href="#changes">Changes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-20-changes-draft"><a class="header" href="#sbt-20-changes-draft">sbt 2.0 changes (draft)</a></h1>
<h2 id="changes-with-compatibility-implications"><a class="header" href="#changes-with-compatibility-implications">Changes with compatibility implications</a></h2>
<p>See also <a href="changes/./migrating-from-sbt-1.x.html">Migrating from sbt 1.x</a>.</p>
<ul>
<li><strong>Scala 3 in metabuild</strong>. sbt 2.x build.sbt DSL, used for build definitions and plugins, is based on Scala 3.x (currently <strong>3.7.3</strong>)  (Both sbt 1.x and 2.x are capable of building Scala 2.x and 3.x) by <a href="https://github.com/eed3si9n">@eed3si9n</a>, <a href="https://github.com/adpi2">@adpi2</a>, and others.</li>
<li><strong>Common settings</strong>. Bare settings are added to all subprojects, as opposed to just the root subproject, and thus replacing the role that <code>ThisBuild</code> has played.</li>
<li><strong>Incremental test</strong>. <code>test</code> task is changed to be incremental test that can cache test results. Use <code>testFull</code> for full test by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7686">#7686</a></li>
<li><strong>Cached task</strong>. All tasks are cached by default. Details in <a href="changes/../concepts/caching.html">Caching</a>.</li>
<li><strong>Depedency tree</strong>. <code>dependencyTree</code> tasks are unified to one input task by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8199">#8199</a></li>
<li><code>test</code> task type is changed from <code>Unit</code> to <code>TestResult</code> by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8181">#8181</a></li>
<li>Default settings and tasks keys typed to <code>URL</code> (i.e. <code>apiMappings</code>, <code>apiURL</code>, <code>homepage</code>, <code>organizationHomepage</code>, <code>releaseNotesURL</code>) were changed to <code>URI</code> in <a href="https://github.com/sbt/sbt/pull/7927">#7927</a>.</li>
<li><code>licenses</code> key is changed from <code>Seq[(String, URL)]</code> to <code>Seq[License]</code> in <a href="https://github.com/sbt/sbt/pull/7927">#7927</a>.</li>
<li>sbt 2.x plugins are published with <code>_sbt2_3</code> suffix by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7671">#7671</a></li>
<li>sbt 2.x adds <code>platform</code> setting so <code>ModuleID</code>'s <code>%%</code> operator can cross build on JVM as well as JS and Native, as opposed to <code>%%%</code> operator that was created in a plugin to workaround this issue, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/6746">#6746</a></li>
<li>Dropped <code>useCoursier</code> setting so Coursier cannot be opted out, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7712">#7712</a></li>
<li><code>Key.Classpath</code> is changed to be an alias of the <code>Seq[Attributed[xsbti.HashedVirtualFileRef]]</code> type, instead of <code>Seq[Attributed[File]]</code>. Similarly, some task keys that used to return <code>File</code> have changed to return <code>HashedVirtualFileRef</code> instead. See <a href="changes/../concepts/caching.html#caching-files">Caching Files</a>.</li>
<li>In sbt 2.x <code>target</code> defaults to <code>target/out/jvm/scala-3.7.3/&lt;subproject&gt;/</code>, as opposed to <code>&lt;subproject&gt;/target/</code>.</li>
<li>sbt 2.x auto reloads by default on <code>build.sbt</code> changes, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8211">#8211</a></li>
<li><code>Project#autoAggregate</code> is added for automatic aggregation, by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8290">#8290</a></li>
</ul>
<h3 id="dropped-dreprecations"><a class="header" href="#dropped-dreprecations">Dropped dreprecations</a></h3>
<ul>
<li>Removed <code>IntegrationTest</code> configuration in <a href="https://github.com/sbt/sbt/pull/8184">#8184</a></li>
<li>Removed sbt 0.13 style shell syntax in <a href="https://github.com/sbt/sbt/pull/7700">#7700</a></li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Project matrix</strong>. Project matrix, which was available via plugin in sbt 1.x, is in-sourced to provide parallel cross build support.</li>
<li><strong>sbt query</strong>. sbt 2.x extends the unified slash syntax to support query of subprojects. Details below.</li>
<li><strong>Local/remote cache system</strong>. Details below</li>
<li><strong>Client-side run</strong>. Details below.</li>
</ul>
<h3 id="common-settings-1"><a class="header" href="#common-settings-1">Common settings</a></h3>
<p>In sbt 2.x, the bare settings in <code>build.sbt</code> are interpreted to be common settings, and are injected to all subprojects. This means we can now set <code>scalaVersion</code> without using <code>ThisBuild</code> scoping:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<p>This also fixes the so-called dynamic dispatch problem:</p>
<pre><code class="language-scala">lazy val hi = taskKey[String]("")
hi := name.value + "!"
</code></pre>
<p>In sbt 1.x <code>hi</code> task will capture the name of the root project, but in sbt 2.x it will return the <code>name</code> of each subproject with <code>!</code>:</p>
<pre><code class="language-scala">$ sbt show hi
[info] entering *experimental* thin client - BEEP WHIRR
[info] terminate the server with `shutdown`
&gt; show hi
[info] foo / hi
[info]  foo!
[info] hi
[info]  root!
</code></pre>
<p>Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/6746">#6746</a></p>
<h3 id="sbt-query"><a class="header" href="#sbt-query">sbt query</a></h3>
<p>To filter down the subprojects, sbt 2.x introduces sbt query.</p>
<pre><code class="language-bash">$ sbt foo.../test
</code></pre>
<p>The above runs all subprojects that begins with <code>foo</code>.</p>
<pre><code class="language-bash">$ sbt ...@scalaBinaryVersion=3/test
</code></pre>
<p>The above runs all subprojects whose <code>scalaBinaryVersion</code> is <code>3</code>. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7699">#7699</a></p>
<h3 id="incremental-test"><a class="header" href="#incremental-test">Incremental test</a></h3>
<p>In sbt 2.x, <code>test</code> task became an input task that accept arguments that can filter the test suites to run:</p>
<pre><code class="language-bash">&gt; test *Example*
</code></pre>
<p>In addition, <code>test</code> is incremental and cached. This means, the test will not run unless it previously failed or something changed since the last run.</p>
<p>See <a href="changes/../reference/sbt-test.html">test</a> for details.</p>
<h3 id="localremote-cache-system"><a class="header" href="#localremote-cache-system">Local/remote cache system</a></h3>
<p>sbt 2.x implements cached task by default, which can automatically cache the task results to local disk and Bazel-compatible remote cache.</p>
<pre><code class="language-scala">lazy val task1 = taskKey[String]("doc for task1")

task1 := name.value + version.value + "!"
</code></pre>
<p>This tracks the inputs into the <code>task1</code> and creates a machine-wide disk cache, which can also be configured to also use a remote cache. Since it's common for sbt tasks to also produce files on the side, we also provide a mechanism to cache file contents:</p>
<pre><code class="language-scala">lazy val task1 = taskKey[String]("doc for task1")

task1 := {
  val converter = fileConverter.value
  ....
  val output = converter.toVirtualFile(somefile)
  Def.declareOutput(output)
  name.value + version.value + "!"
}
</code></pre>
<p>See <a href="changes/../concepts/caching.html">Caching</a> for details. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/7464">#7464</a> / <a href="https://github.com/sbt/sbt/pull/7525">#7525</a>.</p>
<h3 id="client-side-run"><a class="header" href="#client-side-run">Client-side run</a></h3>
<p>The sbt runner 1.10.10 and later script defaults to using sbtn (GraalVM native-image client) for sbt 2.x. In sbt 2.0, sbt server sends the <code>run</code> task back to sbtn, which will fork a fresh JVM. All you have to do is:</p>
<pre><code class="language-bash">sbt run
</code></pre>
<p>This avoids blocking the sbt server, and you can have multiple runs. Contributed by <a href="https://github.com/eed3si9n">@eed3si9n</a> in <a href="https://github.com/sbt/sbt/pull/8060">#8060</a>. See also <a href="changes/../reference/sbt-run.html">run</a> documentation.</p>
<h3 id="performance-improvements"><a class="header" href="#performance-improvements">Performance improvements</a></h3>
<p>Adrien Piquerez contributed a series of changes to improve performance while he was at Scala Center.</p>
<ul>
<li>perf: Reduces number of long-living instances to speed up startup by 20% relative to 2.0.0-M2 by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7866">#7866</a></li>
<li>perf: Reduces creation of <code>Setting</code> and <code>Initialize</code>  by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7880">#7880</a></li>
<li>perf: Refactors <code>Settings</code> and optimize indexing of aggregate keys by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7879">#7879</a></li>
<li>perf: Removes instances of <code>Info</code> and <code>BasicAttributeMap</code> by <a href="https://github.com/adpi2">@adpi2</a> in <a href="https://github.com/sbt/sbt/pull/7882">#7882</a></li>
</ul>
<h2 id="previously-on-sbt"><a class="header" href="#previously-on-sbt">Previously on sbt</a></h2>
<p>See also:</p>
<ul>
<li><a href="https://www.scala-sbt.org/1.x/docs/sbt-1.0-Release-Notes.html">sbt 1.0 changes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-sbt-1x"><a class="header" href="#migrating-from-sbt-1x">Migrating from sbt 1.x</a></h1>
<h2 id="changing-buildsbt-dsl-to-scala-3x"><a class="header" href="#changing-buildsbt-dsl-to-scala-3x">Changing <code>build.sbt</code> DSL to Scala 3.x</a></h2>
<p>As a reminder, users can build either Scala 2.x or Scala 3.x programs using either sbt 1.x or sbt 2.x. However, the Scala that underlies the <code>build.sbt</code> DSL is determined by the sbt version. In sbt 2.0, we are migrating to Scala 3.7.x.</p>
<p>This means that if you implement custom tasks or sbt plugins for sbt 2.x, it must be done using Scala 3.x. Consult <a href="https://docs.scala-lang.org/scala3/guides/migration/incompatibility-table.html">Scala 3.x incompatibility table</a> and <a href="https://docs.scala-lang.org/scala3/guides/migration/tooling-scala2-xsource3.html">Scala 2 with -Xsource:3</a> for details about Scala 3.x.</p>
<pre><code class="language-scala">// This works on Scala 2.12.20 under -Xsource:3
import sbt.{ given, * }
</code></pre>
<h3 id="import-given"><a class="header" href="#import-given">Import given</a></h3>
<p>One of the differences between Scala 2.x and 3.x is the way typeclass instances are imported into scope. In Scala 2.x <code>import FooCodec._</code> was used whereas Scala 3 uses <code>import FooCodec.given</code>. Writing:</p>
<pre><code class="language-scala">// The following works for both sbt 1.x and 2.x
import sbt.librarymanagement.LibraryManagementCodec.{ given, * }
</code></pre>
<h3 id="avoid-postfix"><a class="header" href="#avoid-postfix">Avoid postfix</a></h3>
<p>It wasn't uncommon for sbt 0.13 and 1.x examples to use postfix notations, especially with <code>ModuleID</code>:</p>
<pre><code class="language-scala">// BAD
libraryDependencies +=
  "com.github.sbt" % "junit-interface" % "0.13.2" withSources() withJavadoc()
</code></pre>
<p>The above will fail to load on sbt 2.x:</p>
<pre><code class="language-scala">-- Error: /private/tmp/foo/build.sbt:9:61 --------------------------------------
9 |  "com.github.sbt" % "junit-interface" % "0.13.2" withSources() withJavadoc()
  |                                                             ^^
  |can't supply unit value with infix notation because nullary method withSources
   in class ModuleIDExtra: (): sbt.librarymanagement.ModuleID takes no arguments;
   use dotted invocation instead: (...).withSources()
</code></pre>
<p>To fix this, use the normal (dotted) function call notation:</p>
<pre><code class="language-scala">// GOOD
libraryDependencies +=
  ("com.github.sbt" % "junit-interface" % "0.13.2").withSources().withJavadoc()
</code></pre>
<h2 id="bare-settings-changes"><a class="header" href="#bare-settings-changes">Bare settings changes</a></h2>
<pre><code class="language-scala">version := "0.1.0"
scalaVersion := "3.7.3"
</code></pre>
<p><em>Bare settings</em>, like the example above, are settings written directly in <code>build.sbt</code> without <code>settings(...)</code>.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="changes/migrating-from-sbt-1.x.html#admonition-warning"></a>
</div>
<div>
<p>In sbt 1.x bare settings were project settings that applied only to the root subproject. In sbt 2.x, the bare settings in <code>build.sbt</code> are common settings that are injected to <strong>all subprojects</strong>.</p>
</div>
</div>
<pre><code class="language-scala">name := "root"         // all subprojects will be named root!
publish / skip := true // all subprojects will be skipped!
</code></pre>
<p>To apply some settings to the root subproject only, either define it using multi-project build, or scope the setting under <code>LocalRootProject</code>:</p>
<pre><code class="language-scala">LocalRootProject / name := "root"
LocalRootProject / publish / skip := true
</code></pre>
<h3 id="migrating-thisbuild"><a class="header" href="#migrating-thisbuild">Migrating ThisBuild</a></h3>
<p>In sbt 2.x, bare settings settings should no longer be scoped to <code>ThisBuild</code>. One benefit of the new <em>common settings</em> over <code>ThisBuild</code> is that it would act in a more predictable delegation. These settings are inserted between plugins settings and those defined in <code>settings(...)</code>, meaning they can be used to define settings like <code>Compile / scalacOptions</code>, which was not possible with <code>ThisBuild</code>.</p>
<h2 id="migrating-to-cached-tasks"><a class="header" href="#migrating-to-cached-tasks">Migrating to cached tasks</a></h2>
<p>See <a href="changes/../reference/cached-task.html">Cached task</a> reference for details, including the way to opt out of caching.</p>
<h2 id="migration-away-from-integrationtest"><a class="header" href="#migration-away-from-integrationtest">Migration away from IntegrationTest</a></h2>
<p>To migrate away from the <code>IntegrationTest</code> configuration, create a separate subproject and implement it as normal test.</p>
<h2 id="migrating-to-slash-syntax"><a class="header" href="#migrating-to-slash-syntax">Migrating to slash syntax</a></h2>
<p>sbt 1.x supported both the sbt 0.13 style syntax and the slash syntax. sbt 2.x removes the support for the sbt 0.13 syntax, so use the slash syntax for both sbt shell and in <code>build.sbt</code>:</p>
<pre><code class="language-scala">&lt;project-id&gt; / Config / intask / key
</code></pre>
<p>For example, <code>test:compile</code> will no longer work on the shell. Use <code>Test/compile</code> instead. See <a href="https://eed3si9n.com/syntactic-scalafix-rule-for-unified-slash-syntax/">syntactic Scalafix rule for unified slash syntax</a> for semi-automated migration of <code>build.sbt</code> files.</p>
<pre><code class="language-bash">scalafix --rules=https://gist.githubusercontent.com/eed3si9n/57e83f5330592d968ce49f0d5030d4d5/raw/7f576f16a90e432baa49911c9a66204c354947bb/Sbt0_13BuildSyntax.scala *.sbt project/*.scala
</code></pre>
<h2 id="cross-building-sbt-plugins"><a class="header" href="#cross-building-sbt-plugins">Cross building sbt plugins</a></h2>
<p>In sbt 2.x, if you cross build an sbt plugin with Scala 3.x and 2.12.x, it will automatically cross build against sbt 1.x and sbt 2.x:</p>
<pre><code class="language-scala">// using sbt 2.x
lazy val plugin = (projectMatrix in file("plugin"))
  .enablePlugins(SbtPlugin)
  .settings(
    name := "sbt-vimquit",
  )
  .jvmPlatform(scalaVersions = Seq("3.6.2", "2.12.20"))
</code></pre>
<p>If you use <code>projectMatrix</code>, make sure to move the plugin to a subdirectory like <code>plugin/</code>. Otherwise, the synthetic root project will also pick up the <code>src/</code>.</p>
<h3 id="cross-building-sbt-plugin-with-sbt-1x"><a class="header" href="#cross-building-sbt-plugin-with-sbt-1x">Cross building sbt plugin with sbt 1.x</a></h3>
<p>Use sbt 1.10.2 or later, if you want to cross build using sbt 1.x.</p>
<pre><code class="language-scala">// using sbt 1.x
lazy val scala212 = "2.12.20"
lazy val scala3 = "3.6.2"
ThisBuild / crossScalaVersions := Seq(scala212, scala3)

lazy val plugin = (project in file("plugin"))
  .enablePlugins(SbtPlugin)
  .settings(
    name := "sbt-vimquit",
    (pluginCrossBuild / sbtVersion) := {
      scalaBinaryVersion.value match {
        case "2.12" =&gt; "1.5.8"
        case _      =&gt; "2.0.0-RC6"
      }
    },
  )
</code></pre>
<h2 id="changes-to-"><a class="header" href="#changes-to-">Changes to <code>%%</code></a></h2>
<p>In sbt 2.x, <code>ModuleID</code>'s <code>%%</code> operator has become platform-aware. For JVM subprojects, <code>%%</code> works as before, encoding Scala suffix (for example <code>_3</code>) on Maven repositories.</p>
<h3 id="migrating--operator"><a class="header" href="#migrating--operator">Migrating <code>%%%</code> operator</a></h3>
<p>When Scala.JS or Scala Native becomes available on sbt 2.x, <code>%%</code> will encode both the Scala version (such as <code>_3</code>) and the platform suffix (<code>_sjs1</code> etc). As a result, <code>%%%</code> can be replaced with <code>%%</code>:</p>
<pre><code class="language-scala">libraryDependencies += "org.scala-js" %% "scalajs-dom" % "2.8.0"
</code></pre>
<p>Use <code>.platform(Platform.jvm)</code> in case where JVM libraries are needed.</p>
<h2 id="changes-to-target"><a class="header" href="#changes-to-target">Changes to <code>target</code></a></h2>
<p>In sbt 2.x, the <code>target</code> directory is unified to be a single <code>target/</code> directory in the working directory, and each subproject creates a subdirectory encoding platform, Scala version, and the subproject id. To absorb this change in scripted tests, <code>exists</code>, <code>absent</code>, and <code>delete</code> now supports glob expression <code>**</code>, as well as <code>||</code>.</p>
<pre><code class="language-bash"># before
$ absent target/out/jvm/scala-3.3.1/clean-managed/src_managed/foo.txt
$ exists target/out/jvm/scala-3.3.1/clean-managed/src_managed/bar.txt

# after
$ absent target/**/src_managed/foo.txt
$ exists target/**/src_managed/bar.txt

# either is ok
$ exists target/**/proj/src_managed/bar.txt || proj/target/**/src_managed/bar.txt
</code></pre>
<h2 id="the-plugincompat-technique"><a class="header" href="#the-plugincompat-technique">The PluginCompat technique</a></h2>
<p>To use the same <code>*.scala</code> source but target both sbt 1.x and 2.x, we can create a shim, for example an object named <code>PluginCompat</code> in both <code>src/main/scala-2.12/</code> and <code>src/main/scala-3/</code>.</p>
<h3 id="migrating-classpath-type"><a class="header" href="#migrating-classpath-type">Migrating Classpath type</a></h3>
<p>sbt 2.x changed the <code>Classpath</code> type to be an alias of the <code>Seq[Attributed[xsbti.HashedVirtualFileRef]]</code> type. The following is a shim created to work with classpaths from both sbt 1.x and 2.x.</p>
<pre><code class="language-scala">// src/main/scala-3/PluginCompat.scala

package sbtfoo

import java.nio.file.{ Path =&gt; NioPath }
import sbt.*
import xsbti.{ FileConverter, HashedVirtualFileRef, VirtualFile }

private[sbtfoo] object PluginCompat:
  type FileRef = HashedVirtualFileRef
  type Out = VirtualFile

  def toNioPath(a: Attributed[HashedVirtualFileRef])(using conv: FileConverter): NioPath =
    conv.toPath(a.data)
  inline def toFile(a: Attributed[HashedVirtualFileRef])(using conv: FileConverter): File =
    toNioPath(a).toFile()
  def toNioPaths(cp: Seq[Attributed[HashedVirtualFileRef]])(using conv: FileConverter): Vector[NioPath] =
    cp.map(toNioPath).toVector
  inline def toFiles(cp: Seq[Attributed[HashedVirtualFileRef]])(using conv: FileConverter): Vector[File] =
    toNioPaths(cp).map(_.toFile())
end PluginCompat
</code></pre>
<p>and here's for sbt 1.x:</p>
<pre><code class="language-scala">// src/main/scala-2.12/PluginCompat.scala

package sbtfoo

import sbt.*

private[sbtfoo] object PluginCompat {
  type FileRef = java.io.File
  type Out = java.io.File

  def toNioPath(a: Attributed[File])(implicit conv: FileConverter): NioPath =
    a.data.toPath()
  def toFile(a: Attributed[File])(implicit conv: FileConverter): File =
    a.data
  def toNioPaths(cp: Seq[Attributed[File]])(implicit conv: FileConverter): Vector[NioPath] =
    cp.map(_.data.toPath()).toVector
  def toFiles(cp: Seq[Attributed[File]])(implicit conv: FileConverter): Vector[File] =
    cp.map(_.data).toVector

  // This adds `Def.uncached(...)`
  implicit class DefOp(singleton: Def.type) {
    def uncached[A1](a: A1): A1 = a
  }
}
</code></pre>
<p>Now we can import <code>PluginCompat.*</code> and use <code>toNioPaths(...)</code> etc to absorb the differences between sbt 1.x and 2.x. The above demonstrates how we can absorb the classpath type change, and convert it into a vector of NIO Paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command"><a class="header" href="#command">Command</a></h1>
<p>A <em>command</em> is a system-level building block of sbt, often used to capture user interaction or IDE interaction.</p>
<p><img src="concepts/../files/command.svg" style="width: 50%;"></img></p>
<p>We can think of each command as a <code>State =&gt; State</code> function. In sbt, the state represents the following:</p>
<ol>
<li>Build structure (<code>build.sbt</code> etc)</li>
<li>Your disk (source code, JAR outputs, etc)</li>
</ol>
<p>Thus, a command would typically modify either the build structure or the disk. For example, the <code>set</code> command can apply a setting to modify the build strcuture:</p>
<pre><code class="language-scala">&gt; set name := "foo"
</code></pre>
<p>The <code>act</code> command can lift a task such as <code>compile</code> into a command:</p>
<pre><code class="language-scala">&gt; compile
</code></pre>
<p>The compilation would read from the disk and write outputs, or display error messages on the screen.</p>
<h2 id="commands-are-sequentially-processed"><a class="header" href="#commands-are-sequentially-processed">Commands are sequentially processed</a></h2>
<p>Because there is only one state, a characteristic of commands is that they are executed one at a time.</p>
<p><img src="concepts/../files/command2.svg" alt="command" /></p>
<p>There are some execptions to this rule, but generally commands run sequentially. One mental image that might be useful is that a command is similar to a cashier taking an order in a cafe, and it will be processed in the sequence it was received.</p>
<h2 id="tasks-run-in-parallel"><a class="header" href="#tasks-run-in-parallel">Tasks run in parallel</a></h2>
<p>As mentioned above, the <code>act</code> command translates tasks into the command level. While doing so, the <code>act</code> command will broadcast the task across the aggregated subprojects and run independent tasks in parallel.</p>
<p>Similarly, the <code>reload</code> command that runs during the startup of a session will initialize the settings in parallel.</p>
<p><img src="concepts/../files/act.svg" alt="act" /></p>
<h2 id="the-role-of-sbt-server"><a class="header" href="#the-role-of-sbt-server">The role of sbt server</a></h2>
<p>sbt server is a service that accepts commands from either the command line or a network API called Build Server Protocol. This mechanism allows both the build user and IDEs to share the same sbt session.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-building"><a class="header" href="#cross-building">Cross building</a></h1>
<p><em>Cross building</em> refers to the idea of building multiple targets from the same set of source file. This includes Scala cross building, targeting multiple versions of Scala releases; platform cross building, targeting JVM, Scala.JS, and Scala Native; and custom virtual axes like Spark versions.</p>
<h2 id="using-the-cross-built-libraries"><a class="header" href="#using-the-cross-built-libraries">Using the cross-built libraries</a></h2>
<p>To use a library built against multiple versions of Scala, double the first <code>%</code> in a ModuleID to be <code>%%</code>. This tells sbt that it should append the Scala ABI (application binary interface) suffix to the dependency's name. For example:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" %% "cats-effect" % "3.5.4"
</code></pre>
<p>When the current Scala version is Scala 3.x, the above is equivalent to the following:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" % "cats-effect_3" % "3.5.4"
</code></pre>
<p>See <a href="concepts/../reference/cross-building-setup.html">cross building setup</a> for more details on the setup.</p>
<h2 id="historical-context"><a class="header" href="#historical-context">Historical context</a></h2>
<p>In the earlier years of Scala (pre-Scala 2.9), the Scala library did not maintain binary compatibility even at the patch level, so each time a new Scala version was released, the libraries had to be re-released against the new version of Scala. This meant that a library user needed to pick a specific version that was compatible with the Scala version they were using.</p>
<p>Even after Scala 2.9.x, the Scala library did not maintain the binary compatibility at minor version level, so the libraries compiled against Scala 2.10.x was not compatible with 2.11.x.</p>
<p>To workaround this problem, sbt developed cross building mechanism such that:</p>
<ul>
<li>Same set of source files can be compiled against multiple versions of Scala</li>
<li>Define a convention to append ABI version (e.g. <code>_2.12</code>) to the Maven artifact</li>
<li>Later this mechanism was extended to support Scala.JS and other platforms</li>
</ul>
<h2 id="project-matrix"><a class="header" href="#project-matrix">Project matrix</a></h2>
<p>sbt 2.x introduces project matrix, which enables cross building to happen in parallel.</p>
<pre><code class="language-scala">organization := "com.example"
scalaVersion := "3.7.3"
version      := "0.1.0-SNAPSHOT"

lazy val core = (projectMatrix in file("core"))
  .settings(
    name := "core"
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
<p>See <a href="concepts/../reference/cross-building-setup.html">cross building setup</a> for more details on the setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-query-1"><a class="header" href="#sbt-query-1">sbt query</a></h1>
<p>sbt 2.x extends the slash syntax to enable aggregation of subprojects:</p>
<p><em>act</em> <code>::=</code> [ <em>query</em> <code>/</code> ] [ <em>config</em> <code>/</code> ] [ <em>in-task</em> <code>/</code> ] ( <em>taskKey</em> | <em>settingKey</em> )</p>
<p>In other words, sbt query is a new way of writing the subproject-axis.</p>
<h3 id="subproject-reference"><a class="header" href="#subproject-reference">Subproject reference</a></h3>
<p>A subproject reference works as a query to select the subproject:</p>
<div id="admonition-buildsbt-example-1" class="admonition admonish-example" role="note" aria-labelledby="admonition-buildsbt-example-1-title">
<div class="admonition-title">
<div id="admonition-buildsbt-example-1-title">
<p>build.sbt example 1</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-buildsbt-example-1"></a>
</div>
<div>
<pre><code class="language-scala">scalaVersion := "3.7.3"

lazy val foo = project
</code></pre>
</div>
</div>
<p>Given the above build, we can run tests on <code>foo</code> subproject as follows, which is the same syntax as it was in sbt 1.x:</p>
<pre><code>foo/test
</code></pre>
<h3 id="-wildcard"><a class="header" href="#-wildcard"><code>...</code> wildcard</a></h3>
<p><code>...</code> wildcard matches to any characters, and can be combined with other letters and numbers to filter down the root aggregate list. For example, we can run tests on all subproject that starts with <code>foo</code> as follows:</p>
<pre><code>foo.../test
</code></pre>
<div id="admonition-note--vs-" class="admonition admonish-note" role="note" aria-labelledby="admonition-note--vs--title">
<div class="admonition-title">
<div id="admonition-note--vs--title">
<p>Note: * vs ...</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-note--vs-"></a>
</div>
<div>
<p>sbt query intentionally uses <code>...</code> (dot dot dot) instead of more intuitive <code>*</code> (asterisk) because <code>*</code> is often used in a shell as a wildcard to match existing files or directories. This would require quoting, and forgetting to quote <code>*/test</code> would match to something like <code>src/test</code>.</p>
</div>
</div>
<h3 id="scalabinaryversion-parameter"><a class="header" href="#scalabinaryversion-parameter"><code>@scalaBinaryVersion</code> parameter</a></h3>
<p><code>@scalaBinaryVersion</code> parameter matches to the subproject's <code>scalaBinaryVersion</code> setting.</p>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="concepts/sbt-query.html#admonition-example"></a>
</div>
<div>
<pre><code class="language-scala">val toolkitV = "0.5.0"
val toolkit = "org.scala-lang" %% "toolkit" % toolkitV

lazy val foo = projectMatrix
  .settings(
    libraryDependencies += toolkit,
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))

lazy val bar = projectMatrix
  .settings(
    libraryDependencies += toolkit,
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
</div>
</div>
<p>For example, we can run tests on all 3.x subprojects as follows:</p>
<pre><code>...@scalaBinaryVersion=3/test
</code></pre>
<p>This can be used from a terminal as follows:</p>
<pre><code class="language-bash">$ sbt ...@scalaBinaryVersion=3/test
[info] entering *experimental* thin client - BEEP WHIRR
[info] terminate the server with `shutdown`
&gt; ...@scalaBinaryVersion=3/test
[info] Passed: Total 0, Failed 0, Errors 0, Passed 0
[info] No tests to run for Test / testQuick
[info] compiling 1 Scala source to /tmp/foo/target/out/jvm/scala-3.6.4/foo/test-backend ...
[info] Passed: Total 0, Failed 0, Errors 0, Passed 0
[info] No tests to run for bar / Test / testQuick
example.ExampleSuite:
  + Scala version 0.003s
[info] Passed: Total 1, Failed 0, Errors 0, Passed 1
</code></pre>
<p>This lets us filter down the aggregated subprojects, which could be a lot using <code>projectMatrix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>sbt 2.0 introduces hybrid local/remote cache system, which can cache the task results to local disk and Bazel-compatible remote cache. Throughout sbt releases it has implemented various caches, like <code>update</code> cache, incremental compilation, but sbt 2.x's cache is a significant step change for a few reasons:</p>
<ol>
<li><strong>Automatic</strong>. sbt 2.x cache automates the caching by embedding itself into the task macro unlike sbt 1.x wherein the plugin author called the cache functions manually in the task implementation.</li>
<li><strong>Machine-wide</strong>. sbt 2.x disk cache is shared among all builds on a machine.</li>
<li><strong>Remote-ready</strong>. In sbt 2.x, the cache storage is configured separately such that all cacheable tasks are automatically remote-cache-ready.</li>
</ol>
<p>The overall objective of caching is to flatten the build and test time growth as the code size increases compared to the status quo. For this reason, speedup ratio would depend on the code size etc, but aiming for 5x to 20x is achievable for builds that currently takes 10+ minutes to test.</p>
<h2 id="basics-of-caching"><a class="header" href="#basics-of-caching">Basics of caching</a></h2>
<p>The basic idea is treat as if the build process is a pure function that takes input <code>(A1, A2, A3, ...)</code> and return some outputs <code>(R1, List(O1, O2, O3, ...))</code>. For example, we can take a list of source files, Scala version, and produce a <code>*.jar</code> file at the end. If the assumption holds, then for the same inputs, we can memorize the ouput JAR for everyone. We are interested in this technique because using the memorized output JAR would be faster than performing the actual task like Scala compilation etc.</p>
<h3 id="hermetic-build"><a class="header" href="#hermetic-build">Hermetic build</a></h3>
<p>As a mental model of the <em>build as a pure function</em>, build engineers sometimes use the term <em>hermetic build</em>, which is a build that takes place in a shipping container in a dessert with no clocks or the Internet. If we can produce a JAR file from that state, then the JAR file should be safe to be shared by any machine. Why did I mention the clock? It's because a JAR file could capture the timestamp, and thus produce slightly different JARs each time. To avoid this, hermetic build tools overwrite the timestamp to a fixed date 2010-01-01 regardless of when the build took place.</p>
<p>A build that ends up capturing ephemeral inputs, are said to <em>break the hermeticity</em> or <em>non-hermetic</em>. Another common way the hermeticity is broken is capturing absolute paths as either input or output. Sometimes the path gets embedded into the JAR via a macro, you might not know until you inspect the bytecode.</p>
<h2 id="automatic-caching"><a class="header" href="#automatic-caching">Automatic caching</a></h2>
<p>Here's a demonstration of the automatic caching:</p>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := name.value + version.value + "!"
</code></pre>
<p>In sbt 2.x, the task result will be cached based on the values of two settings <code>name</code> and <code>version</code>. The first time we run the task, it will be executed onsite, but it will use the disk cache from the second time onwards:</p>
<pre><code>sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 0%, 1 onsite task
sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
</code></pre>
<h3 id="caching-is-just-as-hard-as-serialization"><a class="header" href="#caching-is-just-as-hard-as-serialization">Caching is just as hard as serialization</a></h3>
<p>To participate in the automatic caching, the input keys (e.g. <code>name</code> and <code>version</code>) must provide a given　for <code>sjsonnew.HashWriter</code> typeclass and return type must provide a given for <code>sjsonnew.JsonFormat</code>. <a href="https://www.scala-sbt.org/contraband/">Contraband</a> can be used to generate sjson-new codecs.</p>
<h2 id="caching-files"><a class="header" href="#caching-files">Caching files</a></h2>
<p>Caching files (e.g. <code>java.io.File</code>) requires its own consideration, not because it's technically difficult, but mostly because of the ambiguity and assumptions when files are involved. When we say a "file" it could actually mean:</p>
<ol>
<li>Relative path from a well-known location</li>
<li>Materialized actual file</li>
<li>A unique proof of a file, or a content hash</li>
</ol>
<p>Technically speaking, a <code>File</code> just means the file path, so we can deserialize just the filename such as <code>target/a/b.jar</code>. This will fail the downstream tasks if they assumed that <code>target/a/b.jar</code> would exist in the file system. For clarity, and also for avoiding to capture absolute paths, sbt 2.x provides three separate types for the three cases.</p>
<ul>
<li><code>xsbti.VirtualFileRef</code> is used to mean just the relative path, which is equivalent to passing a string</li>
<li><code>xsbti.VirtualFile</code> represents a materialized file with contents, which could be a virtual file or a file in your disk</li>
</ul>
<p>However, for the purpose of hermetic build, neither is great to represent a list of files. Having just the filename alone doesn't guarantee that the file will be the same, and carrying the entire content of the files is too inefficient in a JSON etc.</p>
<p>This is where the mysterious third option, a unique proof of file comes in handy. In addition to the relative path, <code>HashedVirtualFileRef</code> tracks the SHA-256 content hash and the file size. This can easily be serialized to JSON yet we can reference the exact file.</p>
<h3 id="the-effect-of-file"><a class="header" href="#the-effect-of-file">The effect of file</a></h3>
<p>There are many tasks that generate file that do not use <code>VirtualFile</code> as the return type. For example, <code>compile</code> returns <code>Analysis</code> instead, and <code>*.class</code> file generation happens as a <em>side effect</em> in sbt 1.x.</p>
<p>To participate in caching, we need to declare these effects as something we care about.</p>
<pre><code class="language-scala">someKey := {
  val conv = fileConverter.value
  val out: java.nio.file.Path = createFile(...)
  val vf: xsbti.VirtualFile = conv.toVirtualFile(out)
  Def.declareOutput(vf)
  vf: xsbti.HashedVirtualFileRef
}
</code></pre>
<h2 id="remote-caching"><a class="header" href="#remote-caching">Remote caching</a></h2>
<p>You can optionally extend the build to use remote cache in addition to the local disk cache. Remote caching could improve build performance by allowing multiple machines to share build artifacts and outputs.</p>
<p>Imagine you have a dozen people in your project or a company. Each morning, you will <code>git pull</code> the changes the dozen people made, and you need to build their code. If you have a successful project, the code size will only get bigger over time, and the % of the time you spend building someone else's in your day increases. This becomes the limiting factor of your team size and code size. Remote caching reverses this tide by CI systems hydrate the cache and you can download the artifacts and task outputs.</p>
<p>sbt 2.x implements Bazel-compatible gRPC interface, which works with number of backend both open source and commercial. See <a href="concepts/../reference/remote-cache-setup.html">Remote cache setup</a> for more details.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>See also <a href="concepts/../reference/cached-task.html">Cached task</a> reference guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-1"><a class="header" href="#reference-1">Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-1"><a class="header" href="#sbt-1">sbt</a></h1>
<p>See <a href="reference/../guide/basic-tasks.html">Basic Tasks</a> in the Getting Started Guide for an intro to the basics.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<p><code>sbt</code><br> <code>sbt</code> <em>command</em> <em>args</em><br> <code>sbt --server</code><br> <code>sbt --script-version</code></p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>sbt is a simple build tool created originally for Scala and Java. It lets us declare subprojects and their various dependencies and custom tasks to ensure that we'll always get a fast, repeatable build.</p>
<h3 id="sbt-runner-and-sbt-server"><a class="header" href="#sbt-runner-and-sbt-server">sbt runner and sbt server</a></h3>
<ul>
<li>sbt runner is a system shell script named <code>sbt</code>, or <code>sbt.bat</code> on Windows. That is capable of running <em>any version of sbt</em>. This is sometimes called "sbt-the-shell-script".
<ul>
<li>When sbt 2.x is detected, sbt runner executes in a client mode, typically using sbtn, a GraalVM native implementation of the thin client program.</li>
<li>sbt runner also executes sbt launcher, a launcher that is capable of running <em>any verions of sbt</em>.</li>
<li>When you install sbt from a installer, what you're installing is the sbt runner.</li>
</ul>
</li>
<li>sbt server is sbt's main artifact, and the actual build tool.
<ul>
<li>The sbt version is determined by <code>project/build.properties</code> in each working directory.</li>
<li>sbt server accepts commands from sbtn, network API, or via its own sbt shell.</li>
</ul>
</li>
</ul>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
<p>This mechanism allows builds to be configured to a specific version of sbt, and everyone working on the project would use the same build semantics, regardless of the sbt runner installed on their machine.</p>
<p>This also means that some features are implemented at sbt runner or sbtn level, while other features are implemented at sbt server level.</p>
<h2 id="sbt-commands"><a class="header" href="#sbt-commands">sbt commands</a></h2>
<div id="admonition-note-on-commands" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-on-commands-title">
<div class="admonition-title">
<div id="admonition-note-on-commands-title">
<p>Note on commands</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt.html#admonition-note-on-commands"></a>
</div>
<div>
<p>In sbt, there are <em>tasks</em> that operate at the subproject level (like <code>compile</code>), and <em>commands</em> in the narrow sense (like <code>set</code>), which is capable of manipulating the build definition itself.</p>
<p>Given that settings and tasks are lifted into the <code>act</code> command, we can consider <em>all things that can be typed into the sbt shell</em> as commands in the wide sense.
See the <a href="reference/../concepts/command.html">Command</a> concept page for details.</p>
</div>
</div>
<!--
-   Some tasks produce useful values. The `toString` representation of
    these values can be shown using `show <task>` to run the task
    instead of just `<task>`.
-   In a multi-project build, execution dependencies and the aggregate
    setting control which tasks from which projects are executed. See
    [multi-project builds][Multi-Project].
-->
<h3 id="subproject-level-tasks"><a class="header" href="#subproject-level-tasks">Subproject-level tasks</a></h3>
<ul>
<li><code>clean</code> Deletes all generated files (the <code>target</code> directory).</li>
<li><a href="reference/./sbt-publish.html"><code>publish</code></a> Publishes artifacts (such as JARs) to the repository defined by the <code>publishTo</code> setting.</li>
<li><a href="reference/./sbt-publish.html"><code>publishLocal</code></a> Publishes artifacts (such as JARs) to the local Ivy repository as described in Publishing.</li>
<li><a href="reference/./sbt-update.html"><code>update</code></a> Resolves and retrieves external dependencies.</li>
</ul>
<h3 id="configuration-level-tasks"><a class="header" href="#configuration-level-tasks">Configuration-level tasks</a></h3>
<p>Configuration-level tasks are tasks associated with a configuration. For example, <code>compile</code>, which is equivalent to <code>Compile/compile</code>, compiles the main source code (the <code>Compile</code> configuration). <code>Test/compile</code> compiles the test source code (the <code>Test</code> configuration). Most tasks for the <code>Compile</code> configuration have an equivalent in the <code>Test</code> configuration that can be run using a <code>Test/</code> prefix.</p>
<ul>
<li>
<p><a href="reference/./sbt-compile.html"><code>compile</code></a> Compiles the main sources (in the <code>src/main/scala</code> directory). <code>Test/compile</code> compiles test sources (in the src/test/scala/ directory).</p>
</li>
<li>
<p><code>console</code> Starts the Scala interpreter with a classpath including the compiled sources, all JARs in the lib directory, and managed libraries. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows). Similarly, Test/console starts the interpreter with the test classes and classpath.</p>
</li>
<li>
<p><code>doc</code> Generates API documentation for Scala source files in <code>src/main/scala</code> using scaladoc. <code>Test/doc</code> generates API documentation for source files in <code>src/test/scala</code>.</p>
</li>
<li>
<p><code>package</code> Creates a JAR file containing the files in <code>src/main/resources</code> and the classes compiled from <code>src/main/scala</code>. <code>Test/package</code> creates a JAR containing the files in <code>src/test/resources</code> and the class compiled from <code>src/test/scala</code>.</p>
</li>
<li>
<p><code>packageDoc</code> Creates a JAR file containing API documentation generated from Scala source files in src/main/scala. Test/packageDoc creates a JAR containing API documentation for test sources files in src/test/scala.</p>
</li>
<li>
<p><code>packageSrc</code>: Creates a JAR file containing all main source files and resources. The packaged paths are relative to src/main/scala and src/main/resources. Similarly, Test/packageSrc operates on test source files and resources.</p>
</li>
<li>
<p><a href="reference/./sbt-run.html"><code>run &lt;argument&gt;*</code></a> Runs the main class for the project in the same virtual machine as sbt. The main class is passed the arguments provided.</p>
</li>
<li>
<p><code>runMain &lt;main-class&gt; &lt;argument&gt;*</code> Runs the specified main class for the project in the same virtual machine as sbt. The main class is passed the arguments provided.<!-- See
  [Running Project Code][Running-Project-Code] for
  details on the use of System.exit and multithreading (including
  GUIs) in code run by this action. `Test/runMain` runs the specified
  main class in the test code. --></p>
</li>
<li>
<p><a href="reference/./sbt-tes.html"><code>test &lt;test&gt;*</code></a> Runs the tests specified as arguments (or all tests if no arguments are given) that:</p>
<ol>
<li>have not been run yet OR</li>
<li>failed the last time they were run OR</li>
<li>had any transitive dependencies recompiled since the last successful run<br> <code>*</code> is interpreted as a wildcard in the test name.</li>
</ol>
</li>
<li>
<p><a href="reference/./sbt-test.html"><code>testFull</code></a> Runs all tests detected during test compilation.</p>
</li>
</ul>
<!--
-   [`testOnly <test>*`](./sbt-test.md) Runs the tests provided as arguments.

-   `consoleQuick` Starts the Scala interpreter with the project's
    compile-time dependencies on the classpath. Test/consoleQuick uses
    the test dependencies. This task differs from console in that it
    does not force compilation of the current project's sources.
-   `consoleProject` Enters an interactive session with sbt and the
    build definition on the classpath. The build definition and related
    values are bound to variables and common packages and values are
    imported. See the [consoleProject documentation][Console-Project]
    for more information.
-->
<h3 id="general-commands"><a class="header" href="#general-commands">General commands</a></h3>
<ul>
<li><code>shutdown</code> Shuts down the sbt server to end the current sbt session.</li>
<li><code>exit</code> or <code>quit</code> End the current interactive session or build. Additionally, Ctrl+D (Unix) or Ctrl+Z (Windows) will exit the interactive prompt.</li>
<li><code>help &lt;command&gt;</code> Displays detailed help for the specified command. If the command does not exist, help lists detailed help for commands whose name or description match the argument, which is interpreted as a regular expression. If no command is provided, displays brief descriptions of the main commands. Related commands are tasks and settings.</li>
<li><code>projects [add|remove &lt;URI&gt;]</code> List all available projects if no arguments provided or adds/removes the build at the provided URI.<!-- (See [multi-project builds][Multi-Project] for details on multi-project
  builds.) --></li>
</ul>
<!--
-   `project <project-id>` Change the current project to the project
    with ID `<project-id>`. Further operations will be done in the
    context of the given project.
    (See [multi-project builds][Multi-Project] for
    details on multiple project builds.)
-->
<ul>
<li>
<p><a href="reference/./watch.html">Watch command</a> <code>~ &lt;command&gt;</code> Executes the project specified action or method whenever source files change.</p>
</li>
<li>
<p><code>&lt; filename</code> Executes the commands in the given file. Each command should be on its own line. Empty lines and lines beginning with '#' are ignored</p>
</li>
<li>
<p><code>A ; B</code> Execute A and if it succeeds, run B. Note that the leading semicolon is required.</p>
</li>
<li>
<p><code>eval &lt;Scala-expression&gt;</code> Evaluates the given Scala expression and returns the result and inferred type. This can be used to set system properties, as a calculator, to fork processes, etc ... For example:</p>
<pre><code>&gt; eval System.setProperty("demo", "true")
&gt; eval 1+1
&gt; eval "ls -l" !
</code></pre>
</li>
</ul>
<!--
-   `+ <command>` Executes the project specified action or method for
    all versions of Scala defined in the crossScalaVersions setting.
-   `++ <version|home-directory> <command>` Temporarily changes the
    version of Scala building the project and executes the provided
    command. `<command>` is optional. The specified version of Scala is
    used until the project is reloaded, settings are modified (such as
    by the set or session commands), or ++ is run again. `<version>`
    does not need to be listed in the build definition, but it must be
    available in a repository. Alternatively, specify the path to a
    Scala installation.
-->
<h3 id="commands-for-managing-the-build-definition"><a class="header" href="#commands-for-managing-the-build-definition">Commands for managing the build definition</a></h3>
<ul>
<li>
<p><code>reload [plugins|return]</code> If no argument is specified, reloads the build, recompiling any build or plugin definitions as necessary. reload plugins changes the current project to the build definition project (in <code>project/</code>). This can be useful to directly manipulate the build definition. For example, running clean on the build definition project will force snapshots to be updated and the build definition to be recompiled. reload return changes back to the main project.</p>
</li>
<li>
<p><code>set &lt;setting-expression&gt;</code> Evaluates and applies the given setting definition. The setting applies until sbt is restarted, the build is reloaded, or the setting is overridden by another set command or removed by the session command.<!-- See [.sbt build definition][Basic-Def] and
  [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
<li>
<p><code>session &lt;command&gt;</code> Manages session settings defined by the <code>set</code> command. It can persist settings configured at the prompt.<!-- See [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
<li>
<p><code>inspect &lt;setting-key&gt;</code> Displays information about settings, such as the value, description, defining scope, dependencies, delegation chain, and related settings.<!-- See [Inspecting Settings][Inspecting-Settings] for details. --></p>
</li>
</ul>
<h2 id="sbt-runner-and-launcher"><a class="header" href="#sbt-runner-and-launcher">sbt runner and launcher</a></h2>
<p>When launching the <code>sbt</code> runner from the system shell, various system properties or JVM extra options can be specified to influence its behaviour.</p>
<h3 id="sbt-jvm-options-and-system-properties"><a class="header" href="#sbt-jvm-options-and-system-properties">sbt JVM options and system properties</a></h3>
<p>If the <code>JAVA_OPTS</code> and/or <code>SBT_OPTS</code> environment variables are defined when <code>sbt</code> starts, their content is passed as command line arguments to the JVM running sbt server.</p>
<p>If a file named <code>.jvmopts</code> exists in the  current directory, its content is appended to <code>JAVA_OPTS</code> at sbt startup. Similarly, if <code>.sbtopts</code> and/or <code>/etc/sbt/sbtopts</code> exist, their content is appended to <code>SBT_OPTS</code>. The default value of <code>JAVA_OPTS</code> is <code>-Dfile.encoding=UTF8</code>.</p>
<p>You can also specify JVM system properties and command line options directly as <code>sbt</code> arguments: any <code>-Dkey=val</code> argument will be passed as-is to the JVM, and any <code>-J-Xfoo</code> will be passed as <code>-Xfoo</code>.</p>
<p>See also <code>sbt --help</code> for more details.</p>
<h3 id="sbt-jvm-heap-permgen-and-stack-sizes"><a class="header" href="#sbt-jvm-heap-permgen-and-stack-sizes">sbt JVM heap, permgen, and stack sizes</a></h3>
<p>If you find yourself running out of permgen space or your workstation is low on memory, adjust the JVM configuration as you would for any java application.</p>
<p>For example a common set of memory-related options is:</p>
<pre><code class="language-bash">export SBT_OPTS="-Xmx2048M -Xss2M"
sbt
</code></pre>
<p>Or if you prefer to specify them just for this session:</p>
<pre><code class="language-bash">sbt -J-Xmx2048M -J-Xss2M
</code></pre>
<h3 id="boot-directory"><a class="header" href="#boot-directory">Boot directory</a></h3>
<p><code>sbt</code> runner is just a bootstrap, the actual sbt server, Scala compiler and standard library are by default downloaded to the shared directory  <code>\$HOME/.sbt/boot/</code>.</p>
<p>To change the location of this directory, set the <code>sbt.boot.directory</code> system property. A relative path will be resolved against the current working directory, which can be useful if you want to avoid sharing the boot directory between projects. For example, the following uses the pre-0.11 style of putting the boot directory in <code>project/boot/</code>:</p>
<pre><code class="language-bash">sbt -Dsbt.boot.directory=project/boot/
</code></pre>
<h3 id="terminal-encoding"><a class="header" href="#terminal-encoding">Terminal encoding</a></h3>
<p>The character encoding used by your terminal may differ from Java's default encoding for your platform. In this case, you will need to specify the <code>file.encoding=&lt;encoding&gt;</code> system property, which might look like:</p>
<pre><code class="language-bash">export JAVA_OPTS="-Dfile.encoding=Cp1252"
sbt
</code></pre>
<h3 id="httphttpsftp-proxy"><a class="header" href="#httphttpsftp-proxy">HTTP/HTTPS/FTP Proxy</a></h3>
<p>On Unix, sbt will pick up any HTTP, HTTPS, or FTP proxy settings from the standard <code>http_proxy</code>, <code>https_proxy</code>, and <code>ftp_proxy</code> environment variables. If you are behind a proxy requiring authentication, you need to pass some supplementary flags at sbt startup. See <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/doc-files/net-properties.html">JVM networking system properties</a> for more details.</p>
<p>For example:</p>
<pre><code class="language-bash">sbt -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre>
<p>On Windows, your script should set properties for proxy host, port, and if applicable, username and password. For example, for HTTP:</p>
<pre><code class="language-bash">sbt -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre>
<p>Replace <code>http</code> with <code>https</code> or <code>ftp</code> in the above command line to configure HTTPS or FTP.</p>
<h3 id="other-system-properties"><a class="header" href="#other-system-properties">Other system properties</a></h3>
<p>The following system properties can also be passed to <code>sbt</code> runner:</p>
<h4 id="-dsbtbannertrue"><a class="header" href="#-dsbtbannertrue"><code>-Dsbt.banner=true</code></a></h4>
<p>Show a welcome banner advertising new features.</p>
<h4 id="-dsbtcitrue"><a class="header" href="#-dsbtcitrue"><code>-Dsbt.ci=true</code></a></h4>
<p>Default <code>false</code> (unless then env var <code>BUILD_NUMBER</code> is set). For continuous integration environments. Suppress supershell and color.</p>
<h4 id="-dsbtclienttrue"><a class="header" href="#-dsbtclienttrue"><code>-Dsbt.client=true</code></a></h4>
<p>Run the sbt client.</p>
<h4 id="-dsbtcolorauto"><a class="header" href="#-dsbtcolorauto"><code>-Dsbt.color=auto</code></a></h4>
<ul>
<li>To turn on color, use <code>always</code> or <code>true</code>.</li>
<li>To turn off color, use <code>never</code> or <code>false</code>.</li>
<li>To use color if the output is a terminal (not a pipe) that supports color, use <code>auto</code>.</li>
</ul>
<h4 id="-dsbtcoursierhomehomecachecoursierv1"><a class="header" href="#-dsbtcoursierhomehomecachecoursierv1"><code>-Dsbt.coursier.home=$HOME/.cache/coursier/v1</code></a></h4>
<p>Location of the Coursier artifact cache, where the default is defined by <a href="https://get-coursier.io/docs/cache.html#default-location">Coursier cache resolution logic</a>. You can verify the value with the command <code>csrCacheDirectory</code>.</p>
<h4 id="-dsbtgenbuildpropstrue"><a class="header" href="#-dsbtgenbuildpropstrue"><code>-Dsbt.genbuildprops=true</code></a></h4>
<p>Generate <code>build.properties</code> if missing. If unset, this defers to <code>sbt.skip.version.write</code>.</p>
<h4 id="-dsbtglobalbasehomesbt"><a class="header" href="#-dsbtglobalbasehomesbt"><code>-Dsbt.global.base=$HOME/.sbt/</code></a></h4>
<p>The directory containing global settings and plugins.</p>
<h4 id="-dsbtoverridebuildrepostrue"><a class="header" href="#-dsbtoverridebuildrepostrue"><code>-Dsbt.override.build.repos=true</code></a></h4>
<p>If true, repositories configured in a build definition are ignored and the repositories configured for the launcher are used instead.</p>
<!-- See <tt>sbt.repository.config</tt> and the <a href="reference/Launcher-Configuration.html">sbt launcher</a> documentation. -->
<h4 id="-dsbtrepositoryconfighomesbtrepositories"><a class="header" href="#-dsbtrepositoryconfighomesbtrepositories"><code>-Dsbt.repository.config=$HOME/.sbt/repositories</code></a></h4>
<p>A file containing the repositories to use for the launcher. The format is the same as a <code>[repositories]</code> section for a sbt launcher configuration file. This setting is typically used in conjunction with setting <code>sbt.override.build.repos</code> to <code>true</code>.</p>
<!-- (see <tt>sbt.override.build.repos</tt> and the <a href="reference/Launcher-Configuration.html">sbt launcher</a> documentation).</td> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-update"><a class="header" href="#sbt-update">sbt update</a></h1>
<p>See <a href="reference/../guide/library-dependency-basics.html">library depdency basics</a> in the Getting Started guide to learn about the basics.</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>update</code></p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>sbt uses <a href="https://get-coursier.io/">Coursier</a> to implement library management, also known as a package manager in other ecosystems. The general idea of library management is that you can specify external libraries you would like to use in your subprojects, and the library management system would:</p>
<ul>
<li>Check if such versions exists in the listed repositories</li>
<li>Look for the transitive dependencies (i.e. the libraries used by the libraries)</li>
<li>Attempt to resolve version conflicts, if any</li>
<li>Download the artifacts, such as JAR files, from the repositories</li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Declaring a dependency looks like:</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre>
<p>or</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision % configuration
</code></pre>
<!--
See [configurations](#ivy-configurations) for details on configuration
mappings.
-->
<p>Also, several dependencies can be declared together:</p>
<pre><code class="language-scala">libraryDependencies ++= Seq(
  groupID %% artifactID % revision,
  groupID %% otherID % otherRevision
)
</code></pre>
<p>If you are using a dependency that was built with sbt, double the first <code>%</code> to be <code>%%</code>:</p>
<pre><code class="language-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre>
<p>This will use the right JAR for the dependency built with the version of Scala that you are currently using. If you get an error while resolving this kind of dependency, that dependency probably wasn't published for the version of Scala you are using. See <a href="reference/../concepts/cross-building.html">Cross building</a> for details.</p>
<!--
Ivy can select the latest revision of a module according to constraints
you specify. Instead of a fixed revision like `"1.6.1"`, you specify
`"latest.integration"`, `"2.9.+"`, or `"[1.0,)"`. See the
[Ivy revisions](https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision)
documentation for details.
-->
<h3 id="versionscheme-and-eviction-errors"><a class="header" href="#versionscheme-and-eviction-errors"><code>versionScheme</code> and eviction errors</a></h3>
<p>sbt allows library authors to declare the version semantics using the <code>versionScheme</code> setting:</p>
<pre><code class="language-scala">// Semantic Versioning applied to 0.x, as well as 1.x, 2.x, etc
versionScheme := Some(VersionScheme.EarlySemVer)
</code></pre>
<p>When Coursier finds multiple versions of a library, for example Cats Effect 2.x and Cats Effect 3.0.0-M4, it often resolves the conflict by removing the older version from the graph. This process is colloquially called eviction, like "Cats Effect 2.2.0 was evicted."</p>
<p>This would work if the new tenant is binary compatible with Cats Effect 2.2.0. In this case, the library authors have declared that they are <em>not</em> binary compatible, so the eviction was actually unsafe. An unsafe eviction would cause runtime issues such as <code>ClassNotFoundException</code>. Instead Coursier should've failed to resolve.</p>
<pre><code class="language-scala">lazy val use = project
  .settings(
    name := "use",
    libraryDependencies ++= Seq(
      "org.http4s" %% "http4s-blaze-server" % "0.21.11",
      "org.typelevel" %% "cats-effect" % "3.0.0-M4",
    ),
  )
</code></pre>
<p>sbt performs this secondary compatibility check after Coursier returns a candidate:</p>
<pre><code>[error] stack trace is suppressed; run last use / update for the full output
[error] (use / update) found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
[error]
[error]   * org.typelevel:cats-effect_2.12:3.0.0-M4 (early-semver) is selected over {2.2.0, 2.0.0, 2.0.0, 2.2.0}
[error]       +- use:use_2.12:0.1.0-SNAPSHOT                        (depends on 3.0.0-M4)
[error]       +- org.http4s:http4s-core_2.12:0.21.11                (depends on 2.2.0)
[error]       +- io.chrisdavenport:vault_2.12:2.0.0                 (depends on 2.0.0)
[error]       +- io.chrisdavenport:unique_2.12:2.0.0                (depends on 2.0.0)
[error]       +- co.fs2:fs2-core_2.12:2.4.5                         (depends on 2.2.0)
[error]
[error]
[error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
</code></pre>
<p>This mechanism is called the <em>eviction error</em>.</p>
<h4 id="opting-out-of-the-the-eviction-error"><a class="header" href="#opting-out-of-the-the-eviction-error">Opting out of the the eviction error</a></h4>
<p>If the library authors have declared the compatibility breakage, but if you want to ignore the strict check (often for <code>scala-xml</code>), you can write this in <code>project/plugins.sbt</code> and <code>build.sbt</code>:</p>
<pre><code class="language-scala">libraryDependencySchemes += "org.scala-lang.modules" %% "scala-xml" % VersionScheme.Always
</code></pre>
<p>To ignore all eviction errors:</p>
<pre><code class="language-scala">evictionErrorLevel := Level.Info
</code></pre>
<h3 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h3>
<p>sbt uses the standard Maven Central repository by default. Declare additional repositories with the form:</p>
<pre><code class="language-scala">resolvers += name at location
</code></pre>
<p>For example:</p>
<pre><code class="language-scala">libraryDependencies ++= Seq(
    "org.apache.derby" % "derby" % "10.4.1.3",
    "org.specs" % "specs" % "1.6.1"
)

resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
</code></pre>
<p>sbt can search your local Maven repository if you add it as a repository:</p>
<pre><code class="language-scala">resolvers += Resolver.mavenLocal
</code></pre>
<!--
See [Resolvers][Resolvers] for details on defining other types of repositories.
-->
<h4 id="override-default-resolvers"><a class="header" href="#override-default-resolvers">Override default resolvers</a></h4>
<p><code>resolvers</code> configures additional, inline user resolvers. By default, <code>sbt</code> combines these resolvers with default repositories (Maven Central and the local Ivy repository) to form <code>externalResolvers</code>. To have more control over repositories, set <code>externalResolvers</code> directly. To only specify repositories in addition to the usual defaults, configure <code>resolvers</code>.</p>
<p>For example, to use the Sonatype OSS Snapshots repository in addition to the default repositories,</p>
<pre><code class="language-scala">resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
</code></pre>
<p>To use the local repository, but not the Maven Central repository:</p>
<pre><code class="language-scala">externalResolvers := Resolver.combineDefaultResolvers(resolvers.value.toVector, mavenCentral = false)
</code></pre>
<h4 id="override-all-resolvers-for-all-builds"><a class="header" href="#override-all-resolvers-for-all-builds">Override all resolvers for all builds</a></h4>
<p>The repositories used to retrieve sbt, Scala, plugins, and application dependencies can be configured globally and declared to override the resolvers configured in a build or plugin definition. There are two parts:</p>
<ol>
<li>Define the repositories used by the launcher.</li>
<li>Specify that these repositories should override those in build definitions.</li>
</ol>
<p>The repositories used by the launcher can be overridden by defining <code>~/.sbt/repositories</code>, which must contain a <code>[repositories]</code> section with the same format as the <code>Launcher</code> configuration file. For example:</p>
<pre><code>[repositories]
local
my-maven-repo: https://example.org/repo
my-ivy-repo: https://example.org/ivy-repo/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre>
<p>A different location for the repositories file may be specified by the <code>sbt.repository.config</code> system property in the sbt startup script. The final step is to set <code>sbt.override.build.repos</code> to true to use these repositories for dependency resolution and retrieval.</p>
<h3 id="exclude-transitive-dependencies"><a class="header" href="#exclude-transitive-dependencies">Exclude Transitive Dependencies</a></h3>
<p>In certain cases a transitive dependency should be excluded from all dependencies. This can be achieved by setting up <code>ExclusionRules</code> in <code>excludeDependencies</code>.</p>
<pre><code class="language-scala">excludeDependencies ++= Seq(
  // commons-logging is replaced by jcl-over-slf4j
  ExclusionRule("commons-logging", "commons-logging")
)
</code></pre>
<p>To exclude certain transitive dependencies of a dependency, use the <code>excludeAll</code> or <code>exclude</code> methods. The <code>exclude</code> method should be used when a pom will be published for the project. It requires the organization and module name to exclude. For example,</p>
<pre><code class="language-scala">libraryDependencies += 
  ("log4j" % "log4j" % "1.2.15").exclude("javax.jms", "jms")
</code></pre>
<!--
The `excludeAll` method is more flexible, but because it cannot be
represented in a pom.xml, it should only be used when a pom doesn't need
to be generated. For example,

```scala
libraryDependencies +=
  "log4j" % "log4j" % "1.2.15" excludeAll(
    ExclusionRule(organization = "com.sun.jdmk"),
    ExclusionRule(organization = "com.sun.jmx"),
    ExclusionRule(organization = "javax.jms")
  )
```

See [ModuleID](../api/sbt/librarymanagement/ModuleID.html) for API details.
-->
<h3 id="explicit-url"><a class="header" href="#explicit-url">Explicit URL</a></h3>
<p>If your project requires a dependency that is not present in a repository, a direct URL to its jar can be specified as follows:</p>
<pre><code class="language-scala">libraryDependencies += "slinky" % "slinky" % "2.1" from "https://slinky2.googlecode.com/svn/artifacts/2.1/slinky.jar"
</code></pre>
<p>The URL is only used as a fallback if the dependency cannot be found through the configured repositories. Also, the explicit URL is not included in published metadata (that is, the pom or ivy.xml).</p>
<h3 id="disable-transitivity"><a class="header" href="#disable-transitivity">Disable Transitivity</a></h3>
<p>By default, these declarations fetch all project dependencies, transitively. In some instances, you may find that the dependencies listed for a project aren't necessary for it to build. Projects using the Felix OSGI framework, for instance, only explicitly require its main jar to compile and run. Avoid fetching artifact dependencies with either <code>intransitive()</code> or <code>notTransitive()</code>, as in this example:</p>
<pre><code class="language-scala">libraryDependencies += ("org.apache.felix" % "org.apache.felix.framework" % "1.8.0").intransitive()
</code></pre>
<h3 id="classifiers"><a class="header" href="#classifiers">Classifiers</a></h3>
<p>You can specify the classifier for a dependency using the <code>classifier</code> method. For example, to get the jdk15 version of TestNG:</p>
<pre><code class="language-scala">libraryDependencies += ("org.testng" % "testng" % "5.7").classifier("jdk15")
</code></pre>
<p>For multiple classifiers, use multiple <code>classifier</code> calls:</p>
<pre><code class="language-scala">libraryDependencies += 
  "org.lwjgl.lwjgl" % "lwjgl-platform" % lwjglVersion classifier "natives-windows" classifier "natives-linux" classifier "natives-osx"
</code></pre>
<p>To obtain particular classifiers for all dependencies transitively, run the <code>updateClassifiers</code> task. By default, this resolves all artifacts with the <code>sources</code> or <code>javadoc</code> classifier. Select the classifiers to obtain by configuring the <code>transitiveClassifiers</code> setting. For example, to only retrieve sources:</p>
<pre><code class="language-scala">transitiveClassifiers := Seq("sources")
</code></pre>
<h3 id="download-sources"><a class="header" href="#download-sources">Download Sources</a></h3>
<p>Downloading source and API documentation jars is usually handled by an IDE plugin. These plugins use the <code>updateClassifiers</code> and <code>updateSbtClassifiers</code> tasks, which produce an <code>Update-Report</code> referencing these jars.</p>
<p>To have sbt download the dependency's sources without using an IDE plugin, add <code>withSources()</code> to the dependency definition. For API jars, add <code>withJavadoc()</code>. For example:</p>
<pre><code class="language-scala">libraryDependencies += 
  ("org.apache.felix" % "org.apache.felix.framework" % "1.8.0").withSources().withJavadoc()
</code></pre>
<p>Note that this is not transitive. Use the <code>update*Classifiers</code> tasks for that.</p>
<!--
### Extra Attributes

[Extra attributes](https://ant.apache.org/ivy/history/2.3.0/concept.html#extra)
can be specified by passing key/value pairs to the `extra` method.

To select dependencies by extra attributes:

```scala
libraryDependencies += ("org" % "name" % "rev").extra("color" -> "blue")
```

To define extra attributes on the current project:

```scala
projectID := {
    val previous = projectID.value
    previous.extra("color" -> "blue", "component" -> "compiler-interface")
}
```
-->
<!--
#### Configurations

Ivy configurations are a useful feature for your build when you need
custom groups of dependencies, such as for a plugin. Ivy configurations
are essentially named sets of dependencies. You can read the
[Ivy documentation](https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html)
for details.

The built-in use of configurations in sbt is similar to scopes in Maven.
sbt adds dependencies to different classpaths by the configuration that
they are defined in. See the description of
[Maven Scopes](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope)
for details.

You put a dependency in a configuration by selecting one or more of its
configurations to map to one or more of your project's configurations.
The most common case is to have one of your configurations `A` use a
dependency's configuration `B`. The mapping for this looks like
`"A->B"`. To apply this mapping to a dependency, add it to the end of
your dependency definition:

```scala
libraryDependencies += "org.scalatest" %% "scalatest" % "$example_scalatest_version$" % "test->compile"
```

This says that your project's `"test"` configuration uses `ScalaTest`'s
`"compile"` configuration. See the
[Ivy documentation](https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html)
for more advanced mappings. Most projects published to Maven
repositories will use the `"compile"` configuration.

A useful application of configurations is to group dependencies that are
not used on normal classpaths. For example, your project might use a
`"js"` configuration to automatically download jQuery and then include
it in your jar by modifying `resources`. For example:

```scala
val JS = config("js") hide

ivyConfigurations += JS

libraryDependencies += "jquery" % "jquery" % "3.2.1" % "js->default" from "https://code.jquery.com/jquery-3.2.1.min.js"

Compile / resources ++= update.value.select(configurationFilter("js"))
```

The `config` method defines a new configuration with name `"js"` and
makes it private to the project so that it is not used for publishing.
See [Update Report][Update-Report] for more information on selecting
managed artifacts.

A configuration without a mapping (no `"->"`) is mapped to `"default"`
or `"compile"`. The `->` is only needed when mapping to a different
configuration than those. The ScalaTest dependency above can then be
shortened to:

```scala
libraryDependencies += "org.scalatest" %% "scalatest" % "$example_scalatest_version$" % "test"
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-示例教程-1"><a class="header" href="#sbt-示例教程-1">sbt 示例教程</a></h1>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>compile</code><br> <code>sbt</code> [<em>query</em> / ] <code>Test</code> / <code>compile</code><br></p>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>The <code>compile</code> task compiles the selected subprojects and their subproject dependencies. Since sbt 2.x, the compiled artifacts are cached automatically.</p>
<p>Compiling Scala code with the raw Scala compiler has been slow, so significant poriton of sbt's development efforts deal with various strategies for speeding up compilation.</p>
<h3 id="reduce-the-overhead-of-restarting-the-compiler"><a class="header" href="#reduce-the-overhead-of-restarting-the-compiler">Reduce the overhead of restarting the compiler</a></h3>
<p>sbt server stays up in the background, allowing Scala compilation to run the same Java virtual machine (JVM). Keeping the JVM warm makes compilation significantly faster because it takes a long time to classload the compiler and for the Just-in-Time compiler to optimize it.</p>
<h3 id="incremental-compilation"><a class="header" href="#incremental-compilation">Incremental compilation</a></h3>
<p>When a source file <code>A.scala</code> is modified, sbt goes to great effort to minimize the other source files recompiled due to <code>A.scala</code>'s change. This process of tracking dependencies between the language constructs and recompiling only the required sources is called <em>incremental compilation</em>.</p>
<h3 id="remote-caching-1"><a class="header" href="#remote-caching-1">(Remote) caching</a></h3>
<p>In sbt 2.x, compiled artifacts are not only cached across the sessions and builds, but can optionally be cached across different machines using Bazel-compatible remote cache. See <a href="reference/../concepts/caching.html">Caching</a> for details.</p>
<h3 id="test--compile"><a class="header" href="#test--compile">Test / compile</a></h3>
<p>Scoping the <code>compile</code> task with a configuration, like <code>Test / compile</code> will compile the test sources and their source dependencies.</p>
<h3 id="compilation-settings"><a class="header" href="#compilation-settings">Compilation settings</a></h3>
<h4 id="scalaversion"><a class="header" href="#scalaversion">scalaVersion</a></h4>
<p>The version of Scala used for compilation.</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
<h4 id="scalacoptions"><a class="header" href="#scalacoptions">scalacOptions</a></h4>
<p>Options for the Scala compiler.</p>
<pre><code class="language-scala">Compile / scalacOptions += "-Werror"
</code></pre>
<h4 id="javacoptions"><a class="header" href="#javacoptions">javacOptions</a></h4>
<p>Options for the Java compiler.</p>
<pre><code class="language-scala">Compile / javacOptions ++= List("-Xlint", "-Xlint:-serial")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-run"><a class="header" href="#sbt-run">sbt run</a></h1>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>run</code> [<em>args</em>]</p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>The <code>run</code> task provides a means for running the user program.</p>
<p>In sbt 1.x and earlier, <code>run</code> task ran the user program in the same Java virtual machine (JVM) as the sbt server. sbt 2.x implements <em>client-side run</em>: the <code>run</code> task creates a sandbox environment that contains the program, sends the information back to sbtn, and sbtn launches the user program in a fresh JVM.</p>
<h3 id="motivations"><a class="header" href="#motivations">Motivations</a></h3>
<p>There are several motivations for the client-side run.</p>
<ol>
<li><strong>sys.exit support</strong>. User code can call <code>sys.exit</code>, which normally shuts down the JVM. In sbt 1.x, we needed to trap these <code>sys.exit</code> calls to prevent <code>run</code> from shutting down the sbt session, using the JDK SecurityManager; however, TrapExit was dropped in sbt 1.6.0 (2021) since JDK 17 deprecated SecurityManager feature. Because client-side run runs the user program in its own JVM, it can call <code>sys.exit</code>.</li>
<li><strong>Isolation</strong>. User code can also start threads, or otherwise allocate resources that can be left running after the main method returns. Running user code in a separate JVM gives isolation between the sbt server and the user code.</li>
<li><strong>sbt server availability</strong>. Since the program will run outside of the sbt server, it can become available to the more requests by other clients, for example test or IDE integration.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-test"><a class="header" href="#sbt-test">sbt test</a></h1>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>test</code> [<em>testname1</em> <em>testname2</em>] [ -- <em>options</em> ]</p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>The <code>test</code> task provides a means for compiling and running the tests.</p>
<p>By default, the <code>test</code> task in sbt 2.x:</p>
<ol>
<li><strong>Subproject parallelism</strong>. Performs compilation of the relevant subprojects in parallel, specified by the <a href="reference/../concepts/sbt-query.html">query</a>.</li>
<li><strong>Test suite parallelism</strong>. Maps discovered test suites, to tasks and executes them in parallel.</li>
<li><strong>Incremental test</strong>. Runs only the tests that either failed in the previous run, never run, or if sbt detects changes in the test or its dependencies.</li>
<li><strong>Cached</strong>. The test result is cached machine-wide, and optionally remote cached.</li>
</ol>
<p>The standard source locations for testing are:</p>
<ul>
<li>Scala sources in <code>src/test/scala/</code></li>
<li>Java sources in <code>src/test/java/</code></li>
<li>Resources for the test classpath in <code>src/test/resources/</code></li>
</ul>
<p>The resources may be accessed from tests by using the <code>getResource</code> methods of <code>java.lang.Class</code> or <code>java.lang.ClassLoader</code>.</p>
<h3 id="test-interfaces"><a class="header" href="#test-interfaces">Test interfaces</a></h3>
<p>sbt defines the common interface for JVM-based test frameworks, allowing automatic test suite discovery and parallel execution. By default sbt integrates with <a href="https://scalameta.org/munit/">MUnit</a>, <a href="https://www.scalatest.org/">ScalaTest</a>, <a href="https://hedgehogqa.github.io/scala-hedgehog/">Hedgehog</a>, <a href="https://scalacheck.org/">ScalaCheck</a>, <a href="https://etorreborre.github.io/specs2/">Specs2</a>, <a href="https://typelevel.org/weaver-test/">Weaver</a>, <a href="https://zio.dev/reference/test/">ZIO Test</a>, and <a href="https://github.com/sbt/junit-interface">JUnit 4</a>; this means you only need to add the test framework to the classpath to work with sbt. For example, MUnit may be used by declaring it as a <code>libraryDependency</code>:</p>
<pre><code class="language-scala">lazy val munit = "org.scalameta" %% "munit" % "1.2.0"

libraryDependencies += munit % Test
</code></pre>
<p>In the above, <code>Test</code> denotes the <code>Test</code> configuration, and means that MUnit will only be on the test classpath and it isn't needed by the main sources.</p>
<h4 id="junit"><a class="header" href="#junit">JUnit</a></h4>
<p>Support for JUnit 5 is provided by <a href="https://github.com/sbt/sbt-jupiter-interface">sbt-jupiter-interface</a>. To add JUnit Jupiter support into your project, add the jupiter-interface dependency in your project's main build.sbt file.</p>
<pre><code class="language-scala">libraryDependencies += "com.github.sbt.junit" % "jupiter-interface" % "0.15.1" % Test
</code></pre>
<p>and the sbt-jupiter-interface plugin to your <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">addSbtPlugin("com.github.sbt.junit" % "sbt-jupiter-interface" % "0.15.1")
</code></pre>
<p>Support for JUnit 4 is provided by <a href="https://github.com/sbt/junit-interface">junit-interface</a>. Add the junit-interface dependency in your project's main build.sbt file.</p>
<pre><code class="language-scala">libraryDependencies += "com.github.sbt" % "junit-interface" % "0.13.3" % Test
</code></pre>
<h3 id="test-filtering"><a class="header" href="#test-filtering">Test filtering</a></h3>
<p>In sbt 2.x, the <code>test</code> task accepts a whitespace separated list of test names to run. For example:</p>
<pre><code class="language-bash">&gt; test example.ExampleSuite example.ExampleSuite2
</code></pre>
<p>Here's an example output:</p>
<pre><code class="language-bash">&gt; test example.ExampleSuite example.ExampleSuite2
[info] compiling 1 Scala source to /tmp/foo/target/out/jvm/scala-3.7.2/foo/backend ...
[info] compiling 2 Scala sources to /tmp/foo/target/out/jvm/scala-3.7.2/foo/test-backend ...
example.ExampleSuite:
  + addition 0.003s
example.ExampleSuite2:
  + subtraction 0.003s
[info] Passed: Total 2, Failed 0, Errors 0, Passed 2
[success] elapsed time: 3 s, cache 49%, 25 disk cache hits, 26 onsite tasks
</code></pre>
<p>It supports wildcards as well:</p>
<pre><code>&gt; test *Example*
</code></pre>
<h3 id="incremental-testing"><a class="header" href="#incremental-testing">Incremental testing</a></h3>
<p>In addition to the explicit filter, the <code>test</code> task runs only the tests that satisfy one of the following conditions are run:</p>
<ul>
<li>The tests that failed in the previous run</li>
<li>The tests that were not run before</li>
<li>The tests that have one or more transitive dependencies, maybe in a different project, recompiled.</li>
</ul>
<h3 id="full-testing"><a class="header" href="#full-testing">Full testing</a></h3>
<p>To run, uncached full tests, like sbt 1.x, use the <code>testFull</code> task.</p>
<!--
### Tab completion

Tab completion is provided for test names based on the results of the
last `Test/compile`. This means that a new sources aren't available for
tab completion until they are compiled and deleted sources won't be
removed from tab completion until a recompile. A new test source can
still be manually written out and run using `test`.
-->
<h3 id="other-tasks"><a class="header" href="#other-tasks">Other tasks</a></h3>
<p>Tasks that are available for main sources are generally available for test sources, but are prefixed with <code>Test /</code> on the command line and are referenced in Scala code with <code>Test /</code> as well. These tasks include:</p>
<ul>
<li><code>Test / compile</code></li>
<li><code>Test / console</code></li>
<li><code>Test / consoleQuick</code></li>
<li><code>Test / run</code></li>
<li><code>Test / runMain</code></li>
</ul>
<p>See <a href="reference/./sbt-run.html">sbt run</a> for details on these tasks.</p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>By default, logging is buffered for each test source file until all tests for that file complete. This can be disabled by setting <code>logBuffered</code>:</p>
<pre><code class="language-scala">Test / logBuffered := false
</code></pre>
<h4 id="test-reports"><a class="header" href="#test-reports">Test Reports</a></h4>
<p>By default, sbt will generate JUnit XML test reports for all tests in the build, located in the <code>target/test-reports</code> directory for a project. This can be disabled by disabling the <code>JUnitXmlReportPlugin</code></p>
<pre><code class="language-scala">val myProject = (project in file(".")).disablePlugins(plugins.JUnitXmlReportPlugin)
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<h4 id="test-framework-arguments"><a class="header" href="#test-framework-arguments">Test framework arguments</a></h4>
<p>Arguments to the test framework may be provided on the command line to the <code>test</code> tasks following a <code>--</code> separator. For example:</p>
<pre><code>&gt; test org.example.MyTest -- -verbosity 1
</code></pre>
<p>To specify test framework arguments as part of the build, add options constructed by <code>Tests.Argument</code>:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Argument("-verbosity", "1")
</code></pre>
<p>To specify them for a specific test framework only:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Argument(TestFrameworks.ScalaCheck, "-verbosity", "1")
</code></pre>
<h4 id="setup-and-cleanup"><a class="header" href="#setup-and-cleanup">Setup and Cleanup</a></h4>
<p>Specify setup and cleanup actions using <code>Tests.Setup</code> and <code>Tests.Cleanup</code>. These accept either a function of type <code>() =&gt; Unit</code> or a function of type <code>ClassLoader =&gt; Unit</code>. The variant that accepts a ClassLoader is passed the class loader that is (or was) used for running the tests. It provides access to the test classes as well as the test framework classes.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-test.html#admonition-note"></a>
</div>
<div>
<p>When forking, the <code>ClassLoader</code> containing the test classes cannot be
provided because it is in another JVM. Only use the <code>() =&gt; Unit</code>
variants in this case.</p>
</div>
</div>
<p>Examples:</p>
<pre><code class="language-scala">Test / testOptions += Tests.Setup( () =&gt; println("Setup") )
Test / testOptions += Tests.Cleanup( () =&gt; println("Cleanup") )
Test / testOptions += Tests.Setup( loader =&gt; ... )
Test / testOptions += Tests.Cleanup( loader =&gt; ... )
</code></pre>
<h4 id="disable-parallel-execution-of-test-suites"><a class="header" href="#disable-parallel-execution-of-test-suites">Disable parallel execution of test suites</a></h4>
<p>By default, sbt runs all tasks in parallel and within the same JVM as sbt itself. Because each test suite is mapped to a task, tests are also run in parallel by default. To make tests within a given project execute serially:</p>
<pre><code class="language-scala">Test / parallelExecution := false
</code></pre>
<p>Note that tests from different projects may still execute concurrently.</p>
<h4 id="filter-classes"><a class="header" href="#filter-classes">Filter classes</a></h4>
<p>If you want to only run test classes whose name ends with "Test", use <code>Tests.Filter</code>:</p>
<pre><code class="language-scala">Test / testOptions := Seq(Tests.Filter(s =&gt; s.endsWith("Test")))
</code></pre>
<h4 id="forking-tests"><a class="header" href="#forking-tests">Forking tests</a></h4>
<p>The setting:</p>
<pre><code class="language-scala">Test / fork := true
</code></pre>
<p>specifies that all tests will be executed in a single external JVM. <!-- See
[Forking][Forking] for configuring standard options for forking.
By default,
tests executed in a forked JVM are executed *sequentially*.
--></p>
<p>More control over how tests are assigned to JVMs and what options to pass to those is available with <code>testGrouping</code> key.</p>
<!--
For example in build.sbt:

```scala
import Tests._

{
  def groupByFirst(tests: Seq[TestDefinition]) =
    tests groupBy (_.name(0)) map {
      case (letter, tests) =>
        val options = ForkOptions().withRunJVMOptions(Vector("-Dfirst.letter"+letter))
        new Group(letter.toString, tests, SubProcess(options))
    } toSeq

    Test / testGrouping := groupByFirst( (Test / definedTests).value )
}
```


The tests in a single group are run sequentially.
-->
<p>Control the number of forked JVMs allowed to run at the same time by setting the limit on <code>Tags.ForkedTestGroup</code> tag, which is 1 by default. <code>Setup</code> and <code>Cleanup</code> actions cannot be provided with the actual test class loader when a group is forked.</p>
<!--
In addition, forked tests can optionally be run in parallel within the
forked JVM(s), using the following setting:

```scala
Test / testForkedParallel := true
```

<a name="additional-test-configurations"></a>

### Additional test configurations

You can add an additional test configuration to have a separate set of
test sources and associated compilation, packaging, and testing tasks
and settings. The steps are:

-   Define the configuration
-   Add the tasks and settings
-   Declare library dependencies
-   Create sources
-   Run tasks

The following two examples demonstrate this. The first example shows how
to enable integration tests. The second shows how to define a customized
test configuration. This allows you to define multiple types of tests
per project.

#### Custom test configuration

The previous example may be generalized to a custom test configuration.

```scala
lazy val scalatest = "org.scalatest" %% "scalatest" % "$example_scalatest_version$"
lazy val FunTest = config("fun") extend(Test)

ThisBuild / organization := "com.example"
ThisBuild / scalaVersion := "$example_scala_version$"
ThisBuild / version      := "0.1.0-SNAPSHOT"

lazy val root = (project in file("."))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testSettings),
    libraryDependencies += scalatest % FunTest
    // other settings here
  )
```

Instead of using the built-in configuration, we defined a new one:

```scala
lazy val FunTest = config("fun") extend(Test)
```

The `extend(Test)` part means to delegate to `Test` for undefined
`FunTest` settings. The line that adds the tasks and settings for the
new test configuration is:

```scala
settings(inConfig(FunTest)(Defaults.testSettings))
```

This says to add test and settings tasks in the `FunTest` configuration.
We could have done it this way for integration tests as well. In fact,
`Defaults.itSettings` is a convenience definition:
`val itSettings = inConfig(IntegrationTest)(Defaults.testSettings)`.

The comments in the integration test section hold, except with
`IntegrationTest` replaced with `FunTest` and `"it"` replaced with
`"fun"`. For example, test options can be configured specifically for
`FunTest`:

```scala
FunTest / testOptions += ...
```

Test tasks are run by prefixing them with `fun:`

```
> FunTest / test
```

#### Additional test configurations with shared sources

An alternative to adding separate sets of test sources (and
compilations) is to share sources. In this approach, the sources are
compiled together using the same classpath and are packaged together.
However, different tests are run depending on the configuration.

```scala
lazy val scalatest = "org.scalatest" %% "scalatest" % "$example_scalatest_version$"
lazy val FunTest = config("fun") extend(Test)

ThisBuild / organization := "com.example"
ThisBuild / scalaVersion := "$example_scala_version$"
ThisBuild / version      := "0.1.0-SNAPSHOT"

def itFilter(name: String): Boolean = name endsWith "ITest"
def unitFilter(name: String): Boolean = (name endsWith "Test") && !itFilter(name)

lazy val root = (project in file("."))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testTasks),
    libraryDependencies += scalatest % FunTest,
    Test / testOptions := Seq(Tests.Filter(unitFilter)),
    FunTest / testOptions := Seq(Tests.Filter(itFilter))
    // other settings here
  )
```

The key differences are:

-   We are now only adding the test tasks
    (inConfig(FunTest)(Defaults.testTasks)) and not compilation and
    packaging tasks and settings.
-   We filter the tests to be run for each configuration.

To run standard unit tests, run `test` (or equivalently, `Test / test`):

```
> test
```

To run tests for the added configuration (here, `"FunTest"`), prefix it with
the configuration name as before:

```
> FunTest / test
> FunTest / testOnly org.example.AFunTest
```

##### Application to parallel execution

One use for this shared-source approach is to separate tests that can
run in parallel from those that must execute serially. Apply the
procedure described in this section for an additional configuration.
Let's call the configuration `serial`:

```scala
lazy val Serial = config("serial") extend(Test)
```

Then, we can disable parallel execution in just that configuration
using:

```scala
Serial / parallelExecution := false
```

The tests to run in parallel would be run with `test` and the ones to
run in serial would be run with `Serial/test`.

### Extensions

This page describes adding support for additional testing libraries and
defining additional test reporters. You do this by implementing `sbt`
interfaces (described below). If you are the author of the testing
framework, you can depend on the test interface as a provided
dependency. Alternatively, anyone can provide support for a test
framework by implementing the interfaces in a separate project and
packaging the project as an sbt [Plugin][Plugins].

#### Custom Test Framework

The main Scala testing libraries have built-in support for sbt. To add
support for a different framework, implement the
[uniform test interface](https://github.com/sbt/test-interface).

#### Custom Test Reporters

Test frameworks report status and results to test reporters. You can
create a new test reporter by implementing either
[TestReportListener](../api/sbt/TestReportListener.html) or
[TestsListener](../api/sbt/TestsListener.html).

#### Using Extensions

To use your extensions in a project definition:

Modify the `testFrameworks` setting to reference your test framework:

```scala
testFrameworks += new TestFramework("custom.framework.ClassName")
```

Specify the test reporters you want to use by overriding the
`testListeners` setting in your project definition.

```scala
testListeners += customTestListener
```

where `customTestListener` is of type `sbt.TestReportListener`.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-inspect"><a class="header" href="#sbt-inspect">sbt inspect</a></h1>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5">Synopsis</a></h2>
<p><code>sbt</code> <code>inspect</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em><br> <code>sbt</code> <code>inspect actual</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em><br> <code>sbt</code> <code>inspect tree</code> [<em>subproject</em> / ] [ <em>config</em> / ] <em>task</em></p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>The <code>inspect</code> command provides a means to inspect the task and setting graph. For instace, it can be used to determine which setting should be modified to affect another task.</p>
<h3 id="value-description-and-provided-by"><a class="header" href="#value-description-and-provided-by">Value, Description, and Provided By</a></h3>
<p>The first piece of information provided by <code>inspect</code> is the type of a task or the value and type of a setting.</p>
<p>For example,</p>
<pre><code class="language-bash">$ sbt inspect libraryDependencies
[info] Setting: interface scala.collection.immutable.Seq =
  List(org.scala-lang:scala3-library:3.7.2,
       org.typelevel:toolkit:0.1.29,
       org.typelevel:toolkit-test:0.1.29:test)
[info] Description:
[info]  Declares managed dependencies.
[info] Provided by:
[info]  ProjectRef(uri("file:/tmp/aaa/"), "aaa") / libraryDependencies
....
</code></pre>
<p>The following section of output is labeled "Provided by". This shows the actual scope where the setting is defined.</p>
<p>This shows that <code>libraryDependencies</code> has been defined on the current project (<code>ProjectRef(uri("file:/tmp/aaa/"), "aaa")</code>).</p>
<h3 id="related-settings"><a class="header" href="#related-settings">Related Settings</a></h3>
<p>The <em>Related</em> section of <code>inspect</code> output lists all of the definitions of a key. For example,</p>
<pre><code class="language-bash">&gt; inspect compile
...
[info] Related:
[info]  Test / compile
</code></pre>
<p>This shows that in addition to the requested <code>Compile / compile</code> task, there is also a <code>Test / compile</code> task.</p>
<h3 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h3>
<p>Forward dependencies show the other settings (or tasks) used to define a setting (or task). Reverse dependencies go the other direction, showing what uses a given setting. <code>inspect</code> provides this information based on either the requested dependencies or the actual dependencies. Requested dependencies are those that a setting directly specifies. Actual settings are what those dependencies get resolved to. This distinction is explained in more detail in the following sections.</p>
<h4 id="requested-dependencies"><a class="header" href="#requested-dependencies">Requested Dependencies</a></h4>
<p>As an example, we'll look at <code>console</code>:</p>
<pre><code class="language-bash">$ sbt inspect console
...
[info] Dependencies:
[info]  Compile / console / initialCommands
[info]  Compile / console / compilers
[info]  Compile / state
[info]  Compile / console / cleanupCommands
[info]  Compile / console / taskTemporaryDirectory
[info]  Compile / console / scalaInstance
[info]  Compile / console / scalacOptions
[info]  Compile / console / fullClasspath
[info]  Compile / fileConverter
[info]  Compile / console / streams

...
</code></pre>
<p>This shows the inputs to the <code>console</code> task. We can see that it gets its classpath and options from <code>Compile / console / fullClasspath</code> and <code>Compile / console / scalacOptions</code>. The information provided by the <code>inspect</code> command can thus assist in finding the right setting to change. The convention for keys, like <code>console</code> and <code>fullClasspath</code>, is that the Scala identifier is camel case, while the String representation is lowercase and separated by dashes. The Scala identifier for a configuration is uppercase to distinguish it from tasks like <code>compile</code> and <code>test</code>. For example, we can infer from the previous example how to add code to be run when the Scala interpreter starts up:</p>
<pre><code class="language-scala">&gt; set Compile / console / initialCommands := "import mypackage._"
&gt; console
...
import mypackage._
...
</code></pre>
<p><code>inspect</code> showed that <code>console</code> used the setting <code>Compile / console / initialCommands</code>. Translating the <code>initialCommands</code> string to the Scala identifier gives us <code>initialCommands</code>. <code>compile</code> indicates that this is for the main sources. <code>console /</code> indicates that the setting is specific to <code>console</code>. Because of this, we can set the initial commands on the <code>console</code> task without affecting the <code>consoleQuick</code> task, for example.</p>
<h4 id="actual-dependencies"><a class="header" href="#actual-dependencies">Actual Dependencies</a></h4>
<p><code>inspect actual &lt;scoped-key&gt;</code> shows the actual dependency used. This is useful because delegation means that the dependency can come from a scope other than the requested one. Using <code>inspect actual</code>, we see exactly which scope is providing a value for a setting. Combining <code>inspect actual</code> with plain <code>inspect</code>, we can see the range of scopes that will affect a setting. Returning to the example in Requested Dependencies,</p>
<pre><code class="language-bash">$ sbt inspect actual console
...
[info] Dependencies:
[info]  Compile / console / streams
[info]  Global / taskTemporaryDirectory
[info]  scalaInstance
[info]  Compile / scalacOptions
[info]  Global / initialCommands
[info]  Global / cleanupCommands
[info]  Compile / fullClasspath
[info]  console / compilers
...
</code></pre>
<p>For <code>initialCommands</code>, we see that it comes from the global scope (<code>Global</code>). Combining this with the relevant output from <code>inspect console</code>:</p>
<pre><code>Compile / console / initialCommands
</code></pre>
<p>we know that we can set <code>initialCommands</code> as generally as the global scope, as specific as the current project's <code>console</code> task scope, or anything in between. This means that we can, for example, set <code>initialCommands</code> for the whole project and will affect <code>console</code>:</p>
<pre><code class="language-scala">&gt; set initialCommands := "import mypackage._"
...
</code></pre>
<p>The reason we might want to set it here this is that other console tasks will use this value now. We can see which ones use our new setting by looking at the reverse dependencies output of <code>inspect actual</code>:</p>
<pre><code class="language-bash">$ sbt inspect actual Global/initialCommands
...
[info] Reverse dependencies:
[info]  Compile / console
[info]  consoleProject
[info]  Test / console
[info]  Test / consoleQuick
[info]  Compile / consoleQuick
...
</code></pre>
<p>We now know that by setting <code>initialCommands</code> on the whole project, we affect all console tasks in all configurations in that project. If we didn't want the initial commands to apply for <code>consoleProject</code>, which doesn't have our project's classpath available, we could use the more specific task axis:</p>
<pre><code class="language-scala">&gt; set console / initialCommands := "import mypackage._"
&gt; set consoleQuick / initialCommands := "import mypackage._"`
</code></pre>
<p>or configuration axis:</p>
<pre><code class="language-scala">&gt; set Compile/　initialCommands := "import mypackage._"
&gt; set Test / initialCommands := "import mypackage._"
</code></pre>
<p>The next part describes the Delegates section, which shows the chain of delegation for scopes.</p>
<h3 id="delegates"><a class="header" href="#delegates">Delegates</a></h3>
<p>A setting has a key and a scope. A request for a key in a scope A may be delegated to another scope if A doesn't define a value for the key. The delegation chain is well-defined and is displayed in the Delegates section of the <code>inspect</code> command. The Delegates section shows the order in which scopes are searched when a value is not defined for the requested key.</p>
<p>As an example, consider the initial commands for <code>console</code> again:</p>
<pre><code class="language-bash">$ sbt inspect console/initialCommands
...
[info] Delegates:
[info]  console / initialCommands
[info]  initialCommands
[info]  ThisBuild / console / initialCommands
[info]  ThisBuild / initialCommands
[info]  Zero / console / initialCommands
[info]  Global / initialCommands
...
</code></pre>
<p>This means that if there is no value specifically for <code>console/initialCommands</code>, the scopes listed under Delegates will be searched in order until a defined value is found.</p>
<h3 id="inspect-tree"><a class="header" href="#inspect-tree">Inspect tree</a></h3>
<p>In addition to displaying immediate forward and reverse dependencies as described in the previous section, the <code>inspect tree</code> command can display the full dependency tree for a task or setting. For example,</p>
<pre><code class="language-bash">$ sbt inspect tree console
[info] Compile / console = Task[void]
[info]   +-Global / cleanupCommands =
[info]   +-console / compilers = Task[class xsbti.compile.Compilers]
[info]   +-Compile / fullClasspath = Task[Seq[class sbt.internal.util.Attributed]]
[info]   +-Global / initialCommands =
[info]   +-scalaInstance = Task[class sbt.internal.inc.ScalaInstance]
[info]   +-Compile / scalacOptions = Task[Seq[class java.lang.String]]
[info]   +-Compile / console / streams = Task[interface sbt.std.TaskStreams]
[info]   | +-Global / streamsManager = Task[interface sbt.std.Streams]
[info]   |
[info]   +-Global / taskTemporaryDirectory = target/....
[info]   +-Global / fileConverter = sbt.internal.inc.MappedFileConverter@10095d95
[info]   +-Global / state = Task[class sbt.State]
[info]
[success] elapsed: 0 s
</code></pre>
<p>For each task, <code>inspect tree</code> show the type of the value generated by the task. For a setting, the <code>toString</code> of the setting is displayed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbt-publish"><a class="header" href="#sbt-publish">sbt publish</a></h1>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6">Synopsis</a></h2>
<p><code>sbt</code> [<em>query</em> / ] <code>publish</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishSigned</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishLocal</code><br> <code>sbt</code> [<em>query</em> / ] <code>publishM2</code></p>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>The publish family of tasks provide means for compiling and publishing your project. <em>Publishing</em> in this context consists of uploading a descriptor, such as a Maven POM or <code>ivy.xml</code>, and artifacts, such as a JAR or <code>war</code> file, to a repository so that other projects can specify your project as a dependency.</p>
<ul>
<li>The <code>publish</code> task publishes your project to a remote repository, such as JFrog Artifactory or Sonatype Nexus instance.</li>
<li>The <code>publishSigned</code> task, enabled using <a href="https://github.com/sbt/sbt-pgp">sbt-pgp plugin</a>, is used to publish GPG-signed artifacts.</li>
<li>The <code>publishLocal</code> task publishes your project to the Ivy local file repository, which is usually located at <code>$HOME/.ivy2/local/</code>. You can then use this project from other projects on the same machine.</li>
<li>The <code>publishM2</code> task publishes your project to the local Maven repository.</li>
</ul>
<p>There's a specific recipe for <a href="reference/../recipes/central.html">publishing to the Central Repo</a>.</p>
<h3 id="skip-publishing"><a class="header" href="#skip-publishing">Skip publishing</a></h3>
<p>To avoid publishing a project, add the following setting to the subprojects that you want to skip:</p>
<pre><code class="language-scala">publish / skip := true
</code></pre>
<p>Common use case is to prevent publishing of the root project.</p>
<h3 id="define-the-repository"><a class="header" href="#define-the-repository">Define the repository</a></h3>
<p>To specify the repository, assign a repository to <code>publishTo</code> and optionally set the publishing style. For example, to upload to Nexus:</p>
<pre><code class="language-scala">publishTo := Some("Sonatype Snapshots Nexus" at "https://oss.sonatype.org/content/repositories/snapshots")
</code></pre>
<p>To publish to a local maven repository:</p>
<pre><code class="language-scala">publishTo := Some(MavenCache("local-maven", file("path/to/maven-repo/releases")))
</code></pre>
<p>To publish to a local Ivy repository:</p>
<pre><code class="language-scala">publishTo := Some(Resolver.file("local-ivy", file("path/to/ivy-repo/releases")))
</code></pre>
<p>If you're publishing the Central Repository, you will also have to select the right repository depending on your artifacts: SNAPSHOT versions go to the central-snapshots repository while other versions go to the local staging repository. Doing this selection can be done by using the value of the <code>version</code> setting:</p>
<pre><code class="language-scala">publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<h3 id="publishing-locally"><a class="header" href="#publishing-locally">Publishing locally</a></h3>
<p>The <code>publishLocal</code> task will publish to the "local" Ivy repository. By default, this is at <code>$HOME/.ivy2/local/</code>. Other builds on the same machine can then list the project as a dependency. For example, if the project you are publishing has configuration parameters like:</p>
<pre><code class="language-scala">organization := "com.example"
version := "0.1-SNAPSHOT"
name := "hello"
</code></pre>
<p>Then another build on the same machine can depend on it:</p>
<pre><code class="language-scala">libraryDependencies += "com.example" %% "hello" % "0.1-SNAPSHOT"
</code></pre>
<p>The version number you select must end with <code>SNAPSHOT</code>, or you must change the version number each time you publish to indicate that it's a changing artifact.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-publish.html#admonition-warning"></a>
</div>
<div>
<p>Generally the use of SNAPSHOT dependencies should be avoided beyond testing on a single machine
since it makes dependency resolution slower and the build non-repeatable.</p>
</div>
</div>
<p>Similar to <code>publishLocal</code>, <code>publishM2</code> task will publish the user's Maven local repository. This is at the location specified by <code>$HOME/.m2/settings.xml</code> or at <code>$HOME/.m2/repository/</code> by default. Another build would require <code>Resolver.mavenLocal</code> to resolve out of it:</p>
<pre><code class="language-scala">resolvers += Resolver.mavenLocal
</code></pre>
<!--
See [Resolvers][Resolvers] for more details.
-->
<h3 id="credentials"><a class="header" href="#credentials">Credentials</a></h3>
<p>There are two ways to specify credentials for such a repository.</p>
<p>The first and better way is to load them from a file, for example:</p>
<pre><code class="language-scala">credentials += Credentials(Path.userHome / ".sbt" / ".credentials")
</code></pre>
<p>The credentials file is a properties file with keys <code>realm</code>, <code>host</code>, <code>user</code>, and <code>password</code>. For example:</p>
<pre><code>realm=Sonatype Nexus Repository Manager
host=my.artifact.repo.net
user=admin
password=admin123
</code></pre>
<p>The second way is to specify them inline:</p>
<pre><code class="language-scala">credentials += Credentials("Sonatype Nexus Repository Manager", "my.artifact.repo.net", "admin", "admin123")
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/sbt-publish.html#admonition-note"></a>
</div>
<div>
<p>Credentials matching is done using both: <code>realm</code> and <code>host</code> keys.
The <code>realm</code> key is the HTTP <code>WWW-Authenticate</code> header's realm directive, which is
part of the response of HTTP servers for <a href="https://en.wikipedia.org/wiki/Basic_access_authentication#Server_side">HTTP Basic Authentication</a>.
For a given repository, this can be found by reading all the headers received.
For example:</p>
<pre><code class="language-bash">curl -D - my.artifact.repo.net
</code></pre>
</div>
</div>
<h3 id="cross-publishing"><a class="header" href="#cross-publishing">Cross-publishing</a></h3>
<p>To support multiple incompatible Scala versions, use projectMatrix and publish (see <a href="reference/./cross-building-setup.html">Cross building setup</a>).</p>
<h3 id="overriding-the-publishing-convention"><a class="header" href="#overriding-the-publishing-convention">Overriding the publishing convention</a></h3>
<p>By default sbt will publish your artifact with the binary version of Scala you're using. For example if your project is using Scala 2.13.x your example artifact would be published under <code>example_2.13</code>. This is often what you want, but if you're publishing a pure Java artifact or a compiler plugin you'll want to change the <code>CrossVersion</code>. See the <a href="reference/./cross-building-setup.html">Cross building setup</a> page for more details under the <em>Publishing convention</em> section.</p>
<h3 id="published-artifacts"><a class="header" href="#published-artifacts">Published artifacts</a></h3>
<p>By default, the main binary JAR, a sources JAR, and a API documentation JAR are published. You can declare other types of artifacts to publish and disable or modify the default artifacts. See the <a href="reference/./artifact.html">Artifact</a> page for details.</p>
<h3 id="version-scheme"><a class="header" href="#version-scheme">Version scheme</a></h3>
<p><code>versionScheme</code> setting tracks the version scheme of the build:</p>
<pre><code class="language-scala">versionScheme := Some("early-semver")
</code></pre>
<p>The supported values are <code>"early-semver"</code>, <code>"pvp"</code>, <code>"semver-spec"</code>, and <code>"strict"</code>. sbt will include this information into <code>pom.xml</code> and <code>ivy.xml</code> as a property.</p>
<ul>
<li><code>Some("early-semver")</code>: Early Semantic Versioning that would keep binary compatibility across patch updates within 0.Y.z (for instance 0.13.0 and 0.13.2). Once it goes 1.0.0, it follows the regular Semantic Versioning where 1.1.0 is bincompat with 1.0.0.</li>
<li><code>Some("semver-spec")</code>: Semantic Versioning where all 0.y.z are treated as initial development (no bincompat guarantees).</li>
<li><code>Some("pvp")</code>. Haskell Package Versioning Policy where X.Y are treated as major version.</li>
<li><code>Some("strict")</code>. Requires exact match of version.</li>
</ul>
<p>This information will be annotated into the <code>pom.xml</code> file, which helps downstream projects determine whether a version conflict is safe to resolve or not. See <a href="https://www.scala-lang.org/blog/2021/02/16/preventing-version-conflicts-with-versionscheme.html">Preventing version conflicts with versionScheme</a> (2021).</p>
<h3 id="modifying-the-generated-pom"><a class="header" href="#modifying-the-generated-pom">Modifying the generated POM</a></h3>
<p>When <code>publishMavenStyle</code> is <code>true</code>, a POM is generated by the <code>makePom</code> action and published to the repository instead of an Ivy file. This POM file may be altered by changing a few settings. Set <code>pomExtra</code> to provide XML (<code>scala.xml.NodeSeq</code>) to insert directly into the generated pom. For example:</p>
<pre><code class="language-scala">pomExtra := &lt;something&gt;&lt;/something&gt;
</code></pre>
<p>There is also a <code>pomPostProcess</code> setting that can be used to manipulate the final XML before it is written. It's type is <code>Node =&gt; Node</code>.</p>
<pre><code class="language-scala">pomPostProcess := { (node: Node) =&gt;
  ....
}
</code></pre>
<p><code>makePom</code> adds to the POM any Maven-style repositories you have declared. You can filter these by modifying <code>pomRepositoryFilter</code>, which by default excludes local repositories. To instead only include local repositories:</p>
<pre><code class="language-scala">pomIncludeRepository := { (repo: MavenRepository) =&gt;
  repo.root.startsWith("file:")
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-command"><a class="header" href="#watch-command">Watch command</a></h1>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7">Synopsis</a></h2>
<p><code>sbt</code> <code>~</code> <em>command1</em><br> <code>sbt</code> <code>~</code> <em>command1</em> [ <code>;</code> <em>command2</em> <code>;</code> ... ]</p>
<h2 id="descrption"><a class="header" href="#descrption">Descrption</a></h2>
<p>The watch command is denoted by <code>~</code> (tilde), and it provides the ability to monitor the input files for particular tasks and repeat the tasks when changes to those files occur.</p>
<p>Some example usages are described below:</p>
<h3 id="compile-1"><a class="header" href="#compile-1">Compile</a></h3>
<p>A common use-case is continuous compilation. The following commands will make sbt watch for source changes in the Test and Compile (default) configurations respectively and re-run the compile command.</p>
<pre><code class="language-bash">&gt; ~ Test / compile

&gt; ~ compile
</code></pre>
<p>Note that because <code>Test / compile</code> depends on <code>Compile / compile</code>, source changes in the main source directory will trigger recompilation of the test sources.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Triggered execution is often used when developing in a test driven development (TDD) style. The following command will monitor changes to both the main and test source sources for the build and re-run only the tests that reference classes that have been re-compiled since the last test run.</p>
<pre><code class="language-bash">&gt; ~ test
</code></pre>
<p>It is also possible to re-run only a particular test if its dependencies have changed.</p>
<pre><code class="language-bash">&gt; ~ test foo.BarTest
</code></pre>
<p>It is possible to always re-run a test when source changes are detected regardless of whether the test depends on any of the updated source files.</p>
<pre><code class="language-bash">&gt; ~ testOnly foo.BarTest
</code></pre>
<p>To run all of the tests in the project when any sources change, use</p>
<pre><code class="language-bash">&gt; ~ testFull
</code></pre>
<h3 id="running-multiple-commands"><a class="header" href="#running-multiple-commands">Running Multiple Commands</a></h3>
<p>The watch command supports watching multiple, semicolon separated, tasks. For example, the following command will monitor for source file changes and run <code>clean</code> and <code>test</code>:</p>
<pre><code class="language-bash">&gt; ~ clean; test
</code></pre>
<h3 id="build-sources"><a class="header" href="#build-sources">Build sources</a></h3>
<p>If the build is configured to automatically reload when build source changes are made by setting <code>Global / onChangedBuildSource := ReloadOnSourceChanges</code>, then sbt will monitor the build sources (i.e. <code>*.sbt</code> and <code>*.{java,scala}</code> files in the <code>project</code> directory). When build source changes are detected, the build will be reloaded and sbt will re-enter triggered execution mode when the reload completes.</p>
<!--
The following snippet can be added as a [global setting](../api/sbt/Global-Settings.html) to `~/.sbt/1.0/config.sbt` to enable `ReloadOnSourceChanges` for all sbt 1.3+ builds without breaking earlier versions:

```
Def.settings {
  try {
    val value = Class.forName("sbt.nio.Keys\$ReloadOnSourceChanges\$").getDeclaredField("MODULE\$").get(null)
    val clazz = Class.forName("sbt.nio.Keys\$WatchBuildSourceOption")
    val manifest = new scala.reflect.Manifest[AnyRef]{ def runtimeClass = clazz }
    Seq(
      Global / SettingKey[AnyRef]("onChangedBuildSource")(manifest, sbt.util.NoJsonWriter()) := value
    )
  } catch {
    case e: Throwable =>
      Nil
  }
}
```
-->
<h3 id="clearing-the-screen"><a class="header" href="#clearing-the-screen">Clearing the screen</a></h3>
<p>sbt can clear the console screen before it evaluates the task or after it triggers an event. To configure sbt to clear the screen after an event is triggered add</p>
<pre><code class="language-scala">ThisBuild / watchTriggeredMessage := Watch.clearScreenOnTrigger
</code></pre>
<p>to the build settings. To clear the screen before running the task, add</p>
<pre><code class="language-scala">ThisBuild  / watchBeforeCommand := Watch.clearScreen
</code></pre>
<p>to the build settings.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The behavior of triggered execution can be configured via a number of settings.</p>
<ul>
<li>
<p><code>watchTriggers: Seq[Glob]</code> adds search queries for files that should task trigger evaluation but that the task does not directly depend on. For example, if the project build.sbt file contains <code>foo / watchTriggers += baseDirectory.value.toGlob / "*.txt"</code>, then any modifications to files ending with the <code>txt</code> extension will cause the <code>foo</code> command to trigger when in triggered execution mode.</p>
</li>
<li>
<p><code>watchTriggeredMessage: (Int, Path, Seq[String]) =&gt; Option[String]</code> sets the message that is displayed when a file modification triggers a new build. Its input parameters are the current watch iteration count, the file that triggered the build and the command(s) that are going to be run. By default, it prints a message indicating what file triggered the build and what commands its going to run. No message is printed when the function returns <code>None</code>. To clear the screen before printing the message, just add <code>Watch.clearScreen()</code> inside of the task definition. This will ensure that the screen is cleared and that the message, if any is defined, will be printed after the screen clearing.</p>
</li>
<li>
<p><code>watchInputOptions: Seq[Watch.InputOption]</code> allows the build to override the default watch options. For example, to add the ability to reload the build by typing the 'l' key, add <code>ThisBuild / watchInputOptions += Watch.InputOption('l', "reload", Watch.Reload)</code> to the <code>build.sbt</code> file. When using the default <code>watchStartMessage</code>, this will also add the option to the list displayed by the '?' option.</p>
</li>
<li>
<p><code>watchBeforeCommand: () =&gt; Unit</code> provides a callback to run before evaluating the task.  It can be used to clear the console screen by adding <code>ThisBuild / watchBeforeCommand := Watch.clearScreen</code> to the project build.sbt file. By default it is no-op.</p>
</li>
<li>
<p><code>watchLogLevel</code> sets the logging level of the file monitoring system. This can be useful if the triggered execution is not being evaluated when source files or modified or if is unexpectedly triggering due to modifications to files that should not be monitored.</p>
</li>
<li>
<p><code>watchInputParser: Parser[Watch.Action]</code> changes how the monitor handles input events. For example, setting <code>watchInputParser := 'l' ^^^ Watch.Reload | '\r' ^^^ new Watch.Run("")</code> will make it so that typing the 'l' key will reload the build and typing a newline will return to the shell. By default this is automatically derived from the <code>watchInputOptions</code>.</p>
</li>
<li>
<p><code>watchStartMessage: (Int, ProjectRef, Seq[String]) =&gt; Option[String]</code> sets the banner that is printed while the watch process is waiting for file or input events. The inputs are the iteration count, the current project and the commands to run. The default message includes instructions for terminating the watch or displaying all available options. This banner is only displayed if <code>watchOnIteration</code> logs the result of <code>watchStartMessage</code>.</p>
</li>
<li>
<p><code>watchOnIteration: (Int, ProjectRef, Seq[String]) =&gt; Watch.Action</code> a function that is evaluated before waiting for source or input events. It can be used to terminate the watch early if, for example, a certain number of iterations have been reached. By default, it just logs the result of <code>watchStartMessage</code>.</p>
</li>
<li>
<p><code>watchForceTriggerOnAnyChange: Boolean</code> configures whether or not the contents of a source file must change in order to trigger a build. The default value is false.</p>
</li>
<li>
<p><code>watchPersistFileStamps: Boolean</code> toggles whether or not sbt will persist the file hashes computed for source files across multiple task evaluation runs. This can improve performance for projects with many source files. Because the file hashes are cached, it is possible for the evaluated task to read an invalid hash if many source files are being concurrently modified. The default value is false.</p>
</li>
<li>
<p><code>watchAntiEntropy: FiniteDuration</code> controls the time that must elapse before a build is re-triggered by the same file that previously triggered the build. This is intended to prevent spurious builds that can occur when a file is modified in short bursts. The default value is 500ms.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cached-task"><a class="header" href="#cached-task">Cached task</a></h1>
<p>This page covers the cached task details. See <a href="reference/../concepts/caching.html">Caching</a> for a general explanation.</p>
<h2 id="automatic-caching-1"><a class="header" href="#automatic-caching-1">Automatic caching</a></h2>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := name.value + version.value + "!"
</code></pre>
<p>In sbt 2.x, the task result will be automatically cached based on the two settings <code>name</code> and <code>version</code>. The first time we run the task it will be executed onsite, but the second time onward, it will use the disk cache:</p>
<pre><code>sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 0%, 1 onsite task
sbt:demo&gt; show someKey
[info] demo0.1.0-SNAPSHOT!
[success] elapsed time: 0 s, cache 100%, 1 disk cache hit
</code></pre>
<h3 id="caching-is-serialization-hard"><a class="header" href="#caching-is-serialization-hard">Caching is serialization-hard</a></h3>
<p>To participate in the automatic caching, the input keys (e.g. <code>name</code> and <code>version</code>) must provide a given for <code>sjsonnew.HashWriter</code> typeclass and return type must provide a given for <code>sjsonnew.JsonFormat</code>. <a href="https://www.scala-sbt.org/contraband/">Contraband</a> can be used to generate sjson-new codecs.</p>
<h2 id="effect-tracking"><a class="header" href="#effect-tracking">Effect tracking</a></h2>
<h3 id="the-effect-of-file-creation"><a class="header" href="#the-effect-of-file-creation">The effect of file creation</a></h3>
<p>To cache the effect of file creation, not just returning the name of the file, we need to track the effect of file creation using <code>Def.declareOutput(vf)</code>.</p>
<pre><code class="language-scala">someKey := {
  val conv = fileConverter.value
  val out: java.nio.file.Path = createFile(...)
  val vf: xsbti.VirtualFile = conv.toVirtualFile(out)
  Def.declareOutput(vf)
  vf: xsbti.HashedVirtualFileRef
}
</code></pre>
<h2 id="opting-out-from-caching"><a class="header" href="#opting-out-from-caching">Opting out from caching</a></h2>
<h3 id="build-wide-opt-out"><a class="header" href="#build-wide-opt-out">Build-wide opt-out</a></h3>
<p>To opt out of by-default custom task caching, add the following to <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">Compile / scalacOptions += "-Xmacro-settings:sbt:no-default-task-cache"
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/cached-task.html#admonition-note"></a>
</div>
<div>
<p>This applies only to the custom tasks introduced in the build. Any cached tasks provided by sbt or plugins will remain cached.</p>
</div>
</div>
<h3 id="per-task-key-opt-out"><a class="header" href="#per-task-key-opt-out">Per-task-key opt-out</a></h3>
<p>Next, if you want to opt some task keys from caching, you can set the cache level as follows:</p>
<pre><code class="language-scala">@transient
val someKey = taskKey[String]("something")
</code></pre>
<p>or</p>
<pre><code class="language-scala">@cacheLevel(include = Array.empty)
val someKey = taskKey[String]("something")
</code></pre>
<h3 id="per-task-opt-out"><a class="header" href="#per-task-opt-out">Per-task opt-out</a></h3>
<p>To opt out of the cache individually, use <code>Def.uncached(...)</code> as follows:</p>
<pre><code class="language-scala">val someKey = taskKey[String]("something")

someKey := Def.uncached {
  name.value + somethingUncachable.value + "!"
}
</code></pre>
<h2 id="remote-caching-2"><a class="header" href="#remote-caching-2">Remote caching</a></h2>
<p>sbt 2.x implements Bazel-compatible gRPC interface, which works with number of backend both open source and commercial. See <a href="reference/./remote-cache-setup.html">Remote cache setup</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-building-setup"><a class="header" href="#cross-building-setup">Cross building setup</a></h1>
<p>This page covers cross building setup. See <a href="reference/../concepts/cross-building.html">Cross building</a> for general explanation.</p>
<h2 id="using-cross-built-libraries"><a class="header" href="#using-cross-built-libraries">Using cross-built libraries</a></h2>
<p>To use a library built against multiple versions of Scala, double the first <code>%</code> in a ModuleID to be <code>%%</code>. This tells sbt that it should append the current version of Scala being used to build the library to the dependency’s name. For example:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" %% "cats-effect" % "3.5.4"
</code></pre>
<p>A nearly equivalent, manual alternative for a fixed version of Scala is:</p>
<pre><code class="language-scala">libraryDependencies += "org.typelevel" % "cats-effect_3" % "3.5.4"
</code></pre>
<h3 id="scala-3-specific-cross-versions"><a class="header" href="#scala-3-specific-cross-versions">Scala 3 specific cross-versions</a></h3>
<p>If you are developing an application in Scala 3, you can use Scala 2.13 libraries:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.for3Use2_13)
</code></pre>
<p>This is equivalent to using <code>%%</code> except it resolves the <code>_2.13</code> variant of the library  when <code>scalaVersion</code> is 3.x.y.</p>
<p>Conversely we have <code>CrossVersion.for2_13Use3</code> to use the <code>_3</code> variant of the library when <code>scalaVersion</code> is 2.13.x:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.for2_13Use3)
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/cross-building-setup.html#admonition-warning"></a>
</div>
<div>
<p><strong>Warning for library authors:</strong> It is generally not safe to publish a Scala 3 library that depends on a Scala 2.13 library or vice-versa. Doing so could introduce two versions of the same library like <code>scala-xml_2.13</code> and <code>scala-xml_3</code> on the end users' classpath.</p>
</div>
</div>
<h3 id="more-about-using-cross-built-libraries"><a class="header" href="#more-about-using-cross-built-libraries">More about using cross-built libraries</a></h3>
<p>You can have fine-grained control over the behavior for different Scala versions by using the <code>cross</code> method on <code>ModuleID</code> These are equivalent:</p>
<pre><code class="language-scala">"a" % "b" % "1.0"
("a" % "b" % "1.0").cross(CrossVersion.disabled)
</code></pre>
<p>These are equivalent:</p>
<pre><code class="language-scala">"a" %% "b" % "1.0"
("a" % "b" % "1.0").cross(CrossVersion.binary)
</code></pre>
<p>This overrides the defaults to always use the full Scala version instead of the binary Scala version:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.full)
</code></pre>
<p><code>CrossVersion.patch</code> sits between <code>CrossVersion.binary</code> and <code>CrossVersion.full</code> in that it strips off any trailing <code>-bin-...</code> suffix which is used to distinguish variant but binary compatible Scala toolchain builds.</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.patch)
</code></pre>
<p><code>CrossVersion.constant</code> fixes a constant value:</p>
<pre><code class="language-scala">("a" % "b" % "1.0").cross(CrossVersion.constant("2.9.1"))
</code></pre>
<p>It is equivalent to:</p>
<pre><code class="language-scala">"a" % "b_2.9.1" % "1.0"
</code></pre>
<h2 id="project-matrix-1"><a class="header" href="#project-matrix-1">Project matrix</a></h2>
<p>sbt 2.x introduces project matrix, which enables cross building to happen in parallel.</p>
<pre><code class="language-scala">organization := "com.example"
scalaVersion := "3.7.3"
version      := "0.1.0-SNAPSHOT"

lazy val core = (projectMatrix in file("core"))
  .settings(
    name := "core"
  )
  .jvmPlatform(scalaVersions = Seq("3.7.3", "2.13.17"))
</code></pre>
<h2 id="publishing-convention"><a class="header" href="#publishing-convention">Publishing convention</a></h2>
<p>We use the Scala ABI (application binary interface) version as suffix to denote which version of Scala was used to compile a library. For example, the artifact name <code>cats-effect_2.13</code> means Scala 2.13.x was used. <code>cats-effect_3</code> means Scala 3.x was used. This fairly simple approach allows interoperability with users of Maven, Ant and other build tools. For pre-prelease versions of Scala, such as 2.13.0-RC1, full version will be considered the ABI version.</p>
<p><code>crossVersion</code> setting can be used to override the publishing convention:</p>
<ul>
<li><code>CrossVersion.disabled</code> (no suffix)</li>
<li><code>CrossVersion.binary</code> (<code>_&lt;scala-abi-version&gt;</code>)</li>
<li><code>CrossVersion.full</code> (<code>_&lt;scala-version&gt;</code>)</li>
</ul>
<p>The default is either <code>CrossVersion.binary</code> or <code>CrossVersion.disabled</code> depending on the value of <code>crossPaths</code>. Because (unlike Scala library) Scala compiler is not forward compatible among the patch releases, compiler plugins should use <code>CrossVersion.full</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-cache-setup"><a class="header" href="#remote-cache-setup">Remote cache setup</a></h1>
<p>This page covers remote caching setup. See <a href="reference/../concepts/caching.html">Caching</a> for general explanation of the caching system.</p>
<h2 id="grpc-remote-cache"><a class="header" href="#grpc-remote-cache">gRPC remote cache</a></h2>
<p>While there might be multiple remote cache store implemention in the future, sbt 2.0 ships with a gRPC client that is compatible with the Bazel remote cache backends. To configure sbt 2.x, add the following to <code>project/plugins.sbt</code></p>
<pre><code class="language-scala">addRemoteCachePlugin
</code></pre>
<p>There are many Bazel remote cache backends, both open source and commercial solutions. While this page documents is not an exhaustive list of all Bazel remote cache implementations, hopefully it shows how sbt 2.x can be set up for wide array of them.</p>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>There are a few flavors of <a href="https://grpc.io/docs/guides/auth/">gRPC authentication</a>, and Bazel remote cache backends use various kind of them:</p>
<ol>
<li>Unauthenticated. Useful for testing.</li>
<li>Default TLS/SSL.</li>
<li>TLS/SSL with custom server certificate.</li>
<li>TTL/SSL with custom server and client certificate, mTLS.</li>
<li>Default TLS/SSL with API token header.</li>
</ol>
<h3 id="bazel-remote-without-authentication"><a class="header" href="#bazel-remote-without-authentication">bazel-remote without authentication</a></h3>
<p>You can grab the code from <a href="https://github.com/buchgr/bazel-remote">buchgr/bazel-remote</a> and run it on a laptop using Bazel:</p>
<pre><code class="language-bash">bazel run :bazel-remote  -- --max_size 5 --dir $HOME/work/bazel-remote/temp \
  --http_address localhost:8000 \
  --grpc_address localhost:2024
</code></pre>
<p>To configure sbt 2.x, add the following to <code>project/plugins.sbt</code></p>
<pre><code class="language-scala">addRemoteCachePlugin
</code></pre>
<p>and append the following to <code>build.sbt</code>:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpc://localhost:2024"))
</code></pre>
<h3 id="bazel-remote-with-mtls"><a class="header" href="#bazel-remote-with-mtls">bazel-remote with mTLS</a></h3>
<p>In a real environment, mTLS can ensure that the transport is encrypted and mutually authenticated. bazel-remote can be started with something like the follows:</p>
<pre><code class="language-bash">bazel run :bazel-remote  -- --max_size 5 --dir $HOME/work/bazel-remote/temp \
  --http_address localhost:8000 \
  --grpc_address localhost:2024 \
  --tls_ca_file /tmp/sslcert/ca.crt \
  --tls_cert_file /tmp/sslcert/server.crt \
  --tls_key_file /tmp/sslcert/server.pem
</code></pre>
<p>sbt 2.x setting would look like this in this scenario:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://localhost:2024"))
Global / remoteCacheTlsCertificate := Some(file("/tmp/sslcert/ca.crt"))
Global / remoteCacheTlsClientCertificate := Some(file("/tmp/sslcert/client.crt"))
Global / remoteCacheTlsClientKey := Some(file("/tmp/sslcert/client.pem"))
</code></pre>
<p>Note the <code>grpcs://</code>, as opposed to <code>grpc://</code>.</p>
<h3 id="engflow"><a class="header" href="#engflow">EngFlow</a></h3>
<p><a href="https://www.engflow.com/">EngFlow GmbH</a> is a build solution company founded in 2020 by core members of Bazel team, providing build analytics and remote execution backend for Bazel, which includes remote cache.</p>
<p>After signing up for trial on <a href="https://my.engflow.com/">https://my.engflow.com/</a>, the page instructs you to start a trial cluster using a docker. If you followed the instruction, this should start a remote cache service on port 8080. The sbt 2.x configuration would look like this for the trial cluster:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpc://localhost:8080"))
</code></pre>
<h3 id="buildbuddy"><a class="header" href="#buildbuddy">BuildBuddy</a></h3>
<p><a href="https://www.buildbuddy.io/">BuildBuddy</a> is a build solution company founded by ex-Google engineers, providing build analytics and remote execution backend for Bazel. It's also available open source as <a href="https://github.com/buildbuddy-io/buildbuddy">buildbuddy-io/buildbuddy</a>.</p>
<p>After signing up, BuildBuddy Personal plan lets you use BuildBuddy across the Internet.</p>
<ol>
<li>From <a href="https://app.buildbuddy.io/">https://app.buildbuddy.io/</a>, go to Settings, and change the Organization URL to <code>&lt;something&gt;.buildbuddy.io</code>.</li>
<li>Next, go to Quickstart and take note of the URLs and <code>--remote_headers</code>.</li>
<li>Create a file called <code>$HOME/.sbt/buildbuddy_credential.txt</code> and put in the API key:</li>
</ol>
<pre><code>x-buildbuddy-api-key=*******
</code></pre>
<p>The sbt 2.x configuration would look like this:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://something.buildbuddy.io"))
Global / remoteCacheHeaders += IO.read(BuildPaths.defaultGlobalBase / "buildbuddy_credential.txt").trim
</code></pre>
<h3 id="nativelink"><a class="header" href="#nativelink">NativeLink</a></h3>
<p><a href="https://docs.nativelink.dev/">NativeLink</a> is an open-source Bazel remote execution backend implementated in Rust with emphasis on performance. As of June 2024, there's NativeLink Cloud in beta.</p>
<ol>
<li>From <a href="https://app.nativelink.com/">https://app.nativelink.com/</a>, go to Quickstart and take note of the URLs and <code>--remote_header</code>.</li>
<li>Create a file called <code>$HOME/.sbt/nativelink_credential.txt</code> and put in the API key:</li>
</ol>
<pre><code>x-nativelink-api-key=*******
</code></pre>
<p>The sbt 2.x configuration would look like this:</p>
<pre><code class="language-scala">Global / remoteCache := Some(uri("grpcs://something.build-faster.nativelink.net"))
Global / remoteCacheHeaders += IO.read(BuildPaths.defaultGlobalBase / "nativelink_credential.txt").trim
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifact"><a class="header" href="#artifact">Artifact</a></h1>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>An artifact is a single file ready for publishing a specific version of a subproject. This is a concept that originated in <a href="https://maven.apache.org/ref/3.9.11/maven-core/artifact-handlers.html">Apache Maven</a> and <a href="https://ant.apache.org/ivy/history/2.3.0/terminology.html#artifact">Ivy</a>.</p>
<p>In the JVM ecosystem, common artifacts are Java archives, or JAR files. Compressed package formats are often preferred because they are easier to manage, download, and store.</p>
<p>To illustrate, the following is a list of artifacts for a library, enumerated in an <code>ivy.xml</code> file:</p>
<pre><code class="language-xml">  &lt;publications&gt;
    &lt;artifact name="core_3" type="jar" ext="jar" conf="compile"/&gt;
    &lt;artifact e:classifier="sources" name="core_3" type="src" ext="jar" conf="sources"/&gt;
    &lt;artifact e:classifier="javadoc" name="core_3" type="doc" ext="jar" conf="docs"/&gt;
    &lt;artifact name="core_3" type="pom" ext="pom" conf="pom"/&gt;
  &lt;/publications&gt;
</code></pre>
<p>This shows that an artifact has a name, a type, and an extention, and optionally a classifier.</p>
<ul>
<li><strong>name</strong>. This is going to be the same as the subproject's module name.</li>
<li><strong>type</strong>. The functional category of the artifact, such as <code>jar</code>, <code>src</code>, and <code>doc</code>.</li>
<li><strong>extension</strong>. The file extention, such as <code>jar</code>, <code>war</code>, <code>zip</code>, <code>xml</code> etc.</li>
<li><strong>classifier</strong>. In Maven, classifier is an arbitrary string that can be appended for an alternative or secondary artifact.</li>
</ul>
<h3 id="selecting-default-artifacts"><a class="header" href="#selecting-default-artifacts">Selecting default artifacts</a></h3>
<p>By default, the published artifacts are:</p>
<ol>
<li>The main binary JAR</li>
<li>The JAR containing the main sources and resources</li>
<li>The JAR containing the API documentation</li>
</ol>
<p>You can add artifacts for the test classes, sources, or API or you can disable some of the main artifacts.</p>
<p>To add all <code>Test</code> artifacts:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    Test / publishArtifact := true,
  )
</code></pre>
<p>To add them individually:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // enable publishing the jar produced by `Test/package`
    Test / packageBin / publishArtifact := true,

    // enable publishing the test API jar
    Test / packageDoc / publishArtifact := true,

    // enable publishing the test sources jar
    Test / packageSrc / publishArtifact := true,
  )
</code></pre>
<p>To disable main artifacts individually:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // disable publishing the main jar produced by `package`
    Compile / packageBin / publishArtifact := false,

    // disable publishing the main API jar
    Compile / packageDoc / publishArtifact := false,

    // disable publishing the main sources jar
    Compile / packageSrc / publishArtifact := false,
  )
</code></pre>
<h3 id="modifying-default-artifacts"><a class="header" href="#modifying-default-artifacts">Modifying default artifacts</a></h3>
<p>Each built-in artifact has several configurable settings in addition to <code>publishArtifact</code>. The basic ones are <code>artifact</code> (of type <code>SettingKey[Artifact]</code>), <code>mappings</code> (of type <code>TaskKey[(File, String)]</code>), and <code>artifactPath</code> (of type <code>SettingKey[File]</code>). They are scoped by <code>(Config / &lt;task&gt;)</code> as indicated in the previous section.</p>
<p>To modify the type of the main artifact, for example:</p>
<pre><code class="language-scala">Compile / packageBin / artifact := {
  val prev: Artifact = (Compile / packageBin / artifact).value
  prev.withType("bundle")
}
</code></pre>
<p>The generated artifact name is determined by the <code>artifactName</code> setting. This setting is of type <code>(ScalaVersion, ModuleID, Artifact) =&gt; String</code>. The ScalaVersion argument provides the full Scala version String and the binary compatible part of the version String. The String result is the name of the file to produce. The default implementation is <code>Artifact.artifactName _</code>. The function may be modified to produce different local names for artifacts without affecting the published name, which is determined by the <code>artifact</code> definition combined with the repository pattern.</p>
<p>For example, to produce a minimal name without a classifier or cross path:</p>
<pre><code class="language-scala">artifactName := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =&gt;
  artifact.name + "-" + module.revision + "." + artifact.extension
}
</code></pre>
<p>(Note that in practice you rarely want to drop the classifier.)</p>
<p>Finally, you can get the <code>(Artifact, File)</code> pair for the artifact by mapping the <code>packagedArtifact</code> task. Note that if you don't need the <code>Artifact</code>, you can get just the File from the package task (<code>package</code>, <code>packageDoc</code>, or <code>packageSrc</code>). In both cases, mapping the task to get the file ensures that the artifact is generated first and so the file is guaranteed to be up-to-date.</p>
<p>For example:</p>
<pre><code class="language-scala">val myTask = taskKey[Unit]("My task.")

myTask :=  {
  val (art, file) = (Compile / packageBin / packagedArtifact).value
  println("Artifact definition: " + art)
  println("Packaged file: " + file.getAbsolutePath)
}
</code></pre>
<h3 id="defining-custom-artifacts"><a class="header" href="#defining-custom-artifacts">Defining custom artifacts</a></h3>
<p>In addition to configuring the built-in artifacts, you can declare other artifacts to publish. Multiple artifacts are allowed when using Ivy metadata, but a Maven POM file only supports distinguishing artifacts based on classifiers and these are not recorded in the POM.</p>
<p>Basic <code>Artifact</code> construction look like:</p>
<pre><code class="language-scala">Artifact("name", "type", "extension")
Artifact("name", "classifier")
Artifact("name", url: URL)
Artifact("name", Map("extra1" -&gt; "value1", "extra2" -&gt; "value2"))
</code></pre>
<p>For example:</p>
<pre><code class="language-scala">Artifact("myproject", "zip", "zip")
Artifact("myproject", "image", "jpg")
Artifact("myproject", "jdk15")
</code></pre>
<p>See the <a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency-artifact.html">Ivy documentation</a> for more details on artifacts. See the <a href="reference/../api/sbt/librarymanagement/Artifact$.html">Artifact API</a> for combining the parameters above and specifying [Configurations] and extra attributes.</p>
<p>To declare these artifacts for publishing, map them to the task that generates the artifact:</p>
<pre><code class="language-scala">val myImageTask = taskKey[File](...)

myImageTask := {
  val artifact: File = makeArtifact(...)
  artifact
}

addArtifact(Artifact("myproject", "image", "jpg"), myImageTask)
</code></pre>
<p><code>addArtifact</code> returns a sequence of settings (wrapped in a <a href="reference/../api/sbt/internal/util/Init$SettingsDefinition.html">SettingsDefinition</a>). In a full build configuration, usage looks like:</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    addArtifact(...)
  )
</code></pre>
<h3 id="publishing-war-files"><a class="header" href="#publishing-war-files">Publishing .war files</a></h3>
<p>A common use case for web applications is to publish the <code>.war</code> file instead of the <code>.jar</code> file.</p>
<pre><code class="language-scala">lazy val app = (project in file("app"))
  .settings(
    // disable .jar publishing
    Compile / packageBin / publishArtifact := false,

    // create an Artifact for publishing the .war file
    Compile / packageWar / artifact := {
      val prev: Artifact = (Compile / packageWar / artifact).value
      prev.withType("war").withExtension("war")
    },

    // add the .war file to what gets published
    addArtifact(Compile / packageWar / artifact, packageWar),
  )
</code></pre>
<h3 id="using-dependencies-with-artifacts"><a class="header" href="#using-dependencies-with-artifacts">Using dependencies with artifacts</a></h3>
<p>To specify the artifacts to use from a dependency that has custom or multiple artifacts, use the <code>artifacts</code> method on your dependencies. For example:</p>
<pre><code class="language-scala">libraryDependencies += ("org" % "name" % "rev").artifacts(Artifact("name", "type", "ext"))
</code></pre>
<p>The <code>from</code> and <code>classifer</code> methods (described on the <a href="reference/./sbt-update.html">sbt update</a> page) are actually convenience methods that translate to <code>artifacts</code>:</p>
<pre><code class="language-scala">def from(url: String) = artifacts(Artifact(name, new URL(url)))
def classifier(c: String) = artifacts(Artifact(name, c))
</code></pre>
<p>That is, the following two dependency declarations are equivalent:</p>
<pre><code class="language-scala">libraryDependencies += ("org.testng" % "testng" % "5.7").classifier("jdk15")

libraryDependencies += ("org.testng" % "testng" % "5.7").artifacts(Artifact("testng", "jdk15"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-task"><a class="header" href="#input-task">Input task</a></h1>
<p>sbt provides a capability to define custom tasks that can parse user inputs and offer tab completion. The details of the parser will be covered in <a href="reference/tab-completion-parser.html">tab-completion parser</a> later.</p>
<p>This page describes how to hook those parser combinators into the input task system.</p>
<h2 id="input-keys"><a class="header" href="#input-keys">Input keys</a></h2>
<p>A key for an input task is of type <code>InputKey</code> and represents the input task like a <code>SettingKey</code> represents a setting or a <code>TaskKey</code> represents a task. Define a new input task key using the <code>inputKey.apply</code> factory method:</p>
<pre><code class="language-scala">// goes in project/Build.scala or in build.sbt
val demo = inputKey[Unit]("A demo input task.")
</code></pre>
<p>The definition of an input task is similar to that of a normal task, but it can also use the result of a</p>
<p><a href="reference/tab-completion-parser.html">Parser</a> applied to user input. Just as the special <code>value</code> method gets the value of a setting or task, the special <code>parsed</code> method gets the result of a <code>Parser</code>.</p>
<h2 id="basic-input-task-definition"><a class="header" href="#basic-input-task-definition">Basic input task definition</a></h2>
<p>The simplest input task accepts a space-delimited sequence of arguments. It does not provide useful tab completion and parsing is basic. The built-in parser for space-delimited arguments is constructed via the <code>spaceDelimited</code> method, which accepts as its only argument the label to present to the user during tab completion.</p>
<p>For example, the following task prints the current Scala version and then echoes the arguments passed to it on their own line.</p>
<pre><code class="language-scala">import complete.DefaultParsers.{ *, given }

demo := {
  // get the result of parsing
  val args: Seq[String] = spaceDelimited("&lt;arg&gt;").parsed
  // Here, we also use the value of the `scalaVersion` setting
  println("The current Scala version is " + scalaVersion.value)
  println("The arguments to demo were:")
  args.foreach(println(_))
}
</code></pre>
<h2 id="input-task-using-parsers"><a class="header" href="#input-task-using-parsers">Input task using Parsers</a></h2>
<p>The Parser provided by the <code>spaceDelimited</code> method does not provide any flexibility in defining the input syntax. Using a custom parser is just a matter of defining your own <code>Parser</code> as described on the <a href="reference/tab-completion-parser.html">Parsing Input</a> page.</p>
<h3 id="constructing-the-parser"><a class="header" href="#constructing-the-parser">Constructing the Parser</a></h3>
<p>The first step is to construct the actual <code>Parser</code> by defining a value of one of the following types:</p>
<ol>
<li><code>Parser[I]</code>: a basic parser that does not use any settings</li>
<li><code>Initialize[Parser[I]]</code>: a parser whose definition depends on one or more settings</li>
<li><code>Initialize[State =&gt; Parser[I]]</code>: a parser that is defined using both settings and the current <a href="reference/Build-State.html">state</a></li>
</ol>
<p>We already saw an example of the first case with <code>spaceDelimited</code>, which doesn't use any settings in its definition. As an example of the third case, the following defines a contrived <code>Parser</code> that uses the project's Scala and sbt version settings as well as the state. To use these settings, we need to wrap the Parser construction in <code>Def.setting</code> and get the setting values with the special <code>value</code> method:</p>
<pre><code class="language-scala">import sbt.complete.DefaultParsers.{ *, given }
import sbt.complete.Parser

val parser: Def.Initialize[State =&gt; Parser[(String,String)]] =
Def.setting {
  (state: State) =&gt;
    ( token("scala" &lt;~ Space) ~ token(scalaVersion.value) ) |
    ( token("sbt" &lt;~ Space) ~ token(sbtVersion.value) ) |
    ( token("commands" &lt;~ Space) ~
        token(state.remainingCommands.size.toString) )
}
</code></pre>
<p>This Parser definition will produce a value of type <code>(String,String)</code>. The input syntax defined isn't very flexible; it is just a demonstration. It will produce one of the following values for a successful parse (assuming the current Scala version is 3.7.3, the current sbt version is 2.0.0-RC6, and there are 3 commands left to run):</p>
<ul>
<li>(scala,3.7.3)</li>
<li>(sbt,2.0.0-RC6)</li>
<li>(commands,3)</li>
</ul>
<p>Again, we were able to access the current Scala and sbt version for the project because they are settings. Tasks cannot be used to define the parser.</p>
<h3 id="constructing-the-task"><a class="header" href="#constructing-the-task">Constructing the Task</a></h3>
<p>Next, we construct the actual task to execute from the result of the <code>Parser</code>. For this, we define a task as usual, but we can access the result of parsing via the special <code>parsed</code> method on <code>Parser</code>.</p>
<p>The following contrived example uses the previous example's output (of type <code>(String,String)</code>) and the result of the <code>package</code> task to print some information to the screen.</p>
<pre><code class="language-scala">demo := {
    val (tpe, value) = parser.parsed
    println("Type: " + tpe)
    println("Value: " + value)
    println("Packaged: " + packageBin.value.getAbsolutePath)
}
</code></pre>
<h2 id="the-inputtask-type"><a class="header" href="#the-inputtask-type">The InputTask type</a></h2>
<p>It helps to look at the <code>InputTask</code> type to understand more advanced usage of input tasks. The core input task type is:</p>
<pre><code class="language-scala">class InputTask[A1](val parser: State =&gt; Parser[Task[A1]])
</code></pre>
<p>Normally, an input task is assigned to a setting and you work with <code>Initialize[InputTask[A1]]</code>.</p>
<p>Breaking this down,</p>
<ol>
<li>You can use other settings (via Initialize) to construct an input task.</li>
<li>You can use the current State to construct the parser.</li>
<li>The parser accepts user input and provides tab completion.</li>
<li>The parser produces the task to run.</li>
</ol>
<p>So, you can use settings or <code>State</code> to construct the parser that defines an input task's command line syntax. This was described in the previous section. You can then use settings, <code>State</code>, or user input to construct the task to run. This is implicit in the input task syntax.</p>
<h2 id="using-other-input-tasks"><a class="header" href="#using-other-input-tasks">Using other input tasks</a></h2>
<p>The types involved in an input task are composable, so it is possible to reuse input tasks. The <code>.parsed</code> and <code>.evaluated</code> methods are defined on InputTasks to make this more convenient in common situations:</p>
<ul>
<li>Call <code>.parsed</code> on an <code>InputTask[A1]</code> or <code>Initialize[InputTask[A1]]</code> to get the <code>Task[A1]</code> created after parsing the command line</li>
<li>Call <code>.evaluated</code> on an <code>InputTask[A1]</code> or <code>Initialize[InputTask[A1]]</code> to get the value of type <code>A1</code> from evaluating that task</li>
</ul>
<p>In both situations, the underlying <code>Parser</code> is sequenced with other parsers in the input task definition. In the case of <code>.evaluated</code>, the generated task is evaluated.</p>
<p>The following example applies the <code>run</code> input task, a literal separator parser <code>--</code>, and <code>run</code> again. The parsers are sequenced in order of syntactic appearance, so that the arguments before <code>--</code> are passed to the first <code>run</code> and the ones after are passed to the second.</p>
<pre><code class="language-scala">val run2 = inputKey[Unit](
    "Runs the main class twice with different argument lists separated by --")

val separator: Parser[String] = "--"

run2 := {
   val one = (Compile / run).evaluated
   val sep = separator.parsed
   val two = (Compile / run).evaluated
}
</code></pre>
<p>For a main class Demo that echoes its arguments, this looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; run2 a b -- c d
[info] Running Demo c d
[info] Running Demo a b
c
d
a
b
</code></pre>
<h2 id="preapplying-input"><a class="header" href="#preapplying-input">Preapplying input</a></h2>
<p>Because <code>InputTasks</code> are built from <code>Parsers</code>, it is possible to generate a new <code>InputTask</code> by applying some input programmatically. (It is also possible to generate a <code>Task</code>, which is covered in the next section.) Two convenience methods are provided on <code>InputTask[T]</code> and <code>Initialize[InputTask[T]]</code> that accept the String to apply.</p>
<ul>
<li><code>partialInput</code> applies the input and allows further input, such as from the command line</li>
<li><code>fullInput</code> applies the input and terminates parsing, so that further input is not accepted</li>
</ul>
<p>In each case, the input is applied to the input task's parser. Because input tasks handle all input after the task name, they usually require initial whitespace to be provided in the input.</p>
<p>Consider the example in the previous section. We can modify it so that we:</p>
<ul>
<li>Explicitly specify all of the arguments to the first <code>run</code>. We use <code>name</code> and <code>version</code> to show that settings can be used to define and modify parsers.</li>
<li>Define the initial arguments passed to the second <code>run</code>, but allow further input on the command line.</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/input-task.html#admonition-note"></a>
</div>
<div>
<p>If the input derives from settings you need to use, for
example, <code>Def.taskDyn { ... }.value</code></p>
</div>
</div>
<pre><code class="language-scala">lazy val run2 = inputKey[Unit]("Runs the main class twice: " +
   "once with the project name and version as arguments"
   "and once with command line arguments preceded by hard coded values.")

// The argument string for the first run task is ' &lt;name&gt; &lt;version&gt;'
lazy val firstInput: Initialize[String] =
   Def.setting(s" ${name.value} ${version.value}")

// Make the first arguments to the second run task ' red blue'
lazy val secondInput: String = " red blue"

run2 := {
   val one = (Compile / run).fullInput(firstInput.value).evaluated
   val two = (Compile / run).partialInput(secondInput).evaluated
}
</code></pre>
<p>For a main class Demo that echoes its arguments, this looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; run2 green
[info] Running Demo demo 1.0
[info] Running Demo red blue green
demo
1.0
red
blue
green
</code></pre>
<h2 id="get-a-task-from-an-inputtask"><a class="header" href="#get-a-task-from-an-inputtask">Get a Task from an InputTask</a></h2>
<p>The previous section showed how to derive a new <code>InputTask</code> by applying input. In this section, applying input produces a <code>Task</code>. The <code>toTask</code> method on <code>Initialize[InputTask[A1]]</code> accepts the <code>String</code> input to apply and produces a task that can be used normally. For example, the following defines a plain task <code>runFixed</code> that can be used by other tasks or run directly without providing any input:</p>
<pre><code class="language-scala">lazy val runFixed = taskKey[Unit]("A task that hard codes the values to `run`")

runFixed := {
   val _ = (Compile / run).toTask(" blue green").value
   println("Done!")
}
</code></pre>
<p>For a main class Demo that echoes its arguments, running <code>runFixed</code> looks like:</p>
<pre><code class="language-bash">$ sbt
&gt; runFixed
[info] Running Demo blue green
blue
green
Done!
</code></pre>
<p>Each call to <code>toTask</code> generates a new task, but each task is configured the same as the original <code>InputTask</code> (in this case, <code>run</code>) but with different input applied. For example:</p>
<pre><code class="language-scala">lazy val runFixed2 = taskKey[Unit]("A task that hard codes the values to `run`")

run / fork := true

runFixed2 := {
   val x = (Compile / run).toTask(" blue green").value
   val y = (Compile / run).toTask(" red orange").value
   println("Done!")
}
</code></pre>
<p>The different <code>toTask</code> calls define different tasks that each run the project's main class in a new jvm. That is, the <code>fork</code> setting configures both, each has the same classpath, and each run the same main class. However, each task passes different arguments to the main class. For a main class Demo that echoes its arguments, the output of running <code>runFixed2</code> might look like:</p>
<pre><code class="language-bash">$ sbt
&gt; runFixed2
[info] Running Demo blue green
[info] Running Demo red orange
blue
green
red
orange
Done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-completion-parser"><a class="header" href="#tab-completion-parser">Tab-completion parser</a></h1>
<p>This page describes the parser combinators in sbt. These parsers are used to parse user input and provide tab completion for <a href="reference/input-task.html">input tasks</a> and <a href="reference/../concepts/command.html">commands</a>.</p>
<!--
If you are already familiar with Scala's parser combinators, the methods
are mostly the same except that their arguments are strict. There are
two additional methods for controlling tab completion that are discussed
at the end of the section.
-->
<p>Parser combinators build up a parser from smaller parsers. A <code>Parser[A]</code> in its most basic usage is a function <code>String =&gt; Option[A]</code>. It accepts a <code>String</code> to parse and produces a value wrapped in <code>Some</code> if parsing succeeds or <code>None</code> if it fails. Error handling and tab completion make this picture more complicated, but we'll stick with <code>Option</code> for this discussion.</p>
<h2 id="basic-parsers"><a class="header" href="#basic-parsers">Basic parsers</a></h2>
<p>The simplest parser combinators match exact inputs:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the input is 'x', returning the Char 'x'
//  and failing otherwise
val singleChar: Parser[Char] = 'x'

// A parser that succeeds if the input is "blue", returning the String "blue"
//   and failing otherwise
val litString: Parser[String] = "blue"
</code></pre>
<p>In these examples, implicit conversions produce a literal <code>Parser</code> from a <code>Char</code> or <code>String</code>. Other basic parser constructors are the <code>charClass</code>, <code>success</code> and <code>failure</code> methods:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the character is a digit, returning the matched Char
//   The second argument, "digit", describes the parser and is used in error messages
val digit: Parser[Char] = charClass((c: Char) =&gt; c.isDigit, "digit")

// A parser that produces the value 3 for an empty input string, fails otherwise
val alwaysSucceed: Parser[Int] = success(3)

// Represents failure (always returns None for an input String).
//  The argument is the error message.
val alwaysFail: Parser[Nothing] = failure("Invalid input.")
</code></pre>
<h2 id="built-in-parsers"><a class="header" href="#built-in-parsers">Built-in parsers</a></h2>
<p>sbt comes with several built-in parsers defined in <code>sbt.complete.DefaultParsers</code>. <!-- ../api/sbt/internal/util/complete/DefaultParsers$.html --></p>
<p>Some commonly used built-in parsers are:</p>
<ul>
<li><code>Space</code>, <code>NotSpace</code>, <code>OptSpace</code>, and <code>OptNotSpace</code> for parsing spaces or non-spaces, required or not.</li>
<li><code>StringBasic</code> for parsing text that may be quoted.</li>
<li><code>IntBasic</code> for parsing a signed Int value.</li>
<li><code>Digit</code> and <code>HexDigit</code> for parsing a single decimal or hexadecimal digit.</li>
<li><code>Bool</code> for parsing a <code>Boolean</code> value</li>
</ul>
<p>See the <a href="reference/../api/sbt/internal/util/complete/DefaultParsers$.html">DefaultParsers API</a> for details.</p>
<h2 id="combining-parsers"><a class="header" href="#combining-parsers">Combining parsers</a></h2>
<p>We build on these basic parsers to construct more interesting parsers. We can combine parsers in a sequence, choose between parsers, or repeat a parser.</p>
<pre><code class="language-scala">// A parser that succeeds if the input is "blue" or "green",
//  returning the matched input
val color: Parser[String] = "blue" | "green"

// A parser that matches either "fg" or "bg"
val select: Parser[String] = "fg" | "bg"

// A parser that matches "fg" or "bg", a space, and then the color, returning the matched values.
val setColor: Parser[(String, Char, String)] =
  select ~ ' ' ~ color

// Often, we don't care about the value matched by a parser, such as the space above
//  For this, we can use ~&gt; or &lt;~, which keep the result of
//  the parser on the right or left, respectively
val setColor2: Parser[(String, String)]  =  select ~ (' ' ~&gt; color)

// Match one or more digits, returning a list of the matched characters
val digits: Parser[Seq[Char]] = charClass(_.isDigit, "digit").+

// Match zero or more digits, returning a list of the matched characters
val digits0: Parser[Seq[Char]] = charClass(_.isDigit, "digit").*

// Optionally match a digit
val optDigit: Parser[Option[Char]] = charClass(_.isDigit, "digit").?
</code></pre>
<h2 id="transforming-results"><a class="header" href="#transforming-results">Transforming results</a></h2>
<p>A key aspect of parser combinators is transforming results along the way into more useful data structures. The fundamental methods for this are <code>map</code> and <code>flatMap</code>. Here are examples of <code>map</code> and some convenience methods implemented on top of <code>map</code>.</p>
<pre><code class="language-scala">// Apply the `digits` parser and apply the provided function to the matched
//   character sequence
val num: Parser[Int] = digits.map: (chars: Seq[Char]) =&gt;
  chars.mkString.toInt }

// Match a digit character, returning the matched character or return '0' if the input is not a digit
val digitWithDefault: Parser[Char] = charClass(_.isDigit, "digit") ?? '0'

// The previous example is equivalent to:
val digitDefault: Parser[Char] =
  charClass(_.isDigit, "digit").?.map: (d: Option[Char]) =&gt;
    d.getOrElse('0')

// Succeed if the input is "blue" and return the value 4
val blue = "blue" ^^^ 4

// The above is equivalent to:
val blueM = "blue".map((s: String) =&gt; 4)
</code></pre>
<h2 id="controlling-tab-completion"><a class="header" href="#controlling-tab-completion">Controlling tab completion</a></h2>
<p>Most parsers have reasonable default tab completion behavior. For example, the string and character literal parsers will suggest the underlying literal for an empty input string. However, it is impractical to determine the valid completions for <code>charClass</code>, since it accepts an arbitrary predicate. The <code>examples</code> method defines explicit completions for such a parser:</p>
<pre><code class="language-scala">val digit = charClass(_.isDigit, "digit").examples("0", "1", "2")
</code></pre>
<p>Tab completion will use the examples as suggestions. The other method controlling tab completion is <code>token</code>. The main purpose of <code>token</code> is to determine the boundaries for suggestions. For example, if your parser is:</p>
<pre><code class="language-scala">("fg" | "bg") ~ ' ' ~ ("green" | "blue")
</code></pre>
<p>then the potential completions on empty input are: <code>console fg green fg blue bg green bg blue</code></p>
<p>Typically, you want to suggest smaller segments or the number of suggestions becomes unmanageable. A better parser is:</p>
<pre><code class="language-scala">token( ("fg" | "bg") ~ ' ') ~ token("green" | "blue")
</code></pre>
<p>Now, the initial suggestions would be (with <code>_</code> representing a space): <code>console fg_ bg_</code></p>
<p>Be careful not to overlap or nest tokens, as in <code>token("green" ~ token("blue"))</code>. The behavior is unspecified (and should generate an error in the future), but typically the outer most token definition will be used.</p>
<h2 id="dependent-parsers"><a class="header" href="#dependent-parsers">Dependent parsers</a></h2>
<p>Sometimes a parser must analyze some data and then more data needs to be parsed, and it is dependent on the previous one. The key for obtaining this behaviour is to use the <code>flatMap</code> function.</p>
<p>As an example, it will shown how to select several items from a list of valid ones with completion, but no duplicates are possible.  A space is used to separate the different items.</p>
<pre><code class="language-scala">def select1(items: Iterable[String]) =
  token(Space ~&gt; StringBasic.examples(FixedSetExamples(items)))

def selectSome(items: Seq[String]): Parser[Seq[String]] = {
   select1(items).flatMap: v =&gt;
     val remaining = items.filter(_ != v)
     if remaining.size == 0 then success(v :: Nil)
     else selectSome(remaining).?.map(v +: _.getOrElse(Seq()))
 }
</code></pre>
<p>As you can see, the <code>flatMap</code> function provides the previous value.  With this info, a new parser is constructed for the remaining items.  The <code>map</code> combinator is also used in order to transform the output of the parser.</p>
<p>The parser is called recursively, until it is found the trivial case of no possible choices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-plugins"><a class="header" href="#community-plugins">Community Plugins</a></h1>
<h3 id="the-github-sbt-organization"><a class="header" href="#the-github-sbt-organization">The GitHub sbt Organization</a></h3>
<p>The <a href="https://github.com/sbt">sbt organization</a> is available for use by any sbt plugin. Developers who contribute their plugins into the community organization will still retain control over their repository and its access. The goal of the sbt organization is to organize sbt software into one central location.</p>
<p>A side benefit to using the sbt organization for projects is that you can use gh-pages to host websites under the https://www.scala-sbt.org domain.</p>
<p>The <a href="https://github.com/sbt/sbt-autoplugin.g8">sbt autoplugin giter8 template</a> is a good place to start. This sets up a new sbt plugin project appropriately. The generated <code>README</code> includes a summary of the steps for publishing a new community plugin.</p>
<div id="admonition-plugins-available-for-sbt-2x" class="admonition admonish-note" role="note" aria-labelledby="admonition-plugins-available-for-sbt-2x-title">
<div class="admonition-title">
<div id="admonition-plugins-available-for-sbt-2x-title">
<p>Plugins available for sbt 2.x</p>
</div>
<a class="admonition-anchor-link" href="community-plugins.html#admonition-plugins-available-for-sbt-2x"></a>
</div>
<div>
<p><a href="https://github.com/sbt/website/edit/develop/src/reference/community-plugins.md">[Edit]</a> this page to
submit a pull request that adds
your plugin to the list.</p>
</div>
</div>
<div style="display: none;">
### Code formatter plugins
<ul>
<li><a href="https://scalameta.org/scalafmt/">sbt-scalafmt</a>: code formatting using Scalafmt. <!-- 829 stars --></li>
<li><a href="https://github.com/sbt/sbt-scalariform">sbt-scalariform</a>: code formatting using Scalariform. <!-- 218 stars --></li>
<li><a href="https://github.com/lucidsoftware/neo-sbt-scalafmt">neo-sbt-scalafmt</a>: code formatting using Scalafmt. <!-- 80 stars --></li>
<li><a href="https://github.com/sbt/sbt-java-formatter">sbt-java-formatter</a>: code formatting for Java sources. <!-- 8 stars --></li>
<li><a href="https://github.com/swoval/sbt-source-format">sbt-source-format</a>: code formatting for Java and clang (c/c++/objc) sources. <!-- 1 stars --></li>
<li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of style rules across your company</li>
</ul>
</div>
<div style="display: none;">
<h3 id="one-jar-plugins"><a class="header" href="#one-jar-plugins">One jar plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a>: create über JARs.<!-- 1136 stars --></li>
</ul>
</div>
<div style="display: none;">
<h3 id="verification-plugins"><a class="header" href="#verification-plugins">Verification plugins</a></h3>
<ul>
<li><a href="https://github.com/NiceKingWei/sbt-stainless">sbt-stainless</a>: verify Scala or Dotty code using stainless. <!-- 1 star --></li>
</ul>
<h3 id="language-support-plugins"><a class="header" href="#language-support-plugins">Language support plugins</a></h3>
<ul>
<li><a href="https://github.com/earldouglas/sbt-frege">sbt-frege</a>: build Frege code with sbt. <!-- 47 stars --></li>
<li><a href="https://github.com/tnakamot/sbt-cc">sbt-cc</a>: compile C and C++ source files with sbt.</li>
</ul>
</div>
<h3 id="release-plugins"><a class="header" href="#release-plugins">Release plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-native-packager">sbt-native-packager</a> (<a href="https://sbt-native-packager.readthedocs.io/en/stable/">docs</a>): build native packages (RPM, .deb etc) for your projects. <!-- 1602 stars --></li>
<li><a href="https://github.com/sbt/sbt-release">sbt-release</a>: create a customizable release process. <!-- 652 stars --></li>
<li><a href="https://github.com/sbt/sbt-ci-release">sbt-ci-release</a>: automate Central Repo releases from GitHub Actions. <!-- 302 stars --></li>
<li><a href="https://github.com/sbt/sbt-pgp">sbt-pgp</a>: sign artifacts using PGP/GPG and manage signing keys. <!-- 149 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/xerial/sbt-pack">sbt-pack</a>: create runnable distributions for your projects. <!-- 302 stars --></p>
</li>
<li>
<p><a href="https://github.com/marcuslonnberg/sbt-docker">sbt-docker</a>: create and push Docker images. <!-- 72 stars --></p>
</li>
<li>
<p><a href="https://github.com/arktekk/sbt-aether-deploy">sbt-aether-deploy</a>: publish artefacts using Eclipse Aether. <!-- 59 stars --></p>
</li>
<li>
<p><a href="https://github.com/Verizon/sbt-rig">sbt-rig</a>: opinionated common release steps. <!-- 50 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-s3">sbt-s3</a>: manage objects on Amazon S3.<!-- 36 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-osgi">sbt-osgi</a>: create OSGi bundles.<!-- 32 stars --></p>
</li>
<li>
<p><a href="https://github.com/ohnosequences/sbt-github-release">sbt-github-release</a>: publish Github releases. <!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/Tapad/sbt-hadoop-oss">sbt-hadoop</a>: publish artifacts to the <a href="https://hadoop.apache.org">Hadoop</a> Distributed File System (HDFS).<!-- 6 stars --></p>
</li>
<li>
<p><a href="https://github.com/laughedelic/sbt-publish-more">sbt-publish-more</a>: publish artifacts to several repositories <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/amanjpro/sbt-deploy-plugin">sbt-deploy</a>: create deployable fat JARs. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://chiselapp.com/user/twenstar/repository/sbt-release-fossil">sbt-release-fossil</a>: enhances <a href="https://github.com/sbt/sbt-release">sbt-release</a> to support <a href="https://fossil-scm.org">Fossil</a> repositories</p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-autoversion">sbt-autoversion</a>: automatically set your next version bump based on patterns of your commit message since last release. <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/saint1991/sbt-gcs">sbt-gcs</a>: manage objects on Google Cloud Storage. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/kotobotov/sbt-sourcebundler">sbt-sourcebundler</a>: merge all source code into one scala file. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/vaslabs/sbt-kubeyml">sbt-kubeyml</a>: Create a typesafe kubernetes Deployment based on your project settings</p>
</li>
<li>
<p><a href="https://github.com/hnaderi/sbt-k8s">sbt-k8s</a>: Create any manifest or use provided cookbooks using <a href="https://github.com/hnaderi/scala-k8s">scala-k8s</a> library</p>
</li>
<li>
<p><a href="https://github.com/AmadeusITGroup/sbt-release-notes">sbt-release-notes</a>: provide a Release Step for <a href="https://github.com/sbt/sbt-release">sbt-release</a> to automatically update the release notes file.</p>
</li>
</ul>
</div>
<div style="display: none;">
<h3 id="deployment-integration-plugins"><a class="header" href="#deployment-integration-plugins">Deployment integration plugins</a></h3>
<ul>
<li><a href="https://github.com/heroku/heroku-sbt-plugin">sbt-heroku</a>: deploy applications directly to Heroku. <!-- 86 stars --></li>
<li><a href="https://github.com/Tapad/sbt-docker-compose">sbt-docker-compose</a>: launch Docker images using docker compose. <!-- 86 stars --></li>
<li><a href="https://github.com/sbt/sbt-appengine">sbt-appengine</a> deploy your webapp to Google App Engine. <!-- 65 stars --></li>
<li><a href="https://github.com/Tapad/sbt-marathon">sbt-marathon</a>: deploy applications on Apache Mesos using the <a href="https://mesosphere.github.io/marathon">Marathon</a> framework. <!-- 19 stars --></li>
<li><a href="https://github.com/riot-framework/sbt-riotctl">sbt-riotctl</a>: deploy applications as systemd services directly to a Raspberry Pi, ensuring dependencies (e.g. wiringpi) are met.</li>
<li><a href="https://github.com/tirithel/sbt-kind">sbt-kind</a>: load built docker images into a <a href="https://kind.sigs.k8s.io/">kind</a> cluster.</li>
</ul>
</div>
<h3 id="ide-integration-plugins"><a class="header" href="#ide-integration-plugins">IDE integration plugins</a></h3>
<ul>
<li><a href="https://github.com/JetBrains/sbt-structure">sbt-structure</a>: extract project structure in XML for IntelliJ Scala plugin. <!-- 74 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/sbt/sbteclipse">sbteclipse</a>: Eclipse project definition generator. <!-- 672 stars --></li>
<li><a href="https://github.com/orrsella/sbt-sublime">sbt-sublime</a>: Sublime Text project generator. <!-- 145 stars --></li>
</ul>
</div>
<h3 id="test-plugins"><a class="header" href="#test-plugins">Test plugins</a></h3>
<ul>
<li><a href="https://github.com/stryker-mutator/stryker4s">sbt-stryker4s</a>: Test your tests with mutation testing. <!-- 202 stars --></li>
<li><a href="https://github.com/tkawachi/sbt-doctest">sbt-doctest</a>: generate and run tests from Scaladoc comments. <!-- 120 stars --></li>
<li><a href="https://github.com/xuwei-k/test-times-reporter">test-times-reporter</a>: report slow tests. <!-- 3 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="Testing-sbt-plugins.html">scripted</a>: integration testing for sbt plugins.</li>
<li><a href="https://github.com/ktoso/sbt-jmh">sbt-jmh</a>: run Java Microbenchmark Harness (JMH) benchmarks from sbt. <!-- 403 stars --></li>
<li><a href="https://github.com/gatling/gatling-sbt">gatling-sbt</a>: performance and load-testing using Gatling. <!-- 79 stars --></li>
<li><a href="https://github.com/sbt/sbt-multi-jvm">sbt-multi-jvm</a>: run tests using multiple JVMs. <!-- 36 stars --></li>
<li><a href="https://github.com/scalaprops/sbt-scalaprops">sbt-scalaprops</a>: scalaprops property-based testing integration. <!-- 10 stars --></li>
<li><a href="https://github.com/sbt/sbt-testng">sbt-testng</a>: TestNG framework integration. <!-- 8 stars --></li>
<li><a href="https://github.com/ktoso/sbt-jcstress">sbt-jcstress</a>: Java Concurrency Stress Test (jcstress) integration. <!-- 8 stars --></li>
<li><a href="https://github.com/OlegYch/sbt-cached-ci">sbt-cached-ci</a>: Incremental sbt builds for CI environments. <!-- 0 stars --></li>
</ul>
</div>
<h3 id="library-dependency-plugins"><a class="header" href="#library-dependency-plugins">Library dependency plugins</a></h3>
<ul>
<li><a href="https://github.com/xuwei-k/sbt-conflict-classes">sbt-conflict-classes</a>: show conflict classes in the classpath. <!-- 16 stars --></li>
<li><a href="https://github.com/johanandren/sbt-akka-version-check">sbt-akka-version-check</a>: detect Akka module mismatches and fail build. <!-- 10 stars --></li>
<li><a href="https://github.com/philippus/sbt-license-check">sbt-license-check</a>: check and report on licenses used, fail build for disallowed licenses. <!-- 9 stars --></li>
<li><a href="https://github.com/philippus/sbt-pekko-version-check">sbt-pekko-version-check</a>: check if the Apache Pekko modules match. <!-- 5 stars --></li>
<li><a href="https://github.com/philippus/sbt-jackson-version-check">sbt-jackson-version-check</a>: check if the Jackson modules match. <!-- 3 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/rtimush/sbt-updates">sbt-updates</a>: list updated versions of dependencies. <!-- 361 stars --></li>
<li><a href="https://github.com/frugalmechanic/fm-sbt-s3-resolver">fm-sbt-s3-resolver</a>: resolve and publish artefacts using Amazon S3. <!-- 79 stars --></li>
<li><a href="https://github.com/ohnosequences/sbt-s3-resolver">sbt-s3-resolver</a>: resolve dependencies using Amazon S3. <!-- 73 stars --></li>
<li><a href="https://github.com/albuch/sbt-dependency-check">sbt-dependency-check</a>: check dependencies for known vulnerabilities/CVEs. <!-- 56 stars --></li>
<li><a href="https://github.com/tkawachi/sbt-lock">sbt-lock</a>: create a lock file containing explicit sbt dependencies. <!-- 33 stars --></li>
<li><a href="https://github.com/sbt/sbt-license-report">sbt-license-report</a>: generate reports of licenses used by dependencies. <!-- 25 stars --></li>
<li><a href="https://github.com/sbt/sbt-duplicates-finder">sbt-duplicates-finder</a>: detect class and resources conflicting in your project's classpath. <!-- 13 stars --></li>
<li><a href="https://github.com/lightbend/sbt-google-cloud-storage">sbt-google-cloud-storage</a>: resolver and publisher for Google Cloud Storage.</li>
<li><a href="https://github.com/delprks/sbt-trace">sbt-trace</a>: find traces of the client or library usage in other projects. <!-- 3 stars --></li>
<li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of specified versions of dependencies across your company</li>
<li><a href="https://stringbean.github.io/sbt-dependency-lock">sbt-dependency-lock</a>: generate dependency lockfiles and check for changes at build time.</li>
<li><a href="https://github.com/djice/sbt-unzip-plugin">sbt-unzip</a>: Extract zip dependencies where you want in your project.</li>
</ul>
</div>
<h3 id="web-and-frontend-development-plugins"><a class="header" href="#web-and-frontend-development-plugins">Web and frontend development plugins</a></h3>
<ul>
<li><a href="https://github.com/earldouglas/sbt-war">sbt-war</a>: package and run WAR files <!-- 381 stars --></li>
<li><a href="https://github.com/sbt/sbt-web">sbt-web</a>: library for building sbt plugins for the web. <!-- 314 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://www.playframework.com">Play Framework</a>: reactive web framework for Scala and Java. <!-- 9727 stars --></p>
</li>
<li>
<p><a href="https://www.scala-js.org">Scala.js</a>: Scala to JavaScript compiler.<!-- 3113 stars --></p>
</li>
<li>
<p><a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a>: Servlet support. <!-- 379 stars --></p>
</li>
<li>
<p><a href="https://github.com/vmunier/sbt-web-scalajs">sbt-web-scalajs</a>: use Scala.js with any web server. <!-- 148 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-less">sbt-less</a>: Less CSS compilation support.<!-- 34 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-js-engine">sbt-js-engine</a>: support for sbt plugins that use JavaScript. <!-- 33 stars --></p>
</li>
<li>
<p><a href="https://github.com/joost-de-vries/sbt-typescript">sbt-typescript</a>: TypeScript compilation support. <!-- 25 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-uglify">sbt-uglify</a>: JavaScript minifier using UglifyJS. <!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/andriimartynov/sbt-terser">sbt-terser</a>: JavaScript (ES6+) minifier using terser. <!-- 0 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-digest">sbt-digest</a>: generate checksums of assets. <!-- 18 stars --></p>
</li>
<li>
<p><a href="https://github.com/scalatra/sbt-scalatra">sbt-scalatra</a>: build and run Scalatra apps. <!-- 17 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-scala-js-map">sbt-scala-js-map</a>: Configure source mapping for Scala.js projects hosted on Github. <!-- 16 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-gzip">sbt-gzip</a>: gzip compressor for assets.<!-- 15 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-stylus">sbt-stylus</a>: Stylus stylesheet compiler.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/sake92/sbt-hepek">sbt-hepek</a>: Render static websites directly from Scala code.<!-- 5 stars --></p>
</li>
<li>
<p><a href="https://chiselapp.com/user/twenstar/repository/sbt-puresass">sbt-puresass</a>: <a href="https://github.com/sbt/sbt-web">sbt-web</a> plugin for Sass styles compilation.</p>
</li>
<li>
<p><a href="https://github.com/swachter/scala-ts">sbt-scala-ts</a>; generates TypeScript declaration files from ScalaJS sources and outputs Node modules.</p>
</li>
</ul>
</div>
<h3 id="database-plugins"><a class="header" href="#database-plugins">Database plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/flyway-sbt">flyway-sbt</a> Flyway database migration. <!-- 131 stars --></li>
<li><a href="https://github.com/sbt-dao-generator/sbt-dao-generator">sbt-dao-generator</a> generate code for O/R Mapper Free <!-- 14 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/scalikejdbc/scalikejdbc">scalikejdbc-mapper-generator</a>: Scala code generator from database schema. <!-- 802 stars --></li>
<li><a href="https://github.com/localytics/sbt-dynamodb">sbt-dynamodb</a>: run a local Amazon DynamoDB test instance from sbt. <!-- 41 stars --></li>
<li><a href="https://github.com/LeonhardtDavid/migrations">sbt-migrations</a>: database migrations manager.</li>
</ul>
</div>
<h3 id="code-generator-plugins"><a class="header" href="#code-generator-plugins">Code generator plugins</a></h3>
<ul>
<li>
<p><a href="https://github.com/sbt/sbt-buildinfo">sbt-buildinfo</a>: generate Scala code from sbt setting keys. <!-- 559 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-github-actions">sbt-github-actions</a>: generate GitHub Actions YAML <!-- 197 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-protobuf">sbt-protobuf</a>: protobuf code generator.<!-- 173 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt-teavm/sbt-teavm">sbt-teavm</a>: generate JavaScript and WebAssembly from Java bytecode <!-- 11 stars --></p>
</li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/eed3si9n/scalaxb">sbt-scalaxb</a>: generate model classes from XML schemas and WSDL. <!-- 243 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-header">sbt-header</a>: auto-generate source code file headers (such as copyright notices). <!-- 111 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-boilerplate">sbt-boilerplate</a>: TupleX and FunctionX boilerplate code generator. <!-- 78 stars --></p>
</li>
<li>
<p><a href="https://github.com/cavorite/sbt-avro">sbt-avro</a>: Apache Avro schema and protocol generator. <!-- 66 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-aspectj">sbt-aspectj</a>: AspectJ weaving for sbt.<!-- 62 stars --></p>
</li>
<li>
<p><a href="https://github.com/thesamet/sbt-protoc">sbt-protoc</a>: protobuf code generator using protoc. <!-- 35 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/contraband">sbt-contraband</a> (<a href="https://www.scala-sbt.org/contraband">docs</a>): generate pseudo-case classes from GraphQL schemas. <!-- 34 stars --></p>
</li>
<li>
<p><a href="https://github.com/ihji/sbt-antlr4">sbt-antlr4</a>: run ANTLR v4 from sbt.<!-- 22 stars --></p>
</li>
<li>
<p><a href="https://github.com/xerial/sbt-sql">sbt-sql</a>: generate model classes from SQL. <!-- 15 stars --></p>
</li>
<li>
<p><a href="https://github.com/fiadliel/sbt-partial-unification">sbt-partial-unification</a>: enable partial unification support in Scala (SI-2712). <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/ant8e/sbt-i18n">sbt-i18n</a>: transform your i18n bundles into Scala code. <!-- 1 stars --></p>
</li>
<li>
<p><a href="https://github.com/earldouglas/sbt-lit">sbt-lit</a>: build literate code with sbt.</p>
</li>
<li>
<p><a href="https://github.com/yurique/embedded-files">sbt-embedded-files</a>: generate Scala objects containing the contents of glob-specified files as strings or byte-arrays.</p>
</li>
<li>
<p><a href="https://github.com/scala-ts/scala-ts/">sbt-scala-ts</a>: generate TypeScript code according compiled Scala types (case class, trait, object, ...). <!-- 149 stars --></p>
</li>
</ul>
</div>
<h3 id="static-code-analysis-plugins"><a class="header" href="#static-code-analysis-plugins">Static code analysis plugins</a></h3>
<ul>
<li><a href="https://github.com/wartremover/wartremover">wartremover</a>: flexible Scala linting tool. <!-- 728 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li><a href="https://github.com/scalastyle/scalastyle-sbt-plugin">scalastyle-sbt-plugin</a>: code style checking using Scalastyle. <!-- 114 stars --></li>
<li><a href="https://github.com/sksamuel/sbt-scapegoat">sbt-scapegoat</a>: static analysis using Scapegoat. <!-- 63 stars --></li>
<li><a href="https://github.com/orrsella/sbt-stats">sbt-stats</a>: generate source code statistics (lines of code etc). <!-- 53 stars --></li>
<li><a href="https://scalacenter.github.io/scalafix/">sbt-scalafix</a>: refactoring and linting tool for Scala using Scalafix. <!-- 24 stars --></li>
<li><a href="https://github.com/cb372/sbt-explicit-dependencies">sbt-explicit-dependencies</a>: check that you have declared all your library dependencies correctly <!-- 12 stars --></li>
<li><a href="https://github.com/johanandren/sbt-taglist">sbt-taglist</a>: find tags within source files (such as TODO and FIXME). <!-- 11 stars --></li>
<li><a href="https://github.com/rtimush/sbt-rewarn">sbt-rewarn</a>: always display compilation warnings, despite the incremental compilation. <!-- 11 stars --></li>
<li><a href="https://github.com/xerial/sbt-jcheckstyle">sbt-jcheckstyle</a>: Java code style checking using Checkstyle. <!-- 6 stars --></li>
<li><a href="https://github.com/mwz/sbt-sonar">sbt-sonar</a>: integration with <a href="https://www.sonarqube.org">SonarQube</a>. <!-- 2 stars --></li>
<li><a href="https://github.com/BotTech/scala2plantuml">sbt-scala2plantuml</a>: generates <a href="https://plantuml.com/">PlantUML</a> diagrams from Scala code.</li>
</ul>
</div>
<h3 id="utility-and-system-plugins"><a class="header" href="#utility-and-system-plugins">Utility and system plugins</a></h3>
<ul>
<li>
<p><a href="https://github.com/sbt/sbt-git">sbt-git</a>: run git commands from sbt.<!-- 233 stars --></p>
</li>
<li>
<p><a href="https://github.com/philippus/sbt-dotenv">sbt-dotenv</a>: load environment variables from .env into the JVM System Environment for local development. <!-- 189 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-dynver">sbt-dynver</a>: set project version dynamically from git metadata. <!-- 87 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-nocomma">sbt-nocomma</a>: reduce commas. <!-- 13 stars --></p>
</li>
<li>
<p><a href="https://github.com/xuwei-k/sbt-jshell">sbt-jshell</a>: Java REPL for sbt.<!-- 10 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-vimquit">sbt-vimquit</a>: adds <code>:q</code> command. <!-- 6 stars --></p>
</li>
</ul>
<div style="display: none;">
- [sbt-revolver](https://github.com/spray/sbt-revolver): auto-restart forked
  JVMs on update. <!-- 563 stars -->
- [sbt-conscript](https://github.com/foundweekends/conscript)
  ([docs](https://www.foundweekends.org/conscript/)): distribute apps using
  GitHub and Maven Central. <!-- 467 stars -->
- [sbt-errors-summary](https://github.com/Duhemm/sbt-errors-summary): show a
  summary of compilation errors. <!-- 145 stars -->
- [MiMa](https://github.com/lightbend/mima): binary
  compatibility management for Scala libraries. <!-- 134 stars -->
- [sbt-groll](https://github.com/sbt/sbt-groll): navigate git history inside
  sbt. <!-- 100 stars -->
- [sbt-prompt](https://github.com/agemooij/sbt-prompt): add promptlets and
  themes to your sbt prompt. <!-- 75 stars -->
- [sbt-crossproject](https://github.com/portable-scala/sbt-crossproject):
  cross-build Scala, Scala.js and Scala Native. <!-- 66 stars -->
- [sbt-proguard](https://github.com/sbt/sbt-proguard): run ProGuard on
  compiled sources. <!-- 63 stars -->
- [sbt-jni](https://github.com/sbt/sbt-jni): helpers for working with
  projects that use JNI. <!-- 51 stars -->
- [sbt-jol](https://github.com/ktoso/sbt-jol): inspect OpenJDK Java Object
  Layout from sbt. <!-- 48 stars -->
- [sbt-musical](https://github.com/tototoshi/sbt-musical): control iTunes
  from sbt (Mac only). <!-- 47 stars -->
- [sbt-travisci](https://github.com/dwijnand/sbt-travisci): integration
  with Travis CI. <!-- 33 stars -->
- [horder](https://github.com/romanowski/hoarder): cache compilation
  artefacts for future builds. <!-- 31 stars -->
- [sbt-javaagent](https://github.com/sbt/sbt-javaagent): add Java agents to
  projects. <!-- 13 stars -->
<ul>
<li>
<p><a href="https://github.com/jeffreyolchovy/sbt-check">sbt-check</a>: compile up to, and including, the typer phase. <!-- 10 stars --></p>
</li>
<li>
<p><a href="https://github.com/ChristopherDavenport/sbt-mima-version-check">sbt-mima-version-check</a>: Automate which Mima Versions to Check <!-- 6 stars --></p>
</li>
<li>
<p><a href="https://github.com/cuzfrog/sbt-tmpfs">sbt-tmpfs</a>: utilize tmpfs to speed up builds. <!-- 4 stars --></p>
</li>
<li>
<p><a href="https://github.com/melezov/sbt-sh">sbt-sh</a>: run shell commands from sbt.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-ammonite-classpath">sbt-ammonite-classpath</a>: export classpath for <a href="https://ammonite.io/">Ammonite</a> and <a href="https://almond.sh/">Almond</a>.<!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/isomarcte/sbt-version-scheme-enforcer">sbt-version-scheme-enforcer-plugin</a>: Derive Mima settings for your library from your declared <code>versionScheme</code>. This supports Early SemVer, Strict SemVer, and Package Versioning Policy (PVP).</p>
</li>
</ul>
</div>
<h3 id="documentation-plugins"><a class="header" href="#documentation-plugins">Documentation plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-unidoc">sbt-unidoc</a>: create unified API documentation across subprojects. <!-- 126 stars --></li>
<li><a href="https://github.com/xuwei-k/sbt-class-diagram">sbt-class-diagram</a>: generate class diagrams from Scala source code. <!-- 100 stars --></li>
</ul>
<div style="display: none;">
<ul>
<li>
<p><a href="https://github.com/tpolecat/tut">tut</a>: documentation and tutorial generator.<!-- 409  stars --></p>
</li>
<li>
<p><a href="https://github.com/planet42/Laika">Laika</a>: Transform Markdown or reStructuredText into HTML or PDF with Templating.<!-- 161 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-site">sbt-site</a>: site generator.<!-- 131 stars --></p>
</li>
<li>
<p><a href="https://github.com/47degrees/sbt-microsites">sbt-microsites</a>: generate and publish microsites using Jekyll. <!-- 125 stars --></p>
</li>
<li>
<p><a href="https://github.com/sbt/sbt-ghpages">sbt-ghpages</a>: publish generated sites to GitHub pages. <!-- 71 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-api-mappings">sbt-api-mappings</a>: generate Scaladoc <code>apiMappings</code> for common Scala libraries. <!-- 49 stars --></p>
</li>
<li>
<p><a href="https://github.com/laughedelic/literator">literator</a>: generate literate-style markdown docs from your sources. <!-- 33 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-example">sbt-example</a>: generate ScalaTest test suites from examples in Scaladoc. <!-- 17 stars --></p>
</li>
<li>
<p><a href="https://github.com/ThoughtWorksInc/sbt-delombok">sbt-delombok</a>: delombok Java sources files that contain Lombok annotations to make Javadoc contain Lombok-generated classes and methods. <!-- 2 stars --></p>
</li>
<li>
<p><a href="https://github.com/glngn/sbt-alldocs">sbt-alldocs</a>: collect all the docs for a project and dependencies into a single folder.</p>
</li>
<li>
<p><a href="https://github.com/valydia/sbt-apidoc">sbt-apidoc</a>: A port of <a href="https://apidocjs.com">apidocjs</a> to sbt, to document REST Api. <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/Kevin-Lee/sbt-github-pages">sbt-github-pages</a> (<a href="https://kevin-lee.github.io/sbt-github-pages">docs</a>): publish a website to GitHub Pages with minimal effort - works well with GitHub Actions.</p>
</li>
<li>
<p><a href="https://github.com/Kevin-Lee/sbt-docusaur">sbt-docusaur</a> (<a href="https://kevin-lee.github.io/sbt-docusaur">docs</a>): build a website using Docusaurus and publish to GitHub Pages with minimal effort - works well with GitHub Actions.</p>
</li>
<li>
<p><a href="https://github.com/cchantep/sbt-hl-compiler/">sbt-hl-compiler</a>: compile the code snippets from documentation (to keep it consistent). <!-- 1 star --></p>
</li>
<li>
<p><a href="https://github.com/cchantep/sbt-scaladoc-compiler/">sbt-scaladoc-compiler</a>: compile the code snippets included in Scaladoc comments. <!-- 2 stars --></p>
</li>
</ul>
</div>
<div style="display: none;">
### Code coverage plugins
<ul>
<li><a href="https://github.com/scoverage/sbt-scoverage">sbt-scoverage</a>: Scala code coverage using Scoverage. <!-- 347 stars --></li>
<li><a href="https://github.com/sbt/sbt-jacoco">sbt-jacoco</a>: Scala and Java code coverage using JaCoCo. <!-- 76 stars --></li>
</ul>
<h3 id="create-new-project-plugins"><a class="header" href="#create-new-project-plugins">Create new project plugins</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt-fresh">sbt-fresh</a>: create an opinionated fresh sbt project. <!-- 177 stars --></li>
</ul>
</div>
<div style="display: none;">
<h3 id="framework-specific-plugins"><a class="header" href="#framework-specific-plugins">Framework-specific plugins</a></h3>
<ul>
<li><a href="https://github.com/gilt/sbt-newrelic">sbt-newrelic</a>: NewRelic support for artefacts built with sbt-native-packager. <!-- 73 stars --></li>
<li><a href="https://github.com/alonsodomin/sbt-spark">sbt-spark</a>: Spark application configurator. <!-- 7 stars --></li>
<li><a href="https://github.com/sirocchj/sbt-api-builder">sbt-api-builder</a>: support for ApiBuilder from within sbt's shell. <!-- 1 star --></li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>The recipe section of the documentation focuses on the objectives with minimal explanations.</p>
<p>If you are new to sbt, see <a href="recipes/../sbt-by-example.html">sbt by example</a> and <a href="recipes/../guide/index.html">Getting Started</a> section first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-hello-world"><a class="header" href="#how-to-write-hello-world">How to write hello world</a></h1>
<h2 id="objective"><a class="header" href="#objective">Objective</a></h2>
<p>I want to write a hello world program in Scala, and run it.</p>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Create a fresh directory, like <code>hello_scala/</code></p>
</li>
<li>
<p>Create a directory named <code>project/</code> under <code>hello_scala/</code>, and create <code>project/build.properties</code> with</p>
<pre><code>sbt.version=2.0.0-RC6
</code></pre>
</li>
<li>
<p>Under <code>hello_scala/</code>, create <code>build.sbt</code>:</p>
<pre><code class="language-scala">scalaVersion := "3.7.3"
</code></pre>
</li>
<li>
<p>Under <code>hello_scala/</code>, create <code>Hello.scala</code>:</p>
<pre><code class="language-scala"> @main def main(args: String*): Unit =
   println(s"Hello ${args.mkString}")
</code></pre>
</li>
<li>
<p>Navigate to <code>hello_scala/</code> from the terminal, and run <code>sbt</code>:</p>
<pre><code class="language-bash">$ sbt
</code></pre>
</li>
<li>
<p>When the prompt appears, type <code>run</code>:</p>
<pre><code class="language-scala">sbt:hello_scala&gt; run
</code></pre>
</li>
<li>
<p>Type <code>exit</code> to exit the sbt shell:</p>
<pre><code class="language-scala">sbt:hello_scala&gt; exit
</code></pre>
</li>
</ol>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>When you're in a hurry, you can run <code>sbt init</code> in a fresh directory, and select the first template.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-to-the-central-repo"><a class="header" href="#publishing-to-the-central-repo">Publishing to the Central Repo</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/central.html#admonition-note"></a>
</div>
<div>
<p>The recipe section of the documentation focuses on the objectives
with minimal explanations.</p>
<p>See also Sonatype's [Publish guides][sonatype-central-portal-register] for general concepts around publishing to the Central Portal.</p>
</div>
</div>
<h2 id="objective-1"><a class="header" href="#objective-1">Objective</a></h2>
<p>I want to publish my project to the Central Repository.</p>
<h2 id="steps-1"><a class="header" href="#steps-1">Steps</a></h2>
<h3 id="preliminary-1-central-portal-registration"><a class="header" href="#preliminary-1-central-portal-registration">Preliminary 1: Central Portal registration</a></h3>
<p>Create a Central Portal account, following Sonatype's <a href="https://central.sonatype.org/register/central-portal/">Publish guides</a>.</p>
<ul>
<li>If you had an OSSRH account, use <strong>Forgot password</strong> flow to convert the account to the new Central Portal, which lets you keep the previous namespace associations.</li>
<li>If you authenticate via GitHub, <code>io.github.&lt;user_name&gt;</code> will automatically be associated with the account.</li>
</ul>
<p>Follow the steps described in <a href="https://central.sonatype.org/register/namespace/">register a namespace</a> guide to associate a domain name with your account.</p>
<h4 id="preliminary-2-pgp-key-pair"><a class="header" href="#preliminary-2-pgp-key-pair">Preliminary 2: PGP key pair</a></h4>
<p>Follow the Sonatype's <a href="https://central.sonatype.org/publish/requirements/gpg/">GPG guide</a> to generate a PGP key pair.</p>
<p><a href="https://www.gnupg.org/download/">Install GnuPG</a>, and verify the version:</p>
<pre><code class="language-bash">$ gpg --version
gpg (GnuPG/MacGPG2) 2.2.8
libgcrypt 1.8.3
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;
</code></pre>
<p>Next generate a key:</p>
<pre><code>$ gpg --gen-key
</code></pre>
<p>List the keys:</p>
<pre><code>$ gpg --list-keys

/home/foo/.gnupg/pubring.gpg
------------------------------

pub   rsa4096 2018-08-22 [SC]
      1234517530FB96F147C6A146A326F592D39AAAAA
uid           [ultimate] your name &lt;you@example.com&gt;
sub   rsa4096 2018-08-22 [E]
</code></pre>
<p>Distribute the key:</p>
<pre><code>$ gpg --keyserver keyserver.ubuntu.com --send-keys 1234517530FB96F147C6A146A326F592D39AAAAA
</code></pre>
<h3 id="step-1-sbt-pgp"><a class="header" href="#step-1-sbt-pgp">Step 1: sbt-pgp</a></h3>
<p>The <a href="https://github.com/sbt/sbt-pgp#sbt-pgp">sbt-pgp plugin</a> can sign the published artifacts with GPG/PGP. (Optionally <a href="https://github.com/sbt/sbt-ci-release">sbt-ci-release</a> can automate the publishing process.)</p>
<p>Add the following line to your <code>project/plugins.sbt</code> file to enable it for your build:</p>
<pre><code class="language-scala">addSbtPlugin("com.github.sbt" % "sbt-pgp" % "2.3.1")
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/central.html#admonition-note-1"></a>
</div>
<div>
<p>Make sure that the <code>gpg</code> command is in PATH available to the sbt.</p>
</div>
</div>
<h3 id="step-2-credentials"><a class="header" href="#step-2-credentials">Step 2: Credentials</a></h3>
<p>Generate a user token from the portal to be used for the credentials. The token must be stored somewhere safe (NOT in the repository).</p>
<p>sbt 2.x can also reads from the environment variables <code>SONATYPE_USERNAME</code> and <code>SONATYPE_PASSWORD</code> and appends a credential for <code>central.sonatype.com</code> out-of-box, which might be useful for automatic publishing from the CI environment, such as GitHub Actions.</p>
<pre><code class="language-yaml">- run: sbt ci-release
  env:
    PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
    PGP_SECRET: ${{ secrets.PGP_SECRET }}
    SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
    SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}
</code></pre>
<p>On a local machine, a common convention is a <code>$HOME/.sbt/2/credentials.sbt</code> file, with the following:</p>
<pre><code class="language-scala">credentials += Credentials(Path.userHome / ".sbt" / "sonatype_central_credentials")
</code></pre>
<p>Next create a file <code>$HOME/.sbt/sonatype_central_credentials</code>:</p>
<pre><code class="language-property">host=central.sonatype.com
user=&lt;your username&gt;
password=&lt;your password&gt;
</code></pre>
<h3 id="step-3-configure-buildsbt"><a class="header" href="#step-3-configure-buildsbt">Step 3: Configure build.sbt</a></h3>
<p>To publish to a Maven repository, you'll need to configure a few settings so that the correct metadata is generated.</p>
<p><strong>Note</strong>: To publish to the Central Portal, <code>publishTo</code> must be set to the <code>localStaging</code> repository:</p>
<pre><code class="language-scala">// new setting for the Central Portal
publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<p>Add these settings at the end of <code>build.sbt</code> or a separate <code>publish.sbt</code>:</p>
<pre><code class="language-scala">organization := "com.example.project2"
organizationName := "example"
organizationHomepage := Some(url("http://example.com/"))

scmInfo := Some(
  ScmInfo(
    url("https://github.com/your-account/your-project"),
    "scm:git@github.com:your-account/your-project.git"
  )
)
developers := List(
  Developer(
    id = "Your identifier",
    name = "Your Name",
    email = "your@email",
    url = url("http://your.url")
  )
)

description := "Some description about your project."
licenses := List(License.Apache2)
homepage := Some(url("https://github.com/example/project"))

// Remove all additional repository other than Maven Central from POM
pomIncludeRepository := { _ =&gt; false }
publishMavenStyle := true

// new setting for the Central Portal
publishTo := {
  val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
  if version.value.endsWith("-SNAPSHOT") then Some("central-snapshots" at centralSnapshots)
  else localStaging.value
}
</code></pre>
<p>The full format of a <code>pom.xml</code> (an end product of the project configuration used by Maven) file is outlined in <a href="https://maven.apache.org/pom.html">POM Reference</a>. You can add more data to it with the <code>pomExtra</code> option in <code>build.sbt</code>.</p>
<h3 id="step-4-stage-the-artifacts"><a class="header" href="#step-4-stage-the-artifacts">Step 4: Stage the artifacts</a></h3>
<p>From sbt shell run:</p>
<pre><code class="language-bash">&gt; publishSigned
</code></pre>
<h3 id="step-5-upload-or-release-the-bundle"><a class="header" href="#step-5-upload-or-release-the-bundle">Step 5: Upload or release the bundle</a></h3>
<p>From sbt shell run:</p>
<pre><code class="language-bash">&gt; sonaUpload
</code></pre>
<p>This will upload the bundle to the <a href="https://central.sonatype.com/">Central Portal</a>. Hit the "Publish" button to publish to the Central Repository.</p>
<p>If you want to automate the publishing, run:</p>
<pre><code class="language-bash">&gt; sonaRelease
</code></pre>
<p>It might take 10 minutes to a few hours for the published artifacts to be visible on the Central Repository <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a>.</p>
<!--
### Optional steps

#### Publishing SNAPSHOTs

In general, the use of SNAPSHOT artifacts should be limited to short-term testing,
and we do not recommend publishing SNAPSHOTs publicly.
However, should you decide to publish SNAPSHOTs, you can enable it from the Central Portal per namespace.
See Sonatype's [Publishing -SNAPSHOT Releases][publish-portal-snapshots] guide for details.

#### Tag-based publishing via sbt-ci-release

You can further optimize the publishing flow by using the [sbt-ci-release][sbt-ci-release] plugin.

Once you set it up, all you have to do is push a git tag to trigger a release.

#### Integrate with the release process

To automate the publishing approach above with the [sbt-release plugin]
[sbt-release], you should simply add the publishing commands as steps in the
`releaseProcess` task:

```
...
releaseStepCommand("sonatypeOpen \"your groupId\" \"Some staging name\""),
...
releaseStepCommand("publishSigned"),
...
releaseStepCommand("sonaRelease"),
...
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-sbt-as-metals-build-server"><a class="header" href="#use-sbt-as-metals-build-server">Use sbt as Metals build server</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="recipes/use-sbt-as-metals-build-server.html#admonition-warning"></a>
</div>
<div>
<p>This is a draft documentation of sbt 2.x that is yet to be released.
This is a placeholder, copied from sbt 1.x.</p>
</div>
</div>
<h2 id="objective-2"><a class="header" href="#objective-2">Objective</a></h2>
<p>I want to use <a href="https://scalameta.org/metals/">Metals</a> on VS Code with sbt as the build server.</p>
<h2 id="steps-2"><a class="header" href="#steps-2">Steps</a></h2>
<p>To use Metals on VS Code:</p>
<ol>
<li>Install Metals from Extensions tab:<br> <img src="recipes/../files/metals0.png" alt="Metals" /></li>
<li>Open a directory containing a <code>build.sbt</code> file.</li>
<li>From the menubar, run View &gt; Command Palette... (<code>Cmd-Shift-P</code> on macOS) "Metals: Switch build server", and select "sbt"<br> <img src="recipes/../files/metals2.png" alt="Metals" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works:<br> <img src="recipes/../files/metals3.png" alt="Metals" /></li>
</ol>
<p>Use the following setting to opt-out some of the subprojects from BSP.</p>
<pre><code class="language-scala">bspEnabled := false
</code></pre>
<p>When you make changes to the code and save them (<code>Cmd-S</code> on macOS), Metals will invoke sbt to do the actual building work.</p>
<h4 id="interactive-debugging-on-vs-code"><a class="header" href="#interactive-debugging-on-vs-code">Interactive debugging on VS Code</a></h4>
<ol>
<li>Metals supports interactive debugging by setting break points in the code:<br> <img src="recipes/../files/metals4.png" alt="Metals" /></li>
<li>Interactive debugging can be started by right-clicking on an unit test, and selecting "Debug Test." When the test hits a break point, you can inspect the values of the variables:<br> <img src="recipes/../files/metals5.png" alt="Metals" /></li>
</ol>
<p>See <a href="https://code.visualstudio.com/docs/editor/debugging">Debugging</a> page on VS Code documentation for more details on how to navigate an interactive debugging session.</p>
<h4 id="logging-into-sbt-session"><a class="header" href="#logging-into-sbt-session">Logging into sbt session</a></h4>
<p>While Metals uses sbt as the build server, we can also log into the same sbt session using a thin client.</p>
<ul>
<li>From Terminal section, type in <code>sbt --client</code><br> <img src="recipes/../files/metals6.png" alt="Metals" /></li>
</ul>
<p>This lets you log into the sbt session Metals has started. In there you can call <code>testOnly</code> and other tasks with the code already compiled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-to-intellij-idea"><a class="header" href="#import-to-intellij-idea">Import to IntelliJ IDEA</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="recipes/import-to-intellij.html#admonition-warning"></a>
</div>
<div>
<p>This is a draft documentation of sbt 2.x that is yet to be released.
This is a placeholder, copied from sbt 1.x.</p>
</div>
</div>
<h2 id="objective-3"><a class="header" href="#objective-3">Objective</a></h2>
<p>I want to import sbt build to IntelliJ IDEA.</p>
<h2 id="steps-3"><a class="header" href="#steps-3">Steps</a></h2>
<p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is an IDE created by JetBrains, and the Community Edition is open source under Apache v2 license. IntelliJ integrates with many build tools, including sbt, to import the project.</p>
<p>To import a build to IntelliJ IDEA:</p>
<ol>
<li>Install Scala plugin on the Plugins tab:<br> <img src="recipes/../files/intellij1.png" alt="IntelliJ" /></li>
<li>From Projects, open a directory containing a <code>build.sbt</code> file.<br> <img src="recipes/../files/intellij2.png" alt="IntelliJ" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works.</li>
</ol>
<p>IntelliJ Scala plugin uses its own lightweight compilation engine to detect errors, which is fast but sometimes incorrect. Per <a href="https://blog.jetbrains.com/scala/2021/07/27/intellij-scala-plugin-2021-2/#Compiler-based_highlighting">compiler-based highlighting</a>, IntelliJ can be configured to use the Scala compiler for error highlighting.</p>
<h3 id="interactive-debugging-with-intellij-idea"><a class="header" href="#interactive-debugging-with-intellij-idea">Interactive debugging with IntelliJ IDEA</a></h3>
<ol>
<li>IntelliJ supports interactive debugging by setting break points in the code:<br> <img src="recipes/../files/intellij4.png" alt="IntelliJ" /></li>
<li>Interactive debugging can be started by right-clicking on an unit test, and selecting "Debug '&lt;test name&gt;'." Alternatively, you can click the green "run" icon on the left part of the editor near the unit test. When the test hits a break point, you can inspect the values of the variables:<br> <img src="recipes/../files/intellij5.png" alt="IntelliJ" /></li>
</ol>
<p>See <a href="https://www.jetbrains.com/help/idea/debugging-code.html">Debug Code</a> page on IntelliJ documentation for more details on how to navigate an interactive debugging session.</p>
<h2 id="alternative"><a class="header" href="#alternative">Alternative</a></h2>
<h3 id="using-sbt-as-intellij-idea-build-server-advanced"><a class="header" href="#using-sbt-as-intellij-idea-build-server-advanced">Using sbt as IntelliJ IDEA build server (advanced)</a></h3>
<p>Importing the build to IntelliJ means that you're effectively using IntelliJ as the build tool and the compiler while you code (see also <a href="https://blog.jetbrains.com/scala/2021/07/27/intellij-scala-plugin-2021-2/#Compiler-based_highlighting">compiler-based highlighting</a>). While many users are happy with the experience, depending on the code base some of the compilation errors may be false, it may not work well with plugins that generate sources, and generally you might want to code with the identical build semantics as sbt. Thankfully, modern IntelliJ supports alternative <em>build servers</em> including sbt via the <a href="https://build-server-protocol.github.io/">Build Server Protocol</a> (BSP).</p>
<p>The benefit of using BSP with IntelliJ is that you're using sbt to do the actual build work, so if you are the kind of programmer who had sbt session up on the side, this avoids double compilation.</p>
<table class="table table-striped">
  <tr>
    <th><nobr></th>
    <th>Import to IntelliJ</th>
    <th>BSP with IntelliJ</th>
  </tr>
  <tr>
    <td>Reliability</td>
    <td>✅ Reliable behavior</td>
    <td>⚠️ Less mature. Might encounter UX issues.</td>
  </tr>
  <tr>
    <td>Responsiveness</td>
    <td>✅</td>
    <td>⚠️</td>
  </tr>
  <tr>
    <td>Correctness</td>
    <td>⚠️ Uses its own compiler for type checking, but can be configured to use scalac</td>
    <td>✅ Uses Zinc + Scala compiler for type checking</td>
  </tr>
  <tr>
    <td>Generated source</td>
    <td>❌ Generated source requires resync</td>
    <td>✅</td>
  </tr>
  <tr>
    <td>Build reuse</td>
    <td>❌ Using sbt side-by-side requires double build</td>
    <td>✅</td>
  </tr>
</table>
<p>To use sbt as build server on IntelliJ:</p>
<ol>
<li>Install Scala plugin on the Plugins tab.</li>
<li>To use the BSP approach, do not use Open button on the Project tab:<br> <img src="recipes/../files/intellij7.png" alt="IntelliJ" /></li>
<li>From menubar, click New &gt; "Project From Existing Sources", or Find Action (<code>Cmd-Shift-P</code> on macOS) and type "Existing" to find "Import Project From Existing Sources":<br> <img src="recipes/../files/intellij8.png" alt="IntelliJ" /></li>
<li>Open a <code>build.sbt</code> file. Select <strong>BSP</strong> when prompted:<br> <img src="recipes/../files/intellij9.png" alt="IntelliJ" /></li>
<li>Select <strong>sbt (recommended)</strong> as the tool to import the BSP workspace:<br> <img src="recipes/../files/intellij10.png" alt="IntelliJ" /></li>
<li>Once the import process is complete, open a Scala file to see that code completion works:<br> <img src="recipes/../files/intellij11.png" alt="IntelliJ" /></li>
</ol>
<p>Use the following setting to opt-out some of the subprojects from BSP.</p>
<pre><code class="language-scala">bspEnabled := false
</code></pre>
<ul>
<li>Open Preferences, search BSP and check "build automatically on file save", and uncheck "export sbt projects to Bloop before import":<br> <img src="recipes/../files/intellij12.png" alt="IntelliJ" /></li>
</ul>
<p>When you make changes to the code and save them (<code>Cmd-S</code> on macOS), IntelliJ will invoke sbt to do the actual building work.</p>
<p>See also Igal Tabachnik's <a href="https://hmemcpy.com/2021/09/bsp-and-intellij/">Using BSP effectively in IntelliJ and Scala</a> for more details.</p>
<h4 id="logging-into-sbt-session-1"><a class="header" href="#logging-into-sbt-session-1">Logging into sbt session</a></h4>
<p>We can also log into the existing sbt session using the thin client.</p>
<ul>
<li>From Terminal section, type in <code>sbt --client</code> <img src="recipes/../files/intellij6.png" alt="IntelliJ" /></li>
</ul>
<p>This lets you log into the sbt session IntelliJ has started. In there you can call <code>testOnly</code> and other tasks with the code already compiled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-dependency-plugin"><a class="header" href="#source-dependency-plugin">Source dependency plugin</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="recipes/source-dependency-plugin.html#admonition-note"></a>
</div>
<div>
<p>The recipe section of the documentation focuses on the objectives
with minimal explanations.</p>
</div>
</div>
<h2 id="objective-4"><a class="header" href="#objective-4">Objective</a></h2>
<p>I want to use a plugin hosted on a git repository, without publishing to the Central Repo.</p>
<h2 id="steps-4"><a class="header" href="#steps-4">Steps</a></h2>
<ol>
<li>
<p>Host an sbt 2.x plugin on a git repository, built using sbt 2.x.</p>
</li>
<li>
<p>Add the following to <code>project/plugins.sbt</code>:</p>
<pre><code class="language-scala">// In project/plugins.sbt
lazy val jmhRef = ProjectRef(
  uri("https://github.com/eed3si9n/sbt-jmh.git#303c3e98e1d1523e6a4f99abe09c900165028edb"),
  "plugin")
BareBuildSyntax.dependsOn(jmhRef)
</code></pre>
</li>
<li>
<p>When you start sbt, it will automatically clone the repository under <code>$HOME/.sbt/2/staging/</code>.</p>
</li>
</ol>
<p>In the above, <code>https://github.com/eed3si9n/sbt-jmh.git</code> is the HTTP endpoint for a plugin hosted on GitHub, and <code>303c3e98e1d1523e6a4f99abe09c900165028edb</code> is a commit id on the default branch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="symbols"><a class="header" href="#symbols">Symbols</a></h2>
<h3 id="--"><a class="header" href="#--"><code>:=</code>, <code>+=</code>, <code>++=</code></a></h3>
<p>These construct a <a href="appendix/../../../../1.x/api/sbt/internal/util/Init$Setting.html">Setting</a>, which is the fundamental type in the <a href="appendix/../guide/build-definition-basics.html">settings</a> system.</p>
<h3 id=""><a class="header" href="#"><code>%</code></a></h3>
<p>This is used to build up a <a href="appendix/../../../../1.x/api/sbt/librarymanagement/ModuleID.html">ModuleID</a>.</p>
<h3 id="-1"><a class="header" href="#-1"><code>%%</code></a></h3>
<p>This is similar to <code>%</code> except that it identifies a dependency that has been <a href="appendix/../concepts/cross-building.html">cross built</a>.</p>
<h3 id="-2"><a class="header" href="#-2"><code>%%%</code></a></h3>
<p>This is defined in <a href="https://github.com/portable-scala/sbt-platform-deps">sbt-platform-deps</a> in sbt 1.x.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<h3 id="command-1"><a class="header" href="#command-1">Command</a></h3>
<p>A system-level building block of sbt, often used to capture user interaction or IDE interaction. See <a href="appendix/../concepts/command.html">Command</a>.</p>
<h3 id="cross-building-1"><a class="header" href="#cross-building-1">Cross building</a></h3>
<p>The idea of building multiple targets from the same set of source file. This includes Scala cross building, targetting multiple versions of Scala releases; platform cross building, targetting JVM, Scala.JS, and Scala Native; and custom virtual axis like Spark versions.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<h3 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency resolution</a></h3>
<p>During library management, when multiple version candidates (e.g. <code>foo:2.2.0</code> and <code>foo:3.0.0</code>) are found for a library <code>foo</code> within a dependency graph, it is called a <em>dependency conflict</em>. The process of mediating the conflict into a single version is called <em>dependency resolution</em>. Often, this would result in the older version beging removed from the dependency graph, which is called an <em>eviction</em> of <code>foo:2.2.0</code>. In some cases, an eviction is considered unsafe because the candidates are not replacable. See <a href="appendix/../reference/sbt-update.html">sbt update</a>.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<h3 id="eviction"><a class="header" href="#eviction">Eviction</a></h3>
<p>See <a href="appendix/glossary.html#dependency-resolution">dependency resolution</a>.</p>
<h2 id="v"><a class="header" href="#v">V</a></h2>
<h3 id="value"><a class="header" href="#value"><code>value</code></a></h3>
<p><code>.value</code> is used to denote a happens-before relationship from one task or setting to another. This method is special (it is a macro) and cannot be used except in <code>:=</code> or in the standalone construction methods <code>Def.setting</code> and <code>Def.task</code>.</p>
<!--
This is an index of common methods, types, and values you might find in
an sbt build definition. For command names, see
[Running][Running]. For available plugins, see
[the plugins list][Community-Plugins].
-->
<!--
#### Dependency Management

-   [ModuleID](../api/sbt/librarymanagement/ModuleID.html) is the type of a dependency
    definition. See
    [Library Management][Library-Management].
-   [Artifact](../api/sbt/librarymanagement/Artifact.html) represents a single artifact
    (such as a jar or a pom) to be built and published. See
    [Library Management][Library-Management] and [Artifacts][Artifacts].
-   A [Resolver](../api/sbt/librarymanagement/Resolver.html) can resolve and retrieve
    dependencies. Many types of Resolvers can publish dependencies as
    well. A repository is a closely linked idea that typically refers to
    the actual location of the dependencies. However, sbt is not very
    consistent with this terminology and repository and resolver are
    occasionally used interchangeably.
-   A [ModuleConfiguration](../api/sbt/librarymanagement/ModuleConfiguration.html) defines
    a specific resolver to use for a group of dependencies.
-   A [Configuration](../api/sbt/librarymanagement/Configuration.html) is a useful Ivy
    construct for grouping dependencies. See ivy-configurations. It is
    also used for [scoping settings][Scopes].
-   `Compile`, `Test`, `Runtime`, `Provided`, and `Optional` are
    predefined [configurations][ivy-configurations].
-->
<!--
#### Settings and Tasks

-   A [Setting](../api/sbt/internal/util/Init\$Setting.html) describes how to
    initialize a specific setting in the build. It can use the values of
    other settings or the previous value of the setting being
    initialized.
-   A [SettingsDefinition](../api/sbt/internal/util/Init\$SettingsDefinition.html)
    is the actual type of an expression in a build.sbt. This allows
    either a single [Setting](../api/sbt/internal/util/Init\$Setting.html) or a
    sequence of settings
    ([SettingList](../api/sbt/internal/util/Init\$SettingList.html)) to be defined at
    once. The types in a [.scala build definition][Full-Def] always use just a
    plain [Setting](../api/sbt/internal/util/Init\$Setting.html).
-   [Initialize](../api/sbt/internal/util/Init\$Initialize.html) describes how to
    initialize a setting using other settings, but isn't bound to a
    particular setting yet. Combined with an initialization method and a
    setting to initialize, it produces a full
    [Setting](../api/sbt/internal/util/Init\$Setting.html).
-   [TaskKey](../api/sbt/TaskKey.html),
    [SettingKey](../api/sbt/SettingKey.html), and
    [InputKey](../api/sbt/InputKey.html) are keys that represent a task
    or setting. These are not the actual tasks, but keys that are used
    to refer to them. They can be scoped to produce
    [ScopedTask](../api/sbt/ScopedTask.html),
    [ScopedSetting](../api/sbt/ScopedSetting.html), and
    [ScopedInput](../api/sbt/ScopedInput.html). These form the base
    types that provide the Settings methods.
-   [InputTask](../api/sbt/InputTask.html) parses and tab completes
    user input, producing a task to run.
-   [Task](../api/sbt/Task.html) is the type of a task. A task is an
    action that runs on demand. This is in contrast to a setting, which
    is run once at project initialization.
-->
<!--
#### Build Structure

-   [AutoPlugin](../api/sbt/AutoPlugin.html) is the trait implemented for sbt
    [plugins][Using-Plugins].
-   [Project](../api/sbt/Project.html) is both a trait and a
    companion object that declares a single module in a build. See
    [.scala build definition][Full-Def].
-   [Keys](../api/sbt/Keys\$.html) is an object that provides all of
    the built-in keys for settings and tasks.
-   [State](../api/sbt/State.html) contains the full state for a
    build. It is mainly used by [Commands][Commands] and sometimes
    [Input Tasks][Input-Tasks]. See also [State and Actions][Build-State].

-->
<!--
#### Settings and Tasks

See the [Getting Started Guide][Basic-Def] for
details.

-   `in` specifies the [Scope](../api/sbt/Scope.html) or part of the
    [Scope](../api/sbt/Scope.html) of a setting being referenced. See
    [scopes][Scopes].
-->
<!--
#### File and IO

See [RichFile](../api/sbt/io/RichFile.html),
[PathFinder](../api/sbt/io/PathFinder.html), and
[Paths][Paths] for the full documentation.

-   `/` When called on a single File, this is `new File(x,y)`. For
    Seq[File], this is applied for each member of the sequence..
-   `*` and `**` are methods for selecting children (`*`) or descendants
    (`**`) of a File or Seq[File] that match a filter.
-   `|`, `||`, `&&`, `&`, `-`, and `--` are methods for combining
    filters, which are often used for selecting Files. See
    [NameFilter](../api/sbt/io/NameFilter.html) and
    [FileFilter](../api/sbt/io/FileFilter.html). Note that methods with
    these names also exist for other types, such as collections (like
    Seq) and [Parser](../api/sbt/internal/util/complete/Parser.html) (see
    [Parsing Input][Parsing-Input]).
-   `pair` Used to construct mappings from a `File` to another `File` or
    to a String. See [Mapping Files][Mapping-Files].
-   `get` forces a [PathFinder](../api/sbt/io/PathFinder.html) (a
    call-by-name data structure) to a strict `Seq[File]` representation.
    This is a common name in Scala, used by types like Option.
-->
<!--
#### Dependency Management

See [Library Management][Library-Management] for full documentation.

-   `from` Used to specify the fallback URL for a dependency
-   `classifier` Used to specify the classifier for a dependency.
-   `at` Used to define a Maven-style resolver.
-   `intransitive` Marks a [dependency](../api/sbt/librarymanagement/ModuleID.html) or
    [Configuration](../api/sbt/librarymanagement/Configuration.html) as being
    intransitive.
-   `hide` Marks a [Configuration](../api/sbt/librarymanagement/Configuration.html) as
    internal and not to be included in the published metadata.
-->
<!--
#### Parsing

These methods are used to build up
[Parser](../api/sbt/internal/util/complete/Parser.html)s from smaller
[Parser](../api/sbt/internal/util/complete/Parser.html)s. They closely follow the
names of the standard library's parser combinators. See
[Parsing Input][Parsing-Input] for the full documentation. These are
used for
[Input Tasks][Input-Tasks] and
[Commands][Commands].

-   `~`, `~>`, `<~` Sequencing methods.
-   `??`, `?` Methods for making a Parser optional. `?` is postfix.
-   `id` Used for turning a Char or String literal into a Parser. It is
    generally used to trigger an implicit conversion to a Parser.
-   `|`, `||` Choice methods. These are common method names in Scala.
-   `^^^` Produces a constant value when a Parser matches.
-   `+`, `*` Postfix repetition methods. These are common method names
    in Scala.
-   `map`, `flatMap` Transforms the result of a Parser. These are common
    method names in Scala.
-   `filter` Restricts the inputs that a Parser matches on. This is a
    common method name in Scala.
-   `-` Prefix negation. Only matches the input when the original parser
    doesn't match the input.
-   `examples`, `token` Tab completion
-   `!!!` Provides an error message to use when the original parser
    doesn't match the input.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-notes"><a class="header" href="#setup-notes">Setup Notes</a></h1>
<p>See <a href="appendix/Setup.html">Installing sbt runner</a> for the instruction on general setup. Using Coursier or SDKMAN has two advantages.</p>
<ol>
<li>They will install the official packaging by Eclipse Adoptium etc, as opposed to the <a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2019-May/009330.html">"mystery meat OpenJDK builds"</a>.</li>
<li>They will install <code>tgz</code> packaging of sbt that contains all JAR files. (DEB and RPM packages do not to save bandwidth)</li>
</ol>
<p>This page describes alternative ways of installing the sbt runner. Note that some of the third-party packages may not provide the latest version.</p>
<h2 id="os-specific-setup"><a class="header" href="#os-specific-setup">OS specific setup</a></h2>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<h4 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h4>
<pre><code class="language-bash">$ brew install sbt
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="appendix/setup-notes.html#admonition-warning"></a>
</div>
<div>
<p>Homebrew maintainers have added a dependency to JDK 13 because they want to use more brew dependencies (<a href="https://github.com/Homebrew/homebrew-core/issues/50649">brew#50649</a>). This causes sbt to use JDK 13 even when <code>java</code> available on PATH is JDK 8 or 11. To prevent <code>sbt</code> from running on JDK 13, install <a href="https://www.jenv.be/">jEnv</a> or switch to using <a href="https://sdkman.io/">SDKMAN</a>.</p>
</div>
</div>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ul>
<li><a href="https://github.com/sbt/sbt/releases/download/v/sbt-.msi">sbt-.msi</a></li>
</ul>
<h4 id="chocolatey"><a class="header" href="#chocolatey"><a href="https://chocolatey.org/packages/sbt">Chocolatey</a></a></h4>
<pre><code>&gt; choco install sbt
</code></pre>
<h4 id="scoop"><a class="header" href="#scoop"><a href="https://scoop.sh/">Scoop</a></a></h4>
<pre><code>&gt; scoop install sbt
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<h4 id="ubuntu-and-other-debian-based-distributions"><a class="header" href="#ubuntu-and-other-debian-based-distributions">Ubuntu and other Debian-based distributions</a></h4>
<p><a href="appendix/$sbt_deb_package_base$sbt-$app_version$.deb">DEB</a> package is officially supported by sbt, but it does not contain JAR files to save bandwidth.</p>
<p>Ubuntu and other Debian-based distributions use the DEB format, but usually you don't install your software from a local DEB file. Instead they come with package managers both for the command line (e.g. <code>apt-get</code>, <code>aptitude</code>) or with a graphical user interface (e.g. Synaptic). Run the following from the terminal to install <code>sbt</code> (You'll need superuser privileges to do so, hence the <code>sudo</code>).</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install apt-transport-https curl gnupg -yqq
echo "deb https://repo.scala-sbt.org/scalasbt/debian all main" | sudo tee /etc/apt/sources.list.d/sbt.list
echo "deb https://repo.scala-sbt.org/scalasbt/debian /" | sudo tee /etc/apt/sources.list.d/sbt_old.list
curl -sL "https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823" | sudo -H gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/scalasbt-release.gpg --import
sudo chmod 644 /etc/apt/trusted.gpg.d/scalasbt-release.gpg
sudo apt-get update
sudo apt-get install sbt
</code></pre>
<p>Package managers will check a number of configured repositories for packages to offer for installation. You just have to add the repository to the places your package manager will check.</p>
<p>Once <code>sbt</code> is installed, you'll be able to manage the package in <code>aptitude</code> or Synaptic after you updated their package cache. You should also be able to see the added repository at the bottom of the list in System Settings -&gt; Software &amp; Updates -&gt; Other Software:</p>
<p><img src="appendix//files/ubuntu-sources.png" alt="Ubuntu Software &amp; Updates Screenshot" title="Ubuntu Software &amp; Updates Screenshot" /></p>
<p><code>sudo apt-key adv --keyserver hkps://keyserver.ubuntu.com:443 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823</code> may not work on Ubuntu Bionic LTS (18.04) since it's using a buggy GnuPG, so we are advising to use web API to download the public key in the above.</p>
<h4 id="red-hat-enterprise-linux-and-other-rpm-based-distributions"><a class="header" href="#red-hat-enterprise-linux-and-other-rpm-based-distributions">Red Hat Enterprise Linux and other RPM-based distributions</a></h4>
<p><a href="appendix/$sbt_rpm_package_base$sbt-$app_version$.rpm">RPM</a> package is officially supported by sbt, but it does not contain JAR files to save bandwidth.</p>
<p>Red Hat Enterprise Linux and other RPM-based distributions use the RPM format. Run the following from the terminal to install <code>sbt</code> (You'll need superuser privileges to do so, hence the <code>sudo</code>).</p>
<pre><code class="language-bash"># remove old Bintray repo file
sudo rm -f /etc/yum.repos.d/bintray-rpm.repo
curl -L https://www.scala-sbt.org/sbt-rpm.repo &gt; sbt-rpm.repo
sudo mv sbt-rpm.repo /etc/yum.repos.d/
sudo yum install sbt
</code></pre>
<p>On Fedora (31 and above), use <code>sbt-rpm.repo</code>:</p>
<pre><code class="language-bash"># remove old Bintray repo file
sudo rm -f /etc/yum.repos.d/bintray-rpm.repo
curl -L https://www.scala-sbt.org/sbt-rpm.repo &gt; sbt-rpm.repo
sudo mv sbt-rpm.repo /etc/yum.repos.d/
sudo dnf install sbt
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>