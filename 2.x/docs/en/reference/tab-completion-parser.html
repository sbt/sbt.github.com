<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tab-completion parser - The Book of sbt</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/reference/custom-202509.css">
        <link rel="stylesheet" href="../src/reference/mdbook-admonish.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            
            // var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
            var default_theme = "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of sbt</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-cn">Chinese Simplified (中文)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (日本語)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("en");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "reference/tab-completion-parser.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                            lang.href = `${full_path_to_root}${lang.id}/${path}`;
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tab-completion-parser"><a class="header" href="#tab-completion-parser">Tab-completion parser</a></h1>
<p>This page describes the parser combinators in sbt.
These parsers are used to parse user input and provide tab completion for
<a href="input-task.html">input tasks</a> and <a href="../concepts/command.html">commands</a>.</p>
<!--
If you are already familiar with Scala's parser combinators, the methods
are mostly the same except that their arguments are strict. There are
two additional methods for controlling tab completion that are discussed
at the end of the section.
-->
<p>Parser combinators build up a parser from smaller parsers.
A <code>Parser[A]</code> in its most basic usage is a function <code>String =&gt; Option[A]</code>.
It accepts a <code>String</code> to parse and produces a value wrapped in <code>Some</code> if parsing
succeeds or <code>None</code> if it fails. Error handling and tab completion make
this picture more complicated, but we'll stick with <code>Option</code> for this
discussion.</p>
<h2 id="basic-parsers"><a class="header" href="#basic-parsers">Basic parsers</a></h2>
<p>The simplest parser combinators match exact inputs:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the input is 'x', returning the Char 'x'
//  and failing otherwise
val singleChar: Parser[Char] = 'x'

// A parser that succeeds if the input is "blue", returning the String "blue"
//   and failing otherwise
val litString: Parser[String] = "blue"
</code></pre>
<p>In these examples, implicit conversions produce a literal <code>Parser</code> from
a <code>Char</code> or <code>String</code>. Other basic parser constructors are the
<code>charClass</code>, <code>success</code> and <code>failure</code> methods:</p>
<pre><code class="language-scala">import sbt.{ *, given }
import sbt.complete.DefaultParsers.{ *, given }

// A parser that succeeds if the character is a digit, returning the matched Char
//   The second argument, "digit", describes the parser and is used in error messages
val digit: Parser[Char] = charClass((c: Char) =&gt; c.isDigit, "digit")

// A parser that produces the value 3 for an empty input string, fails otherwise
val alwaysSucceed: Parser[Int] = success(3)

// Represents failure (always returns None for an input String).
//  The argument is the error message.
val alwaysFail: Parser[Nothing] = failure("Invalid input.")
</code></pre>
<h2 id="built-in-parsers"><a class="header" href="#built-in-parsers">Built-in parsers</a></h2>
<p>sbt comes with several built-in parsers defined in
<code>sbt.complete.DefaultParsers</code>. <!-- ../api/sbt/internal/util/complete/DefaultParsers$.html --></p>
<p>Some commonly used built-in parsers are:</p>
<ul>
<li><code>Space</code>, <code>NotSpace</code>, <code>OptSpace</code>, and <code>OptNotSpace</code> for parsing
spaces or non-spaces, required or not.</li>
<li><code>StringBasic</code> for parsing text that may be quoted.</li>
<li><code>IntBasic</code> for parsing a signed Int value.</li>
<li><code>Digit</code> and <code>HexDigit</code> for parsing a single decimal or hexadecimal
digit.</li>
<li><code>Bool</code> for parsing a <code>Boolean</code> value</li>
</ul>
<p>See the
<a href="../api/sbt/internal/util/complete/DefaultParsers$.html">DefaultParsers API</a> for
details.</p>
<h2 id="combining-parsers"><a class="header" href="#combining-parsers">Combining parsers</a></h2>
<p>We build on these basic parsers to construct more interesting parsers.
We can combine parsers in a sequence, choose between parsers, or repeat
a parser.</p>
<pre><code class="language-scala">// A parser that succeeds if the input is "blue" or "green",
//  returning the matched input
val color: Parser[String] = "blue" | "green"

// A parser that matches either "fg" or "bg"
val select: Parser[String] = "fg" | "bg"

// A parser that matches "fg" or "bg", a space, and then the color, returning the matched values.
val setColor: Parser[(String, Char, String)] =
  select ~ ' ' ~ color

// Often, we don't care about the value matched by a parser, such as the space above
//  For this, we can use ~&gt; or &lt;~, which keep the result of
//  the parser on the right or left, respectively
val setColor2: Parser[(String, String)]  =  select ~ (' ' ~&gt; color)

// Match one or more digits, returning a list of the matched characters
val digits: Parser[Seq[Char]] = charClass(_.isDigit, "digit").+

// Match zero or more digits, returning a list of the matched characters
val digits0: Parser[Seq[Char]] = charClass(_.isDigit, "digit").*

// Optionally match a digit
val optDigit: Parser[Option[Char]] = charClass(_.isDigit, "digit").?
</code></pre>
<h2 id="transforming-results"><a class="header" href="#transforming-results">Transforming results</a></h2>
<p>A key aspect of parser combinators is transforming results along the way
into more useful data structures. The fundamental methods for this are
<code>map</code> and <code>flatMap</code>. Here are examples of <code>map</code> and some convenience
methods implemented on top of <code>map</code>.</p>
<pre><code class="language-scala">// Apply the `digits` parser and apply the provided function to the matched
//   character sequence
val num: Parser[Int] = digits.map: (chars: Seq[Char]) =&gt;
  chars.mkString.toInt }

// Match a digit character, returning the matched character or return '0' if the input is not a digit
val digitWithDefault: Parser[Char] = charClass(_.isDigit, "digit") ?? '0'

// The previous example is equivalent to:
val digitDefault: Parser[Char] =
  charClass(_.isDigit, "digit").?.map: (d: Option[Char]) =&gt;
    d.getOrElse('0')

// Succeed if the input is "blue" and return the value 4
val blue = "blue" ^^^ 4

// The above is equivalent to:
val blueM = "blue".map((s: String) =&gt; 4)
</code></pre>
<h2 id="controlling-tab-completion"><a class="header" href="#controlling-tab-completion">Controlling tab completion</a></h2>
<p>Most parsers have reasonable default tab completion behavior.
For example, the string and character literal parsers will suggest the
underlying literal for an empty input string. However, it is impractical
to determine the valid completions for <code>charClass</code>, since it accepts an
arbitrary predicate. The <code>examples</code> method defines explicit completions
for such a parser:</p>
<pre><code class="language-scala">val digit = charClass(_.isDigit, "digit").examples("0", "1", "2")
</code></pre>
<p>Tab completion will use the examples as suggestions. The other method
controlling tab completion is <code>token</code>. The main purpose of <code>token</code> is to
determine the boundaries for suggestions. For example, if your parser
is:</p>
<pre><code class="language-scala">("fg" | "bg") ~ ' ' ~ ("green" | "blue")
</code></pre>
<p>then the potential completions on empty input are:
<code>console fg green fg blue bg green bg blue</code></p>
<p>Typically, you want to suggest smaller segments or the number of
suggestions becomes unmanageable. A better parser is:</p>
<pre><code class="language-scala">token( ("fg" | "bg") ~ ' ') ~ token("green" | "blue")
</code></pre>
<p>Now, the initial suggestions would be (with <code>_</code> representing a space):
<code>console fg_ bg_</code></p>
<p>Be careful not to overlap or nest tokens, as in
<code>token("green" ~ token("blue"))</code>. The behavior is unspecified (and
should generate an error in the future), but typically the outer most
token definition will be used.</p>
<h2 id="dependent-parsers"><a class="header" href="#dependent-parsers">Dependent parsers</a></h2>
<p>Sometimes a parser must analyze some data and then more data needs to be parsed,
and it is dependent on the previous one.
The key for obtaining this behaviour is to use the <code>flatMap</code> function.</p>
<p>As an example, it will shown how to select several items from a list of valid ones
with completion, but no duplicates are possible.  A space is used to separate the
different items.</p>
<pre><code class="language-scala">def select1(items: Iterable[String]) =
  token(Space ~&gt; StringBasic.examples(FixedSetExamples(items)))

def selectSome(items: Seq[String]): Parser[Seq[String]] = {
   select1(items).flatMap: v =&gt;
     val remaining = items.filter(_ != v)
     if remaining.size == 0 then success(v :: Nil)
     else selectSome(remaining).?.map(v +: _.getOrElse(Seq()))
 }
</code></pre>
<p>As you can see, the <code>flatMap</code> function provides the previous value.  With this info, a new
parser is constructed for the remaining items.  The <code>map</code> combinator is also used in order
to transform the output of the parser.</p>
<p>The parser is called recursively, until it is found the trivial case of no possible choices.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/input-task.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../community-plugins.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/input-task.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../community-plugins.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>