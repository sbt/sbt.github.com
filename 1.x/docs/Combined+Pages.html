<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>sbt Reference Manual — Combined Pages</title>
        <link rel="shortcut icon" href="favicon.ico"/>
        <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
        <script type="text/javascript" src="js/bootstrap.bundle.min.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom.css" type="text/css" media="screen, projection"/>
        
        <script type="text/javascript">
              Pamflet.twitter = '#sbt #scala';
            </script>
      </head>
      <body class="color_scheme-github">
        <div class="container-fluid contentswrapper h-100">
          <div class="row minh-100">
          <div class="col-md-4 col-xl-3 leftcolumn">&nbsp;</div><div class="col-md-8 col-xs-9">
                  <div class="rightcolmn contents">
                    <div class="tocwrapper">
        
        <div class="tocbody show" id="toc">
        <h4 class="toctitle">Contents</h4>
        <div><a href="#sbt+Reference+Manual">sbt Reference Manual</a></div><ol class="toc"> <li><div><a href="#Getting+Started+with+sbt">Getting Started with sbt</a></div><ol class="toc"> <li><div><a href="#Installing+sbt">Installing sbt</a></div><ol class="toc"> <li><div><a href="#Installing+sbt+on+macOS">Installing sbt on macOS</a></div></li><li><div><a href="#Installing+sbt+on+Windows">Installing sbt on Windows</a></div></li><li><div><a href="#Installing+sbt+on+Linux">Installing sbt on Linux</a></div></li> </ol></li><li><div><a href="#sbt+by+example">sbt by example</a></div></li><li><div><a href="#Directory+structure">Directory structure</a></div></li><li><div><a href="#Running">Running</a></div></li><li><div><a href="#Build+definition">Build definition</a></div></li><li><div><a href="#Multi-project+builds">Multi-project builds</a></div></li><li><div><a href="#Task+graph">Task graph</a></div></li><li><div><a href="#Scopes">Scopes</a></div></li><li><div><a href="#Appending+values">Appending values</a></div></li><li><div><a href="#Scope+delegation+%28.value+lookup%29">Scope delegation (.value lookup)</a></div></li><li><div><a href="#Library+dependencies">Library dependencies</a></div></li><li><div><a href="#Using+plugins">Using plugins</a></div></li><li><div><a href="#Custom+settings+and+tasks">Custom settings and tasks</a></div></li><li><div><a href="#Organizing+the+build">Organizing the build</a></div></li><li><div><a href="#Getting+Started+summary">Getting Started summary</a></div></li> </ol></li><li><div><a href="#Frequently+Asked+Questions">Frequently Asked Questions</a></div><ol class="toc">  </ol></li><li><div><a href="#General+Information">General Information</a></div><ol class="toc"> <li><div><a href="#Credits">Credits</a></div></li><li><div><a href="#Community+Plugins">Community Plugins</a></div></li><li><div><a href="#Community+Repository+Policy">Community Repository Policy</a></div></li><li><div><a href="#Bintray+For+Plugins">Bintray For Plugins</a></div></li><li><div><a href="#Setup+Notes">Setup Notes</a></div></li><li><div><a href="#Using+Sonatype">Using Sonatype</a></div></li><li><div><a href="#Contributing+to+sbt">Contributing to sbt</a></div></li><li><div><a href="#Changes">Changes</a></div><ol class="toc"> <li><div><a href="#Migrating+from+sbt+0.13.x">Migrating from sbt 0.13.x</a></div></li><li><div><a href="#sbt+1.4.x+releases">sbt 1.4.x releases</a></div></li><li><div><a href="#sbt+1.3.x+releases">sbt 1.3.x releases</a></div></li><li><div><a href="#sbt+1.2.x+releases">sbt 1.2.x releases</a></div></li><li><div><a href="#sbt+1.1.x+releases">sbt 1.1.x releases</a></div></li><li><div><a href="#sbt+1.0.x+releases">sbt 1.0.x releases</a></div></li> </ol></li> </ol></li><li><div><a href="#Detailed+Topics">Detailed Topics</a></div><ol class="toc"> <li><div><a href="#Using+sbt">Using sbt</a></div><ol class="toc"> <li><div><a href="#Command+Line+Reference">Command Line Reference</a></div></li><li><div><a href="#Console+Project">Console Project</a></div></li><li><div><a href="#Cross-building">Cross-building</a></div></li><li><div><a href="#Interacting+with+the+Configuration+System">Interacting with the Configuration System</a></div></li><li><div><a href="#Triggered+Execution">Triggered Execution</a></div></li><li><div><a href="#Scripts%2C+REPL%2C+and+Dependencies">Scripts, REPL, and Dependencies</a></div></li><li><div><a href="#sbt+Server">sbt Server</a></div></li><li><div><a href="#Understanding+Incremental+Recompilation">Understanding Incremental Recompilation</a></div></li> </ol></li><li><div><a href="#Configuration">Configuration</a></div><ol class="toc"> <li><div><a href="#Classpaths%2C+sources%2C+and+resources">Classpaths, sources, and resources</a></div></li><li><div><a href="#Compiler+Plugin+Support">Compiler Plugin Support</a></div></li><li><div><a href="#Configuring+Scala">Configuring Scala</a></div></li><li><div><a href="#Forking">Forking</a></div></li><li><div><a href="#Global+Settings">Global Settings</a></div></li><li><div><a href="#Java+Sources">Java Sources</a></div></li><li><div><a href="#Mapping+Files">Mapping Files</a></div></li><li><div><a href="#Local+Scala">Local Scala</a></div></li><li><div><a href="#Macro+Projects">Macro Projects</a></div></li><li><div><a href="#Paths">Paths</a></div></li><li><div><a href="#Parallel+Execution">Parallel Execution</a></div></li><li><div><a href="#External+Processes">External Processes</a></div></li><li><div><a href="#Running+Project+Code">Running Project Code</a></div></li><li><div><a href="#Testing">Testing</a></div></li><li><div><a href="#In+process+class+loading">In process class loading</a></div></li><li><div><a href="#Globs">Globs</a></div></li><li><div><a href="#Remote+Caching">Remote Caching</a></div></li> </ol></li><li><div><a href="#Dependency+Management">Dependency Management</a></div><ol class="toc"> <li><div><a href="#Artifacts">Artifacts</a></div></li><li><div><a href="#Dependency+Management+Flow">Dependency Management Flow</a></div></li><li><div><a href="#Library+Management">Library Management</a></div></li><li><div><a href="#Proxy+Repositories">Proxy Repositories</a></div></li><li><div><a href="#Publishing">Publishing</a></div></li><li><div><a href="#Resolvers">Resolvers</a></div></li><li><div><a href="#Update+Report">Update Report</a></div></li><li><div><a href="#Cached+Resolution">Cached Resolution</a></div></li> </ol></li><li><div><a href="#Tasks+and+Commands">Tasks and Commands</a></div><ol class="toc"> <li><div><a href="#Tasks">Tasks</a></div></li><li><div><a href="#Caching">Caching</a></div></li><li><div><a href="#Input+Tasks">Input Tasks</a></div></li><li><div><a href="#Commands">Commands</a></div></li><li><div><a href="#Parsing+and+tab+completion">Parsing and tab completion</a></div></li><li><div><a href="#State+and+actions">State and actions</a></div></li><li><div><a href="#Tasks%2FSettings%3A+Motivation">Tasks/Settings: Motivation</a></div></li> </ol></li><li><div><a href="#Plugins+and+Best+Practices">Plugins and Best Practices</a></div><ol class="toc"> <li><div><a href="#General+Best+Practices">General Best Practices</a></div></li><li><div><a href="#Plugins">Plugins</a></div></li><li><div><a href="#Plugins+Best+Practices">Plugins Best Practices</a></div></li><li><div><a href="#Setting+up+GitHub+Actions+with+sbt">Setting up GitHub Actions with sbt</a></div></li><li><div><a href="#Setting+up+Travis+CI+with+sbt">Setting up Travis CI with sbt</a></div></li><li><div><a href="#Testing+sbt+plugins">Testing sbt plugins</a></div></li><li><div><a href="#sbt+new+and+Templates">sbt new and Templates</a></div></li><li><div><a href="#Cross+building+plugins">Cross building plugins</a></div></li> </ol></li> </ol></li><li><div><a href="#How+to%E2%80%A6">How to…</a></div><ol class="toc"> <li><div><a href="#Classpaths">Classpaths</a></div></li><li><div><a href="#Customizing+paths">Customizing paths</a></div></li><li><div><a href="#Generating+files">Generating files</a></div></li><li><div><a href="#Inspect+the+build">Inspect the build</a></div></li><li><div><a href="#Interactive+mode">Interactive mode</a></div></li><li><div><a href="#Configure+and+use+logging">Configure and use logging</a></div></li><li><div><a href="#Project+metadata">Project metadata</a></div></li><li><div><a href="#Configure+packaging">Configure packaging</a></div></li><li><div><a href="#Running+commands">Running commands</a></div></li><li><div><a href="#Configure+and+use+Scala">Configure and use Scala</a></div></li><li><div><a href="#Generate+API+documentation">Generate API documentation</a></div></li><li><div><a href="#Define+Custom+Tasks">Define Custom Tasks</a></div></li><li><div><a href="#How+to+take+an+action+on+startup">How to take an action on startup</a></div></li><li><div><a href="#Track+file+inputs+and+outputs">Track file inputs and outputs</a></div></li><li><div><a href="#Troubleshoot+memory+issues">Troubleshoot memory issues</a></div></li><li><div><a href="#Sequencing">Sequencing</a></div><ol class="toc"> <li><div><a href="#Defining+a+sequential+task+with+Def.sequential">Defining a sequential task with Def.sequential</a></div></li><li><div><a href="#Defining+a+dynamic+task+with+Def.taskDyn">Defining a dynamic task with Def.taskDyn</a></div></li><li><div><a href="#Doing+something+after+an+input+task">Doing something after an input task</a></div></li><li><div><a href="#Defining+a+dynamic+input+task+with+Def.inputTaskDyn">Defining a dynamic input task with Def.inputTaskDyn</a></div></li><li><div><a href="#How+to+sequence+using+commands">How to sequence using commands</a></div></li> </ol></li><li><div><a href="#How+to+define+a+custom+dependency+configuration">How to define a custom dependency configuration</a></div></li><li><div><a href="#Examples">Examples</a></div><ol class="toc"> <li><div><a href="#.sbt+build+examples">.sbt build examples</a></div></li><li><div><a href="#.sbt+build+with+.scala+files+example">.sbt build with .scala files example</a></div></li><li><div><a href="#Advanced+configurations+example">Advanced configurations example</a></div></li><li><div><a href="#Advanced+command+example">Advanced command example</a></div></li> </ol></li> </ol></li><li><div><a href="#Index">Index</a></div></li><li><div><a href="#Developer%E2%80%99s+Guide+%28Work+in+progress%29">Developer’s Guide (Work in progress)</a></div><ol class="toc"> <li><div><a href="#Modularization">Modularization</a></div><ol class="toc"> <li><div><a href="#Module+summary">Module summary</a></div></li> </ol></li><li><div><a href="#sbt+Coding+Guideline">sbt Coding Guideline</a></div><ol class="toc">  </ol></li><li><div><a href="#sbt-datatype">sbt-datatype</a></div><ol class="toc">  </ol></li><li><div><a href="#Compiler+Interface">Compiler Interface</a></div><ol class="toc"> <li><div><a href="#Fetching+the+most+specific+sources">Fetching the most specific sources</a></div></li> </ol></li><li><div><a href="#sbt+Launcher">sbt Launcher</a></div><ol class="toc"> <li><div><a href="#Getting+Started+with+the+sbt+launcher">Getting Started with the sbt launcher</a></div></li><li><div><a href="#Sbt+Launcher+Architecture">Sbt Launcher Architecture</a></div></li><li><div><a href="#sbt+Launcher+Configuration">sbt Launcher Configuration</a></div></li> </ol></li><li><div><a href="#Notes">Notes</a></div><ol class="toc"> <li><div><a href="#Core+Principles">Core Principles</a></div></li><li><div><a href="#Settings+Core">Settings Core</a></div></li><li><div><a href="#Setting+Initialization">Setting Initialization</a></div></li><li><div><a href="#Creating+Command+Line+Applications+Using+sbt">Creating Command Line Applications Using sbt</a></div></li> </ol></li> </ol></li><li><div><a href="#Archived+pages">Archived pages</a></div><ol class="toc"> <li><div><a href="#Hello%2C+World">Hello, World</a></div></li> </ol></li> </ol></div>
      </div><h1 id="sbt+Reference+Manual">sbt Reference Manual<a href="#sbt+Reference+Manual" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>sbt is a build tool for Scala, Java, and
<a href="https://github.com/d40cht/sbt-cpp">more</a>. It requires Java 1.8 or
later.
</p><h3 id="Install">Install<a href="#Install" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="Setup.html">Installing sbt</a> for the setup instructions.
</p><h3 id="Getting+Started">Getting Started<a href="#Getting+Started" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To get started, <em>please read</em> the
<a href="Getting-Started.html">Getting Started Guide</a>. You will save
yourself a <em>lot</em> of time if you have the right understanding of the big
picture up-front.
All documentation may be found via the table of contents included on the left of every page.
</p><p>See also <a href="Faq.html">Frequently asked question</a>.
</p><p>See <a href="https://www.scala-sbt.org/support.html">Support</a> on where you can get help about sbt.
For discussing sbt development, use <a href="https://github.com/sbt/sbt/discussions">Discussions</a>.
To stay up to date about the news related to sbt, follow us <a href="https://twitter.com/scala_sbt">@scala_sbt</a>.
</p><h3 id="Features+of+sbt">Features of sbt<a href="#Features+of+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Little or no configuration required for simple projects
</li><li>Scala-based <a href="Basic-Def.html">build definition</a> that can
use the full flexibility of Scala code
</li><li>Accurate incremental recompilation using information extracted from
the compiler
</li><li><a href="Library-Dependencies.html">Library management support</a> using Coursier
</li><li>Continuous compilation and testing with
<a href="Triggered-Execution.html">triggered execution</a>
</li><li>Supports mixed Scala/<a href="Java-Sources.html">Java</a> projects
</li><li>Supports <a href="Testing.html">testing</a> with ScalaCheck,
specs, and ScalaTest. JUnit is supported by a plugin.
</li><li>Starts the Scala REPL with project classes and dependencies on the
classpath
</li><li>Modularization supported with
<a href="Multi-Project.html">sub-projects</a>
</li><li>External project support (list a git repository as a dependency!)
</li><li><a href="Parallel-Execution.html">Parallel task execution</a>,
including parallel test execution
</li></ul><h3 id="Also">Also<a href="#Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This documentation can be forked
on <a href="https://github.com/sbt/website/">GitHub</a>. Feel free to make
corrections and add documentation.
</p><p>Documentation for 0.13.x has been
<a href="https://www.scala-sbt.org/0.13/docs/index.html">archived here</a>. This
documentation applies to sbt 1.4.7.
</p><p>See also the <a href="https://www.scala-sbt.org/1.x/api/sbt/index.html">API Documentation</a>,
and the <a href="Name-Index.html">index of names and types</a>.
</p><h1 id="Getting+Started+with+sbt">Getting Started with sbt<a href="#Getting+Started+with+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>sbt uses a small number of concepts to support flexible and powerful
build definitions. There are not that many concepts, but sbt is not
exactly like other build systems and there are details you <em>will</em>
stumble on if you haven’t read the documentation.
</p><p>The Getting Started Guide covers the concepts you need to know to create
and maintain an sbt build definition.
</p><p>It is <em>highly recommended</em> to read the Getting Started Guide!
</p><p>If you are in a huge hurry, the most important conceptual background can
be found in <a href="Basic-Def.html">build definition</a>, <a href="Scopes.html">scopes</a>, and
<a href="Task-Graph.html">task graph</a>. But we don’t promise that
it’s a good idea to skip the other pages in the guide.
</p><p>It’s best to read in order, as later pages in the Getting Started Guide
build on concepts introduced earlier.
</p><p>Thanks for trying out sbt and <em>have fun</em>!
</p><h2 id="Installing+sbt">Installing sbt<a href="#Installing+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>To create an sbt project, you’ll need to take these steps:
</p><ul><li>Install JDK (We recommend AdoptOpenJDK JDK 8 or AdoptOpenJDK JDK 11).
</li><li>Install sbt.
</li><li>Setup a simple <a href="Hello.html">hello world</a> project
</li><li>Move on to <a href="Running.html">running</a> to learn how to run sbt.
</li><li>Then move on to <a href="Basic-Def.html">.sbt build definition</a> to learn more
about build definitions.
</li></ul><p>Ultimately, the installation of sbt boils down to a launcher JAR
and a shell script, but depending on your platform, we provide
several ways to make the process less tedious.  Head over to the
installation steps for <a href="Installing-sbt-on-Mac.html">macOS</a>, <a href="Installing-sbt-on-Windows.html">Windows</a>, or
<a href="Installing-sbt-on-Linux.html">Linux</a>.
</p><h3 id="Tips+and+Notes">Tips and Notes<a href="#Tips+and+Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you have any trouble running sbt, see <a href="../docs/Setup-Notes.html">Setup Notes</a> on
terminal encodings, HTTP proxies, and JVM options.
</p><h2 id="Installing+sbt+on+macOS">Installing sbt on macOS<a href="#Installing+sbt+on+macOS" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Install+JDK">Install JDK<a href="#Install+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Follow the link to install <a href="https://adoptopenjdk.net/">JDK 8 or 11</a>.
</p><p>Or use <a href="https://sdkman.io/">SDKMAN!</a>:
</p><pre><code class="">$ sdk list java
$ sdk install java 11.0.4.hs-adpt
</code></pre><h3 id="Installing+from+a+universal+package">Installing from a universal package<a href="#Installing+from+a+universal+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Download <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.zip">ZIP</a> or <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.tgz">TGZ</a> package, and expand it.
</p><h3 id="Installing+from+a+third-party+package">Installing from a third-party package<a href="#Installing+from+a+third-party+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><p><strong>Note:</strong> Third-party packages may not provide the latest version. Please make
sure to report any issues with these packages to the relevant
maintainers.
</p></blockquote><h4 id=""><a href="https://brew.sh/">Homebrew</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ brew install sbt
</code></pre><h4 id=""><a href="https://sdkman.io/">SDKMAN!</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ sdk install sbt
</code></pre><h2 id="Installing+sbt+on+Windows">Installing sbt on Windows<a href="#Installing+sbt+on+Windows" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Install+JDK">Install JDK<a href="#Install+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Follow the link to install <a href="https://adoptopenjdk.net/">JDK 8 or 11</a>.
</p><h3 id="Installing+from+a+universal+package">Installing from a universal package<a href="#Installing+from+a+universal+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Download <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.zip">ZIP</a> or <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.tgz">TGZ</a> package and expand it.
</p><h3 id="Windows+installer">Windows installer<a href="#Windows+installer" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Download <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.msi">msi installer</a> and install it.
</p><h3 id="Installing+from+a+third-party+package">Installing from a third-party package<a href="#Installing+from+a+third-party+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><p><strong>Note:</strong> Third-party packages may not provide the latest version. Please make
sure to report any issues with these packages to the relevant
maintainers.
</p></blockquote><h4 id=""><a href="https://scoop.sh/">Scoop</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ scoop install sbt
</code></pre><h4 id=""><a href="https://chocolatey.org">Chocolatey</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ choco install sbt
</code></pre><h2 id="Installing+sbt+on+Linux">Installing sbt on Linux<a href="#Installing+sbt+on+Linux" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Installing+from+SDKMAN">Installing from SDKMAN<a href="#Installing+from+SDKMAN" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To install both JDK and sbt, consider using <a href="https://sdkman.io/">SDKMAN</a>.
</p><pre><code class="">$ sdk list java
$ sdk install java 11.0.4.hs-adpt
$ sdk install sbt
</code></pre><p>This has two advantages.
1. It will install the official packaging by AdoptOpenJDK, as opposed to the <a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2019-May/009330.html">“mystery meat OpenJDK builds“</a>.
2. It will install <code>tgz</code> packaging of sbt that contains all JAR files. (DEB and RPM packages do not to save bandwidth)
</p><h3 id="Install+JDK">Install JDK<a href="#Install+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You must first install a JDK. We recommend <strong>AdoptOpenJDK JDK 8</strong> or <strong>JDK 11</strong>.
</p><p>The details around the package names differ from one distribution to another. For example, Ubuntu xenial (16.04LTS) has <a href="https://packages.ubuntu.com/hu/xenial/openjdk-8-jdk">openjdk-8-jdk</a>. Redhat family calls it <a href="https://apps.fedoraproject.org/packages/java-1.8.0-openjdk-devel">java-1.8.0-openjdk-devel</a>.
</p><h3 id="Installing+from+a+universal+package">Installing from a universal package<a href="#Installing+from+a+universal+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Download <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.zip">ZIP</a> or <a href="https://github.com/sbt/sbt/releases/download/v1.4.7/sbt-1.4.7.tgz">TGZ</a> package and expand it.
</p><h3 id="Ubuntu+and+other+Debian-based+distributions">Ubuntu and other Debian-based distributions<a href="#Ubuntu+and+other+Debian-based+distributions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="https://dl.bintray.com/sbt/debian/sbt-1.4.7.deb">DEB</a> package is officially supported by sbt.
</p><p>Ubuntu and other Debian-based distributions use the DEB format, but usually you don’t install your software from a local DEB file. Instead they come with package managers both for the command line (e.g. <code>apt-get</code>, <code>aptitude</code>) or with a graphical user interface (e.g. Synaptic).
Run the following from the terminal to install <code>sbt</code> (You’ll need superuser privileges to do so, hence the <code>sudo</code>).
</p><pre><code>echo &quot;deb https://dl.bintray.com/sbt/debian /&quot; | sudo tee -a /etc/apt/sources.list.d/sbt.list
curl -sL &quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot; | sudo apt-key add
sudo apt-get update
sudo apt-get install sbt
</code></pre><p>Package managers will check a number of configured repositories for packages to offer for installation. sbt binaries are published to Bintray, and conveniently Bintray provides an APT repository. You just have to add the repository to the places your package manager will check.
</p><p>Once <code>sbt</code> is installed, you’ll be able to manage the package in <code>aptitude</code> or Synaptic after you updated their package cache. You should also be able to see the added repository at the bottom of the list in System Settings -&gt; Software &amp; Updates -&gt; Other Software:
</p><p><img src="files/ubuntu-sources.png" title="Ubuntu Software &amp; Updates Screenshot" alt="Ubuntu Software &amp; Updates Screenshot"/>
</p><p><strong>Note</strong>: There have been reports about SSL error using Ubuntu: <code>Server access Error: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty url=https://repo1.maven.org/maven2/org/scala-sbt/sbt/1.1.0/sbt-1.1.0.pom</code>, which apparently stems from OpenJDK 9 using PKCS12 format for <code>/etc/ssl/certs/java/cacerts</code> <a href="https://bugs.launchpad.net/ubuntu/+source/ca-certificates-java/+bug/1739631">cert-bug</a>. According to <a href="https://stackoverflow.com/a/50103533/3827">https://stackoverflow.com/a/50103533/3827</a> it is fixed in Ubuntu Cosmic (18.10), but Ubuntu Bionic LTS (18.04) is still waiting for a release. See the answer for a workaround.
</p><p><strong>Note</strong>: <code>sudo apt-key adv --keyserver hkps://keyserver.ubuntu.com:443 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823</code> may not work on Ubuntu Bionic LTS (18.04) since it’s using a buggy GnuPG, so we are advising to use web API to download the public key in the above.
</p><h3 id="Red+Hat+Enterprise+Linux+and+other+RPM-based+distributions">Red Hat Enterprise Linux and other RPM-based distributions<a href="#Red+Hat+Enterprise+Linux+and+other+RPM-based+distributions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="https://dl.bintray.com/sbt/rpm/sbt-1.4.7.rpm">RPM</a> package is officially supported by sbt.
</p><p>Red Hat Enterprise Linux and other RPM-based distributions use the RPM format.
Run the following from the terminal to install <code>sbt</code> (You’ll need superuser privileges to do so, hence the <code>sudo</code>).
</p><pre><code>curl https://bintray.com/sbt/rpm/rpm | sudo tee /etc/yum.repos.d/bintray-sbt-rpm.repo
sudo yum install sbt
</code></pre><p>sbt binaries are published to Bintray, and conveniently Bintray provides an RPM repository. You just have to add the repository to the places your package manager will check.
</p><p>On Fedora (31 and above), use <code>bintray-sbt-rpm.repo</code> 
</p><pre><code>
curl https://bintray.com/sbt/rpm/rpm | sudo tee /etc/yum.repos.d/bintray-sbt-rpm.repo
sudo dnf install sbt
</code></pre><blockquote><p><strong>Note:</strong> Please report any issues with these to the
<a href="https://github.com/sbt/sbt">sbt</a>
project.
</p></blockquote><h3 id="Gentoo">Gentoo<a href="#Gentoo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The official tree contains ebuilds for sbt. To install the latest available version do:
</p><pre><code>emerge dev-java/sbt
</code></pre><h2 id="sbt+by+example">sbt by example<a href="#sbt+by+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page assumes you’ve <a href="Setup.html">installed sbt 1</a>.
</p><p>Let’s start with examples rather than explaining how sbt works or why.
</p><h3 id="Create+a+minimum+sbt+build">Create a minimum sbt build<a href="#Create+a+minimum+sbt+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">$ mkdir foo-build
$ cd foo-build
$ touch build.sbt
</code></pre><h3 id="Start+sbt+shell">Start sbt shell<a href="#Start+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">$ sbt
[info] Updated file /tmp/foo-build/project/build.properties: set sbt.version to 1.1.4
[info] Loading project definition from /tmp/foo-build/project
[info] Loading settings from build.sbt ...
[info] Set current project to foo-build (in build file:/tmp/foo-build/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/abc4fb6c89985a00fd95/sock
sbt:foo-build&gt;
</code></pre><h3 id="Exit+sbt+shell">Exit sbt shell<a href="#Exit+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To leave sbt shell, type <code>exit</code> or use Ctrl+D (Unix) or Ctrl+Z (Windows).
</p><pre><code class="">sbt:foo-build&gt; exit
</code></pre><h3 id="Compile+a+project">Compile a project<a href="#Compile+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As a convention, we will use the <code>sbt:...&gt;</code> or <code>&gt;</code> prompt to mean that we’re in the sbt interactive shell.
</p><pre><code class="">$ sbt
sbt:foo-build&gt; compile
</code></pre><h3 id="Recompile+on+code+change">Recompile on code change<a href="#Recompile+on+code+change" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Prefixing the <code>compile</code> command (or any other command) with <code>~</code> causes the command to be automatically
re-executed whenever one of the source files within the project is modified. For example:
</p><pre><code class="">sbt:foo-build&gt; ~compile
[success] Total time: 0 s, completed May 6, 2018 3:52:08 PM
1. Waiting for source changes... (press enter to interrupt)
</code></pre><h3 id="Create+a+source+file">Create a source file<a href="#Create+a+source+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Leave the previous command running. From a different shell or in your file manager create in the foo-build
directory the following nested directories: <code>src/main/scala/example</code>. Then, create <code>Hello.scala</code>
in the <code>example</code> directory using your favorite editor as follows:
</p><pre><code class="prettyprint lang-scala">package example

object Hello extends App {
  println(&quot;Hello&quot;)
}
</code></pre><p>This new file should be picked up by the running command:
</p><pre><code class="">[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/classes ...
[info] Done compiling.
[success] Total time: 2 s, completed May 6, 2018 3:53:42 PM
2. Waiting for source changes... (press enter to interrupt)
</code></pre><p>Press <code>Enter</code> to exit <code>~compile</code>.
</p><h3 id="Run+a+previous+command">Run a previous command<a href="#Run+a+previous+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>From sbt shell, press up-arrow twice to find the <code>compile</code> command that you
executed at the beginning.
</p><pre><code class="">sbt:foo-build&gt; compile
</code></pre><h3 id="Getting+help">Getting help<a href="#Getting+help" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Use the <code>help</code> command to get basic help about the available commands.
</p><pre><code class="">sbt:foo-build&gt; help

  about      Displays basic information about sbt and the build.
  tasks      Lists the tasks defined for the current project.
  settings   Lists the settings defined for the current project.
  reload     (Re)loads the current project or changes to plugins project or returns from it.
  new        Creates a new sbt build.
  projects   Lists the names of available projects or temporarily adds/removes extra builds to the session.
  project    Displays the current project or changes to the provided `project`.

....
</code></pre><p>Display the description of a specific task:
</p><pre><code class="">sbt:foo-build&gt; help run
Runs a main class, passing along arguments provided on the command line.
</code></pre><h3 id="Run+your+app">Run your app<a href="#Run+your+app" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; run
[info] Packaging /tmp/foo-build/target/scala-2.12/foo-build_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Running example.Hello
Hello
[success] Total time: 1 s, completed May 6, 2018 4:10:44 PM
</code></pre><h3 id="Set+ThisBuild+%2F+scalaVersion+from+sbt+shell">Set ThisBuild / scalaVersion from sbt shell<a href="#Set+ThisBuild+%2F+scalaVersion+from+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; set ThisBuild / scalaVersion := &quot;2.12.7&quot;
[info] Defining ThisBuild / scalaVersion
</code></pre><p>Check the <code>scalaVersion</code> setting:
</p><pre><code class="">sbt:foo-build&gt; scalaVersion
[info] 2.12.7
</code></pre><h3 id="Save+the+session+to+build.sbt">Save the session to build.sbt<a href="#Save+the+session+to+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We can save the ad-hoc settings using <code>session save</code>.
</p><pre><code class="">sbt:foo-build&gt; session save
[info] Reapplying settings...
</code></pre><p><code>build.sbt</code> file should now contain:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;

</code></pre><h3 id="Name+your+project">Name your project<a href="#Name+your+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using an editor, change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;
  )
</code></pre><h3 id="Reload+the+build">Reload the build<a href="#Reload+the+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Use the <code>reload</code> command to reload the build. The command causes the
<code>build.sbt</code> file to be re-read, and its settings applied.
</p><pre><code class="">sbt:foo-build&gt; reload
[info] Loading project definition from /tmp/foo-build/project
[info] Loading settings from build.sbt ...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
sbt:Hello&gt;
</code></pre><p>Note that the prompt has now changed to <code>sbt:Hello&gt;</code>.
</p><h3 id="Add+ScalaTest+to+libraryDependencies">Add ScalaTest to libraryDependencies<a href="#Add+ScalaTest+to+libraryDependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using an editor, change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )
</code></pre><p>Use the <code>reload</code> command to reflect the change in <code>build.sbt</code>.
</p><pre><code class="">sbt:Hello&gt; reload
</code></pre><h3 id="Run+tests">Run tests<a href="#Run+tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; test
</code></pre><h3 id="Run+incremental+tests+continuously">Run incremental tests continuously<a href="#Run+incremental+tests+continuously" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; ~testQuick
</code></pre><h3 id="Write+a+test">Write a test<a href="#Write+a+test" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Leaving the previous command running, create a file named <code>src/test/scala/HelloSpec.scala</code>
using an editor:
</p><pre><code class="prettyprint lang-scala">import org.scalatest._

class HelloSpec extends FunSuite with DiagrammedAssertions {
  test(&quot;Hello should start with H&quot;) {
    assert(&quot;hello&quot;.startsWith(&quot;H&quot;))
  }
}
</code></pre><p><code>~testQuick</code> should pick up the change:
</p><pre><code class="">2. Waiting for source changes... (press enter to interrupt)
[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/test-classes ...
[info] Done compiling.
[info] HelloSpec:
[info] - Hello should start with H *** FAILED ***
[info]   assert(&quot;hello&quot;.startsWith(&quot;H&quot;))
[info]          |       |          |
[info]          &quot;hello&quot; false      &quot;H&quot; (HelloSpec.scala:5)
[info] Run completed in 135 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0
[info] *** 1 TEST FAILED ***
[error] Failed tests:
[error]   HelloSpec
[error] (Test / testQuick) sbt.TestsFailedException: Tests unsuccessful
</code></pre><h3 id="Make+the+test+pass">Make the test pass<a href="#Make+the+test+pass" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using an editor, change <code>src/test/scala/HelloSpec.scala</code> to:
</p><pre><code class="prettyprint lang-scala">import org.scalatest._

class HelloSpec extends FunSuite with DiagrammedAssertions {
  test(&quot;Hello should start with H&quot;) {
    // Hello, as opposed to hello
    assert(&quot;Hello&quot;.startsWith(&quot;H&quot;))
  }
}
</code></pre><p>Confirm that the test passes, then press <code>Enter</code> to exit the continuous test.
</p><h3 id="Add+a+library+dependency">Add a library dependency<a href="#Add+a+library+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using an editor, change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )
</code></pre><p>Use the <code>reload</code> command to reflect the change in <code>build.sbt</code>.
</p><h3 id="Use+Scala+REPL">Use Scala REPL<a href="#Use+Scala+REPL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We can find out the current weather in New York.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; console
[info] Starting scala interpreter...
Welcome to Scala 2.12.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).
Type in expressions for evaluation. Or try :help.

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

import scala.concurrent._, duration._
import gigahorse._, support.okhttp.Gigahorse
import play.api.libs.json._

Gigahorse.withHttp(Gigahorse.config) { http =&gt;
  val baseUrl = &quot;https://www.metaweather.com/api/location&quot;
  val rLoc = Gigahorse.url(baseUrl + &quot;/search/&quot;).get.
    addQueryString(&quot;query&quot; -&gt; &quot;New York&quot;)
  val fLoc = http.run(rLoc, Gigahorse.asString)
  val loc = Await.result(fLoc, 10.seconds)
  val woeid = (Json.parse(loc) \ 0 \ &quot;woeid&quot;).get
  val rWeather = Gigahorse.url(baseUrl + s&quot;/$woeid/&quot;).get
  val fWeather = http.run(rWeather, Gigahorse.asString)
  val weather = Await.result(fWeather, 10.seconds)
  ({Json.parse(_: String)} andThen Json.prettyPrint)(weather)
}

// press Ctrl+D

// Exiting paste mode, now interpreting.

import scala.concurrent._
import duration._
import gigahorse._
import support.okhttp.Gigahorse
import play.api.libs.json._
res0: String =
{
  &quot;consolidated_weather&quot; : [ {
    &quot;id&quot; : 6446939314847744,
    &quot;weather_state_name&quot; : &quot;Light Rain&quot;,
    &quot;weather_state_abbr&quot; : &quot;lr&quot;,
    &quot;wind_direction_compass&quot; : &quot;WNW&quot;,
    &quot;created&quot; : &quot;2019-02-21T04:39:47.747805Z&quot;,
    &quot;applicable_date&quot; : &quot;2019-02-21&quot;,
    &quot;min_temp&quot; : 0.48000000000000004,
    &quot;max_temp&quot; : 7.84,
    &quot;the_temp&quot; : 2.1700000000000004,
    &quot;wind_speed&quot; : 5.996333145703094,
    &quot;wind_direction&quot; : 293.12257757287307,
    &quot;air_pressure&quot; : 1033.115,
    &quot;humidity&quot; : 77,
    &quot;visibility&quot; : 14.890539250775472,
    &quot;predictability&quot; : 75
  }, {
    &quot;id&quot; : 5806299509948416,
    &quot;weather_state_name&quot; : &quot;Heavy Cloud&quot;,
...

scala&gt; :q // to quit
</code></pre><h3 id="Make+a+subproject">Make a subproject<a href="#Make+a+subproject" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
  )
</code></pre><p>Use the <code>reload</code> command to reflect the change in <code>build.sbt</code>.
</p><h3 id="List+all+subprojects">List all subprojects<a href="#List+all+subprojects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; projects
[info] In file:/tmp/foo-build/
[info]   * hello
[info]     helloCore
</code></pre><h3 id="Compile+the+subproject">Compile the subproject<a href="#Compile+the+subproject" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; helloCore/compile
</code></pre><h3 id="Add+ScalaTest+to+the+subproject">Add ScalaTest to the subproject<a href="#Add+ScalaTest+to+the+subproject" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Broadcast+commands">Broadcast commands<a href="#Broadcast+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set aggregate so that the command sent to <code>hello</code> is broadcast to <code>helloCore</code> too:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><p>After <code>reload</code>, <code>~testQuick</code> now runs on both subprojects:
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; ~testQuick
</code></pre><p>Press <code>Enter</code> to exit the continuous test.
</p><h3 id="Make+hello+depend+on+helloCore">Make hello depend on helloCore<a href="#Make+hello+depend+on+helloCore" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Use <code>.dependsOn(...)</code> to add a dependency on other subprojects. Also let’s move the Gigahorse dependency to <code>helloCore</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Parse+JSON+using+Play+JSON">Parse JSON using Play JSON<a href="#Parse+JSON+using+Play+JSON" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Let’s add Play JSON to <code>helloCore</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><p>After <code>reload</code>, add <code>core/src/main/scala/example/core/Weather.scala</code>:
</p><pre><code class="prettyprint lang-scala">package example.core

import gigahorse._, support.okhttp.Gigahorse
import scala.concurrent._, duration._
import play.api.libs.json._

object Weather {
  lazy val http = Gigahorse.http(Gigahorse.config)

  def weather: Future[String] = {
    val baseUrl = &quot;https://www.metaweather.com/api/location&quot;
    val locUrl = baseUrl + &quot;/search/&quot;
    val weatherUrl = baseUrl + &quot;/%s/&quot;
    val rLoc = Gigahorse.url(locUrl).get.
      addQueryString(&quot;query&quot; -&gt; &quot;New York&quot;)
    import ExecutionContext.Implicits.global
    for {
      loc &lt;- http.run(rLoc, parse)
      woeid = (loc \ 0  \ &quot;woeid&quot;).get
      rWeather = Gigahorse.url(weatherUrl format woeid).get
      weather &lt;- http.run(rWeather, parse)
    } yield (weather \\ &quot;weather_state_name&quot;)(0).as[String].toLowerCase
  }

  private def parse = Gigahorse.asString andThen Json.parse
}
</code></pre><p>Next, change <code>src/main/scala/example/Hello.scala</code> as follows:
</p><pre><code class="prettyprint lang-scala">package example

import scala.concurrent._, duration._
import core.Weather

object Hello extends App {
  val w = Await.result(Weather.weather, 10.seconds)
  println(s&quot;Hello! The weather in New York is $w.&quot;)
  Weather.http.close()
}
</code></pre><p>Let’s run the app to see if it worked:
</p><pre><code class="">sbt:Hello&gt; run
[info] Compiling 1 Scala source to /tmp/foo-build/core/target/scala-2.12/classes ...
[info] Done compiling.
[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/classes ...
[info] Packaging /tmp/foo-build/core/target/scala-2.12/hello-core_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Done compiling.
[info] Packaging /tmp/foo-build/target/scala-2.12/hello_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Running example.Hello
Hello! The weather in New York is mostly cloudy.
</code></pre><h3 id="Add+sbt-native-packager+plugin">Add sbt-native-packager plugin<a href="#Add+sbt-native-packager+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using an editor, create <code>project/plugins.sbt</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-native-packager&quot; % &quot;1.3.4&quot;)
</code></pre><p>Next change <code>build.sbt</code> as follows to add <code>JavaAppPackaging</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .enablePlugins(JavaAppPackaging)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Reload+and+create+a+.zip+distribution">Reload and create a .zip distribution<a href="#Reload+and+create+a+.zip+distribution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; reload
...
sbt:Hello&gt; dist
[info] Wrote /tmp/foo-build/target/scala-2.12/hello_2.12-0.1.0-SNAPSHOT.pom
[info] Wrote /tmp/foo-build/core/target/scala-2.12/hello-core_2.12-0.1.0-SNAPSHOT.pom
[info] Your package is ready in /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
</code></pre><p>Here’s how you can run the packaged app:
</p><pre><code class="">$ /tmp/someother
$ cd /tmp/someother
$ unzip -o -d /tmp/someother /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
$ ./hello-0.1.0-SNAPSHOT/bin/hello
Hello! The weather in New York is mostly cloudy.
</code></pre><h3 id="Dockerize+your+app">Dockerize your app<a href="#Dockerize+your+app" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; Docker/publishLocal
....
[info] Successfully built b6ce1b6ab2c0
[info] Successfully tagged hello:0.1.0-SNAPSHOT
[info] Built image hello:0.1.0-SNAPSHOT
</code></pre><p>Here’s how to run the Dockerized app:
</p><pre><code class="">$ docker run hello:0.1.0-SNAPSHOT
Hello! The weather in New York is mostly cloudy
</code></pre><h3 id="Set+the+version">Set the version<a href="#Set+the+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Change <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / version      := &quot;0.1.0&quot;
ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .enablePlugins(JavaAppPackaging)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Switch+scalaVersion+temporarily">Switch scalaVersion temporarily<a href="#Switch+scalaVersion+temporarily" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; ++2.11.12!
[info] Forcing Scala version to 2.11.12 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
</code></pre><p>Check the <code>scalaVersion</code> setting:
</p><pre><code class="">sbt:Hello&gt; scalaVersion
[info] helloCore / scalaVersion
[info]  2.11.12
[info] scalaVersion
[info]  2.11.12 scalaVersion
[info] 2.12.7
</code></pre><p>This setting will go away after <code>reload</code>.
</p><h3 id="Inspect+the+dist+task">Inspect the dist task<a href="#Inspect+the+dist+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To find out more about <code>dist</code>, try <code>help</code> and <code>inspect</code>.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; help dist
Creates the distribution packages.
sbt:Hello&gt; inspect dist
</code></pre><p>To call inspect recursively on the dependency tasks use <code>inspect tree</code>.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; inspect tree dist
[info] dist = Task[java.io.File]
[info]   +-Universal / dist = Task[java.io.File]
....
</code></pre><h3 id="Batch+mode">Batch mode<a href="#Batch+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can also run sbt in batch mode, passing sbt commands directly from the terminal.
</p><pre><code class="">$ sbt clean &quot;testOnly HelloSpec&quot;
</code></pre><p><strong>Note</strong>: Running in batch mode requires JVM spinup and JIT each time,
so <strong>your build will run much slower</strong>.
For day-to-day coding, we recommend using the sbt shell
or a continuous test like <code>~testQuick</code>.
</p><h3 id="sbt+new+command">sbt new command<a href="#sbt+new+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can use the sbt <code>new</code> command to quickly setup a simple “Hello world” build.
</p><pre><code class="">$ sbt new scala/scala-seed.g8
....
A minimal Scala project.

name [My Something Project]: hello

Template applied in ./hello
</code></pre><p>When prompted for the project name, type <code>hello</code>.
</p><p>This will create a new project under a directory named <code>hello</code>.
</p><h3 id="Credits">Credits<a href="#Credits" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This page is based on the <a href="https://www.scalawilliam.com/essential-sbt/">Essential sbt</a> tutorial written by William “Scala William” Narmontas.
</p><h2 id="Directory+structure">Directory structure<a href="#Directory+structure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page assumes you’ve <a href="Setup.html">installed sbt</a> and seen
<a href="sbt-by-example.html">sbt by example</a>.
</p><h3 id="Base+directory">Base directory<a href="#Base+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt’s terminology, the “base directory” is the directory containing
the project. So if you created a project <code>hello</code> containing
<code>/tmp/foo-build/build.sbt</code> as in the <a href="sbt-by-example.html">sbt by example</a>,
<code>/tmp/foo-build</code> is your base directory.
</p><h3 id="Source+code">Source code<a href="#Source+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt uses the same directory structure as
<a href="https://maven.apache.org/">Maven</a> for source files by default (all paths
are relative to the base directory):
</p><pre><code class="">src/
  main/
    resources/
       &lt;files to include in main jar here&gt;
    scala/
       &lt;main Scala sources&gt;
    scala-2.12/
       &lt;main Scala 2.12 specific sources&gt;
    java/
       &lt;main Java sources&gt;
  test/
    resources
       &lt;files to include in test jar here&gt;
    scala/
       &lt;test Scala sources&gt;
    scala-2.12/
       &lt;test Scala 2.12 specific sources&gt;
    java/
       &lt;test Java sources&gt;
</code></pre><p>Other directories in <code>src/</code> will be ignored. Additionally, all hidden
directories will be ignored.
</p><p>Source code can be placed in the project’s base directory as
<code>hello/app.scala</code>, which may be OK for small projects,
though for normal projects people tend to keep the projects in
the <code>src/main/</code> directory to keep things neat.
The fact that you can place <code>*.scala</code> source code in the base directory might seem like
an odd trick, but this fact becomes relevant <a href="Organizing-Build.html">later</a>.
</p><h3 id="sbt+build+definition+files">sbt build definition files<a href="#sbt+build+definition+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The build definition is described in <code>build.sbt</code> (actually any files named <code>*.sbt</code>) in the project’s base directory.
</p><pre><code class="">build.sbt
</code></pre><h3 id="Build+support+files">Build support files<a href="#Build+support+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to <code>build.sbt</code>, <code>project</code> directory can contain <code>.scala</code> files
that define helper objects and one-off plugins.
See <a href="Organizing-Build.html">organizing the build</a> for more.
</p><pre><code class="">build.sbt
project/
  Dependencies.scala
</code></pre><p>You may see <code>.sbt</code> files inside <code>project/</code> but they are not equivalent to
<code>.sbt</code> files in the project’s base directory. Explaining this will
come <a href="Organizing-Build.html">later</a>, since you’ll need some background information first.
</p><h3 id="Build+products">Build products<a href="#Build+products" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Generated files (compiled classes, packaged jars, managed files, caches,
and documentation) will be written to the <code>target</code> directory by default.
</p><h3 id="Configuring+version+control">Configuring version control<a href="#Configuring+version+control" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Your <code>.gitignore</code> (or equivalent for other version control systems) should
contain:
</p><pre><code class="">target/
</code></pre><p>Note that this deliberately has a trailing <code>/</code> (to match only directories)
and it deliberately has no leading <code>/</code> (to match <code>project/target/</code> in
addition to plain <code>target/</code>).
</p><h2 id="Running">Running<a href="#Running" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes how to use sbt once you have set up your project. It
assumes you’ve <a href="Setup.html">installed sbt</a> and went through
<a href="sbt-by-example.html">sbt by example</a>.
</p><h3 id="sbt+shell">sbt shell<a href="#sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Run sbt in your project directory with no arguments:
</p><pre><code class="">$ sbt
</code></pre><p>Running sbt with no command line arguments starts sbt shell.
sbt shell has a command prompt (with tab completion and
history!).
</p><p>For example, you could type <code>compile</code> at the sbt shell:
</p><pre><code class="">&gt; compile
</code></pre><p>To <code>compile</code> again, press up arrow and then enter.
</p><p>To run your program, type <code>run</code>.
</p><p>To leave sbt shell, type <code>exit</code> or use Ctrl+D (Unix) or Ctrl+Z
(Windows).
</p><h3 id="Batch+mode">Batch mode<a href="#Batch+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can also run sbt in batch mode, specifying a space-separated list of
sbt commands as arguments. For sbt commands that take arguments, pass
the command and arguments as one argument to sbt by enclosing them in
quotes. For example,
</p><pre><code class="">$ sbt clean compile &quot;testOnly TestA TestB&quot;
</code></pre><p>In this example, <code>testOnly</code> has arguments, <code>TestA</code> and <code>TestB</code>. The commands
will be run in sequence (<code>clean</code>, <code>compile</code>, then <code>testOnly</code>).
</p><p><strong>Note</strong>: Running in batch mode requires JVM spinup and JIT each time,
so <strong>your build will run much slower</strong>.
For day-to-day coding, we recommend using the sbt shell
or Continuous build and test feature described below.
</p><p>Beginning in sbt 0.13.16, using batch mode in sbt will issue an
informational startup message,
</p><pre><code class="">$ sbt clean compile
[info] Executing in batch mode. For better performance use sbt's shell
...
</code></pre><p>It will only be triggered for <code>sbt compile</code>, and it can also be
suppressed with <code>suppressSbtShellNotification := true</code>.
</p><h3 id="Continuous+build+and+test">Continuous build and test<a href="#Continuous+build+and+test" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To speed up your edit-compile-test cycle, you can ask sbt to
automatically recompile or run tests whenever you save a source file.
</p><p>Make a command run when one or more source files change by prefixing the
command with <code>~</code>. For example, in sbt shell try:
</p><pre><code class="">&gt; ~testQuick
</code></pre><p>Press enter to stop watching for changes.
</p><p>You can use the <code>~</code> prefix with either sbt shell or batch mode.
</p><p>See <a href="../docs/Triggered-Execution.html">Triggered Execution</a> for more details.
</p><h3 id="Common+commands">Common commands<a href="#Common+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here are some of the most common sbt commands. For a more complete list,
see <a href="../docs/Command-Line-Reference.html">Command Line Reference</a>.
</p><table class="table table-striped">
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><tt>clean</tt></td>
    <td>Deletes all generated files (in the <tt>target</tt> directory).</td>
  </tr>
  <tr>
    <td><tt>compile</tt></td>
    <td>Compiles the main sources (in <tt>src/main/scala</tt> and
   <tt>src/main/java</tt> directories).</td>
  </tr>
  <tr>
    <td><tt>test</tt></td>
    <td>Compiles and runs all tests.</td>
  </tr>
  <tr>
    <td><tt>console</tt></td>
    <td>Starts the Scala interpreter with a classpath including the
   compiled sources and all dependencies. To return to sbt, type <tt>:quit</tt>,
   Ctrl+D (Unix), or Ctrl+Z (Windows).</td>
  </tr>
  <tr>
    <td><nobr><tt>run &lt;argument&gt;*</tt></nobr></td>
    <td>Runs the main class for the project in the same
   virtual machine as sbt.</td>
  </tr>
  <tr>
    <td><tt>package</tt></td>
    <td>Creates a jar file containing the files in
    <tt>src/main/resources</tt> and the classes compiled from <tt>src/main/scala</tt> and
    <tt>src/main/java</tt>.</td>
  </tr>
  <tr>
    <td><tt>help &lt;command&gt;</tt></td>
    <td>Displays detailed help for the specified command.
    If no command is provided, displays brief descriptions of all
    commands.</td>
  </tr>
  <tr>
    <td><tt>reload</tt></td>
    <td>Reloads the build definition (<tt>build.sbt</tt>, <tt>project/*.scala</tt>,
    <tt>project/*.sbt</tt> files). Needed if you change the build definition.</td>
  </tr>
</table><h3 id="Tab+completion">Tab completion<a href="#Tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt shell has tab completion, including at an empty prompt. A
special sbt convention is that pressing tab once may show only a subset
of most likely completions, while pressing it more times shows more
verbose choices.
</p><a name="history"></a><h3 id="sbt+shell+history">sbt shell history<a href="#sbt+shell+history" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt shell remembers history even if you exit sbt and restart it.
The easiest way to access history is to press the up arrow key to cycle
through previously entered commands.
</p><p><strong>Note</strong>: <code>Ctrl-R</code> incrementally <em>searches</em> the history backwards.
</p><p>Through JLine’s integration with the terminal environment,
you can customize sbt shell by changing <code>$HOME/.inputrc</code> file.
For example, the following settings in <code>$HOME/.inputrc</code> will allow up- and down-arrow to perform
prefix-based search of the history.
</p><pre><code class="">&quot;\e[A&quot;: history-search-backward
&quot;\e[B&quot;: history-search-forward
&quot;\e[C&quot;: forward-char
&quot;\e[D&quot;: backward-char
</code></pre><p>sbt shell also supports the following commands:
</p><table class="table table-striped">
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><tt>!</tt></td>
    <td>Show history command help.</td>
  </tr>
  <tr>
    <td><tt>!!</tt></td>
    <td>Execute the previous command again.</td>
  </tr>
  <tr>
    <td><tt>!:</tt></td>
    <td>Show all previous commands.</td>
  </tr>
  <tr>
    <td><tt>!:n</tt></td>
    <td>Show the last <tt>n</tt> commands.</td>
  </tr>
  <tr>
    <td><tt>!n</tt></td>
    <td>Execute the command with index <tt>n</tt>, as shown by the <tt>!:</tt> command.</td>
  </tr>
  <tr>
    <td><tt>!-n</tt></td>
    <td>Execute the nth command before this one.</td>
  </tr>
  <tr>
    <td><tt>!string</tt></td>
    <td>Execute the most recent command starting with 'string.'</td>
  </tr>
  <tr>
    <td><tt>!?string</tt></td>
    <td>Execute the most recent command containing 'string.'</td>
  </tr>
</table><h2 id="Build+definition">Build definition<a href="#Build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes sbt build definitions, including some “theory” and
the syntax of <code>build.sbt</code>.
It assumes you have installed a recent version of sbt, such as sbt 1.4.7,
know how to <a href="Running.html">use sbt</a>,
and have read the previous pages in the Getting Started Guide.
</p><p>This page discusses the <code>build.sbt</code> build definition.
</p><h3 id="Specifying+the+sbt+version">Specifying the sbt version<a href="#Specifying+the+sbt+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As part of your build definition you will specify the version of
sbt that your build uses.
This allows people with different versions of the sbt launcher to
build the same projects with consistent results.
To do this, create a file named <code>project/build.properties</code> that specifies the sbt version as follows:
</p><pre><code class="">sbt.version=1.4.7
</code></pre><p>If the required version is not available locally,
the <code>sbt</code> launcher will download it for you.
If this file is not present, the <code>sbt</code> launcher will choose an arbitrary version,
which is discouraged because it makes your build non-portable.
</p><h3 id="What+is+a+build+definition%3F">What is a build definition?<a href="#What+is+a+build+definition%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <em>build definition</em> is defined in <code>build.sbt</code>,
and it consists of a set of projects (of type <a href="../api/sbt/Project.html"><code>Project</code></a>).
Because the term <em>project</em> can be ambiguous,
we often call it a <em>subproject</em> in this guide.
</p><p>For instance, in <code>build.sbt</code> you define
the subproject located in the current directory like this:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalaVersion := &quot;2.12.7&quot;
  )
</code></pre><p>Each subproject is configured by key-value pairs.
</p><p>For example, one key is <code>name</code> and it maps to a string value, the name of
your subproject.
The key-value pairs are listed under the <code>.settings(...)</code> method as follows:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalaVersion := &quot;2.12.7&quot;
  )
</code></pre><h3 id="How+build.sbt+defines+settings">How build.sbt defines settings<a href="#How+build.sbt+defines+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>build.sbt</code> defines subprojects, which holds a sequence of key-value pairs
called <em>setting expressions</em> using <em>build.sbt domain-specific language(DSL)</em>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><p>Let’s take a closer look at the <code>build.sbt</code> DSL:
<img src="files/setting-expression.png" alt="setting expression"/><br>
<br>
Each entry is called a <em>setting expression</em>.
Some among them are also called task expressions.
We will see more on the difference later in this page.
</p><p>A setting expression consists of three parts:
</p><ol><li>Left-hand side is a <em>key</em>.
</li><li><em>Operator</em>, which in this case is <code>:=</code>
</li><li>Right-hand side is called the <em>body</em>, or the <em>setting body</em>.
</li></ol><p>On the left-hand side, <code>name</code>, <code>version</code>, and <code>scalaVersion</code> are <em>keys</em>.
A key is an instance of
<a href="../api/sbt/SettingKey.html"><code>SettingKey[T]</code></a>,
<a href="../api/sbt/TaskKey.html"><code>TaskKey[T]</code></a>, or
<a href="../api/sbt/InputKey.html"><code>InputKey[T]</code></a> where <code>T</code> is the
expected value type. The kinds of key are explained below.
</p><p>Because key <code>name</code> is typed to <code>SettingKey[String]</code>,
the <code>:=</code> operator on <code>name</code> is also typed specifically to <code>String</code>.
If you use the wrong value type, the build definition will not compile:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := 42  // will not compile
  )
</code></pre><p><code>build.sbt</code> may also be
interspersed with <code>val</code>s, <code>lazy val</code>s, and <code>def</code>s. Top-level <code>object</code>s and
<code>class</code>es are not allowed in <code>build.sbt</code>. Those should go in the <code>project/</code>
directory as Scala source files.
</p><h3 id="Keys">Keys<a href="#Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Types">Types<a href="#Types" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There are three flavors of key:
</p><ul><li><code>SettingKey[T]</code>: a key for a value computed once (the value is
computed when loading the subproject, and kept around).
</li><li><code>TaskKey[T]</code>: a key for a value, called a <em>task</em>, that has to be
recomputed each time, potentially with side effects.
</li><li><code>InputKey[T]</code>: a key for a task that has command line arguments as
input. Check out <a href="../docs/Input-Tasks.html">Input Tasks</a> for more details.
</li></ul><h4 id="Built-in+Keys">Built-in Keys<a href="#Built-in+Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The built-in keys are just fields in an object called
<a href="../api/sbt/Keys$.html">Keys</a>. A <code>build.sbt</code> implicitly has an
<code>import sbt.Keys._</code>, so <code>sbt.Keys.name</code> can be referred to as <code>name</code>.
</p><h4 id="Custom+Keys">Custom Keys<a href="#Custom+Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Custom keys may be defined with their respective creation methods:
<code>settingKey</code>, <code>taskKey</code>, and <code>inputKey</code>. Each method expects the type of the
value associated with the key as well as a description. The name of the
key is taken from the <code>val</code> the key is assigned to. For example, to define
a key for a new task called <code>hello</code>,
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;An example task&quot;)
</code></pre><p>Here we have used the fact that an <code>.sbt</code> file can contain <code>val</code>s and <code>def</code>s
in addition to settings. All such definitions are evaluated before
settings regardless of where they are defined in the file.
</p><blockquote><p><strong>Note:</strong> Typically, lazy vals are used instead of vals to avoid initialization
order problems.
</p></blockquote><h4 id="Task+vs+Setting+keys">Task vs Setting keys<a href="#Task+vs+Setting+keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A <code>TaskKey[T]</code> is said to define a <em>task</em>. Tasks are operations such as
<code>compile</code> or <code>package</code>. They may return <code>Unit</code> (<code>Unit</code> is <code>void</code> for Scala), or
they may return a value related to the task, for example <code>package</code> is a
<code>TaskKey[File]</code> and its value is the jar file it creates.
</p><p>Each time you start a task execution, for example by typing <code>compile</code> at
the interactive sbt prompt, sbt will re-run any tasks involved exactly
once.
</p><p>sbt’s key-value pairs describing the subproject can keep around a fixed string value
for a setting such as name, but it has to keep around some executable
code for a task such as <code>compile</code> — even if that executable code
eventually returns a string, it has to be re-run every time.
</p><p><em>A given key always refers to either a task or a plain setting.</em> That
is, “taskiness” (whether to re-run each time) is a property of the key,
not the value.
</p><h3 id="Defining+tasks+and+settings">Defining tasks and settings<a href="#Defining+tasks+and+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Using <code>:=</code>, you can assign a value to a setting and a computation to a
task. For a setting, the value will be computed once at project load
time. For a task, the computation will be re-run each time the task is
executed.
</p><p>For example, to implement the <code>hello</code> task from the previous section:
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;An example task&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    hello := { println(&quot;Hello!&quot;) }
  )
</code></pre><p>We already saw an example of defining settings when we defined the
project’s name,
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><h4 id="Types+for+tasks+and+settings">Types for tasks and settings<a href="#Types+for+tasks+and+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>From a type-system perspective, the <code>Setting</code> created from a task key is
slightly different from the one created from a setting key.
<code>taskKey := 42</code> results in a <code>Setting[Task[T]]</code> while <code>settingKey := 42</code>
results in a <code>Setting[T]</code>. For most purposes this makes no difference; the
task key still creates a value of type <code>T</code> when the task executes.
</p><p>The <code>T</code> vs. <code>Task[T]</code> type difference has this implication: a setting can’t
depend on a task, because a setting is evaluated only once on project
load and is not re-run. More on this in <a href="Task-Graph.html">task graph</a>.
</p><h3 id="Keys+in+sbt+shell">Keys in sbt shell<a href="#Keys+in+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt shell, you can type the name of any task to execute
that task. This is why typing <code>compile</code> runs the <code>compile</code> task. <code>compile</code> is
a task key.
</p><p>If you type the name of a setting key rather than a task key, the value
of the setting key will be displayed. Typing a task key name executes
the task but doesn’t display the resulting value; to see a task’s
result, use <code>show &lt;task name&gt;</code> rather than plain <code>&lt;task name&gt;</code>. The
convention for keys names is to use <code>camelCase</code> so that the command line
name and the Scala identifiers are the same.
</p><p>To learn more about any key, type <code>inspect &lt;keyname&gt;</code> at the sbt
interactive prompt. Some of the information <code>inspect</code> displays won’t make
sense yet, but at the top it shows you the setting’s value type and a
brief description of the setting.
</p><h3 id="Imports+in+build.sbt">Imports in build.sbt<a href="#Imports+in+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can place import statements at the top of <code>build.sbt</code>; they need not
be separated by blank lines.
</p><p>There are some implied default imports, as follows:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._
</code></pre><p>(In addition, if you have auto plugins, the names marked under <code>autoImport</code> will be imported.)
</p><h3 id="Bare+.sbt+build+definition">Bare .sbt build definition<a href="#Bare+.sbt+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The settings can be written directly into the <code>build.sbt</code> file instead of
putting them inside a <code>.settings(...)</code> call. We call this the “bare style.”
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;1.0&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
</code></pre><p>This syntax is recommended for <code>ThisBuild</code> scoped settings and adding plugins.
See later section about the scoping and the plugins.
</p><h3 id="Adding+library+dependencies">Adding library dependencies<a href="#Adding+library+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To depend on third-party libraries, there are two options. The first is
to drop jars in <code>lib/</code> (unmanaged dependencies) and the other is to add
managed dependencies, which will look like this in <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">val derby = &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += derby
  )
</code></pre><p>This is how you add a managed dependency on the Apache Derby library,
version 10.4.1.3.
</p><p>The <code>libraryDependencies</code> key involves two complexities: <code>+=</code> rather than
<code>:=</code>, and the <code>%</code> method. <code>+=</code> appends to the key’s old value rather than
replacing it, this is explained in
<a href="Task-Graph.html">Task Graph</a>. The <code>%</code>
method is used to construct an Ivy module ID from strings, explained in
<a href="Library-Dependencies.html">Library dependencies</a>.
</p><p>We’ll skip over the details of library dependencies until later in the
Getting Started Guide. There’s a
<a href="Library-Dependencies.html">whole page</a> covering it later on.
</p><h2 id="Multi-project+builds">Multi-project builds<a href="#Multi-project+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page introduces multiple subprojects in a single build.
</p><p>Please read the earlier pages in the Getting Started Guide first, in
particular you need to understand <a href="Basic-Def.html">build.sbt</a> before reading
this page.
</p><h3 id="Multiple+subprojects">Multiple subprojects<a href="#Multiple+subprojects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It can be useful to keep multiple related subprojects in a single build,
especially if they depend on one another and you tend to modify them
together.
</p><p>Each subproject in a build has its own source directories, generates
its own jar file when you run package, and in general works like any
other project.
</p><p>A project is defined by declaring a lazy val of type
<a href="../api/sbt/Project.html">Project</a>. For example, :
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))

lazy val core = (project in file(&quot;core&quot;))
</code></pre><p>The name of the val is used as the subproject’s ID, which
is used to refer to the subproject at the sbt shell.
</p><p>Optionally the base directory may be omitted if it’s the same as the name of the val.
</p><pre><code class="prettyprint lang-scala">lazy val util = project

lazy val core = project
</code></pre><a name="ThisBuild"></a><h4 id="Build-wide+settings">Build-wide settings<a href="#Build-wide+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To factor out common settings across multiple subprojects,
define the settings scoped to <code>ThisBuild</code>.
<code>ThisBuild</code> acts as a special subproject name that you can use to define default
value for the build.
When you define one or more subprojects, and when the subproject does not define
<code>scalaVersion</code> key, it will look for <code>ThisBuild / scalaVerion</code>.
</p><p>The limitation is that the right-hand side needs to be a pure value
or settings scoped to <code>Global</code> or <code>ThisBuild</code>,
and there are no default settings scoped to subprojects. (See <a href="Scopes.html">Scopes</a>)
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    // other settings
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    // other settings
  )
</code></pre><p>Now we can bump up <code>version</code> in one place, and it will be reflected
across subprojects when you reload the build.
</p><h4 id="Common+settings">Common settings<a href="#Common+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Another way to factor out common settings across multiple projects is to
create a sequence named <code>commonSettings</code> and call <code>settings</code> method
on each project.
</p><pre><code class="prettyprint lang-scala">lazy val commonSettings = Seq(
  target := { baseDirectory.value / &quot;target2&quot; }
)

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    commonSettings,
    // other settings
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    commonSettings,
    // other settings
  )
</code></pre><h3 id="Dependencies">Dependencies<a href="#Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Projects in the build can be completely independent of one another, but
usually they will be related to one another by some kind of dependency.
There are two types of dependencies: aggregate and classpath.
</p><h4 id="Aggregation">Aggregation<a href="#Aggregation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Aggregation means that running a task on the aggregate project will also
run it on the aggregated projects. For example,
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)

lazy val util = (project in file(&quot;util&quot;))

lazy val core = (project in file(&quot;core&quot;))
</code></pre><p>In the above example, the root project aggregates <code>util</code> and <code>core</code>. Start
up sbt with two subprojects as in the example, and try compile. You
should see that all three projects are compiled.
</p><p><em>In the project doing the aggregating</em>, the root project in this case,
you can control aggregation per-task. For example, to avoid aggregating
the <code>update</code> task:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)
  .settings(
    update / aggregate := false
  )

[...]
</code></pre><p><code>update / aggregate</code> is the aggregate key scoped to the <code>update</code> task. (See
<a href="Scopes.html">scopes</a>.)
</p><p>Note: aggregation will run the aggregated tasks in parallel and with no
defined ordering between them.
</p><h4 id="Classpath+dependencies">Classpath dependencies<a href="#Classpath+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A project may depend on code in another project. This is done by adding
a <code>dependsOn</code> method call. For example, if core needed util on its
classpath, you would define core as:
</p><pre><code class="prettyprint lang-scala">lazy val core = project.dependsOn(util)
</code></pre><p>Now code in <code>core</code> can use classes from <code>util</code>. This also creates an
ordering between the projects when compiling them; <code>util</code> must be updated
and compiled before core can be compiled.
</p><p>To depend on multiple projects, use multiple arguments to <code>dependsOn</code>,
like <code>dependsOn(bar, baz)</code>.
</p><h5 id="Per-configuration+classpath+dependencies">Per-configuration classpath dependencies<a href="#Per-configuration+classpath+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>core dependsOn(util)</code> means that the <code>compile</code> configuration in <code>core</code> depends
on the <code>compile</code> configuration in <code>util</code>. You could write this explicitly as
<code>dependsOn(util % &quot;compile-&gt;compile&quot;)</code>.
</p><p>The <code>-&gt;</code> in <code>&quot;compile-&gt;compile&quot;</code> means “depends on” so <code>&quot;test-&gt;compile&quot;</code>
means the <code>test</code> configuration in <code>core</code> would depend on the <code>compile</code>
configuration in <code>util</code>.
</p><p>Omitting the <code>-&gt;config</code> part implies <code>-&gt;compile</code>, so
<code>dependsOn(util % &quot;test&quot;)</code> means that the <code>test</code> configuration in <code>core</code> depends
on the <code>Compile</code> configuration in <code>util</code>.
</p><p>A useful declaration is <code>&quot;test-&gt;test&quot;</code> which means <code>test</code> depends on <code>test</code>.
This allows you to put utility code for testing in <code>util/src/test/scala</code>
and then use that code in <code>core/src/test/scala</code>, for example.
</p><p>You can have multiple configurations for a dependency, separated by
semicolons. For example,
<code>dependsOn(util % &quot;test-&gt;test;compile-&gt;compile&quot;)</code>.
</p><h3 id="Inter-project+dependencies">Inter-project dependencies<a href="#Inter-project+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On extremely large projects with many files and many subprojects, sbt
can perform less optimally at continuously watching files that have
changed and use a lot of disk and system I/O.
</p><p>sbt has <code>trackInternalDependencies</code> and <code>exportToInternal</code>
settings. These can be used to control whether to trigger compilation
of a dependent subprojects when you call <code>compile</code>. Both keys will
take one of three values: <code>TrackLevel.NoTracking</code>,
<code>TrackLevel.TrackIfMissing</code>, and <code>TrackLevel.TrackAlways</code>. By default
they are both set to <code>TrackLevel.TrackAlways</code>.
</p><p>When <code>trackInternalDependencies</code> is set to
<code>TrackLevel.TrackIfMissing</code>, sbt will no longer try to compile
internal (inter-project) dependencies automatically, unless there are
no <code>*.class</code> files (or JAR file when <code>exportJars</code> is <code>true</code>) in the
output directory.
</p><p>When the setting is set to <code>TrackLevel.NoTracking</code>, the compilation of
internal dependencies will be skipped. Note that the classpath will
still be appended, and dependency graph will still show them as
dependencies. The motivation is to save the I/O overhead of checking
for the changes on a build with many subprojects during
development. Here’s how to set all subprojects to <code>TrackIfMissing</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / trackInternalDependencies := TrackLevel.TrackIfMissing
ThisBuild / exportJars := true

lazy val root = (project in file(&quot;.&quot;))
  .aggregate(....)
</code></pre><p>The <code>exportToInternal</code> setting allows the dependee subprojects to opt
out of the internal tracking, which might be useful if you want to
track most subprojects except for a few. The intersection of the
<code>trackInternalDependencies</code> and <code>exportToInternal</code> settings will be
used to determine the actual track level. Here’s an example to opt-out
one project:
</p><pre><code class="prettyprint lang-scala">lazy val dontTrackMe = (project in file(&quot;dontTrackMe&quot;))
  .settings(
    exportToInternal := TrackLevel.NoTracking
  )
</code></pre><h3 id="Default+root+project">Default root project<a href="#Default+root+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If a project is not defined for the root directory in the build, sbt
creates a default one that aggregates all other projects in the build.
</p><p>Because project <code>hello-foo</code> is defined with <code>base = file(&quot;foo&quot;)</code>, it will be
contained in the subdirectory foo. Its sources could be directly under
<code>foo</code>, like <code>foo/Foo.scala</code>, or in <code>foo/src/main/scala</code>. The usual sbt
<a href="Directories.html">directory structure</a> applies underneath <code>foo</code> with the
exception of build definition files.
</p><h3 id="Navigating+projects+interactively">Navigating projects interactively<a href="#Navigating+projects+interactively" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>At the sbt interactive prompt, type <code>projects</code> to list your projects and
<code>project &lt;projectname&gt;</code> to select a current project. When you run a task
like <code>compile</code>, it runs on the current project. So you don’t necessarily
have to compile the root project, you could compile only a subproject.
</p><p>You can run a task in another project by explicitly specifying the
project ID, such as <code>subProjectID/compile</code>.
</p><h3 id="Common+code">Common code<a href="#Common+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The definitions in <code>.sbt</code> files are not visible in other <code>.sbt</code> files. In
order to share code between <code>.sbt</code> files, define one or more Scala files
in the <code>project/</code> directory of the build root.
</p><p>See <a href="Organizing-Build.html">organizing the build</a> for details.
</p><h3 id="Appendix%3A+Subproject+build+definition+files">Appendix: Subproject build definition files<a href="#Appendix%3A+Subproject+build+definition+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Any <code>.sbt</code> files in <code>foo</code>, say <code>foo/build.sbt</code>, will be merged with the build
definition for the entire build, but scoped to the <code>hello-foo</code> project.
</p><p>If your whole project is in hello, try defining a different version
(<code>version := &quot;0.6&quot;</code>) in <code>hello/build.sbt</code>, <code>hello/foo/build.sbt</code>, and
<code>hello/bar/build.sbt</code>. Now <code>show version</code> at the sbt interactive prompt. You
should get something like this (with whatever versions you defined):
</p><pre><code class="">&gt; show version
[info] hello-foo/*:version
[info]  0.7
[info] hello-bar/*:version
[info]  0.9
[info] hello/*:version
[info]  0.5
</code></pre><p><code>hello-foo/*:version</code> was defined in <code>hello/foo/build.sbt</code>,
<code>hello-bar/*:version</code> was defined in <code>hello/bar/build.sbt</code>, and
<code>hello/*:version</code> was defined in <code>hello/build.sbt</code>. Remember the
<a href="Scopes.html">syntax for scoped keys</a>. Each <code>version</code> key is scoped to a
project, based on the location of the <code>build.sbt</code>. But all three <code>build.sbt</code>
are part of the same build definition.
</p><p>Style choices:
</p><ul><li>Each subproject’s settings can go into <code>*.sbt</code> files in the base directory of that project,
while the root <code>build.sbt</code> declares only minimum project declarations in the form of <code>lazy val foo = (project in file(&quot;foo&quot;))</code> without the settings.
</li><li>We recommend putting all project declarations and settings in the root <code>build.sbt</code> file
in order to keep all build definition under a single file. However, it’s up to you.
</li></ul><p><strong>Note</strong>: You cannot have a project subdirectory or <code>project/*.scala</code> files in the
sub-projects. <code>foo/project/Build.scala</code> would be ignored.
</p><h2 id="Task+graph">Task graph<a href="#Task+graph" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Continuing from <a href="Basic-Def.html">build definition</a>,
this page explains <code>build.sbt</code> definition in more detail.
</p><p>Rather than thinking of <code>settings</code> as key-value pairs,
a better analogy would be to think of it as a <em>directed acyclic graph</em> (DAG)
of tasks where the edges denote <strong>happens-before</strong>. Let’s call this the <em>task graph</em>.
</p><h3 id="Terminology">Terminology<a href="#Terminology" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Let’s review the key terms before we dive in.
</p><ul><li>Setting/Task expression: entry inside <code>.settings(...)</code>.
</li><li>Key: Left hand side of a setting expression. It could be a <code>SettingKey[A]</code>, a <code>TaskKey[A]</code>, or an <code>InputKey[A]</code>.
</li><li>Setting: Defined by a setting expression with <code>SettingKey[A]</code>. The value is calculated once during load.
</li><li>Task: Defined by a task expression with <code>TaskKey[A]</code>. The value is calculated each time it is invoked.
</li></ul><h3 id="Declaring+dependency+to+other+tasks">Declaring dependency to other tasks<a href="#Declaring+dependency+to+other+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In <code>build.sbt</code> DSL, we use <code>.value</code> method to express the dependency to
another task or setting. The value method is special and may only be
called in the argument to <code>:=</code> (or, <code>+=</code> or <code>++=</code>, which we’ll see later).
</p><p>As a first example, consider defining the <code>scalacOptions</code> that depends on
<code>update</code> and <code>clean</code> tasks. Here are the definitions of these keys (from <a href="../api/sbt/Keys$.html">Keys</a>).
</p><p><strong>Note</strong>: The values calculated below are nonsensical for <code>scalaOptions</code>,
and it’s just for demonstration purpose only:
</p><pre><code class="prettyprint lang-scala">val scalacOptions = taskKey[Seq[String]](&quot;Options for the Scala compiler.&quot;)
val update = taskKey[UpdateReport](&quot;Resolves and optionally retrieves dependencies, producing a report.&quot;)
val clean = taskKey[Unit](&quot;Deletes files produced by the build, such as generated sources, compiled classes, and task caches.&quot;)
</code></pre><p>Here’s how we can rewire <code>scalacOptions</code>:
</p><pre><code class="prettyprint lang-scala">scalacOptions := {
  val ur = update.value  // update task happens-before scalacOptions
  val x = clean.value    // clean task happens-before scalacOptions
  // ---- scalacOptions begins here ----
  ur.allConfigurations.take(3)
}
</code></pre><p><code>update.value</code> and <code>clean.value</code> declare task dependencies,
whereas <code>ur.allConfigurations.take(3)</code> is the body of the task.
</p><p><code>.value</code> is not a normal Scala method call. <code>build.sbt</code> DSL
uses a macro to lift these outside of the task body.
<strong>Both <code>update</code> and <code>clean</code> tasks are completed
by the time task engine evaluates the opening <code>{</code> of <code>scalacOptions</code>
regardless of which line it appears in the body.</strong>
</p><p>See the following example:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalacOptions := {
      val out = streams.value // streams task happens-before scalacOptions
      val log = out.log
      log.info(&quot;123&quot;)
      val ur = update.value   // update task happens-before scalacOptions
      log.info(&quot;456&quot;)
      ur.allConfigurations.take(3)
    }
  )
</code></pre><p>Next, from sbt shell type <code>scalacOptions</code>:
</p><pre><code class="">&gt; scalacOptions
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[info] 123
[info] 456
[success] Total time: 0 s, completed Jan 2, 2017 10:38:24 PM
</code></pre><p>Even though <code>val ur = ...</code> appears in between <code>log.info(&quot;123&quot;)</code> and
<code>log.info(&quot;456&quot;)</code> the evaluation of <code>update</code> task happens before
either of them.
</p><p>Here’s another example:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalacOptions := {
      val ur = update.value  // update task happens-before scalacOptions
      if (false) {
        val x = clean.value  // clean task happens-before scalacOptions
      }
      ur.allConfigurations.take(3)
    }
  )
</code></pre><p>Next, from sbt shell type <code>run</code> then <code>scalacOptions</code>:
</p><pre><code class="">&gt; run
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/eugene/work/quick-test/task-graph/target/scala-2.12/classes...
[info] Running example.Hello
hello
[success] Total time: 0 s, completed Jan 2, 2017 10:45:19 PM
&gt; scalacOptions
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[success] Total time: 0 s, completed Jan 2, 2017 10:45:23 PM
</code></pre><p>Now if you check for <code>target/scala-2.12/classes/</code>,
it won’t exist because <code>clean</code> task has run even though it is inside
the <code>if (false)</code>.
</p><p>Another important thing to note is that there’s no guarantee
about the ordering of <code>update</code> and <code>clean</code> tasks.
They might run <code>update</code> then <code>clean</code>, <code>clean</code> then <code>update</code>,
or both in parallel.
</p><h3 id="Inlining+.value+calls">Inlining .value calls<a href="#Inlining+.value+calls" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As explained above, <code>.value</code> is a special method that is used to express
the dependency to other tasks and settings.
Until you’re familiar with build.sbt, we recommend you
put all <code>.value</code> calls at the top of the task body.
</p><p>However, as you get more comfortable, you might wish to inline the <code>.value</code> calls
because it could make the task/setting more concise, and you don’t have to
come up with variable names.
</p><p>We’ve inlined a few examples:
</p><pre><code class="prettyprint lang-scala">scalacOptions := {
  val x = clean.value
  update.value.allConfigurations.take(3)
}
</code></pre><p>Note whether <code>.value</code> calls are inlined, or placed anywhere in the task body,
they are still evaluated before entering the task body.
</p><h4 id="Inspecting+the+task">Inspecting the task<a href="#Inspecting+the+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In the above example, <code>scalacOptions</code> has a <em>dependency</em> on
<code>update</code> and <code>clean</code> tasks.
If you place the above in <code>build.sbt</code> and
run the sbt interactive console, then type <code>inspect scalacOptions</code>, you should see
(in part):
</p><pre><code class="">&gt; inspect scalacOptions
[info] Task: scala.collection.Seq[java.lang.String]
[info] Description:
[info]  Options for the Scala compiler.
....
[info] Dependencies:
[info]  *:clean
[info]  *:update
....
</code></pre><p>This is how sbt knows which tasks depend on which other tasks.
</p><p>For example, if you <code>inspect tree compile</code> you’ll see it depends on another key
<code>incCompileSetup</code>, which it in turn depends on
other keys like <code>dependencyClasspath</code>. Keep following the dependency chains and magic happens.
</p><pre><code class="">&gt; inspect tree compile
[info] compile:compile = Task[sbt.inc.Analysis]
[info]   +-compile:incCompileSetup = Task[sbt.Compiler$IncSetup]
[info]   | +-*/*:skip = Task[Boolean]
[info]   | +-compile:compileAnalysisFilename = Task[java.lang.String]
[info]   | | +-*/*:crossPaths = true
[info]   | | +-{.}/*:scalaBinaryVersion = 2.12
[info]   | |
[info]   | +-*/*:compilerCache = Task[xsbti.compile.GlobalsCache]
[info]   | +-*/*:definesClass = Task[scala.Function1[java.io.File, scala.Function1[java.lang.String, Boolean]]]
[info]   | +-compile:dependencyClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | +-compile:dependencyClasspath::streams = Task[sbt.std.TaskStreams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | +-*/*:streamsManager = Task[sbt.std.Streams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | |
[info]   | | +-compile:externalDependencyClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | | +-compile:externalDependencyClasspath::streams = Task[sbt.std.TaskStreams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | | +-*/*:streamsManager = Task[sbt.std.Streams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | |
[info]   | | | +-compile:managedClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | | | +-compile:classpathConfiguration = Task[sbt.Configuration]
[info]   | | | | | +-compile:configuration = compile
[info]   | | | | | +-*/*:internalConfigurationMap = &lt;function1&gt;
[info]   | | | | | +-*:update = Task[sbt.UpdateReport]
[info]   | | | | |
....
</code></pre><p>When you type <code>compile</code> sbt automatically performs an <code>update</code>, for example. It
Just Works because the values required as inputs to the <code>compile</code>
computation require sbt to do the <code>update</code> computation first.
</p><p>In this way, all build dependencies in sbt are <em>automatic</em> rather than
explicitly declared. If you use a key’s value in another computation,
then the computation depends on that key.
</p><h4 id="Defining+a+task+that+depends+on+other+settings">Defining a task that depends on other settings<a href="#Defining+a+task+that+depends+on+other+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>scalacOptions</code> is a task key.
Let’s say it’s been set to some values already, but you want to
filter out <code>&quot;-Xfatal-warnings&quot;</code> and <code>&quot;-deprecation&quot;</code> for non-2.12.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    organization := &quot;com.example&quot;,
    scalaVersion := &quot;2.12.13&quot;,
    version := &quot;0.1.0-SNAPSHOT&quot;,
    scalacOptions := List(&quot;-encoding&quot;, &quot;utf8&quot;, &quot;-Xfatal-warnings&quot;, &quot;-deprecation&quot;, &quot;-unchecked&quot;),
    scalacOptions := {
      val old = scalacOptions.value
      scalaBinaryVersion.value match {
        case &quot;2.12&quot; =&gt; old
        case _      =&gt; old filterNot (Set(&quot;-Xfatal-warnings&quot;, &quot;-deprecation&quot;).apply)
      }
    }
  )
</code></pre><p>Here’s how it should look on the sbt shell:
</p><pre><code class="">&gt; show scalacOptions
[info] * -encoding
[info] * utf8
[info] * -Xfatal-warnings
[info] * -deprecation
[info] * -unchecked
[success] Total time: 0 s, completed Jan 2, 2017 11:44:44 PM
&gt; ++2.11.8!
[info] Forcing Scala version to 2.11.8 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/xxx/)
&gt; show scalacOptions
[info] * -encoding
[info] * utf8
[info] * -unchecked
[success] Total time: 0 s, completed Jan 2, 2017 11:44:51 PM
</code></pre><p>Next, take these two keys (from <a href="../api/sbt/Keys$.html">Keys</a>):
</p><pre><code class="prettyprint lang-scala">val scalacOptions = taskKey[Seq[String]](&quot;Options for the Scala compiler.&quot;)
val checksums = settingKey[Seq[String]](&quot;The list of checksums to generate and to verify for dependencies.&quot;)
</code></pre><p><strong>Note</strong>: <code>scalacOptions</code> and <code>checksums</code> have nothing to do with each other.
They are just two keys with the same value type, where one is a task.
</p><p>It is possible to compile a <code>build.sbt</code> that aliases <code>scalacOptions</code> to
<code>checksums</code>, but not the other way. For example, this is allowed:
</p><pre><code class="prettyprint lang-scala">// The scalacOptions task may be defined in terms of the checksums setting
scalacOptions := checksums.value
</code></pre><p>There is no way to go the <em>other</em> direction. That is, a setting key
can’t depend on a task key. That’s because a setting key is only
computed once on project load, so the task would not be re-run every
time, and tasks expect to re-run every time.
</p><pre><code class="prettyprint lang-scala">// Bad example: The checksums setting cannot be defined in terms of the scalacOptions task!
checksums := scalacOptions.value
</code></pre><h4 id="Defining+a+setting+that+depends+on+other+settings">Defining a setting that depends on other settings<a href="#Defining+a+setting+that+depends+on+other+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In terms of the execution timing, we can think of the settings
as a special tasks that evaluate during loading time.
</p><p>Consider defining the project organization to be the same as the project name.
</p><pre><code class="prettyprint lang-scala">// name our organization after our project (both are SettingKey[String])
organization := name.value
</code></pre><p>Here’s a realistic example.
This rewires <code>Compile / scalaSource</code> key to a different directory
only when <code>scalaBinaryVersion</code> is <code>&quot;2.11&quot;</code>.
</p><pre><code class="prettyprint lang-scala">Compile / scalaSource := {
  val old = (Compile / scalaSource).value
  scalaBinaryVersion.value match {
    case &quot;2.11&quot; =&gt; baseDirectory.value / &quot;src-2.11&quot; / &quot;main&quot; / &quot;scala&quot;
    case _      =&gt; old
  }
}
</code></pre><h3 id="What%E2%80%99s+the+point+of+the+build.sbt+DSL%3F">What’s the point of the build.sbt DSL?<a href="#What%E2%80%99s+the+point+of+the+build.sbt+DSL%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We use the <code>build.sbt</code> domain-specific language(DSL) to construct a DAG of settings and tasks.
The setting expressions encode settings, tasks and the dependencies among them.
</p><p>This structure is common to <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> (1976), <a href="https://ant.apache.org/">Ant</a> (2000), and <a href="https://ruby.github.io/rake/">Rake</a> (2003).
</p><h4 id="Intro+to+Make">Intro to Make<a href="#Intro+to+Make" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The basic Makefile syntax looks like the following:
</p><pre><code class="">target: dependencies
[tab] system command1
[tab] system command2
</code></pre><p>Given a target (the default target is named <code>all</code>),
</p><ol><li>Make checks if the target’s dependencies have been built, and builds any of the dependencies that hasn’t been built yet.
</li><li>Make runs the system commands in order.
</li></ol><p>Let’s take a look at a <code>Makefile</code>:
</p><pre><code class="">CC=g++
CFLAGS=-Wall

all: hello

hello: main.o hello.o
    $(CC) main.o hello.o -o hello

%.o: %.cpp
    $(CC) $(CFLAGS) -c $&lt; -o $@
</code></pre><p>Running <code>make</code>, it will by default pick the target named <code>all</code>.
The target lists <code>hello</code> as its dependency, which hasn’t been built yet, so Make will build <code>hello</code>.
</p><p>Next, Make checks if the <code>hello</code> target’s dependencies have been built yet.
<code>hello</code> lists two targets: <code>main.o</code> and <code>hello.o</code>.
Once those targets are created using the last pattern matching rule,
only then the system command is executed to link <code>main.o</code> and <code>hello.o</code> to <code>hello</code>.
</p><p>If you’re just running <code>make</code>, you can focus on what you want as the target,
and the exact timing and commands necessary to build the intermediate products are figured out by Make.
We can think of this as dependency-oriented programming, or flow-based programming.
Make is actually considered a hybrid system because while the DSL describes the task dependencies, the actions are delegated to system commands.
</p><h4 id="Rake">Rake<a href="#Rake" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This hybridity is continued for Make successors such as Ant, Rake, and sbt.
Take a look at the basic syntax for Rakefile:
</p><pre><code class="prettyprint lang-ruby">task name: [:prereq1, :prereq2] do |t|
  # actions (may reference prereq as t.name etc)
end
</code></pre><p>The breakthrough made with Rake was that it used a programming language to
describe the actions instead of the system commands.
</p><h4 id="Benefits+of+hybrid+flow-based+programming">Benefits of hybrid flow-based programming<a href="#Benefits+of+hybrid+flow-based+programming" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There are several motivation to organizing the build this way.
</p><p>First is de-duplication. With flow-based programming, a task is executed only once even when it is depended by multiple tasks.
For example, even when multiple tasks along the task graph depend on <code>Compile / compile</code>,
the compilation will be executed exactly once.
</p><p>Second is parallel processing. Using the task graph, the task engine can
schedule mutually non-dependent tasks in parallel.
</p><p>Third is the separation of concern and the flexibility.
The task graph lets the build user wire the tasks together in different ways,
while sbt and plugins can provide various features such as compilation and
library dependency management as functions that can be reused.
</p><h3 id="Summary">Summary<a href="#Summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The core data structure of the build definition is a DAG of tasks,
where the edges denote happens-before relationships.
<code>build.sbt</code> is a DSL designed to express dependency-oriented programming,
or flow-based programming, similar to <code>Makefile</code> and <code>Rakefile</code>.
</p><p>The key motivation for the flow-based programming is de-duplication,
parallel processing, and customizability.
</p><h2 id="Scopes">Scopes<a href="#Scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes scopes. It assumes you’ve read and understood the
previous pages, <a href="Basic-Def.html">build definition</a> and <a href="Task-Graph.html">task graph</a>.
</p><h3 id="The+whole+story+about+keys">The whole story about keys<a href="#The+whole+story+about+keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="Basic-Def.html">Previously</a> we pretended that a key like <code>name</code> corresponded
to one entry in sbt’s map of key-value pairs. This was a simplification.
</p><p>In truth, each key can have an associated value in more than one
context, called a <em>scope.</em>
</p><p>Some concrete examples:
</p><ul><li>if you have multiple projects (also called subprojects) in your build definition, a key can
have a different value in each project.
</li><li>the <code>compile</code> key may have a different value for your main sources and
your test sources, if you want to compile them differently.
</li><li>the <code>packageOptions</code> key (which contains options for creating jar
packages) may have different values when packaging class files
(<code>packageBin</code>) or packaging source code (<code>packageSrc</code>).
</li></ul><p><em>There is no single value for a given key <code>name</code></em>, because the value may
differ according to scope.
</p><p>However, there is a single value for a given <em>scoped</em> key.
</p><p>If you think about sbt processing a list of settings to generate a
key-value map describing the project, as
<a href="Basic-Def.html">discussed earlier</a>, the keys in that key-value map are
<em>scoped</em> keys. Each setting defined in the build definition (for example
in <code>build.sbt</code>) applies to a scoped key as well.
</p><p>Often the scope is implied or has a default, but if the defaults are
wrong, you’ll need to mention the desired scope in <code>build.sbt</code>.
</p><h3 id="Scope+axes">Scope axes<a href="#Scope+axes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <em>scope axis</em> is a type constructor similar to <code>Option[A]</code>,
that is used to form a component in a scope.
</p><p>There are three scope axes:
</p><ul><li>The subproject axis
</li><li>The dependency configuration axis
</li><li>The task axis
</li></ul><p>If you’re not familiar with the notion of <em>axis</em>, we can think of the RGB color cube
as an example:
</p><p><img src="files/rgb_color_solid_cube.png" alt="color cube"/>
</p><p>In the RGB color model, all colors are represented by a point in the cube whose axes
correspond to red, green, and blue components encoded by a number.
Similarly, a full scope in sbt is formed by a <strong>tuple</strong> of a subproject,
a configuration, and a task value:
</p><pre><code class="prettyprint lang-scala">projA / Compile / console / scalacOptions
</code></pre><p>This is the slash syntax, introduced in sbt 1.1, for:
</p><pre><code class="prettyprint lang-scala">scalacOptions in (
  Select(projA: Reference),
  Select(Compile: ConfigKey),
  Select(console.key)
)
</code></pre><h4 id="Scoping+by+the+subproject+axis">Scoping by the subproject axis<a href="#Scoping+by+the+subproject+axis" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you <a href="Multi-Project.html">put multiple projects in a single build</a>, each
project needs its own settings. That is, keys can be scoped according to
the project.
</p><p>The project axis can also be set to <code>ThisBuild</code>, which means the “entire build”,
so a setting applies to the entire build rather than a single project.
Build-level settings are often used as a fallback when a project doesn’t define a
project-specific setting. We will discuss more on build-level settings later in this page.
</p><h4 id="Scoping+by+the+configuration+axis">Scoping by the configuration axis<a href="#Scoping+by+the+configuration+axis" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A <em>dependency configuration</em> (or “configuration” for short) defines
a graph of library dependencies, potentially with its own
classpath, sources, generated packages, etc. The dependency configuration concept
comes from Ivy, which sbt used to use for
managed dependencies <a href="Library-Dependencies.html">Library Dependencies</a>, and from
<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">MavenScopes</a>.
</p><p>Some configurations you’ll see in sbt:
</p><ul><li><code>Compile</code> which defines the main build (<code>src/main/scala</code>).
</li><li><code>Test</code> which defines how to build tests (<code>src/test/scala</code>).
</li><li><code>Runtime</code> which defines the classpath for the <code>run</code> task.
</li></ul><p>By default, all the keys associated with compiling, packaging, and
running are scoped to a configuration and therefore may work differently
in each configuration. The most obvious examples are the task keys
<code>compile</code>, <code>package</code>, and <code>run</code>; but all the keys which <em>affect</em> those keys
(such as <code>sourceDirectories</code> or <code>scalacOptions</code> or <code>fullClasspath</code>) are also
scoped to the configuration.
</p><p>Another thing to note about a configuration is that it can extend other configurations.
The following figure shows the extension relationship among the most common configurations.
</p><p><img src="files/sbt-configurations.png" alt="dependency configurations"/>
</p><p><code>Test</code> and <code>IntegrationTest</code> extends <code>Runtime</code>; <code>Runtime</code> extends <code>Compile</code>;
<code>CompileInternal</code> extends <code>Compile</code>, <code>Optional</code>, and <code>Provided</code>.
</p><h4 id="Scoping+by+Task+axis">Scoping by Task axis<a href="#Scoping+by+Task+axis" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Settings can affect how a task works. For example, the <code>packageSrc</code> task
is affected by the <code>packageOptions</code> setting.
</p><p>To support this, a task key (such as <code>packageSrc</code>) can be a scope for
another key (such as <code>packageOptions</code>).
</p><p>The various tasks that build a package (<code>packageSrc</code>, <code>packageBin</code>,
<code>packageDoc</code>) can share keys related to packaging, such as <code>artifactName</code>
and <code>packageOptions</code>. Those keys can have distinct values for each
packaging task.
</p><h4 id="Zero+scope+component">Zero scope component<a href="#Zero+scope+component" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Each scope axis can be filled in with an instance of the axis type (analogous to <code>Some(_)</code>),
or the axis can be filled in with the special value <code>Zero</code>.
So we can think of <code>Zero</code> as <code>None</code>.
</p><p><code>Zero</code> is a universal fallback for all scope axes,
but its direct use should be reserved to sbt and plugin authors in most cases.
</p><p><code>Global</code> is a scope that sets <code>Zero</code> to all axes: <code>Zero / Zero / Zero</code>. In other words, <code>Global / someKey</code> is a shorthand for <code>Zero / Zero / Zero / someKey</code>.
</p><h3 id="Referring+to+scopes+in+a+build+definition">Referring to scopes in a build definition<a href="#Referring+to+scopes+in+a+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you create a setting in <code>build.sbt</code> with a bare key, it will be scoped
to (current subproject / configuration <code>Zero</code> / task <code>Zero</code>):
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><p>Run sbt and <code>inspect name</code> to see that it’s provided by
<code>ProjectRef(uri(&quot;file:/private/tmp/hello/&quot;), &quot;root&quot;) / name</code>, that is, the
project is <code>ProjectRef(uri(&quot;file:/Users/xxx/hello/&quot;), &quot;root&quot;)</code>, and
neither configuration nor task scope are shown (which means <code>Zero</code>).
</p><p>A bare key on the right hand side is also scoped to
(current subproject / configuration <code>Zero</code> / task <code>Zero</code>):
</p><pre><code class="prettyprint lang-scala">organization := name.value
</code></pre><p>The types of any of the scope axes have been method enriched to have a <code>/</code> operator.
The argument to <code>/</code> can be a key or another scope axis. So for
example, though there’s no good reason to do this, you could have an instance of the
<code>name</code> key scoped to the <code>Compile</code> configuration:
</p><pre><code class="prettyprint lang-scala">Compile / name := &quot;hello&quot;
</code></pre><p>or you could set the name scoped to the <code>packageBin</code> task (pointless! just
an example):
</p><pre><code class="prettyprint lang-scala">packageBin / name := &quot;hello&quot;
</code></pre><p>or you could set the <code>name</code> with multiple scope axes, for example in the
<code>packageBin</code> task in the <code>Compile</code> configuration:
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / name := &quot;hello&quot;
</code></pre><p>or you could use <code>Global</code>:
</p><pre><code class="prettyprint lang-scala">// same as Zero / Zero / Zero / concurrentRestrictions
Global / concurrentRestrictions := Seq(
  Tags.limitAll(1)
)
</code></pre><p>(<code>Global / concurrentRestrictions</code> implicitly converts to
<code>Zero / Zero / Zero / concurrentRestrictions</code>, setting
all axes to <code>Zero</code> scope component; the task and configuration are already
<code>Zero</code> by default, so here the effect is to make the project <code>Zero</code>,
that is, define <code>Zero / Zero / Zero / concurrentRestrictions</code> rather than
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Zero / Zero / concurrentRestrictions</code>)
</p><h3 id="Referring+to+scoped+keys+from+the+sbt+shell">Referring to scoped keys from the sbt shell<a href="#Referring+to+scoped+keys+from+the+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On the command line and in the sbt shell, sbt displays (and parses)
scoped keys like this:
</p><pre><code class="">ref / Config / intask / key
</code></pre><ul><li><code>ref</code> identifies the subproject axis. It could be <code>&lt;project-id&gt;</code>, <code>ProjectRef(uri(&quot;file:...&quot;), &quot;id&quot;)</code>, or <code>ThisBuild</code> that denotes the “entire build” scope.
</li><li><code>Config</code> identifies the configuration axis using the capitalized Scala identifier.
</li><li><code>intask</code> identifies the task axis.
</li><li><code>key</code> identifies the key being scoped.
</li></ul><p><code>Zero</code> can appear for each axis.
</p><p>If you omit part of the scoped key, it will be inferred as follows:
</p><ul><li>the current project will be used if you omit the project.
</li><li>a key-dependent configuration will be auto-detected if you omit the
configuration or task.
</li></ul><p>For more details, see <a href="../docs/Inspecting-Settings.html">Interacting with the Configuration System</a>.
</p><h3 id="Examples+of+scoped+key+notation+in+the+sbt+shell">Examples of scoped key notation in the sbt shell<a href="#Examples+of+scoped+key+notation+in+the+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>fullClasspath</code> specifies just a key, so the default scopes are used:
current project, a key-dependent configuration, and <code>Zero</code> task
scope.
</li><li><code>Test / fullClasspath</code> specifies the configuration, so this is
<code>fullClasspath</code> in the <code>Test</code> configuration, with defaults for the other
two scope axes.
</li><li><code>root / fullClasspath</code> specifies the project <code>root</code>, where the project is
identified with the project id.
</li><li><code>root / Zero / fullClasspath</code> specified the project <code>root</code>, and
specifies <code>Zero</code> for the configuration, rather than the default configuration.
</li><li><code>doc / fullClasspath</code> specifies the <code>fullClasspath</code> key scoped to the <code>doc</code>
task, with the defaults for the project and configuration axes.
</li><li><code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath</code>
specifies a project <code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;)</code>.
Also specifies configuration Test, leaves the default task axis.
</li><li><code>ThisBuild / version</code> sets the subproject axis to “entire build” where
the build is <code>ThisBuild</code>, with the default configuration.
</li><li><code>Zero / fullClasspath</code> sets the subproject axis to <code>Zero</code>,
with the default configuration.
</li><li><code>root / Compile / doc / fullClasspath</code> sets all three scope axes.
</li></ul><h3 id="Inspecting+scopes">Inspecting scopes<a href="#Inspecting+scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt shell, you can use the <code>inspect</code> command to understand
keys and their scopes. Try <code>inspect Test/fullClasspath</code>:
</p><pre><code class="">$ sbt
sbt:Hello&gt; inspect Test / fullClasspath
[info] Task: scala.collection.Seq[sbt.internal.util.Attributed[java.io.File]]
[info] Description:
[info]  The exported classpath, consisting of build products and unmanaged and managed, internal and external dependencies.
[info] Provided by:
[info]  ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath
[info] Defined at:
[info]  (sbt.Classpaths.classpaths) Defaults.scala:1639
[info] Dependencies:
[info]  Test / dependencyClasspath
[info]  Test / exportedProducts
[info]  Test / fullClasspath / streams
[info] Reverse dependencies:
[info]  Test / testLoader
[info] Delegates:
[info]  Test / fullClasspath
[info]  Runtime / fullClasspath
[info]  Compile / fullClasspath
[info]  fullClasspath
[info]  ThisBuild / Test / fullClasspath
[info]  ThisBuild / Runtime / fullClasspath
[info]  ThisBuild / Compile / fullClasspath
[info]  ThisBuild / fullClasspath
[info]  Zero / Test / fullClasspath
[info]  Zero / Runtime / fullClasspath
[info]  Zero / Compile / fullClasspath
[info]  Global / fullClasspath
[info] Related:
[info]  Compile / fullClasspath
[info]  Runtime / fullClasspath
</code></pre><p>On the first line, you can see this is a task (as opposed to a setting,
as explained in <a href="Basic-Def.html">.sbt build definition</a>). The value
resulting from the task will have type
<code>scala.collection.Seq[sbt.Attributed[java.io.File]]</code>.
</p><p>“Provided by” points you to the scoped key that defines the value, in
this case
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath</code> (which
is the <code>fullClasspath</code> key scoped to the <code>Test</code> configuration and the
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;)</code> project).
</p><p>“Dependencies” was discussed in detail in the <a href="Task-Graph.html">previous page</a>.
</p><p>We’ll discuss “Delegates” later.
</p><p>Try <code>inspect fullClasspath</code> (as opposed to the above example,
inspect <code>Test / fullClasspath</code>) to get a sense of the difference. Because
the configuration is omitted, it is autodetected as <code>Compile</code>.
<code>inspect Compile / fullClasspath</code> should therefore look the same as
<code>inspect fullClasspath</code>.
</p><p>Try <code>inspect ThisBuild / Zero / fullClasspath</code> for another contrast. <code>fullClasspath</code> is not
defined in the <code>Zero</code> configuration scope by default.
</p><p>Again, for more details, see <a href="../docs/Inspecting-Settings.html">Interacting with the Configuration System</a>.
</p><h3 id="When+to+specify+a+scope">When to specify a scope<a href="#When+to+specify+a+scope" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You need to specify the scope if the key in question is normally scoped.
For example, the <code>compile</code> task, by default, is scoped to <code>Compile</code> and <code>Test</code>
configurations, and does not exist outside of those scopes.
</p><p>To change the value associated with the <code>compile</code> key, you need to write
<code>Compile / compile</code> or <code>Test / compile</code>. Using plain <code>compile</code> would define
a new compile task scoped to the current project, rather than overriding
the standard compile tasks which are scoped to a configuration.
</p><p>If you get an error like <em>“Reference to undefined setting“</em>, often
you’ve failed to specify a scope, or you’ve specified the wrong scope.
The key you’re using may be defined in some other scope. sbt will try to
suggest what you meant as part of the error message; look for “Did you
mean Compile / compile?”
</p><p>One way to think of it is that a name is only <em>part</em> of a key. In
reality, all keys consist of both a name, and a scope (where the scope
has three axes). The entire expression
<code>Compile / packageBin / packageOptions</code> is a key name, in other words.
Simply <code>packageOptions</code> is also a key name, but a different one (for keys
with no slashes, a scope is implicitly assumed: current project, <code>Zero</code>
config, <code>Zero</code> task).
</p><h3 id="Build-level+settings">Build-level settings<a href="#Build-level+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>An advanced technique for factoring out common settings
across subprojects is to define the settings scoped to <code>ThisBuild</code>.
</p><p>If a key that is scoped to a particular subproject is not found,
sbt will look for it in <code>ThisBuild</code> as a fallback.
Using the mechanism, we can define a build-level default setting for
frequently used keys such as <code>version</code>, <code>scalaVersion</code>, and <code>organization</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;,
ThisBuild / scalaVersion := &quot;2.12.13&quot;,
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    publish / skip := true
  )

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    // other settings
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    // other settings
  )
</code></pre><p>For convenience, there is <code>inThisBuild(...)</code> function that will
scope both the key and the body of the setting expression to <code>ThisBuild</code>.
Putting setting expressions in there would be equivalent to prepending <code>ThisBuild /</code> where possible.
</p><p>Due to the nature of <a href="Scope-Delegation.html">scope delegation</a> that we will cover later,
build-level settings should be set only to a pure value or settings from either <code>Global</code> or <code>ThisBuild</code> scoping.
</p><h3 id="Scope+delegation">Scope delegation<a href="#Scope+delegation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A scoped key may be undefined, if it has no value associated with it in
its scope.
</p><p>For each scope axis, sbt has a fallback search path made up of other scope values.
Typically, if a key has no associated value in a more-specific scope,
sbt will try to get a value from a more general scope, such as the <code>ThisBuild</code> scope.
</p><p>This feature allows you to set a value once in a more general scope,
allowing multiple more-specific scopes to inherit the value.
We will discuss <a href="Scope-Delegation.html">scope delegation</a> in detail later.
</p><h2 id="Appending+values">Appending values<a href="#Appending+values" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Appending+to+previous+values%3A++and">Appending to previous values: <code>+=</code> and <code>++=</code><a href="#Appending+to+previous+values%3A++and" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Assignment with <code>:=</code> is the simplest transformation, but keys have other
methods as well. If the <code>T</code> in <code>SettingKey[T]</code> is a sequence, i.e. the key’s
value type is a sequence, you can append to the sequence rather than
replacing it.
</p><ul><li><code>+=</code> will append a single element to the sequence.
</li><li><code>++=</code> will concatenate another sequence.
</li></ul><p>For example, the key <code>Compile / sourceDirectories</code> has a <code>Seq[File]</code> as its
value. By default this key’s value would include <code>src/main/scala</code>. If you
wanted to also compile source code in a directory called source (since
you just have to be nonstandard), you could add that directory:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories += new File(&quot;source&quot;)
</code></pre><p>Or, using the <code>file()</code> function from the sbt package for convenience:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories += file(&quot;source&quot;)
</code></pre><p>(<code>file()</code> just creates a new <code>File</code>.)
</p><p>You could use <code>++=</code> to add more than one directory at a time:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories ++= Seq(file(&quot;sources1&quot;), file(&quot;sources2&quot;))
</code></pre><p>Where <code>Seq(a, b, c, ...)</code> is standard Scala syntax to construct a
sequence.
</p><p>To replace the default source directories entirely, you use <code>:=</code> of
course:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories := Seq(file(&quot;sources1&quot;), file(&quot;sources2&quot;))
</code></pre><h4 id="When+settings+are+undefined">When settings are undefined<a href="#When+settings+are+undefined" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Whenever a setting uses <code>:=</code>, <code>+=</code>, or <code>++=</code> to create a dependency on itself
or another key’s value, the value it depends on must exist. If it does
not, sbt will complain. It might say <em>“Reference to undefined setting“</em>,
for example. When this happens, be sure you’re using the key in the
<a href="Scopes.html">scope</a> that defines it.
</p><p>It’s possible to create cycles, which is an error; sbt will tell you if
you do this.
</p><h4 id="Tasks+based+on+other+keys%E2%80%99+values">Tasks based on other keys’ values<a href="#Tasks+based+on+other+keys%E2%80%99+values" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You can compute values of some tasks or settings to define or append a value for another task. It’s done by using <code>Def.task</code> as an argument to <code>:=</code>, <code>+=</code>, or <code>++=</code>.
</p><p>As a first example, consider appending a source generator using the project base directory and compilation classpath.
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += Def.task {
  myGenerator(baseDirectory.value, (Compile / managedClasspath).value)
}
</code></pre><h3 id="Appending+with+dependencies%3A++and">Appending with dependencies: <code>+=</code> and <code>++=</code><a href="#Appending+with+dependencies%3A++and" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Other keys can be used when appending to an existing setting or task,
just like they can for assigning with <code>:=</code>.
</p><p>For example, say you have a coverage report named after the project, and
you want to add it to the files removed by clean:
</p><pre><code class="prettyprint lang-scala">cleanFiles += file(&quot;coverage-report-&quot; + name.value + &quot;.txt&quot;)
</code></pre><h2 id="Scope+delegation+%28.value+lookup%29">Scope delegation (.value lookup)<a href="#Scope+delegation+%28.value+lookup%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes scope delegation. It assumes you’ve read and understood the
previous pages, <a href="Basic-Def.html">build definition</a> and <a href="Scopes.html">scopes</a>.
</p><p>Now that we’ve covered all the details of scoping, we can explain the <code>.value</code>
lookup in detail. It’s ok to skip this section if this is your first time reading this page.
</p><p>To summarize what we’ve learned so far:
</p><ul><li>A scope is a tuple of components in three axes: the subproject axis, the configuration axis, and the task axis.
</li><li>There’s a special scope component <code>Zero</code> for any of the scope axes.
</li><li>There’s a special scope component <code>ThisBuild</code> for <strong>the subprojects axis</strong> only.
</li><li><code>Test</code> extends <code>Runtime</code>, and <code>Runtime</code> extends <code>Compile</code> configuration.
</li><li>A key placed in build.sbt is scoped to <code>${current subproject} / Zero / Zero</code> by default.
</li><li>A key can be scoped using <code>/</code> operator.
</li></ul><p>Now let’s suppose we have the following build definition:
</p><pre><code class="prettyprint lang-scala">lazy val foo = settingKey[Int](&quot;&quot;)
lazy val bar = settingKey[Int](&quot;&quot;)

lazy val projX = (project in file(&quot;x&quot;))
  .settings(
    foo := {
      (Test / bar).value + 1
    },
    Compile / bar := 1
  )
</code></pre><p>Inside of <code>foo</code>’s setting body a dependency on the scoped key <code>Test / bar</code> is declared.
However, despite <code>Test / bar</code> being undefined in <code>projX</code>,
sbt is still able to resolve <code>Test / bar</code> to another scoped key,
resulting in <code>foo</code> initialized as <code>2</code>.
</p><p>sbt has a well-defined fallback search path called <em>scope delegation</em>.
This feature allows you to set a value once in a more general scope,
allowing multiple more-specific scopes to inherit the value.
</p><h3 id="Scope+delegation+rules">Scope delegation rules<a href="#Scope+delegation+rules" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here are the rules for scope delegation:
</p><ul><li>Rule 1: Scope axes have the following precedence: the subproject axis, the configuration axis, and then the task axis.
</li><li>Rule 2: Given a scope, delegate scopes are searched by substituting the task axis in the following order:
the given task scoping, and then <code>Zero</code>, which is non-task scoped version of the scope.
</li><li>Rule 3: Given a scope, delegate scopes are searched by substituting the configuration axis in the following order:
the given configuration, its parents, their parents and so on, and then <code>Zero</code> (same as unscoped configuration axis).
</li><li>Rule 4: Given a scope, delegate scopes are searched by substituting the subproject axis in the following order:
the given subproject, <code>ThisBuild</code>, and then <code>Zero</code>.
</li><li>Rule 5: A delegated scoped key and its dependent settings/tasks are evaluated without carrying the original context.
</li></ul><p>We will look at each rule in the rest of this page.
</p><h3 id="Rule+1%3A+Scope+axis+precedence">Rule 1: Scope axis precedence<a href="#Rule+1%3A+Scope+axis+precedence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Rule 1: Scope axes have the following precedence: the subproject axis, the configuration axis, and then the task axis.
</li></ul><p>In other words, given two scope candidates, if one has more specific value on the subproject axis,
it will always win regardless of the configuration or the task scoping.
Similarly, if subprojects are the same, one with more specific configuration value will always win regardless
of the task scoping. We will see more rules to define <em>more specific</em>.
</p><h3 id="Rule+2%3A+The+task+axis+delegation">Rule 2: The task axis delegation<a href="#Rule+2%3A+The+task+axis+delegation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Rule 2: Given a scope, delegate scopes are searched by <strong>substituting</strong> the task axis in the following order:
the given task scoping, and then <code>Zero</code>, which is non-task scoped version of the scope.
</li></ul><p>Here we have a concrete rule for how sbt will generate delegate scopes given a key.
Remember, we are trying to show the search path given an arbitrary <code>(xxx / yyy).value</code>.
</p><p><strong>Exercise A</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">lazy val projA = (project in file(&quot;a&quot;))
  .settings(
    name := {
      &quot;foo-&quot; + (packageBin / scalaVersion).value
    },
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>What is the value of <code>projA / name</code>?
</p><ol><li><code>&quot;foo-2.11.11&quot;</code>
</li><li><code>&quot;foo-2.12.13&quot;</code>
</li><li>something else?
</li></ol><p>The answer is <code>&quot;foo-2.11.11&quot;</code>.
Inside of <code>.settings(...)</code>, <code>scalaVersion</code> is automatically scoped to <code>projA / Zero / Zero</code>,
so <code>packageBin / scalaVersion</code> becomes <code>projA / Zero / packageBin / scalaVersion</code>.
That particular scoped key is undefined.
By using Rule 2, sbt will substitute the task axis to <code>Zero</code> as <code>projA / Zero / Zero</code> (or <code>projA / scalaVersion</code>).
That scoped key is defined to be <code>&quot;2.11.11&quot;</code>.
</p><h3 id="Rule+3%3A+The+configuration+axis+search+path">Rule 3: The configuration axis search path<a href="#Rule+3%3A+The+configuration+axis+search+path" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Rule 3: Given a scope, delegate scopes are searched by substituting the configuration axis in the following order:
the given configuration, its parents, their parents and so on, and then <code>Zero</code> (same as unscoped configuration axis).
</li></ul><p>The example for that is <code>projX</code> that we saw earlier:
</p><pre><code class="prettyprint lang-scala">lazy val foo = settingKey[Int](&quot;&quot;)
lazy val bar = settingKey[Int](&quot;&quot;)

lazy val projX = (project in file(&quot;x&quot;))
  .settings(
    foo := {
      (Test / bar).value + 1
    },
    Compile / bar := 1
  )
</code></pre><p>If we write out the full scope again, it’s <code>projX / Test / Zero</code>.
Also recall that <code>Test</code> extends <code>Runtime</code>, and <code>Runtime</code> extends <code>Compile</code>.
</p><p><code>Test / bar</code> is undefined, but due to Rule 3 sbt will look for
<code>bar</code> scoped in <code>projX / Test / Zero</code>, <code>projX / Runtime / Zero</code>, and then
<code>projX / Compile / Zero</code>. The last one is found, which is <code>Compile / bar</code>.
</p><h3 id="Rule+4%3A+The+subproject+axis+search+path">Rule 4: The subproject axis search path<a href="#Rule+4%3A+The+subproject+axis+search+path" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Rule 4: Given a scope, delegate scopes are searched by substituting the subproject axis in the following order:
the given subproject, <code>ThisBuild</code>, and then <code>Zero</code>.
</li></ul><p><strong>Exercise B</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;

lazy val projB = (project in file(&quot;b&quot;))
  .settings(
    name := &quot;abc-&quot; + organization.value,
    organization := &quot;org.tempuri&quot;
  )
</code></pre><p>What is the value of <code>projB / name</code>?
</p><ol><li><code>&quot;abc-com.example&quot;</code>
</li><li><code>&quot;abc-org.tempuri&quot;</code>
</li><li>something else?
</li></ol><p>The answer is <code>abc-org.tempuri</code>.
So based on Rule 4, the first search path is <code>organization</code> scoped to <code>projB / Zero / Zero</code>,
which is defined in <code>projB</code> as <code>&quot;org.tempuri&quot;</code>.
This has higher precedence than the build-level setting <code>ThisBuild / organization</code>.
</p><h4 id="Scope+axis+precedence%2C+again">Scope axis precedence, again<a href="#Scope+axis+precedence%2C+again" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>Exercise C</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">ThisBuild / packageBin / scalaVersion := &quot;2.12.2&quot;

lazy val projC = (project in file(&quot;c&quot;))
  .settings(
    name := {
      &quot;foo-&quot; + (packageBin / scalaVersion).value
    },
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>What is value of <code>projC / name</code>?
</p><ol><li><code>&quot;foo-2.12.2&quot;</code>
</li><li><code>&quot;foo-2.11.11&quot;</code>
</li><li>something else?
</li></ol><p>The answer is <code>foo-2.11.11</code>.
<code>scalaVersion</code> scoped to <code>projC / Zero / packageBin</code> is undefined.
Rule 2 finds <code>projC / Zero / Zero</code>. Rule 4 finds <code>ThisBuild / Zero / packageBin</code>.
In this case Rule 1 dictates that more specific value on the subproject axis wins,
which is <code>projC / Zero / Zero</code> that is defined to <code>&quot;2.11.11&quot;</code>.
</p><p><strong>Exercise D</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions += &quot;-Ywarn-unused-import&quot;

lazy val projD = (project in file(&quot;d&quot;))
  .settings(
    test := {
      println((Compile / console / scalacOptions).value)
    },
    console / scalacOptions -= &quot;-Ywarn-unused-import&quot;,
    Compile / scalacOptions := scalacOptions.value // added by sbt
  )
</code></pre><p>What would you see if you ran <code>projD/test</code>?
</p><ol><li><code>List()</code>
</li><li><code>List(-Ywarn-unused-import)</code>
</li><li>something else?
</li></ol><p>The answer is <code>List(-Ywarn-unused-import)</code>.
Rule 2 finds <code>projD / Compile / Zero</code>,
Rule 3 finds <code>projD / Zero / console</code>,
and Rule 4 finds <code>ThisBuild / Zero / Zero</code>.
Rule 1 selects <code>projD / Compile / Zero</code>
because it has the subproject axis <code>projD</code>, and the configuration axis has higher
precedence over the task axis.
</p><p>Next, <code>Compile / scalacOptions</code> refers to <code>scalacOptions.value</code>,
we next need to find a delegate for <code>projD / Zero / Zero</code>.
Rule 4 finds <code>ThisBuild / Zero / Zero</code> and thus it resolves to <code>List(-Ywarn-unused-import)</code>.
</p><h3 id="Inspect+command+lists+the+delegates">Inspect command lists the delegates<a href="#Inspect+command+lists+the+delegates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You might want to look up quickly what is going on.
This is where <code>inspect</code> can be used.
</p><pre><code class="">sbt:projd&gt; inspect projD / Compile / console / scalacOptions
[info] Task: scala.collection.Seq[java.lang.String]
[info] Description:
[info]  Options for the Scala compiler.
[info] Provided by:
[info]  ProjectRef(uri(&quot;file:/tmp/projd/&quot;), &quot;projD&quot;) / Compile / scalacOptions
[info] Defined at:
[info]  /tmp/projd/build.sbt:9
[info] Reverse dependencies:
[info]  projD / test
[info]  projD / Compile / console
[info] Delegates:
[info]  projD / Compile / console / scalacOptions
[info]  projD / Compile / scalacOptions
[info]  projD / console / scalacOptions
[info]  projD / scalacOptions
[info]  ThisBuild / Compile / console / scalacOptions
[info]  ThisBuild / Compile / scalacOptions
[info]  ThisBuild / console / scalacOptions
[info]  ThisBuild / scalacOptions
[info]  Zero / Compile / console / scalacOptions
[info]  Zero / Compile / scalacOptions
[info]  Zero / console / scalacOptions
[info]  Global / scalacOptions
</code></pre><p>Note how “Provided by” shows that <code>projD / Compile / console / scalacOptions</code>
is provided by <code>projD / Compile / scalacOptions</code>.
Also under “Delegates”, <em>all</em> of the possible delegate candidates
listed in the order of precedence!
</p><ul><li>All the scopes with <code>projD</code> scoping on the subproject axis are listed first,
then <code>ThisBuild</code>, and <code>Zero</code>.
</li><li>Within a subproject, scopes with <code>Compile</code> scoping on the configuration axis
are listed first, then falls back to <code>Zero</code>.
</li><li>Finally, the task axis scoping lists the given task scoping <code>console /</code> and the one without.
</li></ul><h3 id=".value+lookup+vs+dynamic+dispatch">.value lookup vs dynamic dispatch<a href="#.value+lookup+vs+dynamic+dispatch" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Rule 5: A delegated scoped key and its dependent settings/tasks are evaluated without carrying the original context.
</li></ul><p>Note that scope delegation feels similar to class inheritance in an object-oriented language,
but there’s a difference. In an OO language like Scala if there’s a method named
<code>drawShape</code> on a trait <code>Shape</code>, its subclasses can override the behavior even when <code>drawShape</code> is used
by other methods in the <code>Shape</code> trait, which is called dynamic dispatch.
</p><p>In sbt, however, scope delegation can delegate a scope to a more general scope,
like a project-level setting to a build-level settings,
but that build-level setting cannot refer to the project-level setting.
</p><p><strong>Exercise E</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    inThisBuild(List(
      organization := &quot;com.example&quot;,
      scalaVersion := &quot;2.12.2&quot;,
      version      := scalaVersion.value + &quot;_0.1.0&quot;
    )),
    name := &quot;Hello&quot;
  )

lazy val projE = (project in file(&quot;e&quot;))
  .settings(
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>What will <code>projE / version</code> return?
</p><ol><li><code>&quot;2.12.2_0.1.0&quot;</code>
</li><li><code>&quot;2.11.11_0.1.0&quot;</code>
</li><li>something else?
</li></ol><p>The answer is <code>2.12.2_0.1.0</code>.
<code>projE / version</code> delegates to <code>ThisBuild / version</code>,
which depends on <code>ThisBuild / scalaVersion</code>.
Because of this reason, build level setting should be limited mostly to simple value assignments.
</p><p><strong>Exercise F</strong>: Given the following build definition:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions += &quot;-D0&quot;
scalacOptions += &quot;-D1&quot;

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions += &quot;-D2&quot;,
    Compile / scalacOptions += &quot;-D3&quot;,
    Compile / compile / scalacOptions += &quot;-D4&quot;,
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><p>What will <code>projF / test</code> show?
</p><ol><li><code>&quot;bippy-D4&quot;</code>
</li><li><code>&quot;bippy-D2-D4&quot;</code>
</li><li><code>&quot;bippy-D0-D3-D4&quot;</code>
</li><li>something else?
</li></ol><p>The answer is <code>&quot;bippy-D0-D3-D4&quot;</code>. This is a variation of an exercise
originally created by <a href="https://gist.github.com/paulp/923154ab2d61882195cdea47483592ca">Paul Phillips</a>.
</p><p>It’s a great demonstration of all the rules because <code>someKey += &quot;x&quot;</code> expands to
</p><pre><code class="prettyprint lang-scala">someKey := {
  val old = someKey.value
  old :+ &quot;x&quot;
}
</code></pre><p>Retrieving the old value would cause delegation, and due to Rule 5,
it will go to another scoped key.
Let’s get rid of <code>+=</code> first, and annotate the delegates for old values:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions := {
  // Global / scalacOptions &lt;- Rule 4
  val old = (ThisBuild / scalacOptions).value
  old :+ &quot;-D0&quot;
}

scalacOptions := {
  // ThisBuild / scalacOptions &lt;- Rule 4
  val old = scalacOptions.value
  old :+ &quot;-D1&quot;
}

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions := {
      // ThisBuild / scalacOptions &lt;- Rules 2 and 4
      val old = (compile / scalacOptions).value
      old :+ &quot;-D2&quot;
    },
    Compile / scalacOptions := {
      // ThisBuild / scalacOptions &lt;- Rules 3 and 4
      val old = (Compile / scalacOptions).value
      old :+ &quot;-D3&quot;
    },
    Compile / compile / scalacOptions := {
      // projF / Compile / scalacOptions &lt;- Rules 1 and 2
      val old = (Compile / compile / scalacOptions).value
      old :+ &quot;-D4&quot;
    },
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><p>This becomes:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions := {
  Nil :+ &quot;-D0&quot;
}

scalacOptions := {
  List(&quot;-D0&quot;) :+ &quot;-D1&quot;
}

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions := List(&quot;-D0&quot;) :+ &quot;-D2&quot;,
    Compile / scalacOptions := List(&quot;-D0&quot;) :+ &quot;-D3&quot;,
    Compile / compile / scalacOptions := List(&quot;-D0&quot;, &quot;-D3&quot;) :+ &quot;-D4&quot;,
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><h2 id="Library+dependencies">Library dependencies<a href="#Library+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page assumes you’ve already read the earlier Getting Started pages, in
particular <a href="Basic-Def.html">build definition</a>, <a href="Scopes.html">scopes</a>, and
<a href="Task-Graph.html">task graph</a>.
</p><p>Library dependencies can be added in two ways:
</p><ul><li><em>unmanaged dependencies</em> are jars dropped into the <code>lib</code> directory
</li><li><em>managed dependencies</em> are configured in the build definition and
downloaded automatically from repositories
</li></ul><h3 id="Unmanaged+dependencies">Unmanaged dependencies<a href="#Unmanaged+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Most people use managed dependencies instead of unmanaged. But unmanaged
can be simpler when starting out.
</p><p>Unmanaged dependencies work like this: add jars to <code>lib</code> and they will be
placed on the project classpath. Not much else to it!
</p><p>You can place test jars such as
<a href="https://scalacheck.org/">ScalaCheck</a>,
<a href="http://specs2.org">Specs2</a>, and
<a href="https://www.scalatest.org/">ScalaTest</a> in <code>lib</code> as well.
</p><p>Dependencies in <code>lib</code> go on all the classpaths (for <code>compile</code>, <code>test</code>, <code>run</code>,
and <code>console</code>). If you wanted to change the classpath for just one of
those, you would adjust <code>Compile / dependencyClasspath</code> or
<code>Runtime / dependencyClasspath</code> for example.
</p><p>There’s nothing to add to <code>build.sbt</code> to use unmanaged dependencies,
though you could change the <code>unmanagedBase</code> key if you’d like to use a
different directory rather than <code>lib</code>.
</p><p>To use <code>custom_lib</code> instead of <code>lib</code>:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;custom_lib&quot;
</code></pre><p><code>baseDirectory</code> is the project’s root directory, so here you’re changing
<code>unmanagedBase</code> depending on <code>baseDirectory</code> using the special <code>value</code> method
as explained in <a href="Task-Graph.html">task graph</a>.
</p><p>There’s also an <code>unmanagedJars</code> task which lists the jars from the
<code>unmanagedBase</code> directory. If you wanted to use multiple directories or do
something else complex, you might need to replace the whole
<code>unmanagedJars</code> task with one that does something else, e.g. empty the list for
<code>Compile</code> configuration regardless of the files in <code>lib</code> directory:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedJars := Seq.empty[sbt.Attributed[java.io.File]]
</code></pre><h3 id="Managed+Dependencies">Managed Dependencies<a href="#Managed+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt uses <a href="https://get-coursier.io/">Coursier</a> to implement managed
dependencies, so if you’re familiar with Coursier, Apache Ivy or Maven, you won’t have
much trouble.
</p><h4 id="The++key">The <code>libraryDependencies</code> key<a href="#The++key" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Most of the time, you can simply list your dependencies in the setting
<code>libraryDependencies</code>. It’s also possible to write a Maven POM file or Ivy
configuration file to externally configure your dependencies, and have
sbt use those external configuration files. You can learn more about
that <a href="../docs/Library-Management.html#External+Maven+or+Ivy">here</a>.
</p><p>Declaring a dependency looks like this, where <code>groupId</code>, <code>artifactId</code>, and
<code>revision</code> are strings:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision
</code></pre><p>or like this, where <code>configuration</code> can be a string or a <code>Configuration</code> value (such as <code>Test</code>):
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre><p><code>libraryDependencies</code> is declared in
<a href="../api/sbt/Keys$.html#libraryDependencies:sbt.SettingKey[Seq[sbt.librarymanagement.ModuleID]]">Keys</a> like
this:
</p><pre><code class="prettyprint lang-scala">val libraryDependencies = settingKey[Seq[ModuleID]](&quot;Declares managed dependencies.&quot;)
</code></pre><p>The <code>%</code> methods create <code>ModuleID</code> objects from strings, then you add those
<code>ModuleID</code> to <code>libraryDependencies</code>.
</p><p>Of course, sbt (via Coursier) has to know where to download the module. If
your module is in one of the default repositories sbt comes with, this
will just work. For example, Apache Derby is in the standard Maven2
repository:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;
</code></pre><p>If you type that in <code>build.sbt</code> and then <code>update</code>, sbt should download Derby
to <a href="https://get-coursier.io/docs/cache">the Coursier cache</a>. (By the way, <code>update</code> is a dependency
of <code>compile</code> so there’s no need to manually type <code>update</code> most of the time.)
</p><p>Of course, you can also use <code>++=</code> to add a list of dependencies all at
once:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  groupID % artifactID % revision,
  groupID % otherID % otherRevision
)
</code></pre><p>In rare cases you might find reasons to use <code>:=</code> with <code>libraryDependencies</code>
as well.
</p><h4 id="Getting+the+right+Scala+version+with">Getting the right Scala version with <code>%%</code><a href="#Getting+the+right+Scala+version+with" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you use <code>organization %% moduleName % version</code> rather than
<code>organization % moduleName % version</code> (the difference is the double <code>%%</code> after
the <code>organization</code>), sbt will add your project’s binary Scala version to the artifact
name. This is just a shortcut. You could write this without the <code>%%</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-tools&quot; % &quot;scala-stm_2.11&quot; % &quot;0.3&quot;
</code></pre><p>Assuming the <code>scalaVersion</code> for your build is <code>2.11.1</code>, the following is
identical (note the double <code>%%</code> after <code>&quot;org.scala-tools&quot;</code>):
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-tools&quot; %% &quot;scala-stm&quot; % &quot;0.3&quot;
</code></pre><p>The idea is that many dependencies are compiled for multiple Scala
versions, and you’d like to get the one that matches your project
to ensure binary compatibility.
</p><p>See <a href="../docs/Cross-Build.html">Cross Building</a> for some more detail on this.
</p><h4 id="Ivy+revisions">Ivy revisions<a href="#Ivy+revisions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>version</code> in <code>organization % moduleName % version</code> does not have to be a
single fixed version. Ivy can select the latest revision of a module
according to constraints you specify. Instead of a fixed revision like
<code>&quot;1.6.1&quot;</code>, you specify <code>&quot;latest.integration&quot;</code>, <code>&quot;2.9.+&quot;</code>, or <code>&quot;[1.0,)&quot;</code>. See the
<a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision">Ivy
revisions</a>
documentation for details.
</p><!-- TODO: Add aliases -->
<p>Occasionally a Maven “version range” is used to specify a dependency
(transitive or otherwise), such as <code>[1.3.0,)</code>.  If a specific version
of the dependency is declared in the build, and it satisfies the
range, then sbt will use the specified version.  Otherwise, Coursier could
go out to the Internet to find the latest version.  This would result
to a surprising behavior where the effective version keeps changing
over time, even though there’s a specified version of the library that
satisfies the range condition.
</p><p>Maven version ranges will be replaced with its lower bound if the
build so that when a satisfactory version is found in the dependency
graph it will be used.  You can disable this behavior using the JVM
flag <code>-Dsbt.modversionrange=false</code>.
</p><h4 id="Resolvers">Resolvers<a href="#Resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Not all packages live on the same server; sbt uses the standard Maven2
repository by default. If your dependency isn’t on one of the default
repositories, you’ll have to add a <em>resolver</em> to help Ivy find it.
</p><p>To add an additional repository, use
</p><pre><code class="prettyprint lang-scala">resolvers += name at location
</code></pre><p>with the special <code>at</code> between two strings.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>The <code>resolvers</code> key is defined in
<a href="../api/sbt/Keys$.html#resolvers:sbt.SettingKey[Seq[sbt.librarymanagement.Resolver]]">Keys</a> like this:
</p><pre><code class="prettyprint lang-scala">val resolvers = settingKey[Seq[Resolver]](&quot;The user-defined additional resolvers for automatically managed dependencies.&quot;)
</code></pre><p>The <code>at</code> method creates a <code>Resolver</code> object from two strings.
</p><p>sbt can search your local Maven repository if you add it as a
repository:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
</code></pre><p>or, for convenience:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.mavenLocal
</code></pre><p>See <a href="../docs/Resolvers.html">Resolvers</a> for details on defining other types of
repositories.
</p><h4 id="Overriding+default+resolvers">Overriding default resolvers<a href="#Overriding+default+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>resolvers</code> does not contain the default resolvers; only additional ones
added by your build definition.
</p><p>sbt combines <code>resolvers</code> with some default repositories to form
<code>externalResolvers</code>.
</p><p>Therefore, to change or remove the default resolvers, you would need to
override <code>externalResolvers</code> instead of <code>resolvers</code>.
</p><h4 id="Per-configuration+dependencies">Per-configuration dependencies<a href="#Per-configuration+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Often a dependency is used by your test code (in <code>src/test/scala</code>, which
is compiled by the <code>Test</code> configuration) but not your main code.
</p><p>If you want a dependency to show up in the classpath only for the <code>Test</code>
configuration and not the <code>Compile</code> configuration, add <code>% &quot;test&quot;</code> like this:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot; % &quot;test&quot;
</code></pre><p>You may also use the type-safe version of <code>Test</code> configuration as follows:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot; % Test
</code></pre><p>Now, if you type <code>show compile:dependencyClasspath</code> at the sbt interactive
prompt, you should not see the derby jar. But if you type
<code>show test:dependencyClasspath</code>, you should see the derby jar in the list.
</p><p>Typically, test-related dependencies such as
<a href="https://scalacheck.org/">ScalaCheck</a>,
<a href="http://specs2.org">Specs2</a>, and
<a href="https://www.scalatest.org/">ScalaTest</a> would be defined with <code>% &quot;test&quot;</code>.
</p><p>There are more details and tips-and-tricks related to library
dependencies on <a href="../docs/Library-Management.html">this page</a>.
</p><h2 id="Using+plugins">Using plugins<a href="#Using+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Please read the earlier pages in the Getting Started Guide first, in
particular you need to understand <a href="Basic-Def.html">build.sbt</a>, <a href="Task-Graph.html">task graph</a>,
<a href="Library-Dependencies.html">library dependencies</a>, before reading this page.
</p><h3 id="What+is+a+plugin%3F">What is a plugin?<a href="#What+is+a+plugin%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin extends the build definition, most commonly by adding new
settings. The new settings could be new tasks. For example, a plugin
could add a <code>codeCoverage</code> task which would generate a test coverage
report.
</p><h3 id="Declaring+a+plugin">Declaring a plugin<a href="#Declaring+a+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If your project is in directory <code>hello</code>, and you’re adding
sbt-site plugin to the build definition, create <code>hello/project/site.sbt</code>
and declare the plugin dependency by passing the plugin’s Ivy module ID
to <code>addSbtPlugin</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-site&quot; % &quot;0.7.0&quot;)
</code></pre><p>If you’re adding sbt-assembly, create <code>hello/project/assembly.sbt</code> with the following:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.11.2&quot;)
</code></pre><p>Not every plugin is located on one of the default repositories and a
plugin’s documentation may instruct you to also add the repository where
it can be found:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sonatypeRepo(&quot;public&quot;)
</code></pre><p>Plugins usually provide settings that get added to a project to enable
the plugin’s functionality. This is described in the next section.
</p><h3 id="Enabling+and+disabling+auto+plugins">Enabling and disabling auto plugins<a href="#Enabling+and+disabling+auto+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin can declare that its settings be automatically added to the build definition,
in which case you don’t have to do anything to add them.
</p><p>As of sbt 0.13.5, there is a new
<a href="../docs/Plugins.html">auto plugins</a> feature that enables
plugins to automatically, and safely, ensure their settings and
dependencies are on a project. Many auto plugins should have their default
settings automatically, however some may require explicit enablement.
</p><p>If you’re using an auto plugin that requires explicit enablement, then you
have to add the following to your <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))
  .enablePlugins(FooPlugin, BarPlugin)
  .settings(
    name := &quot;hello-util&quot;
  )
</code></pre><p>The <code>enablePlugins</code> method allows projects to explicitly define the
auto plugins they wish to consume.
</p><p>Projects can also exclude plugins using the <code>disablePlugins</code>
method. For example, if we wish to remove the <code>IvyPlugin</code> settings
from <code>util</code>, we modify our <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))
  .enablePlugins(FooPlugin, BarPlugin)
  .disablePlugins(plugins.IvyPlugin)
  .settings(
    name := &quot;hello-util&quot;
  )
</code></pre><p>Auto plugins should document whether they need to be explicitly enabled. If you’re
curious which auto plugins are enabled for a given project, just run the
<code>plugins</code> command on the sbt console.
</p><p>For example:
</p><pre><code class="">&gt; plugins
In file:/home/jsuereth/projects/sbt/test-ivy-issues/
        sbt.plugins.IvyPlugin: enabled in scala-sbt-org
        sbt.plugins.JvmPlugin: enabled in scala-sbt-org
        sbt.plugins.CorePlugin: enabled in scala-sbt-org
        sbt.plugins.JUnitXmlReportPlugin: enabled in scala-sbt-org
</code></pre><p>Here, the <code>plugins</code> output is showing that the sbt default plugins are all
enabled. sbt’s default settings are provided via three plugins:
</p><ol><li><code>CorePlugin</code>: Provides the core parallelism controls for tasks.
</li><li><code>IvyPlugin</code>: Provides the mechanisms to publish/resolve modules.
</li><li><code>JvmPlugin</code>: Provides the mechanisms to compile/test/run/package
Java/Scala projects.
</li></ol><p>In addition, <code>JUnitXmlReportPlugin</code> provides an experimental support for
generating junit-xml.
</p><p>Older non-auto plugins often require settings to be added explicitly, so
that <a href="Multi-Project.html">multi-project build</a> could have different types of
projects. The plugin documentation will indicate how to configure it,
but typically for older plugins this involves adding the base settings
for the plugin and customizing as necessary.
</p><p>For example, for the sbt-site plugin, create <code>site.sbt</code> with the following content
</p><pre><code class="prettyprint lang-scala">site.settings
</code></pre><p>to enable it for that project.
</p><p>If the build defines multiple projects, instead add it directly to the
project:
</p><pre><code class="prettyprint lang-scala">// don't use the site plugin for the `util` project
lazy val util = (project in file(&quot;util&quot;))

// enable the site plugin for the `core` project
lazy val core = (project in file(&quot;core&quot;))
  .settings(site.settings)
</code></pre><h3 id="Global+plugins">Global plugins<a href="#Global+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Plugins can be installed for all your projects at once by declaring them
in <code>$HOME/.sbt/1.0/plugins/</code>. <code>$HOME/.sbt/1.0/plugins/</code> is an sbt project whose
classpath is exported to all sbt build definition projects. Roughly
speaking, any <code>.sbt</code> or <code>.scala</code> files in <code>$HOME/.sbt/1.0/plugins/</code> behave as if
they were in the <code>project/</code> directory for all projects.
</p><p>You can create <code>$HOME/.sbt/1.0/plugins/build.sbt</code> and put <code>addSbtPlugin()</code>
expressions in there to add plugins to all your projects at once.
Because doing so would increase the dependency on the machine environment, 
this feature should be used sparingly. See
<a href="../docs/Best-Practices.html#global-vs-local-plugins">Best Practices</a>.
</p><h3 id="Available+Plugins">Available Plugins<a href="#Available+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There’s <a href="../docs/Community-Plugins.html">a list of available plugins</a>.
</p><p>Some especially popular plugins are:
</p><ul><li>those for IDEs (to import an sbt project into your IDE)
</li><li>those supporting web frameworks, such as
<a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a>.
</li></ul><p>For more details, including ways of developing plugins, see
<a href="../docs/Plugins.html">Plugins</a>.
For best practices, see
<a href="../docs/Plugins-Best-Practices.html">Plugins-Best-Practices</a>.
</p><h2 id="Custom+settings+and+tasks">Custom settings and tasks<a href="#Custom+settings+and+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page gets you started creating your own settings and tasks.
</p><p>To understand this page, be sure you’ve read earlier pages in the
Getting Started Guide, especially <a href="Basic-Def.html">build.sbt</a> and
<a href="Task-Graph.html">task graph</a>.
</p><h3 id="Defining+a+key">Defining a key<a href="#Defining+a+key" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="../api/sbt/Keys$.html">Keys</a> is packed with examples
illustrating how to define keys. Most of the keys are implemented in
<a href="https://github.com/sbt/sbt/blob/develop/main/src/main/scala/sbt/Defaults.scala">Defaults</a>.
</p><p>Keys have one of three types. <code>SettingKey</code> and <code>TaskKey</code> are described in
<a href="Basic-Def.html">.sbt build definition</a>. Read about <code>InputKey</code> on the
<a href="../docs/Input-Tasks.html">Input Tasks</a> page.
</p><p>Some examples from <a href="../api/sbt/Keys$.html">Keys</a>:
</p><pre><code class="prettyprint lang-scala">val scalaVersion = settingKey[String](&quot;The version of Scala used for building.&quot;)
val clean = taskKey[Unit](&quot;Deletes files produced by the build, such as generated sources, compiled classes, and task caches.&quot;)
</code></pre><p>The key constructors have two string parameters: the name of the key
(<code>&quot;scalaVersion&quot;</code>) and a documentation string
(<code>&quot;The version of scala used for building.&quot;</code>).
</p><p>Remember from <a href="Basic-Def.html">.sbt build definition</a> that the type
parameter <code>T</code> in <code>SettingKey[T]</code> indicates the type of value a setting has.
<code>T</code> in <code>TaskKey[T]</code> indicates the type of the task’s result. Also remember
from <a href="Basic-Def.html">.sbt build definition</a> that a setting has a fixed
value until project reload, while a task is re-computed for every “task
execution” (every time someone types a command at the sbt interactive
prompt or in batch mode).
</p><p>Keys may be defined in an <a href="Basic-Def.html">.sbt file</a>,
a <a href="Organizing-Build.html">.scala file</a>, or in an <a href="Using-Plugins.html">auto plugin</a>.
Any <code>val</code>s found under <code>autoImport</code> object of an enabled auto plugin
will be imported automatically into your <code>.sbt</code> files.
</p><h3 id="Implementing+a+task">Implementing a task<a href="#Implementing+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Once you’ve defined a key for your task, you’ll need to complete it with
a task definition. You could be defining your own task, or you could be
planning to redefine an existing task. Either way looks the same; use <code>:=</code>
to associate some code with the task key:
</p><pre><code class="prettyprint lang-scala">val sampleStringTask = taskKey[String](&quot;A sample string task.&quot;)
val sampleIntTask = taskKey[Int](&quot;A sample int task.&quot;)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val library = (project in file(&quot;library&quot;))
  .settings(
    sampleStringTask := System.getProperty(&quot;user.home&quot;),
    sampleIntTask := {
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      sum
    }
  )
</code></pre><p>If the task has dependencies, you’d reference their value using <code>value</code>,
as discussed in <a href="Task-Graph.html">task graph</a>.
</p><p>The hardest part about implementing tasks is often not sbt-specific;
tasks are just Scala code. The hard part could be writing the “body” of
your task that does whatever you’re trying to do. For example, maybe
you’re trying to format HTML in which case you might want to use an HTML
library (you would
<a href="Using-Plugins.html">add a library dependency to your build definition</a> and
write code based on the HTML library, perhaps).
</p><p>sbt has some utility libraries and convenience functions, in particular
you can often use the convenient APIs in
<a href="../api/sbt/io/IO$.html">IO</a> to manipulate files and directories.
</p><h3 id="Execution+semantics+of+tasks">Execution semantics of tasks<a href="#Execution+semantics+of+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When depending on other tasks from a custom task using <code>value</code>,
an important detail to note is the execution semantics of the tasks.
By execution semantics, we mean exactly <em>when</em> these tasks are evaluated.
</p><p>If we take <code>sampleIntTask</code> for instance, each line in the body of the task
should be strictly evaluated one after the other. That is sequential semantics:
</p><pre><code class="prettyprint lang-scala">sampleIntTask := {
  val sum = 1 + 2        // first
  println(&quot;sum: &quot; + sum) // second
  sum                    // third
}
</code></pre><p>In reality JVM may inline the <code>sum</code> to <code>3</code>, but the observable <em>effect</em> of the
task will remain identical as if each line were executed one after the other.
</p><p>Now suppose we define two more custom tasks <code>startServer</code> and <code>stopServer</code>,
and modify <code>sampleIntTask</code> as follows:
</p><pre><code class="prettyprint lang-scala">val startServer = taskKey[Unit](&quot;start server&quot;)
val stopServer = taskKey[Unit](&quot;stop server&quot;)
val sampleIntTask = taskKey[Int](&quot;A sample int task.&quot;)
val sampleStringTask = taskKey[String](&quot;A sample string task.&quot;)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val library = (project in file(&quot;library&quot;))
  .settings(
    startServer := {
      println(&quot;starting...&quot;)
      Thread.sleep(500)
    },
    stopServer := {
      println(&quot;stopping...&quot;)
      Thread.sleep(500)
    },
    sampleIntTask := {
      startServer.value
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      stopServer.value // THIS WON'T WORK
      sum
    },
    sampleStringTask := {
      startServer.value
      val s = sampleIntTask.value.toString
      println(&quot;s: &quot; + s)
      s
    }
  )
</code></pre><p>Running <code>sampleIntTask</code> from sbt interactive prompt results to the following:
</p><pre><code class="">&gt; sampleIntTask
stopping...
starting...
sum: 3
[success] Total time: 1 s, completed Dec 22, 2014 5:00:00 PM
</code></pre><p>To review what happened, let’s look at a graphical notation of <code>sampleIntTask</code>:
</p><p><img src="files/task-dependency00.png" alt="task-dependency"/>
</p><p>Unlike plain Scala method calls, invoking <code>value</code> method on tasks will not
be evaluated strictly. Instead, they simply act as placeholders to denote
that <code>sampleIntTask</code> depends on <code>startServer</code> and <code>stopServer</code> tasks.
When <code>sampleIntTask</code> is invoked by you, sbt’s tasks engine will:
</p><ul><li>evaluate the task dependencies <em>before</em> evaluating <code>sampleIntTask</code> (partial ordering)
</li><li>try to evaluate task dependencies in parallel if they are independent (parallelization)
</li><li>each task dependency will be evaluated once and only once per command execution (deduplication)
</li></ul><h4 id="Deduplication+of+task+dependencies">Deduplication of task dependencies<a href="#Deduplication+of+task+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To demonstrate the last point, we can run <code>sampleStringTask</code> from sbt
interactive prompt.
</p><pre><code class="">&gt; sampleStringTask
stopping...
starting...
sum: 3
s: 3
[success] Total time: 1 s, completed Dec 22, 2014 5:30:00 PM
</code></pre><p>Because <code>sampleStringTask</code> depends on both <code>startServer</code> and <code>sampleIntTask</code> task,
and <code>sampleIntTask</code> also depends on <code>startServer</code> task, it appears twice as task dependency.
If this was a plain Scala method call it would be evaluated twice,
but since <code>value</code> is just denoting a task dependency, it will be evaluated once.
The following is a graphical notation of <code>sampleStringTask</code>’s evaluation:
</p><p><img src="files/task-dependency01.png" alt="task-dependency"/>
</p><p>If we did not deduplicate the task dependencies, we will end up
compiling test source code many times when <code>test</code> task is invoked
since <code>compile in Test</code> appears many times as a task dependency of <code>test in Test</code>.
</p><h4 id="Cleanup+task">Cleanup task<a href="#Cleanup+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>How should one implement <code>stopServer</code> task?
The notion of cleanup task does not fit into the execution model of tasks because
tasks are about tracking dependencies.
The last operation should become the task that depends
on other intermediate tasks. For instance <code>stopServer</code> should depend on <code>sampleStringTask</code>,
at which point <code>stopServer</code> should be the <code>sampleStringTask</code>.
</p><pre><code class="prettyprint lang-scala">lazy val library = (project in file(&quot;library&quot;))
  .settings(
    startServer := {
      println(&quot;starting...&quot;)
      Thread.sleep(500)
    },
    sampleIntTask := {
      startServer.value
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      sum
    },
    sampleStringTask := {
      startServer.value
      val s = sampleIntTask.value.toString
      println(&quot;s: &quot; + s)
      s
    },
    sampleStringTask := {
      val old = sampleStringTask.value
      println(&quot;stopping...&quot;)
      Thread.sleep(500)
      old
    }
  )
</code></pre><p>To demonstrate that it works, run <code>sampleStringTask</code> from the interactive prompt:
</p><pre><code class="">&gt; sampleStringTask
starting...
sum: 3
s: 3
stopping...
[success] Total time: 1 s, completed Dec 22, 2014 6:00:00 PM
</code></pre><p><img src="files/task-dependency02.png" alt="task-dependency"/>
</p><h4 id="Use+plain+Scala">Use plain Scala<a href="#Use+plain+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Another way of making sure that something happens after some other thing is to use Scala.
Implement a simple function in <code>project/ServerUtil.scala</code> for example, and you can write:
</p><pre><code class="prettyprint lang-scala">sampleIntTask := {
  ServerUtil.startServer
  try {
    val sum = 1 + 2
    println(&quot;sum: &quot; + sum)
  } finally {
    ServerUtil.stopServer
  }
  sum
}
</code></pre><p>Since plain method calls follow sequential semantics, everything happens in order.
There’s no deduplication, so you have to be careful about that.
</p><h3 id="Turn+them+into+plugins">Turn them into plugins<a href="#Turn+them+into+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you find you have a lot of custom code, consider moving it to a
plugin for re-use across multiple builds.
</p><p>It’s very easy to create a plugin, as <a href="Using-Plugins.html">teased earlier</a>
and <a href="../docs/Plugins.html">discussed at more length here</a>.
</p><p>This page has been a quick taste; there’s much much more about custom
tasks on the <a href="../docs/Tasks.html">Tasks</a> page.
</p><h2 id="Organizing+the+build">Organizing the build<a href="#Organizing+the+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page discusses the organization of the build structure.
</p><p>Please read the earlier pages in the Getting Started Guide first, in
particular you need to understand
<a href="Basic-Def.html">build.sbt</a>,
<a href="Task-Graph.html">task graph</a>,
<a href="Library-Dependencies.html">Library dependencies</a>,
and <a href="Multi-Project.html">Multi-project builds</a>
before reading this page.
</p><h3 id="sbt+is+recursive">sbt is recursive<a href="#sbt+is+recursive" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>build.sbt</code> conceals how sbt really works. sbt builds are
defined with Scala code. That code, itself, has to be built. What better
way than with sbt?
</p><p>The <code>project</code> directory <em>is another build inside your build</em>, which
knows how to build your build. To distinguish the builds,
we sometimes use the term <strong>proper build</strong> to refer to your build,
and <strong>meta-build</strong> to refer to the build in <code>project</code>.
The projects inside the metabuild can do anything
any other project can do. <em>Your build definition is an sbt project.</em>
</p><p>And the turtles go all the way down. If you like, you can tweak the
build definition of the build definition project, by creating a
<code>project/project/</code> directory.
</p><p>Here’s an illustration.
</p><pre><code class="">hello/                     # your build's root project's base directory

    Hello.scala            # a source file in your build's root project
                           #   (could be in src/main/scala too)

    build.sbt              # build.sbt is part of the source code for
                           #   meta-build's root project inside project/;
                           #   the build definition for your build

    project/               # base directory of meta-build's root project

        Dependencies.scala # a source file in the meta-build's root project,
                           #   that is, a source file in the build definition
                           #   the build definition for your build

        assembly.sbt       # this is part of the source code for
                           #   meta-meta-build's root project in project/project;
                           #   build definition's build definition

        project/           # base directory of meta-meta-build's root project;
                           #   the build definition project for the build definition

            MetaDeps.scala # source file in the root project of
                           #   meta-meta-build in project/project/
</code></pre><p><em>Don’t worry!</em> Most of the time you are not going to need all that. But
understanding the principle can be helpful.
</p><p>By the way: any time files ending in <code>.scala</code> or <code>.sbt</code> are used, naming
them <code>build.sbt</code> and <code>Dependencies.scala</code> are conventions only. This also means
that multiple files are allowed.
</p><h3 id="Tracking+dependencies+in+one+place">Tracking dependencies in one place<a href="#Tracking+dependencies+in+one+place" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>One way of using the fact that <code>.scala</code> files under <code>project</code> becomes
part of the build definition is to create <code>project/Dependencies.scala</code>
to track dependencies in one place.
</p><pre><code class="prettyprint lang-scala">import sbt._

object Dependencies {
  // Versions
  lazy val akkaVersion = &quot;2.3.8&quot;

  // Libraries
  val akkaActor = &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % akkaVersion
  val akkaCluster = &quot;com.typesafe.akka&quot; %% &quot;akka-cluster&quot; % akkaVersion
  val specs2core = &quot;org.specs2&quot; %% &quot;specs2-core&quot; % &quot;2.4.17&quot;

  // Projects
  val backendDeps =
    Seq(akkaActor, specs2core % Test)
}
</code></pre><p>The <code>Dependencies</code> object will be available in <code>build.sbt</code>.
To make it easier to use the <code>val</code>s defined in it, import <code>Dependencies._</code> in your build.sbt file.
</p><pre><code class="prettyprint lang-scala">import Dependencies._

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val backend = (project in file(&quot;backend&quot;))
  .settings(
    name := &quot;backend&quot;,
    libraryDependencies ++= backendDeps
  )
</code></pre><p>This technique is useful when you have a multi-project build that’s getting
large, and you want to ensure that subprojects have consistent dependencies.
</p><h3 id="When+to+use++files">When to use <code>.scala</code> files<a href="#When+to+use++files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In <code>.scala</code> files, you can write any Scala code, including top-level
classes and objects.
</p><p>The recommended approach is to define most settings in
a multi-project <code>build.sbt</code> file,
and using <code>project/*.scala</code> files for task implementations or to share values,
such as keys. The use of <code>.scala</code> files also depends on how comfortable
you or your team are with Scala.
</p><h3 id="Defining+auto+plugins">Defining auto plugins<a href="#Defining+auto+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For more advanced users, another way of organizing your build is to
define one-off <a href="../docs/Plugins.html">auto plugins</a> in <code>project/*.scala</code>.
By defining triggered plugins, auto plugins can be used as a convenient
way to inject custom tasks and commands across all subprojects.
</p><h2 id="Getting+Started+summary">Getting Started summary<a href="#Getting+Started+summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page wraps up the Getting Started Guide.
</p><p>To use sbt, there are a small number of concepts you must understand.
These have some learning curve, but on the positive side, there isn’t
much to sbt <em>except</em> these concepts. sbt uses a small core of powerful
concepts to do everything it does.
</p><p>If you’ve read the whole Getting Started series, now you know what you
need to know.
</p><h3 id="sbt%3A+The+Core+Concepts">sbt: The Core Concepts<a href="#sbt%3A+The+Core+Concepts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>the basics of Scala. It’s undeniably helpful to be familiar with
Scala syntax. <a href="https://www.artima.com/shop/programming_in_scala_3ed">Programming in
Scala</a> written
by the creator of Scala is a great introduction.
</li><li><a href="Basic-Def.html">.sbt build definition</a>
</li><li>your build definition is a big DAG of tasks and their dependencies.
</li><li>to create a <code>Setting</code>, call one of a few methods on a key: <code>:=</code>, <code>+=</code>, or
<code>++=</code>.
</li><li>each setting has a value of a particular type, determined by the key.
</li><li><em>tasks</em> are special settings where the computation to produce the
key’s value will be re-run each time you kick off a task. Non-tasks
compute the value once, when first loading the build definition.
</li><li><a href="Scopes.html">Scopes</a>
</li><li>each key may have multiple values, in distinct scopes.
</li><li>scoping may use three axes: configuration, project, and task.
</li><li>scoping allows you to have different behaviors per-project,
per-task, or per-configuration.
</li><li>a configuration is a kind of build, such as the main one (<code>Compile</code>)
or the test one (<code>Test</code>).
</li><li>the per-project axis also supports “entire build” scope.
</li><li>scopes fall back to or <em>delegate</em> to more general scopes.
</li><li>put most of your configuration in <code>build.sbt</code>, but use <code>.scala</code> build
definition files for defining classes and larger task
implementations.
</li><li>the build definition is an sbt project in its own right, rooted in
the project directory.
</li><li><a href="Using-Plugins.html">Plugins</a> are extensions to the build definition
</li><li>add plugins with the <code>addSbtPlugin</code> method in <code>project/plugins.sbt</code> (NOT
<code>build.sbt</code> in the project’s base directory).
</li></ul><p>If any of this leaves you wondering rather than nodding, please
<a href="../docs/faq.html#getting-help">ask for help</a>, go back and re-read, or try some
experiments in sbt’s interactive mode.
</p><p>Good luck!
</p><h3 id="Advanced+Notes">Advanced Notes<a href="#Advanced+Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><!-- TODO: Link to reference. The rest of this wiki consists of deeper dives and less-commonly-needed
information. -->
<p>Since sbt is open source, don’t forget you can check out the
<a href="https://github.com/sbt/sbt">source code</a> too!
</p><h2 id="Frequently+Asked+Questions">Frequently Asked Questions<a href="#Frequently+Asked+Questions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Project+Information">Project Information<a href="#Project+Information" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="What+does+the+name+%E2%80%9Csbt%E2%80%9D+stand+for%2C+and+why+shouldn%E2%80%99t+it+be+written+%E2%80%9CSBT%E2%80%9D%3F">What does the name “sbt” stand for, and why shouldn’t it be written “SBT”?<a href="#What+does+the+name+%E2%80%9Csbt%E2%80%9D+stand+for%2C+and+why+shouldn%E2%80%99t+it+be+written+%E2%80%9CSBT%E2%80%9D%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>TL;DR</strong> the name sbt doesn’t stand for anything, it’s just “sbt”, and it should be written that way.
</p><p>When Mark Harrah (<a href="https://github.com/harrah">@harrah</a>) first created the project he called it “Simple Build Tool”, but in his
<a href="http://www.scala-lang.org/old/node/392.html">first public announcement</a> of it he already referred to it as just “sbt”.
Over time some have re-defined sbt to stand for “Scala Build Tool”, but we believe that isn’t accurate either
given it can be used to build Java-only projects.
</p><p>Nowadays we just call sbt “sbt”, and to reinforce that the name is no longer an <a href="https://en.oxforddictionaries.com/definition/initialism">initialism</a> we
always write it in all lowercase letters. However, we are cool with <a href="https://ja.wikipedia.org/wiki/%E9%85%A2%E8%B1%9A">酢豚</a> (subuta) as a nickname.
</p><h4 id="How+do+I+get+help%3F">How do I get help?<a href="#How+do+I+get+help%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>See <a href="https://www.scala-sbt.org/support.html#how-can-I-get-help">Support</a>
</li></ul><h4 id="How+do+I+report+a+bug%3F">How do I report a bug?<a href="#How+do+I+report+a+bug%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>See <a href="https://www.scala-sbt.org/community.html#how-can-I-help">Get Involved</a>
</li></ul><h4 id="How+can+I+help%3F">How can I help?<a href="#How+can+I+help%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>See <a href="https://www.scala-sbt.org/community.html#how-can-I-help">Get Involved</a>
</li></ul><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="My+last+command+didn%E2%80%99t+work+but+I+can%E2%80%99t+see+an+explanation.+Why%3F">My last command didn’t work but I can’t see an explanation. Why?<a href="#My+last+command+didn%E2%80%99t+work+but+I+can%E2%80%99t+see+an+explanation.+Why%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.4.7 by default suppresses most stack traces and debugging
information. It has the nice side effect of giving you less noise on
screen, but as a newcomer it can leave you lost for explanation. To see
the previous output of a command at a higher verbosity, type
<code>last &lt;task&gt;</code> where <code>&lt;task&gt;</code> is the task that failed or that you want to
view detailed output for. For example, if you find that your <code>update</code>
fails to load all the dependencies as you expect you can enter:
</p><pre><code class="">&gt; last update
</code></pre><p>and it will display the full output from the last run of the <code>update</code>
command.
</p><h4 id="How+do+I+disable+ansi+codes+in+the+output%3F">How do I disable ansi codes in the output?<a href="#How+do+I+disable+ansi+codes+in+the+output%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Sometimes sbt doesn’t detect that ansi codes aren’t supported and you
get output that looks like:
</p><pre><code class="">[0m[ [0minfo [0m]  [0mSet current project to root
</code></pre><p>or ansi codes are supported but you want to disable colored output. To
completely disable ansi codes, pass <code>-no-colors</code> option:
</p><pre><code class="">$ sbt -no-colors
</code></pre><h4 id="How+can+I+start+a+Scala+interpreter+%28REPL%29+with+sbt+project+configuration+%28dependencies%2C+etc.%29%3F">How can I start a Scala interpreter (REPL) with sbt project configuration (dependencies, etc.)?<a href="#How+can+I+start+a+Scala+interpreter+%28REPL%29+with+sbt+project+configuration+%28dependencies%2C+etc.%29%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In sbt’s shell run <code>console</code>.
</p><h3 id="Build+definitions">Build definitions<a href="#Build+definitions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="What+are+the+%2C+%2C+and++methods%3F">What are the <code>:=</code>, <code>+=</code>, and <code>++=</code> methods?<a href="#What+are+the+%2C+%2C+and++methods%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These are methods on keys used to construct a <code>Setting</code> or a <code>Task</code>. The
Getting Started Guide covers all these methods, see
<a href="Basic-Def.html">.sbt build definition</a>,
<a href="Task-Graph.html">task graph</a>, and
<a href="Appending-Values.html">appending values</a> for
example.
</p><h4 id="What+is+the++method%3F">What is the <code>%</code> method?<a href="#What+is+the++method%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It’s used to create a <code>ModuleID</code> from strings, when specifying managed
dependencies. Read the Getting Started Guide about
<a href="Library-Dependencies.html">library dependencies</a>.
</p><h4 id="What+does++mean%3F">What does <code>ThisBuild / scalaVersion</code> mean?<a href="#What+does++mean%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>ThisBuild</code> acts as a special subproject name that you can use to define default
value for the build.
When you define one or more subprojects, and when the subproject does not define
<code>scalaVersion</code> key, it will look for <code>ThisBuild / scalaVerion</code>.
</p><p>See <a href="Multi-Project.html#ThisBuild">build-wide settings</a>.
</p><h4 id="What+is+%2C+%2C+%E2%80%A6%3F">What is <code>ModuleID</code>, <code>Project</code>, …?<a href="#What+is+%2C+%2C+%E2%80%A6%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To figure out an unknown type or method, have a look at the
<a href="Getting-Started.html">Getting Started Guide</a> if you have not. Also
try the <a href="Name-Index.html">index</a> of commonly used methods, values, and
types, and the <a href="https://www.scala-sbt.org/1.x/api/sbt/index.html">API Documentation</a>.
</p><h4 id="How+do+I+add+files+to+a+jar+package%3F">How do I add files to a jar package?<a href="#How+do+I+add+files+to+a+jar+package%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The files included in an artifact are configured by default by a task
<code>mappings</code> that is scoped by the relevant package task. The <code>mappings</code>
task returns a sequence <code>Seq[(File,String)]</code> of mappings from the file
to include to the path within the jar. See
<a href="Mapping-Files.html">mapping files</a> for details on creating these mappings.
</p><p>For example, to add generated sources to the packaged source artifact:
</p><pre><code class="prettyprint lang-scala">Compile / packageSrc / mappings ++= {
  import Path.{flat, relativeTo}
  val base = (Compile / sourceManaged).value
  val srcs = (Compile / managedSources).value
  srcs pair (relativeTo(base) | flat)
}
</code></pre><p>This takes sources from the <code>managedSources</code> task and relativizes them
against the <code>managedSource</code> base directory, falling back to a flattened
mapping. If a source generation task doesn’t write the sources to the
<code>managedSource</code> directory, the mapping function would have to be
adjusted to try relativizing against additional directories or something
more appropriate for the generator.
</p><h4 id="How+can+I+generate+source+code+or+resources%3F">How can I generate source code or resources?<a href="#How+can+I+generate+source+code+or+resources%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Howto-Generating-Files.html">Generating Files</a>.
</p><h4 id="How+can+a+task+avoid+redoing+work+if+the+input+files+are+unchanged%3F">How can a task avoid redoing work if the input files are unchanged?<a href="#How+can+a+task+avoid+redoing+work+if+the+input+files+are+unchanged%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Caching.html">Caching</a>.
</p><h3 id="Extending+sbt">Extending sbt<a href="#Extending+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+can+I+add+a+new+dependency+configuration%3F">How can I add a new dependency configuration?<a href="#How+can+I+add+a+new+dependency+configuration%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Custom-Dependency-Configuration.html">How to define a custom dependency configuration</a>.
</p><h4 id="How+do+I+add+a+test+configuration%3F">How do I add a test configuration?<a href="#How+do+I+add+a+test+configuration%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See the <a href="Testing.html#additional-test-configurations">Additional test configurations</a> section of
<a href="Testing.html">Testing</a>.
</p><h4 id="How+can+I+create+a+custom+run+task%2C+in+addition+to+%3F">How can I create a custom run task, in addition to <code>run</code>?<a href="#How+can+I+create+a+custom+run+task%2C+in+addition+to+%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This answer is extracted from a
<a href="https://groups.google.com/group/simple-build-tool/browse_thread/thread/4c28ee5b7e18b46a/">mailing list discussion</a>.
</p><p>Read the Getting Started Guide up to
<a href="Custom-Settings.html">custom settings</a> for background.
</p><p>A basic run task is created by:
</p><pre><code class="prettyprint lang-scala">lazy val myRunTask = taskKey[Unit](&quot;A custom run task.&quot;)

// this can go either in a `build.sbt` or the settings member
//   of a Project in a full configuration
fullRunTask(myRunTask, Test, &quot;foo.Foo&quot;, &quot;arg1&quot;, &quot;arg2&quot;)
</code></pre><p>If you want to be able to supply arguments on the command line, replace
<code>TaskKey</code> with <code>InputKey</code> and <code>fullRunTask</code> with <code>fullRunInputTask</code>. The
<code>Test</code> part can be replaced with another configuration, such as
<code>Compile</code>, to use that configuration’s classpath.
</p><p>This run task can be configured individually by specifying the task key
in the scope. For example:
</p><pre><code class="prettyprint lang-scala">fork in myRunTask := true

javaOptions in myRunTask += &quot;-Xmx6144m&quot;
</code></pre><h4 id="How+should+I+express+a+dependency+on+an+outside+tool+such+as+proguard%3F">How should I express a dependency on an outside tool such as proguard?<a href="#How+should+I+express+a+dependency+on+an+outside+tool+such+as+proguard%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Tool dependencies are used to implement a task and are not needed by
project source code. These dependencies can be declared in their own
configuration and classpaths. These are the steps:
</p><ol><li>Define a new <a href="Library-Management.html#ivy-configurations">configuration</a>.
</li><li>Declare the tool
<a href="Library-Management.html">dependencies</a> in that
configuration.
</li><li>Define a classpath that pulls the dependencies from the
<a href="Update-Report.html">Update Report</a> produced by <code>update</code>.
</li><li>Use the classpath to implement the task.
</li></ol><p>As an example, consider a <code>proguard</code> task. This task needs the ProGuard
jars in order to run the tool. First, define and add the new
configuration:
</p><pre><code class="prettyprint lang-scala">lazy val ProguardConfig = config(&quot;proguard&quot;).hide

ivyConfigurations += ProguardConfig
</code></pre><p>Then,
</p><pre><code class="prettyprint lang-scala">// Add proguard as a dependency in the custom configuration.
//  This keeps it separate from project dependencies.
libraryDependencies +=
   &quot;net.sf.proguard&quot; % &quot;proguard&quot; % &quot;4.4&quot; % ProguardConfig.name

// Extract the dependencies from the UpdateReport.
ProguardConfig / managedClasspath := {
    // these are the types of artifacts to include
    val artifactTypes: Set[String] = (ProguardConfig / classpathTypes).value
    Classpaths.managedJars(proguardConfig, artifactTypes, update.value)
}

// Use the dependencies in a task, typically by putting them
//  in a ClassLoader and reflectively calling an appropriate
//  method.
proguard := {
    val cp: Seq[File] = (ProguardConfig / managedClasspath).value
  // ... do something with , which includes proguard ...
}
</code></pre><p>Defining the intermediate classpath is optional, but it can be useful
for debugging or if it needs to be used by multiple tasks. It is also
possible to specify artifact types inline. This alternative <code>proguard</code>
task would look like:
</p><pre><code class="prettyprint lang-scala">proguard := {
   val artifactTypes = Set(&quot;jar&quot;)
    val cp =
      Classpaths.managedJars(proguardConfig, artifactTypes, update.value)
  // ... do something with , which includes proguard ...
}
</code></pre><h4 id="How+would+I+change+sbt%E2%80%99s+classpath+dynamically%3F">How would I change sbt’s classpath dynamically?<a href="#How+would+I+change+sbt%E2%80%99s+classpath+dynamically%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It is possible to register additional jars that will be placed on sbt’s
classpath. Through
<a href="https://www.scala-sbt.org/1.x/api/sbt/State$.html">State</a>, it is possible to obtain a
<a href="../api/xsbti/ComponentProvider.html">xsbti.ComponentProvider</a>, which
manages application components. Components are groups of files in the
<code>~/.sbt/boot/</code> directory and, in this case, the application is sbt. In
addition to the base classpath, components in the “extra” component are
included on sbt’s classpath.
</p><p>(Note: the additional components on an application’s classpath are
declared by the <code>components</code> property in the <code>[main]</code> section of the
launcher configuration file <code>boot.properties</code>.)
</p><p>Because these components are added to the <code>~/.sbt/boot/</code> directory and
<code>~/.sbt/boot/</code> may be read-only, this can fail. In this case, the user
has generally intentionally set sbt up this way, so error recovery is
not typically necessary (just a short error message explaining the
situation.)
</p><h4 id="Example+of+dynamic+classpath+augmentation">Example of dynamic classpath augmentation<a href="#Example+of+dynamic+classpath+augmentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following code can be used where a <code>State =&gt; State</code> is required,
such as in the <code>onLoad</code> setting (described below) or in a
<a href="Commands.html">command</a>. It adds some files to the “extra”
component and reloads sbt if they were not already added. Note that
reloading will drop the user’s session state.
</p><pre><code class="prettyprint lang-scala">def augment(extra: Seq[File])(s: State): State = {
    // Get the component provider
  val cs: xsbti.ComponentProvider = s.configuration.provider.components()

    // Adds the files in 'extra' to the &quot;extra&quot; component
    //   under an exclusive machine-wide lock.
    //   The returned value is 'true' if files were actually copied and 'false'
    //   if the target files already exists (based on name only).
  val copied: Boolean = s.locked(cs.lockFile, cs.addToComponent(&quot;extra&quot;, extra.toArray))

    // If files were copied, reload so that we use the new classpath.
  if(copied) s.reload else s
}
</code></pre><h4 id="How+can+I+take+action+when+the+project+is+loaded+or+unloaded%3F">How can I take action when the project is loaded or unloaded?<a href="#How+can+I+take+action+when+the+project+is+loaded+or+unloaded%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Howto-Startup.html">How to take an action on startup</a>.
</p><h4 id="Example+of+project+load%2Funload+hooks">Example of project load/unload hooks<a href="#Example+of+project+load%2Funload+hooks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following example maintains a count of the number of times a project
has been loaded and prints that number:
</p><pre><code class="prettyprint lang-scala">{
  // the key for the current count
  val key = AttributeKey[Int](&quot;loadCount&quot;)
  // the State transformer
  val f = (s: State) =&gt; {
    val previous = s get key getOrElse 0
    println(&quot;Project load count: &quot; + previous)
    s.put(key, previous + 1)
  }
  Global / onLoad := {
    val previous = (Global / onLoad).value
    f compose previous
  }
}
</code></pre><h3 id="Errors">Errors<a href="#Errors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="On+project+load%2C+%E2%80%9CReference+to+uninitialized+setting%E2%80%9C">On project load, “Reference to uninitialized setting“<a href="#On+project+load%2C+%E2%80%9CReference+to+uninitialized+setting%E2%80%9C" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Setting initializers are executed in order. If the initialization of a
setting depends on other settings that has not been initialized, sbt
will stop loading.
</p><p>In this example, we try to append a library to <code>libraryDependencies</code>
before it is initialized with an empty sequence.
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.4&quot; % &quot;test&quot;

disablePlugins(plugins.IvyPlugin)
</code></pre><p>To correct this, include the IvyPlugin plugin settings, which includes
<code>libraryDependencies := Seq()</code>. So, we just drop the explicit disabling.
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.4&quot; % &quot;test&quot;
</code></pre><p>A more subtle variation of this error occurs when using
<a href="Scopes.html">scoped settings</a>.
</p><pre><code class="prettyprint lang-scala">// error: Reference to uninitialized setting
settings = Seq(
  libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.2&quot; % &quot;test&quot;,
  fullClasspath := fullClasspath.value.filterNot(_.data.name.contains(&quot;commons-io&quot;))
)
</code></pre><p>This setting varies between the test and compile scopes. The solution is
use the scoped setting, both as the input to the initializer, and the
setting that we update.
</p><pre><code class="prettyprint lang-scala">Compile / fullClasspath := (Compile / fullClasspath).value.filterNot(_.data.name.contains(&quot;commons-io&quot;))
</code></pre><h3 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+do+I+resolve+a+checksum+error%3F">How do I resolve a checksum error?<a href="#How+do+I+resolve+a+checksum+error%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This error occurs when the published checksum, such as a sha1 or md5
hash, differs from the checksum computed for a downloaded artifact, such
as a jar or pom.xml. An example of such an error is:
</p><pre><code class="">[warn]  problem while downloading module descriptor:
https://repo1.maven.org/maven2/commons-fileupload/commons-fileupload/1.2.2/commons-fileupload-1.2.2.pom:
invalid sha1: expected=ad3fda4adc95eb0d061341228cc94845ddb9a6fe computed=0ce5d4a03b07c8b00ab60252e5cacdc708a4e6d8 (1070ms)
</code></pre><p>The invalid checksum should generally be reported to the repository
owner (as
<a href="https://issues.sonatype.org/browse/MVNCENTRAL-46">was done</a> for the
above error). In the meantime, you can temporarily disable checking with
the following setting:
</p><pre><code class="prettyprint lang-scala">checksums in update := Nil
</code></pre><p>See <a href="Library-Management.html">library management</a> for details.
</p><h4 id="I%E2%80%99ve+added+a+plugin%2C+and+now+my+cross-compilations+fail%21">I’ve added a plugin, and now my cross-compilations fail!<a href="#I%E2%80%99ve+added+a+plugin%2C+and+now+my+cross-compilations+fail%21" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This problem crops up frequently. Plugins are only published for the
Scala version that sbt uses (currently, 2.12). You can still <em>use</em>
plugins during cross-compilation, because sbt only looks for a 2.12
version of the plugin.
</p><p><strong>… unless you specify the plugin in the wrong place!</strong>
</p><p>A typical mistake is to put global plugin definitions in
<code>~/.sbt/plugins.sbt</code>. <strong>THIS IS WRONG.</strong> <code>.sbt</code> files in <code>~/.sbt</code> are
loaded for <em>each</em> build—that is, for <em>each</em> cross-compilation. So, if
you build for Scala 2.11.0, sbt will try to find a version of the plugin
that’s compiled for 2.11.0—and it usually won’t. That’s because it
doesn’t <em>know</em> the dependency is a plugin.
</p><p>To tell sbt that the dependency is an sbt plugin, make sure you define
your global plugins in a <code>.sbt</code> file in <code>~/.sbt/plugins/</code>. sbt knows
that files in <code>~/.sbt/plugins</code> are only to be used by sbt itself, not as
part of the general build definition. If you define your plugins in a
file under <em>that</em> directory, they won’t foul up your cross-compilations.
Any file name ending in <code>.sbt</code> will do, but most people use
<code>~/.sbt/plugins/build.sbt</code> or <code>~/.sbt/plugins/plugins.sbt</code>.
</p><h3 id="Miscellaneous">Miscellaneous<a href="#Miscellaneous" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Where+can+I+find+plugins+for+1.4.7%3F">Where can I find plugins for 1.4.7?<a href="#Where+can+I+find+plugins+for+1.4.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Community-Plugins.html">Community Plugins</a> for a list of currently available
plugins.
</p><h2 id="General+Information">General Information<a href="#General+Information" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has project “meta-information” such as
where to get help, find source code and how to contribute.
</p><h2 id="Credits">Credits<a href="#Credits" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt was originally created by Mark Harrah (<a href="https://github.com/harrah">@harrah</a>) in <a href="http://www.scala-lang.org/old/node/392.html">2008</a>. Most of the fundamental aspects of sbt, such as the Scala incremental compiler, integration with Maven and Ivy dependencies, and parallel task processing were conceived and initially implemented by Mark.
</p><p>By 2010, when sbt 0.7 came out, many open-source Scala projects were using sbt as their build tool.
</p><p>Mark joined Typesafe (now Lightbend) in 2011, the year the company was founded.  sbt 0.10.0 shipped that same year. Mark remained the maintainer and most active contributor until March 2014, with sbt 0.13.1 as his last release.
</p><p>Josh Suereth (<a href="https://github.com/jsuereth">@jsuereth</a>) at Typesafe became the next maintainer of sbt.
</p><p>In 2014, Eugene Yokota (<a href="https://github.com/eed3si9n">@eed3si9n</a>) joined Typesafe to co-lead sbt with Josh. This team carried the 0.13 series through 0.13.5 and started the trajectory to 1.0 as <a href="sbt-0.13-Tech-Previews.html">technology previews</a>. By the time of Josh’s departure in 2015, after sbt 0.13.9, they had shipped <code>AutoPlugin</code>, kept sbt 0.13 in shape, and laid groundwork for sbt server.
</p><p>Grzegorz Kossakowski (<a href="https://github.com/gkossakowski">@gkossakowski</a>) worked on a better incremental compiler algorithm called “name hashing” during his time on the Scala team at Typesafe. Name hashing became the default incremental compiler in sbt 0.13.6 (2014). Lightbend later commissioned Grzegorz to refine name hashing using a technique called class-based name hashing, which was adopted by Zinc 1. Another notable contribution from Grzegorz was hosting a series of <a href="http://blog.japila.pl/2014/07/gkossakowski-on-warszawscala-about-how-to-patch-scalasbt/">meetups</a> with @WarszawScaLa, and (with his arm in a sling<img src="http://blog.japila.pl/2014/07/hacking-scalasbt-with-gkossakowski-on-warszawscala-meetup-in-javeo_eu/" alt="fix"/> the infamous blank-line problem.
</p><p>In May 2015, Dale Wijnand (<a href="https://github.com/dwijnand">@dwijnand</a>) became a committer from the community after contributing features such as <code>inThisBuild</code> and <code>-=</code>.
</p><p>From June 2015 to early 2016, Martin Duhem (<a href="https://github.com/Duhemm">@Duhemm</a>) joined Typesafe as an intern, working on sbt. During this time, Martin worked on crucial components such as making the compiler bridge configurable for Zinc, and code generation for pseudo case classes (which later became Contraband).
</p><p>Around this time, Eugene, Martin, and Dale started the sbt 1.x codebase, splitting the code base into multiple modules: sbt/sbt, Zinc 1, sbt/librarymanagement, sbt/util, and sbt/io. The aim was to make Zinc 1, an incremental compiler usable by all build tools.
</p><p>In August 2016, Dale joined the Tooling team at Lightbend. Dale and Eugene oversaw the releases 0.13.12 through 0.13.16, as well as the development of sbt 1.0.
</p><p>In spring 2017, the Scala Center participated in the Zinc 1 development effort. Jorge Vicente Cantero (<a href="https://github.com/jvican">@jvican</a>) has contributed a number of improvements including the fix for the “as seen from” bug that had blocked Zinc 1.
</p><p>From spring 2018, Ethan Atkins joined the sbt project as a community member, and quickly became the leading contributor to the project. Initially his contribution was implementing Close Watch that uses native code to provide watch service on macOS. He’s worked on various performance related improvements since then including layered ClassLoader, logging rewrite, and native thin client that uses GraalVM native image.
</p><p>According to <code>git shortlog -sn --no-merges</code> on <a href="https://github.com/sbt/sbt/graphs/contributors">sbt/sbt</a>, <a href="https://github.com/sbt/zinc/graphs/contributors">sbt/zinc</a>, <a href="https://github.com/sbt/librarymanagement/graphs/contributors">sbt/librarymanagement</a>, <a href="https://github.com/sbt/util/graphs/contributors">sbt/util</a>, <a href="https://github.com/sbt/io/graphs/contributors">sbt/io</a>, <a href="https://github.com/sbt/contraband/graphs/contributors">sbt/contraband</a>, and <a href="https://github.com/sbt/website/graphs/contributors">sbt/website</a> there were 9151 non-merge commits by 318 contributors.
</p><ul><li>Mark Harrah 3852
</li><li>Eugene Yokota (eed3si9n)  1760
</li><li>Dale Wijnand  524
</li><li>Josh Suereth  357
</li><li>Grzegorz Kossakowski  349
</li><li>Martin Duhem  333
</li><li>Jorge Vicente Cantero (jvican)  314
</li><li>Eugene Vigdorchik 108
</li><li>Kenji Yoshida (xuwei-k) 96
</li><li>Indrajit Raychaudhuri 90
</li><li>Dan Sanduleac 74
</li><li>Benjy Weinberger  52
</li><li>Max Peng  52
</li><li>Jacek Laskowski 40
</li><li>Jason Zaugg 40
</li><li>Josh Soref  39
</li><li>Krzysztof Romanowski  39
</li><li>Pierre DAL-PRA  36
</li><li>Andrzej Jozwik  33
</li><li>Antonio Cunei 30
</li><li>Aaron S. Hawley 29
</li><li>Guillaume Martres 25
</li><li>James Roper 24
</li><li>Chua Chee Seng (cheeseng) 24
</li><li>Paolo G. Giarrusso  23
</li><li>Matej Urbas 22
</li><li>Stu Hood  22
</li><li>Adriaan Moors 18
</li><li>Jean-Rémi Desjardins  16
</li><li>Sanjin Sehic  16
</li><li>Fedor Korotkov  14
</li><li>Andrew Johnson  13
</li><li>David Perez 13
</li><li>Havoc Pennington  13
</li><li>Liang Tang  12
</li><li>Peter Vlugter 12
</li><li>Taro L. Saito 10
</li><li>Paul Phillips 9
</li><li>Roberto Tyley 9
</li><li>Vojin Jovanovic 9
</li><li>William Benton  9
</li><li>杨博 (Yang Bo)  9
</li><li>Brian Topping 8
</li><li>Bruno Bieth 8
</li><li>Johannes Rudolph  8
</li><li>KAWACHI Takashi 8
</li><li>Ken Kaizu (krrrr38) 8
</li><li>Artyom Olshevskiy 7
</li><li>Eugene Platonov 7
</li><li>Matthew Farwell 7
</li><li>Michael Allman  7
</li><li>David Pratt 6
</li><li>Luca Milanesio  6
</li><li>Nepomuk Seiler  6
</li><li>Peiyu Wang  6
</li><li>Simeon H.K. Fitch 6
</li><li>Stephen Samuel  6
</li><li>Thierry Treyer  6
</li><li>James Earl Douglas  5
</li><li>Jean-Remi Desjardins  5
</li><li>Miles Sabin 5
</li><li>Seth Tisue  5
</li><li>qgd 5
</li><li>Anthony Whitford  4
</li><li>Bardur Arantsson  4
</li><li>Ches Martin 4
</li><li>Chris Birchall  4
</li><li>Daniel C. Sobral  4
</li><li>Heikki Vesalainen 4
</li><li>Krzysztof Nirski  4
</li><li>Lloyd Meta  4
</li><li>Michael Schmitz 4
</li><li>Orr Sella 4
</li><li>Philipp Dörfler 4
</li><li>Tim Harper  4
</li><li>Vasya Novikov 4
</li><li>Vincent Munier  4
</li><li>Jürgen Keck (j-keck)  4
</li><li>Richard Summerhayes (rasummer)  4
</li><li>Adam Warski 3
</li><li>Ben McCann  3
</li><li>Enno Runne  3
</li><li>Eric Bowman 3
</li><li>Henrik Engstrom 3
</li><li>Ian Forsey  3
</li><li>James Ward  3
</li><li>Jesse Kinkead 3
</li><li>Justin Pihony 3
</li><li>Kazuhiro Sera 3
</li><li>Krzysztof Borowski  3
</li><li>Lars Hupel  3
</li><li>Leif Wickland 3
</li><li>Lukas Rytz  3
</li><li>Max Worgan  3
</li><li>Oliver Wickham  3
</li><li>Olli Helenius 3
</li><li>Roman Timushev  3
</li><li>Simon Schäfer 3
</li><li>ZhiFeng Hu  3
</li><li>daniel-shuy 3
</li><li>Roland Schatz 3
</li><li>soc 3
</li><li>wpitula 3
</li><li>Alex Dupre  2
</li><li>Alexey Alekhin  2
</li><li>Allan Erskine 2
</li><li>Alois Cochard 2
</li><li>Andreas Flierl  2
</li><li>Anthony 2
</li><li>Antoine Gourlay 2
</li><li>Arnout Engelen  2
</li><li>Ben Hutchison 2
</li><li>Benjamin Darfler  2
</li><li>Brendan W. McAdams  2
</li><li>Brennan Saeta 2
</li><li>Brian McKenna 2
</li><li>Brian Smith 2
</li><li>BrianLondon 2
</li><li>Charles Feduke  2
</li><li>Christian Dedie 2
</li><li>Cody Allen  2
</li><li>Damien Lecan  2
</li><li>David Barri 2
</li><li>David Harcombe  2
</li><li>David Hotham  2
</li><li>Derek Wickern 2
</li><li>Eric D. Reichert  2
</li><li>Eric J. Christeson  2
</li><li>Evgeny Goldin 2
</li><li>Evgeny Vereshchagin 2
</li><li>Francois Armand (fanf42)  2
</li><li>Fred Dubois 2
</li><li>Heejong Lee 2
</li><li>Henri Kerola  2
</li><li>Hideki Ikio 2
</li><li>Ikenna Nwaiwu 2
</li><li>Ismael Juma 2
</li><li>Jakob Odersky 2
</li><li>Jan Berkel  2
</li><li>Jan Niehusmann  2
</li><li>Jarek Sacha 2
</li><li>Jens Halm 2
</li><li>Joachim Hofer 2
</li><li>Joe Barnes  2
</li><li>Johan Andrén  2
</li><li>Jonas Fonseca 2
</li><li>Josh Kalderimis 2
</li><li>Juan Manuel Caicedo Carvajal  2
</li><li>Justin Kaeser 2
</li><li>Konrad Malawski 2
</li><li>Lex Spoon 2
</li><li>Li Haoyi  2
</li><li>Lloyd 2
</li><li>Lukasz Piepiora 2
</li><li>Marcus Lönnberg 2
</li><li>Marko Elezovic  2
</li><li>Michael Parrott 2
</li><li>Mikael Vallerie 2
</li><li>Myyk Seok 2
</li><li>Ngoc Dao  2
</li><li>Nicolas Rémond  2
</li><li>Oscar Vargas Torres 2
</li><li>Paul Draper 2
</li><li>Paulo “JCranky” Siqueira  2
</li><li>Petro Verkhogliad 2
</li><li>Piotr Kukielka  2
</li><li>Robin Green 2
</li><li>Roch Delsalle 2
</li><li>Roman Iakovlev  2
</li><li>Scott Royston 2
</li><li>Simon Hafner  2
</li><li>Sukant Hajra  2
</li><li>Suzanne Hamilton  2
</li><li>Tejas Mandke  2
</li><li>Thomas Koch 2
</li><li>Thomas Lockney  2
</li><li>Tobias Neef 2
</li><li>Tomasz Bartczak 2
</li><li>Travis  2
</li><li>Vitalii Voloshyn  2
</li><li>Wei Chen  2
</li><li>Wojciech Langiewicz 2
</li><li>Xin Ren 2
</li><li>Zava  2
</li><li>amishak 2
</li><li>beolnix 2
</li><li>ddworak 2
</li><li>drdamour  2
</li><li>Eric K Richardson (ekrich)  2
</li><li>fsi206914 2
</li><li>henry 2
</li><li>kaatzee 2
</li><li>kalmanb 2
</li><li>nau 2
</li><li>qvaughan  2
</li><li>sam 2
</li><li>softprops 2
</li><li>tbje  2
</li><li>timt  2
</li><li>Aaron D. Valade 1
</li><li>Alexander Buchholtz 1
</li><li>Alexandr Nikitin  1
</li><li>Alexandre Archambault 1
</li><li>Alexey Levan  1
</li><li>Anatoly Fayngelerin 1
</li><li>Andrea  1
</li><li>Andrew D Bate 1
</li><li>Andrew Miller 1
</li><li>Ashley Mercer 1
</li><li>Bruce Mitchener 1
</li><li>Cause Cheng 1
</li><li>Cause Chung 1
</li><li>Christian Krause  1
</li><li>Christophe Vidal  1
</li><li>Claudio Bley  1
</li><li>Daniel Peebles  1
</li><li>Denis T 1
</li><li>Devis Lucato  1
</li><li>Dmitry Melnichenko  1
</li><li>EECOLOR 1
</li><li>Edward Samson 1
</li><li>Erik Bakker 1
</li><li>Erik Bruchez  1
</li><li>Ethan 1
</li><li>Federico Ragona 1
</li><li>Felix Leipold 1
</li><li>Geoffroy Couprie  1
</li><li>Gerolf Seitz  1
</li><li>Gilad Hoch  1
</li><li>Gregor Heine  1
</li><li>HairyFotr 1
</li><li>Heiko Seeberger 1
</li><li>Holden Karau  1
</li><li>Hussachai Puripunpinyo  1
</li><li>Jacques 1
</li><li>Jakob Grunig  1
</li><li>James Koch  1
</li><li>Jan Polák 1
</li><li>Jan Ziniewicz 1
</li><li>Jisoo Park  1
</li><li>Joonas Javanainen 1
</li><li>Joscha Feth 1
</li><li>Josef Vlach 1
</li><li>Joseph Earl 1
</li><li>João Costa  1
</li><li>Justin Ko 1
</li><li>Kamil Kloch 1
</li><li>Kazuyoshi Kato  1
</li><li>Kevin Scaldeferri 1
</li><li>Knut Petter Meen  1
</li><li>Krzysztof 1
</li><li>Kunihiko Ito  1
</li><li>LMnet 1
</li><li>Luc Bourlier  1
</li><li>Lucas Mogari  1
</li><li>Lutz Huehnken 1
</li><li>Mal Graty 1
</li><li>Marcos Savoury  1
</li><li>Marek Żebrowski 1
</li><li>Markus Siemens  1
</li><li>Martynas Mickevicius  1
</li><li>Martynas Mickevičius  1
</li><li>Michael Bayne 1
</li><li>Michael Ledin 1
</li><li>Nathan Hamblen  1
</li><li>Nyavro  1
</li><li>OlegYch 1
</li><li>Olivier ROLAND  1
</li><li>Pavel Penkov  1
</li><li>Pedro Larroy  1
</li><li>Peter Pan 1
</li><li>Piotr Kukiełka  1
</li><li>Rikard Pavelic  1
</li><li>Robert Jacob  1
</li><li>Rogach  1
</li><li>Sergey Andreev  1
</li><li>Shanbin Wang  1
</li><li>Shane Hender  1
</li><li>Simon Olofsson  1
</li><li>Stefan Zeiger 1
</li><li>Stephen Duncan Jr 1
</li><li>Steve Gury  1
</li><li>Sören Brunk 1
</li><li>Thomas Grainger 1
</li><li>Tim Sheppard  1
</li><li>Todor Todorov 1
</li><li>Toshiyuki Takahashi 1
</li><li>Travis Brown  1
</li><li>Tsubasa Irisawa 1
</li><li>Victor Hiairrassary 1
</li><li>Yasuo Nakanishi 1
</li><li>Yoshitaka Fujii 1
</li><li>adinath 1
</li><li>albuch  1
</li><li>cchantep  1
</li><li>cdietze 1
</li><li>choucri 1
</li><li>hokada  1
</li><li>joiskov 1
</li><li>jozic 1
</li><li>jyane 1
</li><li>k.bigwheel  1
</li><li>kavedaa 1
</li><li>mmcbride  1
</li><li>pishen tsai 1
</li><li>sanjiv sahayam  1
</li><li>saturday06  1
</li><li>seroperson  1
</li><li>slideon 1
</li><li>thricejamie 1
</li><li>todesking 1
</li><li>totem3  1
</li><li>upescatore  1
</li><li>valydia 1
</li><li>walidbenchikha  1
</li><li>Wiesław Popielarski 1
</li><li>Łukasz Indykiewicz  1
</li></ul><p>For the details on individual contributions, see <a href="Changes.html">Changes</a>.
</p><p>The following people contributed ideas, documentation, or code to sbt but are not listed above:
</p><ul><li>Josh Cough
</li><li>Nolan Darilek
</li><li>Viktor Klang
</li><li>David R. MacIver
</li><li>Ross McDonald
</li><li>Andrew O’Malley
</li><li>Jorge Ortiz
</li><li>Mikko Peltonen
</li><li>Ray Racine
</li><li>Stuart Roebuck
</li><li>Harshad RJ
</li><li>Tony Sloane
</li><li>Francisco Treacy
</li><li>Vesa Vilhonen
</li></ul><p>The sbt ecosystem would not be the same without so many awesome plugins. Here are some of the plugins and their contributors:
</p><ul><li><a href="https://playframework.com/">Play Framework</a> by Lightbend (James Roper, Peter Hausel, and many others)
</li><li><a href="https://www.scala-js.org/">Scala.js</a> by Sébastien Doeraene, Tobias Schlatter, et al
</li><li><a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a> by Eugene Yokota (eed3si9n)
</li><li><a href="https://github.com/coursier/coursier">coursier</a> by Alexandre Archambault
</li><li><a href="http://sbt-native-packager.readthedocs.io/en/stable/">sbt Native Packager</a> by Nepomuk Seiler (muuki88) and Josh Suereth
</li><li><a href="https://github.com/jrudolph/sbt-dependency-graph">sbt-dependency-graph</a> by Johannes Rudolph
</li><li><a href="http://www.wartremover.org/">WartRemover</a> by Claire Neveu and Brian McKenna
</li><li><a href="https://github.com/scala-android/sbt-android">sbt-android</a> by Perry (pfn)
</li><li><a href="https://github.com/spray/sbt-revolver">sbt-revolver</a> by Johannes Rudolph and Mathias (sirthias)
</li><li><a href="https://github.com/marcuslonnberg/sbt-docker">sbt-docker</a> by Marcus Lönnberg
</li><li><a href="https://github.com/tpolecat/tut">tut</a> by Rob Norris (tpolecat)
</li><li><a href="https://github.com/sbt/sbt-release">sbt-release</a> by Gerolf Seitz
</li><li><a href="https://github.com/ktoso/sbt-jmh">sbt-jmh</a> by Konrad Malawski (ktoso)
</li><li><a href="https://github.com/rtimush/sbt-updates">sbt-updates</a> by Roman Timushev
</li><li><a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a> by James Earl Douglas and Artyom Olshevskiy
</li><li><a href="https://github.com/scoverage/sbt-scoverage">sbt-scoverage</a> by Stephen Samuel and Mikko Koponen
</li><li><a href="https://github.com/sbt/sbt-web">sbt-web</a> by Lightbend (Christopher Hunt, Peter Vlugter, et al)
</li><li><a href="https://github.com/sbt/sbt-buildinfo">sbt-buildinfo</a> by Eugene Yokota (eed3si9n)
</li><li><a href="https://github.com/xerial/sbt-pack">sbt-pack</a> by Taro L. Saito (xerial)
</li><li><a href="https://github.com/sbt/sbt-onejar">sbt-onejar</a> by Jason Zaugg (retronym)
</li><li><a href="https://github.com/sbt/sbt-git">sbt-git</a> by Josh Suereth
</li><li><a href="https://github.com/sbt/sbt-scalariform">sbt-scalariform</a> by Heiko Seeberger, Daniel Trinh, et al
</li><li><a href="http://ensime.org/build_tools/sbt/">ensime-sbt</a> by Sam Halliday (fommil)
</li><li><a href="https://github.com/sbt/sbt-fresh">sbt-fresh</a> by Heiko Seeberger
</li><li><a href="https://github.com/vmunier/sbt-web-scalajs">sbt-web-scalajs</a> by Vincent Munier
</li><li><a href="https://github.com/xerial/sbt-sonatype">sbt-sonatype</a> by Taro L. Saito (xerial)
</li><li><a href="https://github.com/orrsella/sbt-sublime">sbt-sublime</a> by Orr Sella
</li><li><a href="https://github.com/Duhemm/sbt-errors-summary">sbt-errors-summary</a> by Martin Duhem
</li><li><a href="https://github.com/sbt/sbt-bintray">sbt-bintray</a> by Doug Tangren (softprops)
</li><li><a href="https://github.com/lightbend/migration-manager/wiki">Migration Manager</a> by Lightbend (Mirco Dotta, Seth Tisue, et al)
</li><li><a href="https://github.com/sbt/sbt-protobuf">sbt-protobuf</a> by Gerolf Seitz and Kenji Yoshida (xuwei-k)
</li><li><a href="https://github.com/sbt/sbt-site">sbt-site</a> by Jonas Fonseca, Josh Suereth, et al
</li><li><a href="https://github.com/tkawachi/sbt-doctest">sbt-doctest</a> by KAWACHI Takashi
</li><li><a href="https://github.com/roboscala/sbt-robovm">sbt-robovm</a> by Jan Polák
</li><li><a href="https://github.com/scalastyle/scalastyle-sbt-plugin">scalastyle-sbt-plugin</a> by Matthew Farwell
</li><li><a href="https://github.com/47deg/sbt-microsites">sbt-microsites</a> by 47 Degrees (Juan Pedro Moreno, Javier de Silóniz Sandino, et al)
</li><li><a href="https://github.com/sbt/sbt-header">sbt-header</a> by Heiko Seeberger and Benedikt Ritter
</li><li><a href="https://github.com/sbt/sbt-groll">sbt-groll</a> by Heiko Seeberger
</li><li><a href="https://github.com/ceedubs/sbt-ctags">sbt-ctags</a> by Cody Allen
</li><li><a href="https://github.com/gilt/sbt-aws-lambda">sbt-aws-lambda</a> by Gilt (Brendan St John, et al)
</li><li><a href="https://github.com/heroku/sbt-heroku">sbt-heroku</a> by Heroku (Joe Kutner)
</li><li><a href="https://github.com/dwijnand/sbt-dynver">sbt-dynver</a> by Dale Wijnand
</li><li><a href="https://github.com/sbt/sbt-unidoc">sbt-unidoc</a> by Eugene Yokota and Peter Vlugter
</li><li><a href="https://github.com/Tapad/sbt-docker-compose">sbt-docker-compose</a> by Tapad (Kurt Kopchik et al)
</li><li><a href="https://github.com/scoverage/sbt-coveralls">sbt-coveralls</a> by Ian Forsey and Stephen Samuel
</li><li><a href="https://github.com/gatling/gatling-sbt">gatling-sbt</a> by Pierre Dal-Pra
</li><li><a href="https://github.com/sbt/sbt-boilerplate">sbt-boilerplate</a> by Johannes Rudolph
</li><li><a href="https://github.com/frugalmechanic/fm-sbt-s3-resolver">fm-sbt-s3-resolver</a> by Tim Underwood
</li><li><a href="https://github.com/dispalt/sbt-reactjs">sbt-reactjs</a> by Dan Di Spaltro
</li><li><a href="https://github.com/sbt/sbt-scalabuff">sbt-scalabuff</a> by Aloïs Cochard
</li><li><a href="https://github.com/sbt/sbt-pgp">sbt-pgp</a> by Josh Suereth
</li><li><a href="https://github.com/sbt/jacoco4sbt">jacoco4sbt</a> by Joachim Hofer
</li><li><a href="https://github.com/ohnosequences/sbt-s3-resolver">sbt-s3-resolver</a> by Alexey Alekhin (laughedelic)
</li><li><a href="https://github.com/shivawu/sbt-maven-plugin">sbt-maven-plugin</a> by Shiva Wu
</li><li><a href="https://github.com/gilt/sbt-newrelic">sbt-newrelic</a> by Gilt (Gary Coady et al)
</li><li><a href="https://github.com/coursera/naptime">naptime</a> by Coursera (Brennan Saeta, Bryan Kane et al)
</li><li><a href="https://github.com/lucidsoftware/neo-sbt-scalafmt">neo-sbt-scalafmt</a> by Lucid Software (Paul Draper et al)
</li><li><a href="http://coursera.github.io/courier/">Courier</a> by Coursera (Joe Betz et al)
</li><li><a href="https://github.com/jrudolph/sbt-optimizer">sbt-optimizer</a> by Johannes Rudolph
</li><li><a href="https://github.com/sbt/sbt-appengine">sbt-appengine</a> by Eugene Yokota (eed3si9n) and Yasushi Abe
</li><li><a href="https://github.com/sbt/sbt-ghpages">sbt/sbt-ghpages</a> by Josh Suereth
</li><li><a href="https://github.com/pfn/kotlin-plugin">kotlin-plugin</a> by Perry (pfn)
</li><li><a href="https://github.com/sbt/sbt-avro">sbt-avro</a> by Juan Manuel Caicedo Carvajal (cavorite), Ben McCann, et al
</li><li><a href="https://github.com/sbt/sbt-aspectj">sbt-aspectj</a> by Lightbend (Peter Vlugter et al)
</li><li><a href="https://github.com/scala-native/sbt-crossproject">sbt-crossproject</a> Denys Shabalin and Guillaume Massé
</li><li><a href="https://github.com/sksamuel/sbt-scapegoat">sbt-scapegoat</a> by Stephen Samuel
</li><li><a href="https://github.com/gilt/sbt-dependency-graph-sugar">sbt-dependency-graph-sugar</a> by Gilt (Brendan St John et al)
</li><li><a href="https://github.com/arktekk/sbt-aether-deploy">sbt-aether-deploy</a> by Arktekk (Erlend Hamnaberg et al)
</li><li><a href="https://github.com/saurfang/sbt-spark-submit">sbt-spark-submit</a> by Forest Fang
</li><li><a href="https://github.com/sbt/sbt-proguard">sbt-proguard</a> by Lightbend (Peter Vlugter et al)
</li><li><a href="https://github.com/jenkinsci/sbt-plugin">Jenkins CI sbt plugin</a> by Uzi Landsmann
</li><li><a href="https://github.com/dscleaver/sbt-quickfix">sbt-quickfix</a> by Dave Cleaver
</li><li><a href="https://github.com/softprops/sbt-growl-plugin">sbt-growl-plugin</a> Doug Tangren (softprops)
</li><li><a href="https://github.com/albuch/sbt-dependency-check">sbt-dependency-check</a> by Alexander v. Buchholtz
</li><li><a href="https://github.com/JetBrains/sbt-structure">sbt-structure</a> by JetBrains (Justin Kaeser et al)
</li><li><a href="https://github.com/ArpNetworking/sbt-typescript">sbt-typescript</a> by Brandon Arp
</li><li><a href="https://github.com/bytedeco/sbt-javacv">sbt-javacv</a> by Bytedeco (Lloyd Chan et al)
</li><li><a href="https://github.com/orrsella/sbt-stats">sbt-stats</a> by Orr Sella
</li><li><a href="https://github.com/Verizon/sbt-rig">sbt-rig</a> by Verizon (Timothy Perrett et al)
</li><li><a href="https://github.com/unicredit/sbt-swagger-codegen">sbt-swagger-codegen</a> by UniCredit (Andrea Peruffo, Francesco MDE, et al)
</li><li><a href="https://github.com/sbt/sbt-pom-reader">sbt-pom-reader</a> by Josh Suereth
</li><li><a href="https://github.com/xuwei-k/sbt-class-diagram">sbt-class-diagram</a> by Kenji Yoshida (xuwei-k)
</li></ul><p>Kudos also to people who have answered questions on <a href="https://stackoverflow.com/tags/sbt/topusers">Stack Overflow</a> (Jacek Laskowski, Lukasz Piepiora, et al) and <a href="gitter.im/sbt/sbt">sbt Gitter channel</a>, and many who have reported issues and contributed ideas on GitHub.
</p><p>Thank you all.
</p><h2 id="Community+Plugins">Community Plugins<a href="#Community+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+Organization">sbt Organization<a href="#sbt+Organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <a href="https://github.com/sbt">sbt organization</a> is available for use by
any sbt plugin. Developers who contribute their plugins into the
community organization will still retain control over their repository
and its access. The goal of the sbt organization is to organize sbt
software into one central location.
</p><p>A side benefit to using the sbt organization for projects is that you
can use gh-pages to host websites under the https://www.scala-sbt.org domain.
</p><p>The <a href="https://github.com/sbt/sbt-autoplugin.g8">sbt autoplugin giter8 template</a> 
is a good place to start. This sets up a new sbt plugin project appropriately. 
The generated <code>README</code> includes a summary of the steps for publishing a new 
community plugin.
</p><h3 id="Community+Ivy+Repository">Community Ivy Repository<a href="#Community+Ivy+Repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="https://www.lightbend.com">Lightbend</a> has provided a freely available
<a href="https://repo.scala-sbt.org/scalasbt">Ivy Repository</a> for sbt projects
to use. This Ivy repository is mirrored from the freely available
<a href="https://bintray.com">Bintray service</a>.
If you’d like to submit your plugin, please follow these instructions:
<a href="Bintray-For-Plugins.html">Bintray For Plugins</a>.
</p><h3 id="Cross+building+plugins+from+sbt+0.13">Cross building plugins from sbt 0.13<a href="#Cross+building+plugins+from+sbt+0.13" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="Cross-Build-Plugins.html">Cross Build Plugins</a>.
</p><h3 id="Plugins+available+for+sbt+1.0+%28including+RC-x%29">Plugins available for sbt 1.0 (including RC-x)<a href="#Plugins+available+for+sbt+1.0+%28including+RC-x%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="https://github.com/sbt/website/edit/develop/src/reference/01-General-Info/02-Community-Plugins.md">[Edit]</a> this page to
submit a pull request that adds
your plugin to the list.
</p><h4 id="Code+formatter+plugins">Code formatter plugins<a href="#Code+formatter+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://scalameta.org/scalafmt/">sbt-scalafmt</a>: code formatting using
Scalafmt. <!-- 829 stars -->
</li><li><a href="https://github.com/sbt/sbt-scalariform">sbt-scalariform</a>: code
formatting using Scalariform. <!-- 218 stars -->
</li><li><a href="https://github.com/lucidsoftware/neo-sbt-scalafmt">neo-sbt-scalafmt</a>: code
formatting using Scalafmt. <!-- 80 stars -->
</li><li><a href="https://github.com/sbt/sbt-java-formatter">sbt-java-formatter</a>:
code formatting for Java sources. <!-- 8 stars -->
</li><li><a href="https://github.com/swoval/sbt-source-format">sbt-source-format</a>:
code formatting for Java and clang (c/c++/objc) sources. <!-- 1 stars -->
</li><li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of style rules across your company
</li></ul><h4 id="Documentation+plugins">Documentation plugins<a href="#Documentation+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/tpolecat/tut">tut</a>: documentation and tutorial generator.
<!-- 409  stars -->
</li><li><a href="https://github.com/planet42/Laika">Laika</a>: Transform Markdown or reStructuredText
into HTML or PDF with Templating.
<!-- 161 stars -->
</li><li><a href="https://github.com/sbt/sbt-site">sbt-site</a>: site generator.
<!-- 131 stars -->
</li><li><a href="https://github.com/47deg/sbt-microsites">sbt-microsites</a>: generate
and publish microsites using Jekyll. <!-- 125 stars -->
</li><li><a href="https://github.com/sbt/sbt-unidoc">sbt-unidoc</a>: create unified API
documentation across subprojects. <!-- 86 stars -->
</li><li><a href="https://github.com/sbt/sbt-ghpages">sbt-ghpages</a>: publish generated
sites to GitHub pages. <!-- 71 stars -->
</li><li><a href="https://github.com/xuwei-k/sbt-class-diagram">sbt-class-diagram</a>: generate
class diagrams from Scala source code. <!-- 54 stars -->
</li><li><a href="https://github.com/ThoughtWorksInc/sbt-api-mappings">sbt-api-mappings</a>:
generate Scaladoc <code>apiMappings</code> for common Scala libraries. <!-- 49 stars -->
</li><li><a href="https://github.com/laughedelic/literator">literator</a>:
generate literate-style markdown docs from your sources. <!-- 33 stars -->
</li><li><a href="https://github.com/ThoughtWorksInc/sbt-example">sbt-example</a>:
 generate ScalaTest test suites from examples in Scaladoc. <!-- 17 stars -->
</li><li><a href="https://github.com/ThoughtWorksInc/sbt-delombok">sbt-delombok</a>:
 delombok Java sources files that contain Lombok annotations to make Javadoc contain Lombok-generated classes and methods. <!-- 2 stars -->
</li><li><a href="https://github.com/glngn/sbt-alldocs">sbt-alldocs</a>: collect all the docs for a project and dependencies into a single folder.
</li><li><a href="https://github.com/valydia/sbt-apidoc">sbt-apidoc</a>: A port of <a href="https://apidocjs.com">apidocjs</a> to sbt, to document REST Api. <!-- 1 star -->
</li><li><a href="https://github.com/Kevin-Lee/sbt-github-pages">sbt-github-pages</a>
(<a href="https://kevin-lee.github.io/sbt-github-pages">docs</a>): publish a website to GitHub Pages with minimal effort - works well with GitHub Actions.
</li><li><a href="https://github.com/Kevin-Lee/sbt-docusaur">sbt-docusaur</a>
(<a href="https://kevin-lee.github.io/sbt-docusaur">docs</a>): build a website using Docusaurus and publish to GitHub Pages with minimal effort - works well with GitHub Actions.
</li><li><a href="https://github.com/cchantep/sbt-hl-compiler/">sbt-hl-compiler</a>: compile the code snippets from documentation (to keep it consistent). <!-- 1 star -->
</li><li><a href="https://github.com/cchantep/sbt-scaladoc-compiler/">sbt-scaladoc-compiler</a>: compile the code snippets included in Scaladoc comments. <!-- 2 stars -->
</li></ul><h4 id="One+jar+plugins">One jar plugins<a href="#One+jar+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a>: create fat JARs.
<!-- 1136 stars -->
</li></ul><h4 id="Release+plugins">Release plugins<a href="#Release+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbt-native-packager">sbt-native-packager</a>
(<a href="http://sbt-native-packager.readthedocs.io/en/stable/">docs</a>): build
native packages (RPM, .deb etc) for your projects. <!-- 303 stars -->
</li><li><a href="https://github.com/xerial/sbt-pack">sbt-pack</a>: create runnable distributions
for your projects. <!-- 302 stars -->
</li><li><a href="https://github.com/sbt/sbt-bintray">sbt-bintray</a>: publish artefacts to
Bintray. <!-- 137 stars -->
</li><li><a href="https://github.com/xerial/sbt-sonatype">sbt-sonatype</a>: publish artefacts to
Maven Central. <!-- 148 stars -->
</li><li><a href="https://github.com/sbt/sbt-release">sbt-release</a>: create a customizable
release process. <!-- 113 stars -->
</li><li><a href="https://github.com/sbt/sbt-pgp">sbt-pgp</a>: sign artefacts using PGP/GPG and
manage signing keys. <!-- 79 stars -->
</li><li><a href="https://github.com/marcuslonnberg/sbt-docker">sbt-docker</a>: create and
push Docker images. <!-- 72 stars -->
</li><li><a href="https://github.com/arktekk/sbt-aether-deploy">sbt-aether-deploy</a>: publish
artefacts using Eclipse Aether. <!-- 59 stars -->
</li><li><a href="https://github.com/Verizon/sbt-rig">sbt-rig</a>: opinionated common release
steps. <!-- 50 stars -->
</li><li><a href="https://github.com/sbt/sbt-s3">sbt-s3</a>: manage objects on Amazon S3.
<!-- 36 stars -->
</li><li><a href="https://github.com/sbt/sbt-osgi">sbt-osgi</a>: create OSGi bundles.
<!-- 32 stars -->
</li><li><a href="https://github.com/ohnosequences/sbt-github-release">sbt-github-release</a>: 
publish Github releases. <!-- 22 stars -->
</li><li><a href="https://github.com/Tapad/sbt-hadoop-oss">sbt-hadoop</a>: publish artifacts
to the <a href="https://hadoop.apache.org">Hadoop</a> Distributed File System (HDFS).
<!-- 6 stars -->
</li><li><a href="https://github.com/laughedelic/sbt-publish-more">sbt-publish-more</a>:
publish artifacts to several repositories <!-- 1 star -->
</li><li><a href="https://github.com/amanjpro/sbt-deploy-plugin">sbt-deploy</a>: create
deployable fat JARs. <!-- 1 star -->
</li><li><a href="https://chiselapp.com/user/twenstar/repository/sbt-release-fossil">sbt-release-fossil</a>:
enhances <a href="https://github.com/sbt/sbt-release">sbt-release</a> to support <a href="https://fossil-scm.org">Fossil</a> repositories
</li><li><a href="https://github.com/sbt/sbt-autoversion">sbt-autoversion</a>: automatically set your
next version bump based on patterns of your commit message since last release. <!-- 2 stars -->
</li><li><a href="https://github.com/saint1991/sbt-gcs">sbt-gcs</a>: manage objects on Google Cloud Storage. <!-- 1 star -->
</li><li><a href="https://github.com/kotobotov/sbt-sourcebundler">sbt-sourcebundler</a>: merge all source code into one scala file. <!-- 1 star -->
</li><li><a href="https://github.com/vaslabs/sbt-kubeyml">sbt-kubeyml</a>: Create a typesafe kubernetes Deployment based on your project settings
</li></ul><h4 id="Deployment+integration+plugins">Deployment integration plugins<a href="#Deployment+integration+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/heroku/sbt-heroku">sbt-heroku</a>: deploy applications
directly to Heroku. <!-- 86 stars -->
</li><li><a href="https://github.com/Tapad/sbt-docker-compose">sbt-docker-compose</a>:
launch Docker images using docker compose. <!-- 86 stars -->
</li><li><a href="https://github.com/sbt/sbt-appengine">sbt-appengine</a>
deploy your webapp to Google App Engine. <!-- 65 stars -->
</li><li><a href="https://github.com/Tapad/sbt-marathon">sbt-marathon</a>: deploy applications
on Apache Mesos using the <a href="https://mesosphere.github.io/marathon">Marathon</a>
framework. <!-- 19 stars -->
</li><li><a href="https://github.com/riot-framework/sbt-riotctl">sbt-riotctl</a>: deploy 
applications as systemd services directly to a Raspberry Pi, ensuring 
dependencies (e.g. wiringpi) are met.
</li></ul><h4 id="Utility+and+system+plugins">Utility and system plugins<a href="#Utility+and+system+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/spray/sbt-revolver">sbt-revolver</a>: auto-restart forked
JVMs on update. <!-- 563 stars -->
</li><li><a href="https://github.com/foundweekends/conscript">sbt-conscript</a>
(<a href="http://www.foundweekends.org/conscript/">docs</a>): distribute apps using
GitHub and Maven Central. <!-- 467 stars -->
</li><li><a href="https://github.com/sbt/sbt-git">sbt-git</a>: run git commands from sbt.
<!-- 233 stars -->
</li><li><a href="https://github.com/Duhemm/sbt-errors-summary">sbt-errors-summary</a>: show a
summary of compilation errors. <!-- 145 stars -->
</li><li><a href="https://github.com/lightbend/migration-manager">MiMa</a>: binary
compatibility management for Scala libraries. <!-- 134 stars -->
</li><li><a href="https://github.com/sbt/sbt-groll">sbt-groll</a>: navigate git history inside
sbt. <!-- 100 stars -->
</li><li><a href="https://github.com/dwijnand/sbt-dynver">sbt-dynver</a>: set project version
dynamically from git metadata. <!-- 87 stars -->
</li><li><a href="https://github.com/agemooij/sbt-prompt">sbt-prompt</a>: add promptlets and
themes to your sbt prompt. <!-- 75 stars -->
</li><li><a href="https://github.com/scala-native/sbt-crossproject">sbt-crossproject</a>:
cross-build Scala, Scala.js and Scala Native. <!-- 66 stars -->
</li><li><a href="https://github.com/sbt/sbt-proguard">sbt-proguard</a>: run ProGuard on
compiled sources. <!-- 63 stars -->
</li><li><a href="https://github.com/JetBrains/sbt-structure">sbt-structure</a>: extract project
structure in XML format. <!-- 53 stars -->
</li><li><a href="https://github.com/jodersky/sbt-jni">sbt-jni</a>: helpers for working with
projects that use JNI. <!-- 51 stars -->
</li><li><a href="https://github.com/ktoso/sbt-jol">sbt-jol</a>: inspect OpenJDK Java Object
Layout from sbt. <!-- 48 stars -->
</li><li><a href="https://github.com/tototoshi/sbt-musical">sbt-musical</a>: control iTunes
from sbt (Mac only). <!-- 47 stars -->
</li><li><a href="https://github.com/dwijnand/sbt-travisci">sbt-travisci</a>: integration
with Travis CI. <!-- 33 stars -->
</li><li><a href="https://github.com/romanowski/hoarder">horder</a>: cache compilation
artefacts for future builds. <!-- 31 stars -->
</li><li><a href="https://github.com/sbt/sbt-javaagent">sbt-javaagent</a>: add Java agents to
projects. <!-- 13 stars -->
</li><li><a href="https://github.com/xuwei-k/sbt-jshell">sbt-jshell</a>: Java REPL for sbt.
<!-- 10 stars -->
</li><li><a href="https://github.com/jeffreyolchovy/sbt-check">sbt-check</a>: compile up to,
and including, the typer phase. <!-- 10 stars -->
</li><li><a href="https://github.com/ChristopherDavenport/sbt-mima-version-check">sbt-mima-version-check</a>: Automate which Mima Versions to Check <!-- 6 stars -->
</li><li><a href="https://github.com/cuzfrog/sbt-tmpfs">sbt-tmpfs</a>: utilize tmpfs to speed
up builds. <!-- 4 stars -->
</li><li><a href="https://github.com/melezov/sbt-sh">sbt-sh</a>: run shell commands from sbt.
<!-- 2 stars -->
</li><li><a href="https://github.com/ThoughtWorksInc/sbt-ammonite-classpath">sbt-ammonite-classpath</a>: export classpath for <a href="https://ammonite.io/">Ammonite</a> and <a href="https://almond.sh/">Almond</a>.
<!-- 2 stars -->
</li></ul><h4 id="IDE+integration+plugins">IDE integration plugins<a href="#IDE+integration+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbteclipse">sbteclipse</a>: Eclipse project
definition generator. <!-- 672 stars -->
</li><li><a href="https://github.com/orrsella/sbt-sublime">sbt-sublime</a>: Sublime Text project
generator. <!-- 145 stars -->
</li></ul><h4 id="Test+plugins">Test plugins<a href="#Test+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="Testing-sbt-plugins.html">scripted</a>: integration testing for sbt plugins.
</li><li><a href="https://github.com/ktoso/sbt-jmh">sbt-jmh</a>: run Java Microbenchmark Harness
(JMH) benchmarks from sbt. <!-- 403 stars -->
</li><li><a href="https://github.com/tkawachi/sbt-doctest">sbt-doctest</a>: generate and run
tests from Scaladoc comments. <!-- 120 stars -->
</li><li><a href="https://github.com/gatling/gatling-sbt">gatling-sbt</a>: performance and
load-testing using Gatling. <!-- 79 stars -->
</li><li><a href="https://github.com/sbt/sbt-multi-jvm">sbt-multi-jvm</a>: run tests using
multiple JVMs. <!-- 36 stars -->
</li><li><a href="https://github.com/scalaprops/sbt-scalaprops">sbt-scalaprops</a>: scalaprops
property-based testing integration. <!-- 10 stars -->
</li><li><a href="https://github.com/sbt/sbt-testng">sbt-testng</a>: TestNG framework
integration. <!-- 8 stars -->
</li><li><a href="https://github.com/ktoso/sbt-jcstress">sbt-jcstress</a>: Java Concurrency
Stress Test (jcstress) integration. <!-- 8 stars -->
</li><li><a href="https://github.com/stryker-mutator/stryker4s">sbt-stryker4s</a>: Test your tests with mutation testing. <!-- 40 stars -->
</li><li><a href="https://github.com/OlegYch/sbt-cached-ci">sbt-cached-ci</a>: Incremental sbt builds for CI environments. <!-- 0 stars -->
</li></ul><h4 id="Library+dependency+plugins">Library dependency plugins<a href="#Library+dependency+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/coursier/coursier">coursier</a>: pure Scala dependency
fetcher. <!-- 1021 stars -->
</li><li><a href="https://github.com/jrudolph/sbt-dependency-graph">sbt-dependency-graph</a>:
create dependency graphs using GraphML, graphviz or ASCII. <!-- 821 stars -->
</li><li><a href="https://github.com/rtimush/sbt-updates">sbt-updates</a>: list updated versions
of dependencies. <!-- 361 stars -->
</li><li><a href="https://github.com/frugalmechanic/fm-sbt-s3-resolver">fm-sbt-s3-resolver</a>:
resolve and publish artefacts using Amazon S3. <!-- 79 stars -->
</li><li><a href="https://github.com/ohnosequences/sbt-s3-resolver">sbt-s3-resolver</a>: resolve
dependencies using Amazon S3. <!-- 73 stars -->
</li><li><a href="https://github.com/albuch/sbt-dependency-check">sbt-dependency-check</a>:
check dependencies for known vulnerabilities/CVEs. <!-- 56 stars -->
</li><li><a href="https://github.com/tkawachi/sbt-lock">sbt-lock</a>: create a lock file
containing explicit sbt dependencies. <!-- 33 stars -->
</li><li><a href="https://github.com/sbt/sbt-license-report">sbt-license-report</a>: generate
reports of licenses used by dependencies. <!-- 25 stars -->
</li><li><a href="https://github.com/sbt/sbt-duplicates-finder">sbt-duplicates-finder</a>: detect
class and resources conflicting in your project’s classpath. <!-- 13 stars -->
</li><li><a href="https://github.com/lightbend/sbt-google-cloud-storage">sbt-google-cloud-storage</a>: resolver and publisher for Google Cloud Storage.
</li><li><a href="https://github.com/delprks/sbt-trace">sbt-trace</a>: find traces of the client or library usage in other projects. <!-- 3 stars -->
</li><li><a href="https://github.com/leobenkel/safety_plugin">safety-plugin</a>: Enforce the use of specified versions of dependencies across your company
</li><li><a href="https://stringbean.github.io/sbt-dependency-lock">sbt-dependency-lock</a>:
generate dependency lockfiles and check for changes at build time.
</li></ul><h4 id="Web+and+frontend+development+plugins">Web and frontend development plugins<a href="#Web+and+frontend+development+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://www.playframework.com">Play Framework</a>: reactive web framework for
Scala and Java. <!-- 9727 stars -->
</li><li><a href="https://www.scala-js.org">Scala.js</a>: Scala to JavaScript compiler.
<!-- 3113 stars -->
</li><li><a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a>: Servlet
support. <!-- 379 stars -->
</li><li><a href="https://github.com/sbt/sbt-web">sbt-web</a>: library for building sbt plugins
for the web. <!-- 314 stars -->
</li><li><a href="https://github.com/vmunier/sbt-web-scalajs">sbt-web-scalajs</a>: use Scala.js
with any web server. <!-- 148 stars -->
</li><li><a href="https://github.com/sbt/sbt-less">sbt-less</a>: Less CSS compilation support.
<!-- 34 stars -->
</li><li><a href="https://github.com/sbt/sbt-js-engine">sbt-js-engine</a>: support for sbt
plugins that use JavaScript. <!-- 33 stars -->
</li><li><a href="https://github.com/joost-de-vries/sbt-typescript">sbt-typescript</a>:
TypeScript compilation support. <!-- 25 stars -->
</li><li><a href="https://github.com/sbt/sbt-uglify">sbt-uglify</a>: JavaScript minifier using
UglifyJS. <!-- 22 stars -->
</li><li><a href="https://github.com/andriimartynov/sbt-terser">sbt-terser</a>: JavaScript (ES6+) minifier 
using terser. <!-- 0 stars -->
</li><li><a href="https://github.com/sbt/sbt-digest">sbt-digest</a>: generate checksums of
assets. <!-- 18 stars -->
</li><li><a href="https://github.com/scalatra/sbt-scalatra">sbt-scalatra</a>: build and run
Scalatra apps. <!-- 17 stars -->
</li><li><a href="https://github.com/ThoughtWorksInc/sbt-scala-js-map">sbt-scala-js-map</a>: Configure source mapping for Scala.js projects hosted on Github. <!-- 16 stars -->
</li><li><a href="https://github.com/sbt/sbt-gzip">sbt-gzip</a>: gzip compressor for assets.
<!-- 15 stars -->
</li><li><a href="https://github.com/sbt/sbt-stylus">sbt-stylus</a>: Stylus stylesheet compiler.
<!-- 2 stars -->
</li><li><a href="https://github.com/sake92/sbt-hepek">sbt-hepek</a>: Render static websites directly from Scala code.
<!-- 5 stars -->
</li><li><a href="https://chiselapp.com/user/twenstar/repository/sbt-puresass">sbt-puresass</a>: <a href="https://github.com/sbt/sbt-web">sbt-web</a> plugin for Sass styles compilation.
</li><li><a href="https://github.com/swachter/scala-ts">sbt-scala-ts</a>; generates TypeScript declaration files from ScalaJS sources and outputs Node modules.
</li></ul><h4 id="Database+plugins">Database plugins<a href="#Database+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/scalikejdbc/scalikejdbc">scalikejdbc-mapper-generator</a>:
Scala code generator from database schema. <!-- 802 stars -->
</li><li><a href="https://github.com/localytics/sbt-dynamodb">sbt-dynamodb</a>: run a local
Amazon DynamoDB test instance from sbt. <!-- 41 stars -->
</li><li><a href="https://github.com/LeonhardtDavid/migrations">sbt-migrations</a>: database
migrations manager.
</li></ul><h4 id="Framework-specific+plugins">Framework-specific plugins<a href="#Framework-specific+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/gilt/sbt-newrelic">sbt-newrelic</a>: NewRelic support for
artefacts built with sbt-native-packager. <!-- 73 stars -->
</li><li><a href="https://github.com/alonsodomin/sbt-spark">sbt-spark</a>: Spark application
configurator. <!-- 7 stars -->
</li><li><a href="https://github.com/sirocchj/sbt-api-builder">sbt-api-builder</a>: support for
ApiBuilder from within sbt’s shell. <!-- 1 star -->
</li></ul><h4 id="Code+generator+plugins">Code generator plugins<a href="#Code+generator+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbt-buildinfo">sbt-buildinfo</a>: generate Scala code
from SBT setting keys. <!-- 318 stars -->
</li><li><a href="https://github.com/eed3si9n/scalaxb">sbt-scalaxb</a>: generate model classes
from XML schemas and WSDL. <!-- 243 stars -->
</li><li><a href="https://github.com/sbt/sbt-protobuf">sbt-protobuf</a>: protobuf code generator.
<!-- 132 stars -->
</li><li><a href="https://github.com/sbt/sbt-header">sbt-header</a>: auto-generate source code
file headers (such as copyright notices). <!-- 111 stars -->
</li><li><a href="https://github.com/sbt/sbt-boilerplate">sbt-boilerplate</a>: TupleX and FunctionX
boilerplate code generator. <!-- 78 stars -->
</li><li><a href="https://github.com/cavorite/sbt-avro">sbt-avro</a>: Apache Avro schema
and protocol generator. <!-- 66 stars -->
</li><li><a href="https://github.com/sbt/sbt-aspectj">sbt-aspectj</a>: AspectJ weaving for sbt.
<!-- 62 stars -->
</li><li><a href="https://github.com/thesamet/sbt-protoc">sbt-protoc</a>: protobuf code generator
using protoc. <!-- 35 stars -->
</li><li><a href="https://github.com/sbt/contraband">sbt-contraband</a>
(<a href="https://www.scala-sbt.org/contraband">docs</a>): generate pseudo-case classes
from GraphQL schemas. <!-- 34 stars -->
</li><li><a href="https://github.com/ihji/sbt-antlr4">sbt-antlr4</a>: run ANTLR v4 from sbt.
<!-- 22 stars -->
</li><li><a href="https://github.com/xerial/sbt-sql">sbt-sql</a>: generate model classes from
SQL. <!-- 15 stars -->
</li><li><a href="https://github.com/fiadliel/sbt-partial-unification">sbt-partial-unification</a>:
enable partial unification support in Scala (SI-2712). <!-- 2 stars -->
</li><li><a href="https://github.com/ant8e/sbt-i18n">sbt-i18n</a>:
transform your i18n bundles into Scala code. <!-- 1 stars -->
</li><li><a href="https://github.com/earldouglas/sbt-lit">sbt-lit</a>: build literate code with sbt.
</li><li><a href="https://github.com/yurique/embedded-files">sbt-embedded-files</a>: 
generate Scala objects containing the contents of glob-specified files as strings or byte-arrays. 
</li><li><a href="https://github.com/scala-ts/scala-ts/">sbt-scala-ts</a>:
generate TypeScript code according compiled Scala types (case class, trait, object, …). <!-- 149 stars -->
</li></ul><h4 id="Static+code+analysis+plugins">Static code analysis plugins<a href="#Static+code+analysis+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/wartremover/wartremover">wartremover</a>: flexible Scala
linting tool. <!-- 728 stars -->
</li><li><a href="https://github.com/scalastyle/scalastyle-sbt-plugin">scalastyle-sbt-plugin</a>:
code style checking using Scalastyle. <!-- 114 stars -->
</li><li><a href="https://github.com/sksamuel/sbt-scapegoat">sbt-scapegoat</a>: static analysis
using Scapegoat. <!-- 63 stars -->
</li><li><a href="https://github.com/orrsella/sbt-stats">sbt-stats</a>: generate source code
statistics (lines of code etc). <!-- 53 stars -->
</li><li><a href="https://scalacenter.github.io/scalafix/">sbt-scalafix</a>: refactoring and 
linting tool for Scala using Scalafix. <!-- 24 stars --> 
</li><li><a href="https://github.com/cb372/sbt-explicit-dependencies">sbt-explicit-dependencies</a>:
check that you have declared all your library dependencies correctly <!-- 12 stars -->
</li><li><a href="https://github.com/johanandren/sbt-taglist">sbt-taglist</a>: find tags within
source files (such as TODO and FIXME). <!-- 11 stars -->
</li><li><a href="https://github.com/rtimush/sbt-rewarn">sbt-rewarn</a>: always display compilation warnings,
despite the incremental compilation. <!-- 11 stars -->
</li><li><a href="https://github.com/xerial/sbt-jcheckstyle">sbt-jcheckstyle</a>: Java code
style checking using Checkstyle. <!-- 6 stars -->
</li><li><a href="https://github.com/mwz/sbt-sonar">sbt-sonar</a>: integration with
<a href="https://www.sonarqube.org">SonarQube</a>. <!-- 2 stars -->
</li></ul><h4 id="Code+coverage+plugins">Code coverage plugins<a href="#Code+coverage+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/scoverage/sbt-scoverage">sbt-scoverage</a>: Scala code
coverage using Scoverage. <!-- 347 stars -->
</li><li><a href="https://github.com/sbt/sbt-jacoco">sbt-jacoco</a>: Scala and Java code coverage
using JaCoCo. <!-- 76 stars -->
</li></ul><h4 id="Create+new+project+plugins">Create new project plugins<a href="#Create+new+project+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbt-fresh">sbt-fresh</a>: create an opinionated fresh
sbt project. <!-- 177 stars -->
</li></ul><h4 id="In-house+plugins">In-house plugins<a href="#In-house+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/sbt/sbt-houserules">sbt-houserules</a>: houserules settings
for sbt modules. <!-- 12 stars -->
</li></ul><h4 id="Verification+plugins">Verification plugins<a href="#Verification+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/NiceKingWei/sbt-stainless">sbt-stainless</a>: verify Scala or Dotty code using stainless. <!-- 1 star -->
</li></ul><h4 id="Language+support+plugins">Language support plugins<a href="#Language+support+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="https://github.com/earldouglas/sbt-frege">sbt-frege</a>: build Frege
code with sbt. <!-- 47 stars -->
</li><li><a href="https://github.com/tnakamot/sbt-cc">sbt-cc</a>: compile C and C++ source files with sbt.
</li></ul><h2 id="Community+Repository+Policy">Community Repository Policy<a href="#Community+Repository+Policy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The community repository has the following guideline for artifacts
published to it:
</p><ol><li>All published artifacts are the authors own work or have an
appropriate license which grants distribution rights.
</li><li>All published artifacts come from open source projects, that have an
open patch acceptance policy.
</li><li>All published artifacts are placed under an organization in a DNS
domain for which you have the permission to use or are an owner
(scala-sbt.org is available for sbt plugins).
</li><li>All published artifacts are signed by a committer of the project
(coming soon).
</li></ol><h2 id="Bintray+For+Plugins">Bintray For Plugins<a href="#Bintray+For+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><strong>This is currently in Beta mode.</strong>
</p><p>sbt hosts their community plugin repository on
<a href="https://bintray.com/sbt">Bintray</a>.
Bintray is a repository hosting site, similar to github, which allows users to contribute their own
plugins, while sbt can aggregate them together in a common repository.
</p><p>This document walks you through the means to create your own repository
for hosting your sbt plugins and then linking them into the sbt shared
repository. This will make your plugins available for all sbt users
without additional configuration (besides declaring a dependency on your
plugin).
</p><p>To do this, we need to perform the following steps:
</p><h3 id="Create+an+Open+Source+Distribution+account+on+Bintray">Create an Open Source Distribution account on Bintray<a href="#Create+an+Open+Source+Distribution+account+on+Bintray" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>First, go to <a href="https://bintray.com/signup/oss">https://bintray.com/signup/oss</a> to create an Open Source Distribution Bintray Account.
</p><p>If you end up at the <a href="https://bintray.com">Bintray home page</a>, do NOT click on the Free Trial,
but click on the link that reads <strong>“For Open Source Distribution Sign Up Here“</strong>.
</p><img src="files/bintray-signup.png" style="width: 100%; height: 100%">
<h3 id="Create+a+repository+for+your+sbt+plugins">Create a repository for your sbt plugins<a href="#Create+a+repository+for+your+sbt+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now, we’ll create a repository to host our personal sbt plugins. In
bintray, create a generic repository called <code>sbt-plugins</code>.
</p><p>First, go to your user page and click on the <code>new repository</code> link:
</p><img src="files/bintray-new-repo-link.png" style="width: 100%; height: 100%">
<p>You should see the following dialog:
</p><img src="files/bintray-new-repo-dialog.png" style="width: 100%; height: 100%">
<p>Fill it out similarly to the above image, the settings are:
</p><ul><li>Name:   sbt-plugins
</li><li>Type:   Generic
</li><li>Desc:   My sbt plugins
</li><li>Tags:   sbt
</li></ul><p>Once this is done, you can begin to configure your sbt-plugins to
publish to bintray.
</p><h3 id="Add+the+sbt-bintray+plugin+to+your+build.">Add the sbt-bintray plugin to your build.<a href="#Add+the+sbt-bintray+plugin+to+your+build." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>First, add the sbt-bintray to your plugin build.
</p><p>First, create a <code>project/bintray.sbt</code> file
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.foundweekends&quot; % &quot;sbt-bintray&quot; % &quot;0.5.2&quot;)
</code></pre><p>Next, a make sure your <code>build.sbt</code> file has the following settings
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;&lt;YOUR PLUGIN VERSION HERE&gt;&quot;
ThisBuild / organization := &quot;&lt;INSERT YOUR ORG HERE&gt;&quot;
ThisBuild / description := &quot;&lt;YOUR DESCRIPTION HERE&gt;&quot;

// This is an example.  sbt-bintray requires licenses to be specified
// (using a canonical name).
ThisBuild / licenses += (&quot;Apache-2.0&quot;, url(&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;))

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    sbtPlugin := true,
    name := &quot;&lt;YOUR PLUGIN HERE&gt;&quot;,
    publishMavenStyle := false,
    bintrayRepository := &quot;sbt-plugins&quot;,
    bintrayOrganization in bintray := None
  )
</code></pre><p>Make sure your project has a valid license specified, as well as unique
name and organization.
</p><h3 id="Make+a+release">Make a release<a href="#Make+a+release" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><ul><li>Note: bintray does not support snapshots. We recommend using
<a href="https://github.com/sbt/sbt-git#versioning-with-git">git-revisions supplied by the sbt-git plugin</a>*.
</li></ul></blockquote><p>Once your build is configured, open the sbt console in your build and run
</p><pre><code class="">sbt&gt; publish
</code></pre><p>The plugin will ask you for your credentials. If you don’t know where
they are, you can find them on <a href="https://bintray.com">Bintray</a>.
</p><ol><li>Login to the website with your credentials.
</li><li>Click on your username
</li><li>Click on edit profile
</li><li>Click on API Key
</li></ol><p>This will get you your password. The sbt-bintray plugin will save your
API key for future use.
</p><ul><li>NOTE: We have to do this before we can link our package to the sbt
org.*
</li></ul><h3 id="Linking+your+package+to+the+sbt+organization">Linking your package to the sbt organization<a href="#Linking+your+package+to+the+sbt+organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now that your plugin is packaged on bintray, you can include it in the
community sbt repository. To do so, go to the
<a href="https://bintray.com/sbt/sbt-plugin-releases">Community sbt repository</a>
screen.
</p><ol><li>Click the green <code>include my package</code> button and select your plugin.
<img src="files/bintray-include-my-package.png" style="width: 100%; height: 100%">
</li><li>Search for your plugin by name and click on the link.
<img src="files/bintray-link-plugin-search.png" style="width: 100%; height: 100%">
</li><li>Your request should be automatically filled out, just click send
<img src="files/bintray-include-package-form.png" style="width: 100%; height: 100%">
</li><li>Shortly, one of the sbt repository admins will approve your link
request.
</li></ol><p>From here on, any releases of your plugin will automatically appear in
the community sbt repository. Congratulations and thank you so much for
your contributions!
</p><h3 id="Linking+your+package+to+the+sbt+organization+%28sbt+org+admins%29">Linking your package to the sbt organization (sbt org admins)<a href="#Linking+your+package+to+the+sbt+organization+%28sbt+org+admins%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re a member of the sbt organization on bintray, you can link your
package to the sbt organization, but via a different means. To do so,
first navigate to the plugin you wish to include and click on the link
button:
</p><img src="files/bintray-org-member-link-button.png" style="width: 100%; height: 100%">
<p>After clicking this you should see a link like the following:
</p><img src="files/bintray-org-member-link-dialog.png" style="width: 100%; height: 100%">
<p>Click on the <code>sbt/sbt-plugin-releases</code> repository and you’re done! Any
future releases will be included in the sbt-plugin repository.
</p><h3 id="Publishing+your+plugin+to+a+private+repository">Publishing your plugin to a private repository<a href="#Publishing+your+plugin+to+a+private+repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you choose not provide your plugin to the community and instead publish it to a private repository using the process described above, you will need to add an appropriate resolver to the project that utilizes this plugin so that the project is able to find the plugin. In your build settings under <code>project/plugins.sbt</code> add the following:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.bintrayIvyRepo(&quot;YOUR ORG&quot;, &quot;sbt-plugins&quot;),

addSbtPlugin(&quot;YOUR ORG&quot; % &quot;YOUR PLUGIN&quot; % &quot;YOUR PLUGIN VERSION&quot;)
</code></pre><p>When publishing sbt plugins, Lightbend recommends using the default, Ivy-style repository formatting. This is automatically handled for you when referencing plugins from the community repository, but for private repositories, you need to explicitly add it using <code>Resolver.bintrayIvyRepo</code>…
</p><h3 id="Summary">Summary<a href="#Summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>After setting up the repository, all new releases will automatically be
included the sbt-plugin-releases repository, available for all users.
When you create a new plugin, after the initial release you’ll have to
link it to the sbt community repository, but the rest of the setup
should already be completed. Thanks for you contributions and happy
hacking.
</p><h2 id="Setup+Notes">Setup Notes<a href="#Setup+Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Some notes on how to set up your <code>sbt</code> script.
</p><h3 id="Do+not+put++on+your+classpath.">Do not put <code>sbt-launch.jar</code> on your classpath.<a href="#Do+not+put++on+your+classpath." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Do <em>not</em> put <code>sbt-launch.jar</code> in your <code>$SCALA_HOME/lib</code> directory, your
project’s <code>lib</code> directory, or anywhere it will be put on a classpath. It
isn’t a library.
</p><h3 id="Terminal+encoding">Terminal encoding<a href="#Terminal+encoding" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The character encoding used by your terminal may differ from Java’s
default encoding for your platform. In this case, you will need to add
the option <code>-Dfile.encoding=&lt;encoding&gt;</code> in your <code>sbt</code> script to set the
encoding, which might look like:
</p><pre><code class="">java -Dfile.encoding=UTF8
</code></pre><h3 id="JVM+heap%2C+permgen%2C+and+stack+sizes">JVM heap, permgen, and stack sizes<a href="#JVM+heap%2C+permgen%2C+and+stack+sizes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you find yourself running out of permgen space or your workstation is
low on memory, adjust the JVM configuration as you would for any
application. For example a common set of memory-related options is:
</p><pre><code class="">java -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled
</code></pre><h3 id="Boot+directory">Boot directory<a href="#Boot+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>sbt-launch.jar</code> is just a bootstrap; the actual meat of sbt, and the
Scala compiler and standard library, are downloaded to the shared
directory <code>$HOME/.sbt/boot/</code>.
</p><p>To change the location of this directory, set the <code>sbt.boot.directory</code>
system property in your <code>sbt</code> script. A relative path will be resolved
against the current working directory, which can be useful if you want
to avoid sharing the boot directory between projects. For example, the
following uses the pre-0.11 style of putting the boot directory in
<code>project/boot/</code>:
</p><pre><code class="">java -Dsbt.boot.directory=project/boot/
</code></pre><h3 id="HTTP%2FHTTPS%2FFTP+Proxy">HTTP/HTTPS/FTP Proxy<a href="#HTTP%2FHTTPS%2FFTP+Proxy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On Unix, sbt will pick up any HTTP, HTTPS, or FTP proxy settings from
the standard <code>http_proxy</code>, <code>https_proxy</code>, and <code>ftp_proxy</code> environment
variables. If you are behind a proxy requiring authentication, your
<code>sbt</code> script must also pass flags to set the <code>http.proxyUser</code> and
<code>http.proxyPassword</code> properties for HTTP, <code>ftp.proxyUser</code> and
<code>ftp.proxyPassword</code> properties for FTP, or <code>https.proxyUser</code> and
<code>https.proxyPassword</code> properties for HTTPS.
</p><p>For example,
</p><pre><code class="">java -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre><p>On Windows, your script should set properties for proxy host, port, and
if applicable, username and password. For example, for HTTP:
</p><pre><code class="">java -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre><p>Replace <code>http</code> with <code>https</code> or <code>ftp</code> in the above command line to
configure HTTPS or FTP.
</p><h3 id="Path+encoding">Path encoding<a href="#Path+encoding" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you have files on your system that have non-ascii characters in them on a
posix system, e.g. Linux or macOS, it may be necessary to set the <code>LC_CTYPE</code>
environment variable. If this environment variable is not set to a UTF-8
compatible locale, e.g. <code>LC_TYPE=en_US.UTF-8</code>, then sbt may crash with a
<code>java.nio.file.InvalidPathException</code>. To see a list of available locales, run
<code>locale -a</code>. For more information about locales, see
<a href="https://docs.oracle.com/cd/E19455-01/806-0169/6j9hsml3j/index.html">International Language Environments Guide</a>.
</p><h2 id="Using+Sonatype">Using Sonatype<a href="#Using+Sonatype" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Deploying to sonatype is easy! Just follow these simple steps:
</p><h3 id="Sonatype+setup">Sonatype setup<a href="#Sonatype+setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The reference process for configuring and publishing to Sonatype is 
described in their <a href="http://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a>.
In short, you need two publicly available URLs: 
</p><ul><li>the website of the project e.g. https://github.com/sonatype/nexus-public
</li><li>the project’s source code e.g. https://github.com/sonatype/nexus-public.git
</li></ul><p>The <a href="http://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a> walks you through the required 
process of setting up the account with Sonatype. It’s as simple as 
<a href="https://issues.sonatype.org/secure/Signup!default.jspa">creating a Sonatype's JIRA account</a> and then a 
<a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134">New Project ticket</a>. When creating the account, try to 
use the same domain in your email address that the project is hosted on.
It makes it easier for Sonatype to validate the relationship with the groupId requested in 
the ticket, but it is not the only method used to confirm the ownership. 
</p><p>Creation of the <em>New Project ticket</em> is as simple as:
</p><ul><li>providing the name of the library in the ticket’s subject,
</li><li>naming the groupId for distributing the library (make sure 
it matches the root package of your code). Sonatype provides
additional hints on choosing the right groupId for publishing your library in 
<a href="http://central.sonatype.org/pages/choosing-your-coordinates.html">Choosing your coordinates guide</a>.
</li><li>providing the SCM and Project URLs to the source code and homepage of the 
library.
</li></ul><p>After creating your Sonatype account on JIRA, you can log in 
to the <a href="https://oss.sonatype.org/#welcome">Nexus Repository Manager</a> using the same credentials,
although this is not required in the guide, it can be helpful later to check 
on published artifacts.
</p><blockquote><p><em>Note:</em> Sonatype advises that responding to a <strong>New Project ticket</strong> might 
take up to two business days, but in my case it was a few minutes.
</p></blockquote><h3 id="sbt+setup">sbt setup<a href="#sbt+setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To address Sonatype’s <a href="http://central.sonatype.org/pages/requirements.html">requirements</a> for publishing to the central repository and to simplify the publishing process, you can
use two community plugins. The <a href="https://github.com/sbt/sbt-pgp#sbt-pgp">sbt-pgp plugin</a> can sign the files with GPG/PGP.
(Optionally <a href="https://github.com/xerial/sbt-sonatype">sbt-sonatype</a> can publish to a Sonatype repository nicer.)
</p><h4 id="step+1%3A+PGP+Signatures">step 1: PGP Signatures<a href="#step+1%3A+PGP+Signatures" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Follow <a href="https://central.sonatype.org/pages/working-with-pgp-signatures.html">Working with PGP Signatures</a>.
</p><p>First, you should <a href="https://www.gnupg.org/download/">install GnuPG</a>, and verify the version:
</p><pre><code class="">$ gpg --version
gpg (GnuPG/MacGPG2) 2.2.8
libgcrypt 1.8.3
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;
</code></pre><p>Next generate a key:
</p><pre><code class="">$ gpg --gen-key
</code></pre><p>List the keys:
</p><pre><code class="">$ gpg --list-keys

/home/foo/.gnupg/pubring.gpg
------------------------------

pub   rsa4096 2018-08-22 [SC]
      1234517530FB96F147C6A146A326F592D39AAAAA
uid           [ultimate] your name &lt;you@example.com&gt;
sub   rsa4096 2018-08-22 [E]
</code></pre><p>Distribute the key:
</p><pre><code class="">$ gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 1234517530FB96F147C6A146A326F592D39AAAAA
</code></pre><h4 id="step+2%3A+sbt-pgp">step 2: sbt-pgp<a href="#step+2%3A+sbt-pgp" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>With the PGP key you want to use, you can sign the artifacts 
you want to publish to the Sonatype repository with the <a href="https://github.com/sbt/sbt-pgp#sbt-pgp">sbt-pgp plugin</a>. Follow 
the instructions for the plugin and you’ll have PGP signed artifacts in no 
time.
</p><p>In short, add the following line to your <code>~/.sbt/1.0/plugins/gpg.sbt</code> file to 
enable it globally for SBT projects:
</p><pre><code class="">addSbtPlugin(&quot;com.github.sbt&quot; % &quot;sbt-pgp&quot; % &quot;2.1.2&quot;)
</code></pre><blockquote><p><em>Note:</em> The plugin is a solution to sign artifacts. It works with the GPG command line tool.
</p></blockquote><p>Make sure that the <code>gpg</code> command is in PATH available to the sbt.
</p><h4 id="step+3%3A+Credentials">step 3: Credentials<a href="#step+3%3A+Credentials" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The credentials for your Sonatype OSSRH account need to be stored
somewhere safe (<em>e.g. NOT in the repository</em>). Common convention is a 
<code>$HOME/.sbt/1.0/sonatype.sbt</code> file, with the following:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(Path.userHome / &quot;.sbt&quot; / &quot;sonatype_credentials&quot;)
</code></pre><p>Next create a file <code>~/.sbt/sonatype_credentials</code>:
</p><pre><code class="">realm=Sonatype Nexus Repository Manager
host=oss.sonatype.org
user=&lt;your username&gt;
password=&lt;your password&gt;
</code></pre><blockquote><p><em>Note:</em> The first two strings must be <code>&quot;Sonatype Nexus Repository Manager&quot;</code>
and <code>&quot;oss.sonatype.org&quot;</code> for Coursier to use the credentials.
</p></blockquote><h4 id="step+4%3A+Configure+build.sbt">step 4: Configure build.sbt<a href="#step+4%3A+Configure+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To publish to a maven repository, you’ll need to configure a few
settings so that the correct metadata is generated.
</p><p>Add these settings at the end of <code>build.sbt</code> or a separate <code>publish.sbt</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example.project2&quot;
ThisBuild / organizationName := &quot;example&quot;
ThisBuild / organizationHomepage := Some(url(&quot;http://example.com/&quot;))

ThisBuild / scmInfo := Some(
  ScmInfo(
    url(&quot;https://github.com/your-account/your-project&quot;),
    &quot;scm:git@github.com:your-account/your-project.git&quot;
  )
)
ThisBuild / developers := List(
  Developer(
    id    = &quot;Your identifier&quot;,
    name  = &quot;Your Name&quot;,
    email = &quot;your@email&quot;,
    url   = url(&quot;http://your.url&quot;)
  )
)

ThisBuild / description := &quot;Some description about your project.&quot;
ThisBuild / licenses := List(&quot;Apache 2&quot; -&gt; new URL(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;))
ThisBuild / homepage := Some(url(&quot;https://github.com/example/project&quot;))

// Remove all additional repository other than Maven Central from POM
ThisBuild / pomIncludeRepository := { _ =&gt; false }
ThisBuild / publishTo := {
  val nexus = &quot;https://oss.sonatype.org/&quot;
  if (isSnapshot.value) Some(&quot;snapshots&quot; at nexus + &quot;content/repositories/snapshots&quot;)
  else Some(&quot;releases&quot; at nexus + &quot;service/local/staging/deploy/maven2&quot;)
}
ThisBuild / publishMavenStyle := true
</code></pre><p>The full format of a <code>pom.xml</code> (an end product of the project configuration 
used by Maven) file is <a href="https://maven.apache.org/pom.html">outlined here</a>.
You can add more data to it with the <code>pomExtra</code> option in <code>build.sbt</code>.
</p><h4 id="step+5%3A+Publishing">step 5: Publishing<a href="#step+5%3A+Publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>From sbt shell run:
</p><pre><code class="">&gt; publishSigned
</code></pre><p>Check the published artifacts in the <a href="https://oss.sonatype.org/#welcome">Nexus Repository Manager</a>
(same login as Sonatype’s Jira account).
</p><p>Close the staging repository and promote the release to central, by hitting
“Close” button, then “Release” button.
</p><h3 id="Optional+steps">Optional steps<a href="#Optional+steps" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="sbt-sonatype">sbt-sonatype<a href="#sbt-sonatype" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><blockquote><p><em>Note:</em> sbt-sonatype is a third-party plugin meaning it is not covered by Lightbend subscription.
</p></blockquote><p>To simplify the usage of the Sonatype’s Nexus, add the following line to 
<code>project/plugins.sbt</code> to import the <a href="https://github.com/xerial/sbt-sonatype">sbt-sonatype plugin</a> to your project:
</p><pre><code class="">addSbtPlugin(&quot;org.xerial.sbt&quot; % &quot;sbt-sonatype&quot; % &quot;3.9.5&quot;)
</code></pre><p>This plugin will facilitate the publishing process, but in short, these are 
the main steps for publishing the libraries to the repository:
</p><ol><li>Create a new staging repository: 
<code>sonatypeOpen &quot;your groupId&quot; &quot;Some staging name&quot;</code>
</li><li>Sign and publish the library to the staging repository:
<code>publishSigned</code>
</li><li>You can and should check the published artifacts in the
<a href="https://oss.sonatype.org/#welcome">Nexus Repository Manager</a> (same login as Sonatype’s
Jira account)
</li><li>Close the staging repository and promote the release to central:
<code>sonatypeRelease</code>
</li></ol><p>After publishing you have to follow the
<a href="http://central.sonatype.org/pages/releasing-the-deployment.html">release workflow of Nexus</a>.
</p><blockquote><p><em>Note:</em> the sbt-sonatype plugin can also be used to publish to other non-sonatype 
repositories
</p></blockquote><h4 id="Publishing+tips">Publishing tips<a href="#Publishing+tips" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Use staged releases to test across large projects of independent releases 
before pushing the full project.
</p><blockquote><p><em>Note:</em> An error message of <code>PGPException: checksum mismatch at 0 of 20</code>
indicates that you got the passphrase wrong. We have found at least on
OS X that there may be issues with characters outside the 7-bit ASCII
range (e.g. Umlauts). If you are absolutely sure that you typed the
right phrase and the error doesn’t disappear, try changing the
passphrase.
</p></blockquote><h4 id="Integrate+with+the+release+process">Integrate with the release process<a href="#Integrate+with+the+release+process" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><blockquote><p><em>Note:</em> sbt-release is a third-party plugin meaning it is not covered by Lightbend subscription.
</p></blockquote><p>To automate the publishing approach above with the <a href="https://github.com/sbt/sbt-release">sbt-release plugin</a>, you should simply add the publishing commands as steps in the
<code>releaseProcess</code> task:
</p><pre><code class="">...
releaseStepCommand(&quot;sonatypeOpen \&quot;your groupId\&quot; \&quot;Some staging name\&quot;&quot;),
...
releaseStepCommand(&quot;publishSigned&quot;),
...
releaseStepCommand(&quot;sonatypeRelease&quot;),
...
</code></pre><h2 id="Contributing+to+sbt">Contributing to sbt<a href="#Contributing+to+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Below is a running list of potential areas of contribution. This list
may become out of date quickly, so you may want to check on the
<a href="https://groups.google.com/d/forum/sbt-dev">sbt-dev mailing list</a> if you are interested in a specific topic.
</p><ol><li><p>There are plenty of possible visualization and analysis
opportunities.
</p><ul><li><p>’compile’ produces an Analysis of the source code containing
</p><ul><li>Source dependencies
</li><li>Inter-project source dependencies
</li><li>Binary dependencies (jars + class files)
</li><li>data structure representing the
<a href="https://github.com/sbt/zinc/tree/v1.1.0/internal/compiler-interface">API</a> of the
source code There is some code already for generating dot
files that isn’t hooked up, but graphing dependencies and
inheritance relationships is a general area of work.
</li></ul></li><li>’update’ produces an [Update Report][Update-Report] mapping
Configuration/ModuleID/Artifact to the retrieved File
</li><li>Ivy produces more detailed XML reports on dependencies. These
come with an XSL stylesheet to view them, but this does not
scale to large numbers of dependencies. Working on this is
pretty straightforward: the XML files are created in <code>~/.ivy2</code>
and the <code>.xsl</code> and <code>.css</code> are there as well, so you don’t even need
to work with sbt. Other approaches described in <a href="https://groups.google.com/group/simple-build-tool/browse_thread/thread/7761f8b2ce51f02c/129064ea836c9baf">the email
thread</a>
</li><li>Tasks are a combination of static and dynamic graphs and it
would be useful to view the graph of a run
</li><li>Settings are a static graph and there is code to generate the
dot files, but isn’t hooked up anywhere.
</li></ul></li><li>There is support for dependencies on external projects, like on
GitHub. To be more useful, this should support being able to update
the dependencies. It is also easy to extend this to other ways of
retrieving projects. Support for svn and hg was a recent
contribution, for example.
</li><li>If you like parsers, sbt commands and input tasks are written using
custom parser combinators that provide tab completion and error
handling. Among other things, the efficiency could be improved.
</li><li>The javap task hasn’t been reintegrated
</li><li>Implement enhanced 0.11-style warn/debug/info/error/trace commands.
Currently, you set it like any other setting:
</li></ol><pre><code class="">set logLevel := Level.Warn
</code></pre><blockquote><p>or
:   set Test / logLevel := Level.Warn
</p><p>You could make commands that wrap this, like:
</p></blockquote><pre><code class="">warn Test/run
</code></pre><p>Also, trace is currently an integer, but should really be an abstract
data type.
</p><ol><li>Each sbt version has more aggressive incremental compilation and
reproducing bugs can be difficult. It would be helpful to have a mode
that generates a diff between successive compilations and records the
options passed to scalac. This could be replayed or inspected to try to
find the cause.
</li></ol><h3 id="Documentation">Documentation<a href="#Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>There’s a lot to do with this documentation. If you check it out
from git, there’s a directory called Dormant with some content that
needs going through.
</li><li>the main page mentions external project references (e.g.
to a git repository) but doesn’t have anything to link to that explains
how to use those.
</li><li>API docs are much needed.
</li><li>Find useful answers or types/methods/values in the other docs, and
pull references to them up into /faq or /Name-Index so people can
find the docs. In general the /faq should feel a bit more like a
bunch of pointers into the regular docs, rather than an alternative
to the docs.
</li><li><p>A lot of the pages could probably have better names, and/or little
</p><p>2-4 word blurbs to the right of them in the sidebar.
</p></li></ol><h2 id="Changes">Changes<a href="#Changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>These are changes made in each sbt release.
</p><h2 id="Migrating+from+sbt+0.13.x">Migrating from sbt 0.13.x<a href="#Migrating+from+sbt+0.13.x" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Migrating+case+class">Migrating case class <code>.copy(...)</code><a href="#Migrating+case+class" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Many of the case classes are replaced with pseudo case classes generated using Contraband. Migrate <code>.copy(foo = xxx)</code> to <code>withFoo(xxx)</code>.
Suppose you have <code>m: ModuleID</code>, and you’re currently calling <code>m.copy(revision = &quot;1.0.1&quot;)</code>. Here how you can migrate it:
</p><pre><code class="prettyprint lang-scala">m.withRevision(&quot;1.0.1&quot;)
</code></pre><h3 id="SbtPlugin">SbtPlugin<a href="#SbtPlugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.13, sbt 1.0, and sbt 1.1 required <code>sbtPlugin</code> setting and scripted plugin to develop an sbt plugin.
sbt 1.2.1 combined both into <code>SbtPlugin</code> plugin.
</p><p>Remove scripted-plugin from <code>project/plugins.sbt</code>, and just use:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
</code></pre><h3 id="sbt+version+specific+source+directory">sbt version specific source directory<a href="#sbt+version+specific+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you are cross building an sbt plugin, one escape hatch we have is sbt version specific source directory <code>src/main/scala-sbt-0.13</code> and <code>src/main/scala-sbt-1.0</code>. In there you can define an object named <code>PluginCompat</code> as follows:
</p><pre><code class="prettyprint lang-scala">package sbtfoo

import sbt._
import Keys._

object PluginCompat {
  type UpdateConfiguration = sbt.librarymanagement.UpdateConfiguration

  def subMissingOk(c: UpdateConfiguration, ok: Boolean): UpdateConfiguration =
    c.withMissingOk(ok)
}
</code></pre><p>Now <code>subMissingOk(...)</code> function can be implemented in sbt version specific way.
</p><a name="slash"></a><h3 id="Migrating+to+slash+syntax">Migrating to slash syntax<a href="#Migrating+to+slash+syntax" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt 0.13 keys were scoped with 2 different syntaxes: one for sbt’s shell and one for in code.
</p><ul><li>sbt 0.13 shell: <code>&lt;project-id&gt;/config:intask::key</code>
</li><li>sbt 0.13 code: <code>key in (&lt;project-id&gt;, Config, intask)</code>
</li></ul><p>Starting sbt 1.1.0, the syntax for scoping keys has been unified for both the shell and the build definitions to
the <strong>slash syntax</strong> as follows:
</p><ul><li><code>&lt;project-id&gt; / Config / intask / key</code>
</li></ul><p>Here are some examples:
</p><pre><code class="prettyprint lang-scala">version in ThisBuild := &quot;1.0.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;,
    scalacOptions in Compile += &quot;-Xlint&quot;,
    scalacOptions in (Compile, console) --= Seq(&quot;-Ywarn-unused&quot;, &quot;-Ywarn-unused-import&quot;),
    fork in Test := true
  )
</code></pre><p>They are now written as:
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;1.0.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;,
    Compile / scalacOptions += &quot;-Xlint&quot;,
    Compile / console / scalacOptions --= Seq(&quot;-Ywarn-unused&quot;, &quot;-Ywarn-unused-import&quot;),
    Test / fork := true
  )
</code></pre><p>And now the same syntax in sbt’s shell:
</p><pre><code class="">sbt:hello&gt; name
[info] hello
sbt:hello&gt; ThisBuild / version
[info] 1.0.0-SNAPSHOT
sbt:hello&gt; show Compile / scalacOptions
[info] * -Xlint
sbt:hello&gt; show Compile / console / scalacOptions
[info] * -Xlint
sbt:hello&gt; Test / fork
[info] true
</code></pre><p>There’s a <a href="https://eed3si9n.com/syntactic-scalafix-rule-for-unified-slash-syntax">syntactic Scalafix rule for unified slash syntax</a>
to semi-automatically rewrite existing sbt 0.13 syntax to the slash syntax. Currently it requires the use of scalafix CLI
and it’s not very precise (because it’s a syntactic rule that only looks at the shape of the code) but it gets most of the job done.
</p><pre><code class="">$ scalafix --rules=https://gist.githubusercontent.com/eed3si9n/57e83f5330592d968ce49f0d5030d4d5/raw/7f576f16a90e432baa49911c9a66204c354947bb/Sbt0_13BuildSyntax.scala *.sbt project/*.scala
</code></pre><h3 id="Migrating+from+sbt+0.12+style">Migrating from sbt 0.12 style<a href="#Migrating+from+sbt+0.12+style" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Before sbt 0.13 (sbt 0.9 to 0.12) it was very common to see in builds the usage of three aspects of sbt:
</p><ul><li>the key dependency operators: <code>&lt;&lt;=</code>, <code>&lt;+=</code>, <code>&lt;++=</code>
</li><li>the tuple enrichments (apply and map) for TaskKey’s and SettingKey’s (eg. <code>(foo, bar) map { (f, b) =&gt; ... }</code>)
</li><li>the use of <code>Build</code> trait in <code>project/Build.scala</code>
</li></ul><p>The release of sbt 0.13 (which was over 3 years ago!) introduced the <code>.value</code> DSL which allowed for much
easier to read and write code, effectively making the first two aspects redundant and they were removed from the official
documentation.
</p><p>Similarly, sbt 0.13’s introduction of multi-project <code>build.sbt</code> made the <code>Build</code> trait redundant.
In addition, the auto plugin feature that’s now standard in sbt 0.13 enabled automatic sorting of plugin settings
and auto import feature, but it made <code>Build.scala</code> more difficult to maintain.
</p><p>As they are removed in sbt 1.0.0, and here we’ll help guide you to how to migrate your code.
</p><h4 id="Migrating+sbt+0.12+style+operators">Migrating sbt 0.12 style operators<a href="#Migrating+sbt+0.12+style+operators" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>With simple expressions such as:
</p><pre><code class="prettyprint lang-scala">a &lt;&lt;= aTaskDef
b &lt;+= bTaskDef
c &lt;++= cTaskDefs
</code></pre><p>it is sufficient to replace them with the equivalent:
</p><pre><code class="prettyprint lang-scala">a := aTaskDef.value
b += bTaskDef.value
c ++= cTaskDefs.value
</code></pre><h4 id="Migrating+from+the+tuple+enrichments">Migrating from the tuple enrichments<a href="#Migrating+from+the+tuple+enrichments" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As mentioned above, there are two tuple enrichments <code>.apply</code> and <code>.map</code>. The difference used to be for whether
you’re defining a setting for a <code>SettingKey</code> or a <code>TaskKey</code>, you use <code>.apply</code> for the former and <code>.map</code> for the
latter:
</p><pre><code class="prettyprint lang-scala">val sett1 = settingKey[String](&quot;SettingKey 1&quot;)
val sett2 = settingKey[String](&quot;SettingKey 2&quot;)
val sett3 = settingKey[String](&quot;SettingKey 3&quot;)

val task1 = taskKey[String](&quot;TaskKey 1&quot;)
val task2 = taskKey[String](&quot;TaskKey 2&quot;)
val task3 = taskKey[String](&quot;TaskKey 3&quot;)
val task4 = taskKey[String](&quot;TaskKey 4&quot;)

sett1 := &quot;s1&quot;
sett2 := &quot;s2&quot;
sett3 &lt;&lt;= (sett1, sett2)(_ + _)

task1 := { println(&quot;t1&quot;); &quot;t1&quot; }
task2 := { println(&quot;t2&quot;); &quot;t2&quot; }
task3 &lt;&lt;= (task1, task2) map { (t1, t2) =&gt; println(t1 + t2); t1 + t2 }
task4 &lt;&lt;= (sett1, sett2) map { (s1, s2) =&gt; println(s1 + s2); s1 + s2 }
</code></pre><p>(Remember you can define tasks in terms of settings, but not the other way round)
</p><p>With the <code>.value</code> DSL you don’t have to know or remember if your key is a <code>SettingKey</code> or a <code>TaskKey</code>:
</p><pre><code class="prettyprint lang-scala">sett1 := &quot;s1&quot;
sett2 := &quot;s2&quot;
sett3 := sett1.value + sett2.value

task1 := { println(&quot;t1&quot;); &quot;t1&quot; }
task2 := { println(&quot;t2&quot;); &quot;t2&quot; }
task3 := { println(task1.value + task2.value); task1.value + task2.value }
task4 := { println(sett1.value + sett2.value); sett1.value + sett2.value }
</code></pre><h4 id="Migrating+when+using+%2C++or">Migrating when using <code>.dependsOn</code>, <code>.triggeredBy</code> or <code>.runBefore</code><a href="#Migrating+when+using+%2C++or" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When instead calling <code>.dependsOn</code>, instead of:
</p><pre><code class="prettyprint lang-scala">a &lt;&lt;= a dependsOn b
</code></pre><p>define it as:
</p><pre><code class="prettyprint lang-scala">a := (a dependsOn b).value
</code></pre><p><strong>Note</strong>: You’ll need to use the <code>&lt;&lt;=</code> operator with <code>.triggeredBy</code> and <code>.runBefore</code> in sbt 0.13.13 and
earlier due to issue <a href="https://github.com/sbt/sbt/issues/1444">#1444</a>.
</p><h4 id="Migrating+when+you+need+to+set+s">Migrating when you need to set <code>Task</code>s<a href="#Migrating+when+you+need+to+set+s" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For keys such as <code>sourceGenerators</code> and <code>resourceGenerators</code> which use sbt’s Task type:
</p><pre><code class="prettyprint lang-scala">val sourceGenerators =
  settingKey[Seq[Task[Seq[File]]]](&quot;List of tasks that generate sources&quot;)
val resourceGenerators =
  settingKey[Seq[Task[Seq[File]]]](&quot;List of tasks that generate resources&quot;)
</code></pre><p>Where you previous would define things as:
</p><pre><code class="prettyprint lang-scala">sourceGenerators in Compile &lt;+= buildInfo
</code></pre><p>for sbt 1, you define them as:
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += buildInfo
</code></pre><p>or in general,
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += Def.task { List(file1, file2) }
</code></pre><h4 id="Migrating+with">Migrating with <code>InputKey</code><a href="#Migrating+with" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When using <code>InputKey</code> instead of:
</p><pre><code class="prettyprint lang-scala">run &lt;&lt;= docsRunSetting
</code></pre><p>when migrating you mustn’t use <code>.value</code> but <code>.evaluated</code>:
</p><pre><code class="prettyprint lang-scala">run := docsRunSetting.evaluated
</code></pre><h3 id="Migrating+from+the+Build+trait">Migrating from the Build trait<a href="#Migrating+from+the+Build+trait" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>With <code>Build</code> trait based build such as:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._
import xyz.XyzPlugin.autoImport._

object HelloBuild extends Build {
  val shared = Defaults.defaultSettings ++ xyz.XyzPlugin.projectSettings ++ Seq(
    organization := &quot;com.example&quot;,
    version      := &quot;0.1.0&quot;,
    scalaVersion := &quot;2.12.1&quot;)

  lazy val hello =
    Project(&quot;Hello&quot;, file(&quot;.&quot;),
      settings = shared ++ Seq(
        xyzSkipWrite := true)
    ).aggregate(core)

  lazy val core =
    Project(&quot;hello-core&quot;, file(&quot;core&quot;),
      settings = shared ++ Seq(
        description := &quot;Core interfaces&quot;,
        libraryDependencies ++= scalaXml.value)
    )

  def scalaXml = Def.setting {
    scalaBinaryVersion.value match {
      case &quot;2.10&quot; =&gt; Nil
      case _      =&gt; (&quot;org.scala-lang.modules&quot; %% &quot;scala-xml&quot; % &quot;1.0.6&quot;) :: Nil
    }
  }
}
</code></pre><p>You can migrate to <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">val shared = Seq(
  organization := &quot;com.example&quot;,
  version      := &quot;0.1.0&quot;,
  scalaVersion := &quot;2.12.1&quot;
)

lazy val helloRoot = (project in file(&quot;.&quot;))
  .aggregate(core)
  .enablePlugins(XyzPlugin)
  .settings(
    shared,
    name := &quot;Hello&quot;,
    xyzSkipWrite := true
  )

lazy val core = (project in file(&quot;core&quot;))
  .enablePlugins(XyzPlugin)
  .settings(
    shared,
    name := &quot;hello-core&quot;,
    description := &quot;Core interfaces&quot;,
    libraryDependencies ++= scalaXml.value
  )

def scalaXml = Def.setting {
  scalaBinaryVersion.value match {
    case &quot;2.10&quot; =&gt; Nil
    case _      =&gt; (&quot;org.scala-lang.modules&quot; %% &quot;scala-xml&quot; % &quot;1.0.6&quot;) :: Nil
  }
}
</code></pre><ol><li>Rename <code>project/Build.scala</code> to <code>build.sbt</code>.
</li><li>Remove import statements <code>import sbt._</code>, <code>import Keys._</code>, and any auto imports.
</li><li>Move all of the inner definitions (like <code>shared</code>, <code>helloRoot</code>, etc) out of the <code>object HelloBuild</code>, and remove <code>HelloBuild</code>.
</li><li>Change <code>Project(...)</code> to <code>(project in file(&quot;x&quot;))</code> style, and call its <code>settings(...)</code> method to pass in the settings. This is so the auto plugins can reorder their setting sequence based on the plugin dependencies. <code>name</code> setting should be set to keep the old names.
</li><li>Remove <code>Defaults.defaultSettings</code> out of <code>shared</code> since these settings are already set by the built-in auto plugins, also remove <code>xyz.XyzPlugin.projectSettings</code> out of <code>shared</code> and call <code>enablePlugins(XyzPlugin)</code> instead.
</li></ol><p><strong>Note</strong>: <code>Build</code> traits is deprecated, but you can still use <code>project/*.scala</code> file to organize your build and/or define ad-hoc plugins. See <a href="Organizing-Build.html">Organizing the build</a>.
</p><h3 id="Migrating+from+Resolver.withDefaultResolvers">Migrating from Resolver.withDefaultResolvers<a href="#Migrating+from+Resolver.withDefaultResolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In 0.13.x, you use other repositories instead of the Maven Central repository:
</p><pre><code class="prettyprint lang-scala">externalResolvers := Resolver.withDefaultResolvers(resolvers.value, mavenCentral = false)
</code></pre><p>After 1.x, <code>withDefaultResolvers</code> was renamed to <code>combineDefaultResolvers</code>. In the meantime, one of the parameters, <code>userResolvers</code>, was changed to <code>Vector</code> instead of <code>Seq</code>.
</p><ul><li><p>You can use <code>toVector</code> to help migration.
</p><pre><code class="prettyprint lang-scala">externalResolvers := Resolver.combineDefaultResolvers(resolvers.value.toVector, mavenCentral = false)
</code></pre></li><li>You can use <code>Vector</code> directly too.
</li></ul><h2 id="sbt+1.4.x+releases">sbt 1.4.x releases<a href="#sbt+1.4.x+releases" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+1.4.1">sbt 1.4.1<a href="#sbt+1.4.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixes <code>sbt new</code> not echoing back the characters <a href="https://github.com/sbt/sbt/pull/5954">#5954</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes compiler error reporting in Zinc <a href="https://github.com/sbt/zinc/pull/931">zinc#931</a> by <a href="https://github.com/adpi2">@adpi2</a>
</li><li>Fixes <code>dependencyBrowseTree</code> etc <a href="https://github.com/sbt/sbt/pull/5967">#5967</a> by <a href="https://github.com/naderghanbari">@naderghanbari</a>
</li><li>Fixes Scala 2.13-3.0 sandwich support for Scala.JS <a href="https://github.com/sbt/sbt/pull/5984">#5984</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Work around <code>classes</code> directory causing “classes does not exist” error  <a href="https://github.com/sbt/zinc/pull/934">zinc#934</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Adds logging to <code>ClassfileManager</code> output <a href="https://github.com/sbt/sbt/pull/5990">#5990</a> by <a href="https://github.com/smarter">@smarter</a>
</li><li>Fixes <code>Ctrl-C</code> and <code>Ctrl-D</code> handling <a href="https://github.com/sbt/sbt/pull/5947">#5947</a>/<a href="https://github.com/sbt/sbt/pull/5975">#5975</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes <code>-Dsbt.color=true</code> not working in some situation <a href="https://github.com/sbt/sbt/pull/5960">#5960</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes <code>FileAlreadyExistsException</code> when <code>project/target</code> is a symbolic link <a href="https://github.com/sbt/sbt/pull/5972">#5972</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes ANSI control character appearing in piped output <a href="https://github.com/sbt/sbt/pull/5966">#5966</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes line reading issue with jEdit <a href="https://github.com/sbt/sbt/pull/5946">#5946</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes sbt hanging on invalid <code>build.sbt</code> and <code>--batch</code> <a href="https://github.com/sbt/sbt/pull/5945">#5945</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes <code>.inputrc</code> file support <a href="https://github.com/sbt/sbt/pull/5973">#5973</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Fixes BSP warning diagnostics disappearing on recompilation <a href="https://github.com/sbt/sbt/issues/5950">#5950</a> by <a href="https://github.com/adpi2">@adpi2</a>
</li><li>Fixes BSP support for custom configurations <a href="https://github.com/sbt/sbt/pull/5930">#5930</a> by <a href="https://github.com/adpi2">@adpi2</a>
</li><li>Fixes custom reporter causing <code>MatchError</code> <a href="https://github.com/sbt/sbt/pull/5948">#5948</a> by <a href="https://github.com/adpi2">@adpi2</a>
</li><li>Fixes <code>shellPrompt</code> and <code>release*</code> keys warning on build linting <a href="https://github.com/sbt/sbt/pull/5983">#5983</a>/<a href="https://github.com/sbt/sbt/pull/5991">#5991</a> by <a href="https://github.com/xirc">@xirc</a> and <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes <code>&lt;task&gt;.value</code> macro causing spurious “a pure expression does nothing” warning <a href="https://github.com/sbt/sbt/pull/5981">#5981</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Preserves SemanticDB files in remote cache <a href="https://github.com/sbt/sbt/pull/5961">#5961</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Adds AdoptOpenJDK support for JDK cross building <a href="https://github.com/sbt/sbt/pull/5964">#5964</a> by <a href="https://github.com/rdesgroppes">@rdesgroppes</a>
</li><li>Improves <code>plugins</code> command output by grouping by subproject <a href="https://github.com/sbt/sbt/pull/5932">#5932</a> by <a href="https://github.com/aaabramov">@aaabramov</a>
</li></ul><h3 id="sbt+1.4.0">sbt 1.4.0<a href="#sbt+1.4.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The headline features of sbt 1.4.0 are:
</p><ul><li>build server protocol (BSP) support
</li><li>sbtn: a native thin client for sbt
</li><li>build caching
</li><li><code>ThisBuild / versionScheme</code> to take the guessing out of eviction warning
</li></ul><h3 id="Build+server+protocol+%28BSP%29+support">Build server protocol (BSP) support<a href="#Build+server+protocol+%28BSP%29+support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds build server protocol (BSP) support, contributed by <a href="https://contributors.scala-lang.org/t/build-server-protocol-in-sbt/4234">Scala Center</a>. Main implementation was done by Adrien Piquerez (<a href="https://twitter.com/adrienpi2">@adpi2</a>) based on <a href="https://twitter.com/eed3si9n">@eed3si9n</a>’s prototype.
</p><p>When sbt 1.4.0 starts, it will create a file named <code>.bsp/sbt.json</code> containing a machine-readable instruction on how to run <code>sbt -bsp</code>, which is a command line program that uses standard input and output to communicate to sbt server using build server protocol.
</p><h4 id="How+to+import+to+IntelliJ+using+BSP">How to import to IntelliJ using BSP<a href="#How+to+import+to+IntelliJ+using+BSP" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ol><li>Start sbt in a terminal
</li><li>Open IntelliJ IDEA 2020.1.2 or later
</li><li>Select “Open or import”, and select “BSP Project”
</li></ol><h4 id="How+to+import+to+VS+Code+%2B+Metals">How to import to VS Code + Metals<a href="#How+to+import+to+VS+Code+%2B+Metals" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ol><li>Delete existing <code>.bsp</code>, <code>.metals</code>, <code>.bloop</code> directories if any
</li><li>Open VS Code in the working directory
</li><li>Ignore the prompt to import the project
</li><li>Start <code>sbt -Dsbt.semanticdb=true</code> in the Terminal tab. Wait till it displays “sbt server started”
</li><li>Navigate to Metals view, and select “Restart build server”
</li><li>Type <code>compile</code> into the sbt session to generate SemanticDB files
</li></ol><p><a href="https://github.com/sbt/sbt/pull/5538">#5538</a>/<a href="https://github.com/sbt/sbt/pull/5443">#5443</a> by <a href="https://github.com/adpi2">@adpi2</a>
</p><h3 id="Native+thin+client">Native thin client<a href="#Native+thin+client" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds an official native thin client called <code>sbtn</code> that supports all tasks. If you’re using the official sbt launcher 1.4.0 and not the knockoff kind you can use <code>--client</code> option to run the native thin client:
</p><pre><code class="">$ sbt --client compile
$ sbt --client shutdown
</code></pre><p>The native thin client will run sbt (server) as a daemon, which avoids the JVM spinup and loading time for the second call onwards. This could an option if you would like to use sbt from the system shell such as Zsh and Fish.
</p><p>Remember to call <code>sbt --client shutdown</code> when you’re done! If you want to enable this via an environment variable you can set <code>SBT_NATIVE_CLIENT</code> to <code>true</code>.
<code>sbtn</code> binary files are also available from https://github.com/sbt/sbtn-dist/releases/tag/v1.4.0
</p><p><a href="https://github.com/sbt/sbt/pull/5620">#5620</a> by <a href="https://github.com/eatkins">@eatkins</a>
</p><h3 id="ThisBuild+%2F+versionScheme">ThisBuild / versionScheme<a href="#ThisBuild+%2F+versionScheme" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds a new setting called <code>ThisBuild / versionScheme</code> to track version scheme of the build:
</p><pre><code class="">ThisBuild / versionScheme := Some(&quot;early-semver&quot;)
</code></pre><p>The supported values are <code>&quot;early-semver&quot;</code>, <code>&quot;pvp&quot;</code>, and <code>&quot;semver-spec&quot;</code>. sbt will include this information into <code>pom.xml</code> and <code>ivy.xml</code> as a property. In addition, sbt 1.4.0 will use the information to take the guessing out of eviction warning when this information is available. <a href="https://github.com/sbt/sbt/pull/5724">#5724</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="VirtualFile+%2B+RemoteCache">VirtualFile + RemoteCache<a href="#VirtualFile+%2B+RemoteCache" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 / Zinc 1.4.0 virtualizes the file paths tracked during incremental compilation. The benefit for this that the state of incremental compilation can shared across <em>different</em> machines, as long as <code>ThisBuild / rootPaths</code> are enumerated beforehand.
</p><p>To demonstrate this, we’ve also added <strong>experimental</strong> <a href="http://eed3si9n.com/cached-compilation-for-sbt">cached compilation</a> feature to sbt. All you need is the following setting:
</p><pre><code class="">ThisBuild / pushRemoteCacheTo := Some(MavenCache(&quot;local-cache&quot;, file(&quot;/tmp/remote-cache&quot;)))
</code></pre><p>Then from machine 1, call <code>pushRemoteCache</code>. This will publish the <code>*.class</code> and Zinc Analysis artifacts to the location. Next, from machine 2, call <code>pullRemoteCache</code>.
</p><p><a href="https://github.com/sbt/zinc/pull/712">zinc#712</a>/<a href="https://github.com/sbt/sbt/pull/5417">#5417</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="Build+linting">Build linting<a href="#Build+linting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On start up, sbt 1.4.0 checks for unused settings/tasks. Because most settings are on the intermediary to other settings/tasks, they are included into the linting by default. The notable exceptions are settings used exclusively by a command. To opt-out, you can either append it to <code>Global / excludeLintKeys</code> or set the rank to invisible.
</p><p><a href="https://github.com/sbt/sbt/pull/5153">#5153</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="Conditional+task">Conditional task<a href="#Conditional+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds support for conditional task (or Selective task), which is a new kind of task automatically created when <code>Def.task { ... }</code> consists of an <code>if</code>-expression:
</p><pre><code class="">bar := {
  if (number.value &lt; 0) negAction.value
  else if (number.value == 0) zeroAction.value
  else posAction.value
}
</code></pre><p>Unlike the regular (Applicative) task composition, conditional tasks delays the evaluation of then-clause and else-clause as naturally expected of an <code>if</code>-expression. This is already possible with <code>Def.taskDyn { ... }</code>, but unlike dynamic tasks, conditional task works with <code>inspect</code> command. See <a href="http://eed3si9n.com/selective-functor-in-sbt">Selective functor for sbt</a> for more details. <a href="https://github.com/sbt/sbt/pull/5558">#5558</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="Incremental+build+pipelining">Incremental build pipelining<a href="#Incremental+build+pipelining" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds experimental incremental build pipelining. To enable build pipelining for the build:
</p><pre><code class="">ThisBuild / usePipelining := true
</code></pre><p>To opt-out of creating an early output for some of the subprojects:
</p><pre><code class="">exportPipelining := false
</code></pre><p><a href="https://github.com/sbt/sbt/pull/5703">#5703</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="sbt-dependency-graph+is+in-sourced">sbt-dependency-graph is in-sourced<a href="#sbt-dependency-graph+is+in-sourced" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 brings in Johannes Rudolph’s sbt-dependency-graph plugin into the code base.
Since it injects many tasks per subprojects, the plugin is split into two parts:
- <code>MiniDependencyTreePlugin</code> that is enabled by default, bringing in <code>dependencyTree</code> task to <code>Compile</code> and <code>Test</code> configurations
- Full strength <code>DependencyTreePlugin</code> that is enabled by putting the following to <code>project/plugins.sbt</code>:
</p><pre><code class="">addDependencyTreePlugin
</code></pre><h3 id="Fixes+with+compatibility+implications">Fixes with compatibility implications<a href="#Fixes+with+compatibility+implications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Replaces Apache Log4j with our own logger by default to avoid Appender leakage. Use <code>ThisBuild / useLog4J := true</code> to use Log4j. <a href="https://github.com/sbt/sbt/pull/5731">#5731</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Makes JAR file creation repeatable by sorting entry by name and dropping timestamps <a href="https://github.com/sbt/sbt/pull/5344">#5344</a>/<a href="https://github.com/sbt/io/pull/279">io#279</a> by <a href="https://github.com/raboof">@raboof</a>
</li><li>Loads bare settings in the alphabetic order of the build files <a href="https://github.com/sbt/sbt/issues/2697">#2697</a>/<a href="https://github.com/sbt/sbt/pull/5447">#5447</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Loads <code>val</code>s from top-to-bottom within a build file <a href="https://github.com/sbt/sbt/issues/2232">#2232</a>/<a href="https://github.com/sbt/sbt/pull/5448">#5448</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>HTTP resolvers require explicit opt-in using <code>.withAllowInsecureProtocol(true)</code> <a href="https://github.com/sbt/sbt/pull/5593">#5593</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Ctrl-C during triggered execution <code>~</code> returns to the shell instead of shutting down sbt <a href="https://github.com/sbt/sbt/pull/5804">#5804</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li></ul><h3 id="Other+updates">Other updates<a href="#Other+updates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Updates shell to use JLine 3 for better tab completion <a href="https://github.com/sbt/sbt/pull/5671">#5671</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Adds support for Scala 2.13-3.0 sandwich <a href="https://github.com/sbt/sbt/pull/5767">#5767</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Throws an error if you run sbt from <code>/</code> without <code>-Dsbt.rootdir=true</code> <a href="https://github.com/sbt/sbt/pull/5112">#5112</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Upates <code>StateTransform</code> to accept <code>State =&gt; State</code> <a href="https://github.com/sbt/sbt/pull/5260">#5260</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes various issues around background run <a href="https://github.com/sbt/sbt/pull/5259">#5259</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Turns off supershell when <code>TERM</code> is set to “dumb” <a href="https://github.com/sbt/sbt/pull/5278">#5278</a> by <a href="https://github.com/hvesalai">@hvesalai</a>
</li><li>Avoids using system temporary directories for logging <a href="https://github.com/sbt/sbt/pull/5289">#5289</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Adds library endpoint for <code>sbt.ForkMain</code> <a href="https://github.com/sbt/sbt/pull/5315">#5315</a> by <a href="https://github.com/olafurpg">@olafurpg</a>
</li><li>Avoids using last modified time of directories to invalidate <code>doc</code> <a href="https://github.com/sbt/sbt/pull/5362">#5362</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes the default artifact of packageSrc for custom configuration <a href="https://github.com/sbt/sbt/pull/5403">#5403</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes task cancellation handling <a href="https://github.com/sbt/sbt/pull/5446">#5446</a>/<a href="https://github.com/sbt/zinc/pull/742">zinc#742</a> by <a href="https://github.com/azolotko">@azolotko</a>
</li><li>Adds <code>toTaskable</code> method injection to <code>Initialize[A]</code> for tuple syntax <a href="https://github.com/sbt/sbt/pull/5439">#5439</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes the error message for an undefined setting <a href="https://github.com/sbt/sbt/pull/5469">#5469</a> by <a href="https://github.com/nigredo-tori">@nigredo-tori</a>
</li><li>Updates <code>semanticdbVersion</code> to 4.3.7 <a href="https://github.com/sbt/sbt/pull/5481">#5481</a> by <a href="https://github.com/anilkumarmyla">@anilkumarmyla</a>
</li><li>Adds <code>Tracked.outputChangedW</code> and <code>Tracked.inputChangedW</code> which requires typeclass evidence of <code>JsonWriter[A]</code> instead of <code>JsonFormat[A]</code> <a href="https://github.com/sbt/sbt/pull/5513">#5513</a> by <a href="https://github.com/bjaglin">@bjaglin</a>
</li><li>Fixes various supershell interferences <a href="https://github.com/sbt/sbt/pull/5319">#5319</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Adds <a href="https://github.com/sbt/sbt/blob/develop/main/src/main/scala/sbt/UpperStateOps.scala">extension methods</a> to <code>State</code> to faciliate sbt server communication <a href="https://github.com/sbt/sbt/pull/5207">#5207</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Adds support for weighed tags for <code>testGrouping</code> <a href="https://github.com/sbt/sbt/pull/5527">#5527</a> by <a href="https://github.com/frosforever">@frosforever</a>
</li><li>Updates to sjson-new, which shades Jawn 1.0.0 <a href="https://github.com/sbt/sbt/pull/5595">#5595</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes NullPointerError when credential realm is <code>null</code> <a href="https://github.com/sbt/sbt/pull/5526">#5526</a> by <a href="https://github.com/3rwww1">@3rwww1</a>
</li><li>Adds <code>Def.promise</code> for long-running tasks to communicate to another task <a href="https://github.com/sbt/sbt/pull/5552">#5552</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Uses Java’s timestamp on JDK 10+ as opposed to using native call <a href="https://github.com/sbt/io/pull/274">io#274</a> by <a href="https://github.com/slandelle">@slandelle</a>
</li><li>Adds retry with backoff during publish (<code>-Dsbt.repository.publish.attempts</code> set to 3) <a href="https://github.com/sbt/librarymanagement/pull/340">lm#340</a> by <a href="https://github.com/izharahmd">@izharahmd</a>
</li><li>Improves failure message for PUT <a href="https://github.com/sbt/librarymanagement/pull/309">lm#309</a> by <a href="https://github.com/swaldman">@swaldman</a>
</li><li>Adds provenance to AnalyzedClass <a href="https://github.com/sbt/zinc/pull/786">zinc#786</a> by <a href="https://github.com/dwijnand">@dwijnand</a> + <a href="https://github.com/mspnf">@mspnf</a>
</li><li>Makes hashing childrenOfSealedClass stable <a href="https://github.com/sbt/zinc/pull/788">zinc#788</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes performance regressions around build source monitoring <a href="https://github.com/sbt/sbt/pull/5530">#5530</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes performance regressions around super shell <a href="https://github.com/sbt/sbt/pull/5531">#5531</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Various performance improvements in Zinc <a href="https://github.com/sbt/zinc/pull/756">zinc#756</a>/<a href="https://github.com/sbt/zinc/pull/763">zinc#763</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Adds a monitor to warn about excessive GC <a href="https://github.com/sbt/sbt/pull/5812">#5812</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes forked tests running tests twice when they match multiple fingerprints <a href="https://github.com/sbt/sbt/pull/5800">#5800</a> by <a href="https://github.com/Duhemm">@Duhemm</a>
</li></ul><h3 id="Participation">Participation<a href="#Participation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 was brought to you by 34 contributors. Ethan Atkins, Eugene Yokota (eed3si9n), Johannes Rudolph, Dale Wijnand, Adrien Piquerez, Jason Zaugg, Arnout Engelen, Josh Soref, Guillaume Martres, Maksim Ochenashko, Anil Kumar Myla, Brice Jaglin, Claudio Bley, João Ferreira, Steve Waldman, frosforever, Alex Zolotko, Heikki Vesalainen, Ismael Juma, Stephane Landelle, Jannik Theiß, izharahmd, lloydmeta, Alexandre Archambault, Eric Peters, Erwan Queffelec, Kenji Yoshida (xuwei-k), Martin Duhem, Olafur Pall Geirsson, Renato Cavalcanti, Vincent PERICART, nigredo-tori. Thanks!
</p><h2 id="sbt+1.3.x+releases">sbt 1.3.x releases<a href="#sbt+1.3.x+releases" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+1.3.0">sbt 1.3.0<a href="#sbt+1.3.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is the third feature release of sbt 1.x, a binary compatible release focusing on new features. sbt 1.x is released under <strong>Semantic Versioning</strong>, and the plugins are expected to work throughout the 1.x series.
</p><p>The headline features of sbt 1.3 are out-of-box <a href="https://get-coursier.io/">Coursier</a> library management, ClassLoader layering, IO improvements, and super shell. Combined together we hope these features will improve the user experience of running your builds.
</p><h4 id="Changes+with+compatibility+implication">Changes with compatibility implication<a href="#Changes+with+compatibility+implication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Library management with Coursier. See below for details.
</li><li>Super shell. See below for details.
</li><li>Multi command no longer requires leading semicolon. clean;Test/compile; would work. #4456 by @eatkins
</li><li>Deprecates HTTP resolvers, but allow localhost or resolvers marked <code>.withAllowInsecureProtocol(true)</code> #4997
</li><li>Deprecates <code>CrossVersion.Disabled</code>. Please use <code>CrossVersion.disabled</code> instead sbt/librarymanagement#316
</li><li>ClassLoader management: To prevent resource leaks, sbt 1.3.0 closes the ephemeral ClassLoaders used by the <code>run</code> and <code>test</code> tasks after those tasks complete. This may cause downstream crashes if the task uses ShutdownHooks or if any threads created by the tasks continue running after the task completes. To disable this behavior, either set <code>Compile / run / fork := true</code> or run sbt with <code>-Dsbt.classloader.close=false</code>.
</li></ul><h4 id="Library+management+with+Coursier">Library management with Coursier<a href="#Library+management+with+Coursier" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 adopts <a href="https://get-coursier.io/">Coursier</a> for the library management. Coursier is a dependency resolver like Ivy, rewritten in Scala by Alexandre Archambault (<a href="https://github.com/alexarchambault">@alexarchambault</a>), aiming to be a faster alternative.
</p><p><strong>Note</strong>: Under some situations, Coursier may not resolve the same way as Ivy (for example remote <code>-SNAPSHOT</code>s are cached for 24 hours). If you wish to go back to Apache Ivy for library management, put the following in your <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / useCoursier := false
</code></pre><p>Many people were involved in the effort of bringing Coursier to sbt. Early in 2018 Leonard Ehrenfried (<a href="https://github.com/leonardehrenfried">@leonardehrenfried</a>) started the Coursier-backed LM API implementation as <a href="https://github.com/sbt/librarymanagement/pull/190">lm#190</a>. During the fall, it was further improved by Andrea Peruffo (<a href="https://github.com/andreaTP">@andreaTP</a>), and <code>lm-coursier</code> eventually became part of coursier/sbt-coursier repository maintained by Alex. This spring, Eugene (<a href="https://github.com/eed3si9n">@eed3si9n</a>) revisited this again to make a few more changes so we can swap out the LM engine in <a href="https://github.com/sbt/sbt/pull/4614">#4614</a> with the help from Alex.
</p><h4 id="Turbo+mode+with+ClassLoader+layering">Turbo mode with ClassLoader layering<a href="#Turbo+mode+with+ClassLoader+layering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 adds “turbo” mode that enables experimental or advanced features that might require some debugging by the build user when it doesn’t work.
</p><pre><code class="prettyprint lang-scala">ThisBuild / turbo := true
</code></pre><p>Initially we are putting the layered ClassLoader (<code>ClassLoaderLayeringStrategy.AllLibraryJars</code>) behind this flag.
</p><p>sbt has always created two-layer ClassLoaders when evaluating the <code>run</code> and <code>test</code> tasks. The top layer of the ClassLoader contains the scala library jars so that the classes in the scala package may be reused across multiple task evaluations. The second layer loads the rest of the project classpath including the library dependencies and project class files. sbt 1.3.0 introduces <strong>experimental</strong> <code>classLoaderLayeringStrategy</code> feature that furthers this concept.
</p><pre><code class="prettyprint lang-scala">Compile / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.Flat
// default
Compile / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.ScalaLibrary
// enabled with turbo
Compile / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.AllLibraryJars

Test / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.Flat
// default
Test / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.ScalaLibrary
// enabled with turbo
Test / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.AllLibraryJars
</code></pre><ul><li><code>ClassLoaderLayeringStrategy.Flat</code> includes all classes and JARs except for the Java runtime. The behavior of tasks using this strategy should be similar to forking without the overhead of starting a new jvm.
</li><li><code>ClassLoaderLayeringStrategy.ScalaLibrary</code> creates a two-layer ClassLoader where Scala standard library is kept warm, similar to sbt 1.2.x
</li><li><code>ClassLoaderLayeringStrategy.AllLibraryJars</code> creates a three-layer ClassLoader where library dependencies, in addition to Scala standard libraries are kept warm
</li></ul><p><code>ClassLoaderLayeringStrategy.AllLibraryJars</code> should benefit the response time of run and test tasks. By caching the library jar classloader, the startup latency of the run and test tasks can be reduced significantly when they are run multiple times within the same session. GC pressure is also reduced because libraries jars will not be reloaded every time the task is evaluated.
</p><p><strong>Note</strong>: ClassLoaderLayeringStrategy.AllLibraryJars reuses the singleton object between the tests, which requires libraries to clean after itself.
</p><p><code>ClassLoaderLayeringStrategy.Flat</code> on the other hand will benefit certain applications that do not work well with layered ClassLoaders. One such example is Java serialization + serialization proxy pattern used by Scala collections.
</p><p>ClassLoader layering was contributed by Ethan Atkins (@eatkins) as #4476
</p><h4 id="IO+improvements">IO improvements<a href="#IO+improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to classloader layering, sbt 1.3.0 incorporates numerous performance enhancements including:
</p><ul><li>faster recursive directory listing — sbt internally uses a native library,
<a href="https://github.com/swoval/swoval/blob/master/files/README.md">swoval</a>, that
provides a jni interface to native os apis that allow for faster recursive
directory listing than the implementations in the java standard library.
</li><li>reduced latency of file change detection in continuous builds. In most cases
file events will trigger task evaluation within 10ms.
</li></ul><p>As of this writing sbt 1.3.0’s edit-compile-test loop for 5000 source files is faster than that edit-compile-test with three source files using sbt 0.13, Gradle, and other build tools we tested (see <a href="https://github.com/eatkins/scala-build-watch-performance">build
performance</a> for
details). These changes were contributed by Ethan Atkins (@eatkins).
</p><h4 id="Glob">Glob<a href="#Glob" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 introduces a new type, <code>Glob,</code> that describes a path search query. For example, all of the scala sources in the project directory can be described by <code>Glob(baseDirectory.value, RecursiveGlob / &quot;*.scala&quot;)</code> or <code>baseDirectory.value.toGlob / ** / &quot;*.scala&quot;,</code> where <code>**</code> is an alias for <code>RecursiveGlob</code>. Glob expands on <a href="https://www.scala-sbt.org/1.x/docs/Paths.html#Path+Finders">PathFinders</a> but they can be composed with no io overhead. Globs can be retrieved using a <code>FileTreeView</code>. For example, one can write:
</p><pre><code class="prettyprint lang-scala">val scalaSources = baseDirectory.value.toGlob / ** / &quot;*.scala&quot;
val javaSources = baseDirectory.value.toGlob / ** / &quot;*.java&quot;
val allSources = fileTreeView.value.list(Seq(scalaSources, javaSources))
</code></pre><p>and the <code>FileTreeView</code> will only traverse the base directory once. Globs and FileTreeView were added by Ethan Atkins (<a href="https://github.com/eatkins">@eatkins</a>) in <a href="https://github.com/sbt/io/pull/178">io#178</a>,<a href="https://github.com/sbt/io/pull/216">io#216</a>,<a href="https://github.com/sbt/io/pull/226">io#226</a>
</p><h4 id="Watch+improvements">Watch improvements<a href="#Watch+improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 introduces a new file monitoring implementation. It uses enhanced apis for tracking file change events using os events. It adds a new parser that extracts the specific task(s) for which it will monitor source files and rerun when it detects changes. Only source dependencies of the running tasks are monitored. For example, when running <code>~compile</code>, changes to test source files will not trigger a new build. Between file events, there are also now options to return to the shell, rerun the previous command(s) or exit sbt. These changes were implemented by Ethan Atkins (<a href="https://github.com/eatkins">@eatkins</a>) in <a href="https://github.com/sbt/io/pull/178">io#178</a>,<a href="https://github.com/sbt/io/pull/216">#216</a>,<a href="https://github.com/sbt/io/pull/226">#226</a>,<a href="https://github.com/sbt/sbt/pull/4512">#4512</a>,<a href="https://github.com/sbt/sbt/pull/4627">#4627</a>.
</p><h4 id="Build+definition+source+watch">Build definition source watch<a href="#Build+definition+source+watch" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 automatically watches the build definition sources and displays a warning
if you execute a task without reloading. This can be configured to reload automatically as follows:
</p><pre><code class="prettyprint lang-scala">Global / onChangedBuildSource := ReloadOnSourceChanges
</code></pre><p>This feature was contributed by Ethan Atkins (<a href="https://github.com/eatkins">@eatkins</a>) in <a href="https://github.com/sbt/sbt/pull/4664">#4664</a>
</p><h4 id="Custom+incremental+tasks">Custom incremental tasks<a href="#Custom+incremental+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 provides support to implement custom incremental tasks based on files.
Given a custom task that returns <code>java.nio.file.Path</code>, <code>Seq[java.nio.file.Path]</code>, <code>File</code>, or <code>Seq[File]</code>,
you can define a few helper tasks to make it more incremental.
</p><pre><code class="prettyprint lang-scala">import java.nio.file._
import scala.sys.process._
val gccCompile = taskKey[Seq[Path]](&quot;compile C code using gcc&quot;)
val gccHeaders = taskKey[Seq[Path]](&quot;header files&quot;)
val gccInclude = settingKey[Path](&quot;include directory&quot;)
val gccLink = taskKey[Path](&quot;link C code using gcc&quot;)

gccCompile / sourceDirectory := sourceDirectory.value
gccCompile / fileInputs += (gccCompile / sourceDirectory).value.toGlob / ** / &quot;*.c&quot;
gccInclude := (gccCompile / sourceDirectory).value.toPath / &quot;include&quot;
gccHeaders / fileInputs += gccInclude.value.toGlob / &quot;*.h&quot;
gccCompile / target := baseDirectory.value / &quot;out&quot;

gccCompile := {
  val objectDir = Files.createDirectories((gccCompile / target).value.toPath / &quot;objects&quot;)
  def objectFile(path: Path): Path =
    target.value.toPath / path.getFileName.toString.replaceAll(&quot;.c$&quot;, &quot;.o&quot;)
  Files.createDirectories(target.value.toPath)
  val headerChanges = gccHeaders.inputFileChanges.hasChanges
  val changes = gccCompile.inputFileChanges
  changes.deleted.foreach(sf =&gt; Files.deleteIfExists(objectFile(sf)))
  val sourceFileChanges = changes.created ++ changes.modified
  val needRecompile = (sourceFileChanges ++ (if (headerChanges) changes.unmodified else Nil)).toSet

  val logger = streams.value.log
  gccCompile.inputFiles.map { sf =&gt;
    val of = objectFile(sf)
    if (!Files.exists(of) || needRecompile(sf)) {
      logger.info(s&quot;Compiling $sf&quot;)
      s&quot;gcc -I${gccInclude.value} -c $sf -o $of&quot;.!!
    }
    of
  }
}
</code></pre><p>Given this setup, <code>gccCompile.inputFiles</code> will return a sequence of all of the input <code>c</code> source files, <code>gccCompile.inputFileChanges</code> returns a data structure containing the created, deleted, modified and unmodified files since the last run of <code>gccCompile</code> while <code>gccHeaders.changedInputFiles</code> returns the headers that have changed since the last run of <code>gccCompile</code>. Taken together, these tasks can be used to incrementally only rebuild the source files that need to be rebuilt given the file system changes since the last time gccCompile completed.
</p><p>In another task such as <code>gccLink</code>, the result of <code>gccCompile</code> can be tracked as well using <code>gccCompile.outputFileChanges</code>.
</p><pre><code class="prettyprint lang-scala">gccLink := {
  val library = (gccCompile / target).value.toPath / &quot;libmylib.dylib&quot;
  val objectFiles = gccCompile.outputFiles
  val logger = streams.value.log
  if (!Files.exists(library) || gccCompile.outputFileChanges.hasChanges) {
    logger.info(s&quot;Rebuilding $library&quot;)
    s&quot;gcc -dynamiclib -o $library ${objectFiles mkString &quot; &quot;}&quot;.!!
  }
  library
}
</code></pre><p>The inputs of a task will automatically be monitored by the ~ command which has a new parser that is context aware. A custom clean task is also implemented for any task that generates file outputs. The clean tasks are aggregated across the project and config scopes. For example, Test / clean will clean all of the files generated by tasks in the Test config declared in the Test config but not the files generated in the Compile config.
</p><p>This feature was contributed by Ethan Atkins (@eatkins) in #4627.
</p><h4 id="Super+shell">Super shell<a href="#Super+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When running in an ANSI-compatible terminal, sbt 1.3.0 will display the currently running tasks. This gives the developer the idea of what tasks are being processed in parallel, and where the build is spending its time. In homage to Gradle’s “Rich Console” and Buck’s “Super Console”, we call ours “Super shell.”
</p><p>To opt-out put the following in the build:
</p><pre><code class="prettyprint lang-scala">ThisBuild / useSuperShell := false
</code></pre><p>or run sbt with <code>--supershell=false</code> (or <code>-Dsbt.supershell=false</code>). This feature was added by Eugene Yokota (<a href="https://github.com/eed3si9n">@eed3si9n</a>) as <a href="https://github.com/sbt/sbt/pull/4396">#4396</a>/<a href="https://github.com/sbt/util/pull/196">util#196</a>.
</p><h4 id="Tracing">Tracing<a href="#Tracing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To view the task breakdown visually, run sbt with <code>--traces</code> (or <code>-Dsbt.traces=true</code>). This will generate <code>build.traces</code> file, which is viewable using Chrome Tracing <code>chrome://tracing/</code>. This feature was contributed by Jason Zaugg (<a href="https://github.com/retronym">@retronym</a>).
</p><p>To output the task timings on screen, run sbt with <code>--timings</code> (or <code>-Dsbt.task.timings=true -Dsbt.task.timings.on.shutdown=true</code>).
</p><h4 id="SemanticDB+support">SemanticDB support<a href="#SemanticDB+support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 makes it easier to generate <a href="https://scalameta.org/docs/semanticdb/guide.html">SemanticDB</a>. To enable the generation of SemanticDB build-wide:
</p><pre><code class="">ThisBuild / semanticdbEnabled := true
ThisBuild / semanticdbVersion := &quot;4.1.9&quot;
ThisBuild / semanticdbIncludeInJar := false
</code></pre><p>This was added by <a href="https://github.com/eed3si9n">@eed3si9n</a> as <a href="https://github.com/sbt/sbt/pull/4410">#4410</a>.
</p><h4 id="print+command">print command<a href="#print+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 adds a new <code>print</code> command, similar to <code>show</code> but prints directly to standard out.
</p><pre><code class=""># sbt -no-colors --error  &quot;print akka-cluster/scalaVersion&quot;
2.12.8
</code></pre><p>This was contributed by David Knapp (<a href="https://github.com/Falmarri">@Falmarri</a>) as <a href="https://github.com/sbt/sbt/pull/4341">#4341</a>
</p><h4 id="Appending+Function1">Appending Function1<a href="#Appending+Function1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>Function1</code> can be appended using <code>+=</code>.
</p><pre><code class="">Global / onLoad += { s =&gt;
  doSomething()
  s
}
</code></pre><p>This was contributed by Dale Wijnand (<a href="https://github.com/dwijnand">@dwijnand</a>) as <a href="https://github.com/sbt/sbt/pull/4521">#4521</a>.
</p><h4 id="JDK+11+support">JDK 11 support<a href="#JDK+11+support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.3.0 is first release of sbt that’s been testing on JDK11 extensively.
All integration tests on Travis CI are on AdoptOpenJDK’s JDK 11, which were updated by <a href="https://github.com/eed3si9n">@eed3si9n</a> as <a href="https://github.com/sbt/sbt/pull/4389">#4389</a>/<a href="https://github.com/sbt/zinc/pull/639">zinc#639</a>/[zinc640].
</p><ul><li>Fixes warnings on JDK 9+ by upgrading to protobuf 3.7.0 <a href="https://github.com/sbt/zinc/pull/644">zinc#644</a> by <a href="https://github.com/smarter">@smarter</a>
</li><li>Fixes spurious rebuilds caused by invalidation of <code>rt.jar</code> on JDK 11 <a href="https://github.com/sbt/sbt/pull/4679">#4679</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li></ul><h4 id="Other+bug+fixes+and+improvements">Other bug fixes and improvements<a href="#Other+bug+fixes+and+improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes cross building with a single-letter alias <a href="https://github.com/sbt/sbt/pull/4355">#4355</a> / <a href="https://github.com/sbt/sbt/issues/1074">#1074</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Removes old warning about global directory <a href="https://github.com/sbt/sbt/pull/4356">#4356</a> / <a href="https://github.com/sbt/sbt/issues/1054">#1054</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Improves JDK discovery for cross-JDK forking <a href="https://github.com/sbt/sbt/pull/4313">#4313</a> / <a href="https://github.com/sbt/sbt/pull/4462">#4462</a> by <a href="https://github.com/raboof">@raboof</a>
</li><li>Expands <code>~</code> in <code>-Dsbt.global.base</code> property to user home. <a href="https://github.com/sbt/sbt/pull/4367">#4367</a> by <a href="https://github.com/kai-chi">@kai-chi</a>
</li><li>Adds <code>def sequential[A](tasks: Seq[Initialize[Task[A]]]): Initialize[Task[A]]</code>. <a href="https://github.com/sbt/sbt/pull/4369">#4369</a> by <a href="https://github.com/3tty0n">@3tty0n</a>
</li><li>Fixes sbt server to send error event on command failure. <a href="https://github.com/sbt/sbt/pull/4378">#4378</a> by <a href="https://github.com/andreaTP">@andreaTP</a>
</li><li>Implements cancellation of request by LSP client. <a href="https://github.com/sbt/sbt/pull/4384">#4384</a> by <a href="https://github.com/andreaTP">@andreaTP</a>
</li><li>Implements <code>&quot;sbt/completion&quot;</code> command in sbt to server to complete sbt commands. <a href="https://github.com/sbt/sbt/pull/4397">#4397</a> by <a href="https://github.com/andreaTP">@andreaTP</a>
</li><li>Fixes errors order reported by sbt server. <a href="https://github.com/sbt/sbt/pull/4497">#4497</a> by <a href="https://github.com/tdroxler">@tdroxler</a>
</li><li>Fixes cached resolution. <a href="https://github.com/sbt/sbt/pull/4424">#4424</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>The sbt task definition linter warns rather than errors by default.
The linter can be disabled entirely by putting <code>import sbt.dsl.LinterLevel.Ignore</code> in scope. <a href="https://github.com/sbt/sbt/pull/4485">#4485</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Full GC is only automatically triggered when sbt has been idle for at least a
minute and is only run at most once between shell commands. This improves shell
responsiveness. <a href="https://github.com/sbt/sbt/pull/4544">#4544</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Avoids NPE in JDK12. <a href="https://github.com/sbt/sbt/pull/4549">#4549</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes the eviction warning summary <a href="https://github.com/sbt/librarymanagement/pull/288">lm#288</a> by <a href="https://github.com/bigwheel">@bigwheel</a>
</li><li>Fixes Zinc’s flag to skip the persistence of API info. <a href="https://github.com/sbt/zinc/pull/399">zinc#399</a> by <a href="https://github.com/romanowski">@romanowski</a>
</li><li>Fixes Zinc not detecting synthetic top level member changes. <a href="https://github.com/sbt/sbt/issues/4316">#4316</a>/<a href="https://github.com/sbt/zinc/pull/572">zinc#572</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Zinc to notify callback of generated non-local classes before the compiler’s middle and backend phases. <a href="https://github.com/sbt/zinc/pull/582">zinc#582</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Removes a use of regex in Zinc for performance. <a href="https://github.com/sbt/zinc/pull/583">zinc#583</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes incremental compilation involving default arguments. <a href="https://github.com/sbt/zinc/pull/591">zinc#591</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Adds Analysis callback of Zinc thread-safe. <a href="https://github.com/sbt/zinc/pull/626">zinc#626</a> by <a href="https://github.com/dotta">@dotta</a>
</li><li>Fixes a non-zero exit Javadoc not failing the task. <a href="https://github.com/sbt/zinc/pull/625">zinc#625</a> by <a href="https://github.com/raboof">@raboof</a>
</li></ul><h4 id="Participation">Participation<a href="#Participation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>First, I’d like to introduce Ethan Atkins, a core community member of sbt project, and author of Close Watch that uses native code to provide watch service on macOS. Normally I don’t publicize the number of commits, but here’s the top 10 for sbt 1.3.0:
</p><pre><code class="">541 Ethan Atkins
369 Eugene Yokota (eed3si9n)
42  Jorge Vicente Cantero (jvican)
35  Łukasz Wawrzyk
34  Dale Wijnand
24  Andrea Peruffo
16​​  Kenji Yoshida (xuwei-k)
13  Guillaume Martres
7   Arnout Engelen
7   Jason Zaugg
</code></pre><p>As a community member, Ethan has contributed various IO related improvements to make sbt more responsive in his own time. sbt 1.3.0 reflects many of his ideas.
</p><p>The last feature release of sbt 1 was <a href="https://www.lightbend.com/blog/scala-sbt-120-patchnotes">sbt 1.2.0</a> in July, 2018. Since then, we’ve released eight patch releases under sbt 1.2.x for bug fixes, but most of the feature enhancements were merged to <code>develop</code> branch. Over the course of these months, 45 contributors contributors participated in sbt 1.3.0 and Zinc: Ethan Atkins, Eugene Yokota (eed3si9n), Jorge Vicente Cantero (jvican), Łukasz Wawrzyk, Dale Wijnand, Andrea Peruffo, Kenji Yoshida (xuwei-k), Guillaume Martres, Arnout Engelen, Jason Zaugg, Krzysztof Romanowski, Antonio Cunei, Mirco Dotta, OlegYch, Alex Dupre, Nepomuk Seiler, 0lejk4, Alexandre Archambault, Eric Peters, Kazuhiro Sera, Philippus, Som Snytt, Syed Akber Jafri, Thomas Droxler, Veera Venky, bigwheel, Akhtyam Sakaev, Alexey Vakhrenev, Eugene Platonov, Helena Edelson, Ignasi Marimon-Clos, Julien Sirocchi, Justin Kaeser, Kajetan Maliszewski, Leonard Ehrenfried, Mikołaj Jakubowski, Nafer Sanabria, Stefan Wachter, Yasuhiro Tatsuno, Yusuke Izawa, falmarri, ilya, kai-chi, tanishiking, Ólafur Páll Geirsson. Thank you!
</p><h2 id="sbt+1.2.x+releases">sbt 1.2.x releases<a href="#sbt+1.2.x+releases" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+1.2.1">sbt 1.2.1<a href="#sbt+1.2.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Forward+bincompat+breakage">Forward bincompat breakage<a href="#Forward+bincompat+breakage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you are writing a plugin, please use 1.2.1+, and avoid 1.2.0.
</p><p>We unintentionally broke forward binary compatibility in 1.2.0.
If someone publishes an sbt plugin using sbt 1.2.0, it cannot be used from sbt 1.0.x or 1.1.x.
sbt 1.2.1 reverts the change, so the forward compatibility is restored.
Unfortunately, this means we won’t be able to use varargs in <code>inThisBuild(...)</code> etc again.
</p><p>Note that we might eventually break forward compatibility, like we did in 0.13.5 for <code>AutoPlugin</code>,
but only when the tradeoff is worth it.
</p><h4 id="The+project+Foo+references+an+unknown+configuration+%E2%80%9Cbar%E2%80%9C">The project Foo references an unknown configuration “bar“<a href="#The+project+Foo+references+an+unknown+configuration+%E2%80%9Cbar%E2%80%9C" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Second regression fix is for the wall of warnings you might have seen in 1.2.0 that looks as follows:
</p><pre><code class="">[warn] The project ProjectRef(uri(&quot;file:/Users/xxx/work/akka/&quot;), &quot;akka-actor-typed&quot;) references an unknown configuration &quot;multi-jvm&quot; and was guessed to be &quot;Multi-jvm&quot;.
[warn] This configuration should be explicitly added to the project.
[warn] The project ProjectRef(uri(&quot;file:/Users/xxx/work/akka/&quot;), &quot;akka-actor-typed-tests&quot;) references an unknown configuration &quot;multi-jvm&quot; and was guessed to be &quot;Multi-jvm&quot;.
[warn] This configuration should be explicitly added to the project.
</code></pre><p>The original issue was that unified slash syntax doesn’t pick the configuration names
when the configuration is not part of the subproject. Since this warning is immaterial,
we are removing them in this patch release.
</p><p>One thing the plugin authors can start doing is declaring the custom configuration
as hidden, and adding them into the subprojects as follows:
</p><pre><code class="prettyprint lang-scala">import sbt._
import sbt.Keys._

object ParadoxPlugin extends AutoPlugin {
  val ParadoxTheme = config(&quot;paradox-theme&quot;).hide
  override def projectConfigurations: Seq[Configuration] = Seq(ParadoxTheme)

  ....
}
</code></pre><p>We are also looking into improving unified slash syntax parser to make it more robust.
</p><h4 id="Other+bug+fixes">Other bug fixes<a href="#Other+bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Updates <code>IO.relativize</code> for JDK 9. <a href="https://github.com/sbt/io/pull/175">io#175</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes logic for adding external class file manager. <a href="https://github.com/sbt/zinc/pull/562">zinc#562</a> by <a href="https://github.com/allanrenucci">@allanrenucci</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>sbt 1.2.1 was brought to you by 4 contributors, according to <code>git shortlog -sn --no-merges v1.2.1...v1.2.0</code> on sbt, zinc, librarymanagement, util, io, launcher-package, and website: Eugene Yokota, Aaron S. Hawley, Ethan Atkins, and Allan Renucci. Thanks! Also special thanks to Ches Martin and Yoshida-san for reporting these issues.
</p><hr/><h3 id="sbt+1.2.0">sbt 1.2.0<a href="#sbt+1.2.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><strong>Warning</strong>: We found forward compatibility breakage in 1.2.0, so we recommend everyone to upgrade to <a href="https://github.com/sbt/sbt/releases/tag/v1.2.1">sbt 1.2.1</a> or later.
</p><p>The headline features of sbt 1.2 are cross JDK forking, composite project, and experimental thin clients. But, there are lots of other bug fixes and enhancements that we’ve been accumulating for six months since sbt 1.1.
</p><h4 id="SbtPlugin+for+plugin+development">SbtPlugin for plugin development<a href="#SbtPlugin+for+plugin+development" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>SbtPlugin</code> is a plugin to declare a project for sbt plugins. This automatically brings in scripted tests, and sets <code>sbtPlugin := true</code>.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
</code></pre><p><strong>Compatibility note</strong>: <code>ScriptedPlugin</code> is no longer a triggered plugin.
</p><p><a href="https://github.com/sbt/sbt/pull/3875">#3875</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h4 id="Cross+JDK+forking">Cross JDK forking<a href="#Cross+JDK+forking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For forked <code>run</code> and <code>test</code>, <code>java++</code> can now switch Java Home.
</p><pre><code class="">sbt:helloworld&gt; run
[info] Running (fork) Hello
[info] 1.8.0_171
sbt:helloworld&gt; java++ 10!
[info] Reapplying settings...
sbt:helloworld&gt; run
[info] Running (fork) Hello
[info] 10.0.1
</code></pre><p>sbt will try to detect Java homes into <code>discoveredJavaHomes</code> setting, supporting <a href="https://github.com/shyiko/jabba">shyiko/jabba</a>. This can be augmented by <code>Global / javaHomes</code>:
</p><pre><code class="">Global / javaHomes += &quot;6&quot; -&gt; file(&quot;/something/java-6&quot;)
</code></pre><p>This feature is intended for testing your library in an older JVM to check compatibility.
</p><p><a href="https://github.com/sbt/sbt/pull/4139">#4139</a> by <a href="https://github.com/2m">@2m</a>, <a href="https://github.com/cunei">@cunei</a>, and <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h4 id="scalaVersion-filtered+aggregation">scalaVersion-filtered aggregation<a href="#scalaVersion-filtered+aggregation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In 2015 James Roper <a href="https://github.com/sbt/sbt-doge/pull/4">contributed</a> scalaVersion-filtered aggregation to sbt-doge. This feature is brought back into sbt 1.2 by Rui Gonçalves (<a href="https://github.com/ruippeixotog">@ruippeixotog</a>) in <a href="https://github.com/sbt/sbt/issues/3698">#3698</a>/<a href="https://github.com/sbt/sbt/pull/3995">#3995</a>!
</p><p>This extends switch command <code>++</code> to take an optional <code>&lt;command&gt;</code>:
</p><pre><code class="">&gt; ++2.12.7 compile
</code></pre><p>This will aggregate only the subproject where <code>++2.12.7</code> is valid, which is useful when you have a build where some subprojects are 2.11 only etc.
</p><h4 id="Composite+project">Composite project<a href="#Composite+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.2.0 introduces “composite project” trait, which allows plugin authors to generate subprojects, for example for cross building.
</p><pre><code class="">trait CompositeProject {
  def componentProjects: Seq[Project]
}
</code></pre><p>This was contributed by <a href="https://github.com/BennyHill">@BennyHill</a> as <a href="https://github.com/sbt/sbt/pull/4056">#4056</a>.
</p><h4 id="Project+matrix">Project matrix<a href="#Project+matrix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>Experimental</strong>. As a reference implementation of the <code>CompositeProject</code> I implemented a new DSL called <code>projectMatrix</code> introduced by <a href="https://github.com/sbt/sbt-projectmatrix">sbt-projectmatrix</a> plugin.
</p><pre><code class="prettyprint lang-scala">lazy val core = (projectMatrix in file(&quot;core&quot;))
  .scalaVersions(&quot;2.12.7&quot;, &quot;2.11.12&quot;)
  .settings(
    name := &quot;core&quot;
  )
  .jvmPlatform()

lazy val app = (projectMatrix in file(&quot;app&quot;))
  .dependsOn(core)
  .scalaVersions(&quot;2.12.7&quot;)
  .settings(
    name := &quot;app&quot;
  )
  .jvmPlatform()
</code></pre><p>The aim of the plugin is to support a generic notion of cross building (Scala version, platform, etc) expressed using subprojects. In the above <code>projectMarix</code> will produce three subprojects: <code>coreJVM2_12</code>, <code>coreJVM2_11</code>, and <code>appJVM2_12</code>.
</p><h4 id="Semantic+Version+selector+API">Semantic Version selector API<a href="#Semantic+Version+selector+API" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.2.0 introduces Semantic Version selector on <code>VersionNumber()</code> datatype supporting basic match, comparison (<code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code>), combination (<code>&gt;1.0.0 &lt;2.0.0</code>, <code>||</code>), ranges (<code>A.B.C - D.E.F</code>), and wildcard (<code>2.12.x</code>).
</p><pre><code class="prettyprint lang-scala">scala&gt; import sbt.librarymanagement.{ VersionNumber, SemanticSelector }
import sbt.librarymanagement.{VersionNumber, SemanticSelector}

scala&gt; VersionNumber(&quot;2.12.5&quot;).matchesSemVer(SemanticSelector(&quot;&gt;=2.12&quot;))
res1: Boolean = true

scala&gt; VersionNumber(&quot;2.12.5&quot;).matchesSemVer(SemanticSelector(&quot;&lt;2.12&quot;))
res2: Boolean = false

scala&gt; VersionNumber(&quot;2.13.0-M4&quot;).matchesSemVer(SemanticSelector(&quot;2.13&quot;))
res3: Boolean = false

scala&gt; VersionNumber(&quot;2.12.5&quot;).matchesSemVer(SemanticSelector(&quot;2.12.1 - 2.12.7&quot;))
res4: Boolean = true

scala&gt; VersionNumber(&quot;2.12.5&quot;).matchesSemVer(SemanticSelector(&quot;2.12.x&quot;))
res5: Boolean = true

scala&gt; VersionNumber(&quot;2.12.5&quot;).matchesSemVer(SemanticSelector(&quot;2.11.x || 2.12.x&quot;))
res6: Boolean = true
</code></pre><p><strong>Note</strong>: This has no effect on library management at the moment.
</p><p>This was contributed by Rikito Taniguchi (<a href="https://github.com/tanishiking">@tanishiking</a>) as <a href="https://github.com/sbt/librarymanagement/pull/239">lm#239</a>.
</p><h4 id="addPluginSbtFile+command">addPluginSbtFile command<a href="#addPluginSbtFile+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There’s been a request from IntelliJ to safely inject a plugin to a build. sbt 1.2.0 adds <code>-addPluginSbtFile</code> command to do so.
</p><pre><code class="">$ cat /tmp/extra.sbt
addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.14.7&quot;)

$ sbt -addPluginSbtFile=/tmp/extra.sbt
...
sbt:helloworld&gt; plugins
In file:/xxxx/hellotest/
  ...
  sbtassembly.AssemblyPlugin: enabled in root
</code></pre><p>Implmented by <a href="https://github.com/eed3si9n">@eed3si9n</a> as <a href="https://github.com/sbt/sbt/pull/4211">#4211</a>.
</p><h4 id="Extensible+sbt+server">Extensible sbt server<a href="#Extensible+sbt+server" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>Experimental</strong>. sbt server can now be extended via the plugin.
</p><pre><code class="prettyprint lang-scala">    Global / serverHandlers += ServerHandler({ callback =&gt;
      import callback._
      import sjsonnew.BasicJsonProtocol._
      import sbt.internal.protocol.JsonRpcRequestMessage
      ServerIntent(
        {
          case r: JsonRpcRequestMessage if r.method == &quot;lunar/helo&quot; =&gt;
            jsonRpcNotify(&quot;lunar/oleh&quot;, &quot;&quot;)
            ()
        },
        PartialFunction.empty
      )
</code></pre><p>This feature is still experimental and the API may change in the future.
</p><p><a href="https://github.com/sbt/sbt/pull/3975">#3975</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h4 id="Thin+client%28s%29">Thin client(s)<a href="#Thin+client%28s%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>Experimental</strong>. sbt 1.2.0 adds a new mode called <code>-client</code>. When sbt is started with -client command, it no longer to loads the build, and instead tries to connect to an instance of sbt server over JSON-RPC. When the server is not running (portfile is not found), it will fork a new instance of sbt entirely in a new JVM.
</p><p>This lets you invoke <code>sbt</code> from the terminal shell or from an editor.
</p><pre><code class="">$ time sbt -client clean
[info] entering *experimental* thin client - BEEP WHIRR
[info] server was not detected. starting an instance
[info] waiting for the server...
[info] waiting for the server...
[info] waiting for the server...
[info] waiting for the server...
[info] server found
&gt; clean
[success] completed
sbt -client clean  9.23s user 2.33s system 22% cpu 50.558 total

# server stays
$ ps | rg java
21860 ttys015    1:22.43 java -Xms2048M -Xmx2048M -Xss2M -jar /usr/local/Cellar/sbt/1.1.6/libexec/bin/sbt-launch.jar
22014 ttys015    0:00.00 rg java

$ time sbt -client clean
[info] entering *experimental* thin client - BEEP WHIRR
&gt; clean
[info] Updating ...
[info] Done updating.
[success] completed
sbt -client clean  3.39s user 1.75s system 104% cpu 4.898 total
</code></pre><p>To end the server, call <code>sbt -client shutdown</code>. <a href="https://github.com/sbt/sbt/pull/4227">#4227</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><p>In addition, there are also an alternative thin clients <a href="https://github.com/cb372/sbt-client">cb372/sbt-client</a> and <a href="https://github.com/dwijnand/sbtl">dwijnand/sbtl</a> implemented using Rust.
</p><h4 id="Changes+with+compatibility+implication">Changes with compatibility implication<a href="#Changes+with+compatibility+implication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Removes deprecated commands <code>-</code>, <code>--</code>, and <code>---</code>. Use <code>onFailure</code>, <code>sbtClearOnFailure</code>, and <code>resumeFromFailure</code> instead. <a href="https://github.com/sbt/sbt/pull/4124">#4124</a>
</li><li>Makes <code>++</code> fail when it doesn’t affect any subprojects <a href="https://github.com/sbt/sbt/pull/4269">#4269</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li></ul><h4 id="Other+bug+fixes+and+improvements">Other bug fixes and improvements<a href="#Other+bug+fixes+and+improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes output caching bug. <a href="https://github.com/sbt/util/pull/169">util#169</a> by <a href="https://github.com/bpholt">@bpholt</a>
</li><li>Fixes “destination file exists” error message. <a href="https://github.com/sbt/librarymanagement/pull/255">lm#255</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Reintroduces <code>Command.process(String, State): State</code>. <a href="https://github.com/sbt/sbt/pull/4023">#4023</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes <code>active.json</code> not getting removed on JVM shutdown. <a href="https://github.com/sbt/sbt/pull/4194">#4194</a> by <a href="https://github.com/veera8337">@veera83372</a>
</li><li>Fixes file permission error (”<code>CreateFile()</code> failed”) while reading the timestamp on Windows. <a href="https://github.com/sbt/io/pull/134">io#134</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Fixes the linter that detects missing <code>.value</code>. <a href="https://github.com/sbt/sbt/pull/4090">#4090</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes <code>StringIndexOutOfBoundsException</code> in <code>removeEscapeSequences</code>. <a href="https://github.com/sbt/util/pull/139">util#139</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes OkHttp’s <code>JavaNetAuthenticator</code> with a null check. <a href="https://github.com/sbt/librarymanagement/pull/177">lm#177</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes Sonatype timeout issue by extending the default timeout to 1h. <a href="https://github.com/sbt/librarymanagement/pull/246">lm#246</a> by <a href="https://github.com/peterneyens">@peterneyens</a>
</li><li>Fixes thread thrashing error during the parallel download. <a href="https://github.com/sbt/librarymanagement/pull/249">lm249</a> by <a href="https://github.com/OlegYch">@OlegYch</a>
</li><li>Fixes JavaDoc warnings logged as errors. <a href="https://github.com/sbt/zinc/pull/506">zinc#506</a> by <a href="https://github.com/kaygorodov">@kaygorodov</a>
</li><li>Fixes class dependency not picking up <code>classOf[A]</code>. <a href="https://github.com/sbt/zinc/pull/510">zinc#510</a> by <a href="https://github.com/natansil">@natansil</a>
</li><li>Fixes class dependency including non-existing objects. <a href="https://github.com/sbt/zinc/pull/422">zinc422</a> by <a href="https://github.com/romanowski">@romanowski</a>
</li><li>Fixes link to the documentation of deprecated 0.10/0.12 DSL syntax. <a href="https://github.com/sbt/sbt/pull/3901">#3901</a> by [@colindean]
</li><li>Fixes the documentation of <code>skip</code> key. <a href="https://github.com/sbt/sbt/pull/3926">#3926</a> by <a href="https://github.com/dkim">@dkim</a>
</li><li>Fixes race condition in non-forked parallel tests. <a href="https://github.com/sbt/sbt/pull/3985">#3985</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes Ctrl-C handing in forked tests when <code>Global / cancelable</code> is set to <code>true</code>. <a href="https://github.com/sbt/sbt/pull/4226">#4226</a> by <a href="https://github.com/driquelme">@driquelme</a>
</li><li>Fixes the stacktrace of <code>run</code>. <a href="https://github.com/sbt/sbt/pull/4232">#4232</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Bumps the version of Giter8 used by <code>sbt new</code> to 0.11.0, fixing various issues <a href="https://github.com/sbt/sbt/pull/4263">#4263</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Improves Javac error parsing. <a href="https://github.com/sbt/zinc/pull/557">zinc#557</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Displays only the eviction warning summary by default, and make it configurable using <code>ThisBuild / evictionWarningOptions</code>. <a href="https://github.com/sbt/librarymanagement/pull/211">lm211</a> and <a href="https://github.com/sbt/sbt/pull/3947">#3947</a> by <a href="https://github.com/exoego">@exoego</a>
</li><li>Allow varargs in <code>inThisBuild(...)</code>, <code>inConfig(C)(...)</code>, <code>inTask(t)(...)</code>, <code>inScope(scope)(...)</code>. <a href="https://github.com/sbt/sbt/pull/4106">#4106</a> by <a href="https://github.com/dwijnand">@dwijnand</a> 
</li><li>Adds <code>fgRun</code> and <code>fgRunMain</code> tasks that behaves like sbt 0.13’s <code>run</code>. <a href="https://github.com/sbt/sbt/pull/4216">#4216</a> by <a href="https://github.com/agaro1121">@agaro1121</a>
</li><li>Supports <code>test.script</code> and <code>pending.script</code> as the scripted file name. <a href="https://github.com/sbt/sbt/pull/4220">#4220</a> by <a href="https://github.com/regadas">@regadas</a>
</li><li>Supports aliases in <code>inspect</code> command. <a href="https://github.com/sbt/sbt/pull/4221">#4221</a> by <a href="https://github.com/gpoirier">@gpoirier</a>
</li><li>Adds the current project’s id to <code>~</code>’s watching message. <a href="https://github.com/sbt/sbt/issues/2038">#2038</a> / <a href="https://github.com/sbt/sbt/pull/3813">#3813</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Changes <code>PathFinder#get</code> to <code>get()</code>. <a href="https://github.com/sbt/io/pull/104">io#104</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Improves the error message when access is denied. <a href="https://github.com/sbt/librarymanagement/pull/203">lm#203</a> by <a href="https://github.com/stephennancekivell">@stephennancekivell</a>
</li><li>Improve the warning message “Choosing local” to something more actionable. <a href="https://github.com/sbt/librarymanagement/pull/248">lm#248</a> by <a href="https://github.com/khvatov">@khvatov</a>
</li><li>Adds an option to ignore scalac options change. <a href="https://github.com/sbt/zinc/pull/548">zinc#548</a> by <a href="https://github.com/lukaszwawrzyk">@lukaszwawrzyk</a>
</li><li>Enable parallel execution of scripted in the plugin. <a href="https://github.com/sbt/sbt/pull/3891">#3891</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Adds factory methods for Configuration axis scope filters <code>inConfigurationsByKeys</code> and <code>inConfigurationsByRefs</code>. <a href="https://github.com/sbt/sbt/pull/3994">#3994</a>
</li><li>Adds <code>lastGrep</code>, <code>loadFailed</code>, etc commands to replace the kebab-cased commands. <a href="https://github.com/sbt/sbt/pull/4080">#4080</a> by <a href="https://github.com/naferx">@naferx</a>, <a href="https://github.com/sbt/sbt/pull/4159">#4159</a> by <a href="https://github.com/Asamsig">@Asamsig</a>, and <a href="https://github.com/sbt/sbt/pull/4169">#4169</a> by <a href="https://github.com/tiqwab">@tiqwab</a>
</li><li>Adds timestamp field to JUnitXML report. <a href="https://github.com/sbt/sbt/pull/4154">4154</a> by <a href="https://github.com/timcharper">@timcharper</a>
</li><li>“Loading settings” log messages now show subproject name. <a href="https://github.com/sbt/sbt/pull/4164">#4164</a> by <a href="https://github.com/alodavi">@alodavi</a>
</li><li><code>about</code> command sorts and indents plugins list. <a href="https://github.com/sbt/sbt/pull/4187">#4187</a> by <a href="https://github.com/mcanlas">@mcanlas</a>
</li><li><code>-Dsbt.offline</code> sets <code>offline</code> setting. <a href="https://github.com/sbt/sbt/pull/4198">#4198</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Selects most recent JDK during cross JDK forking (see below for details) <a href="https://github.com/sbt/sbt/pull/4245">#4245</a> by <a href="https://github.com/raboof">@raboof</a>
</li></ul><h4 id="Internal">Internal<a href="#Internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Removes some compiler warnings. <a href="https://github.com/sbt/sbt/pull/3807">#3087</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Lots of other refactorings by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Removes some compiler warnings in Zinc. <a href="https://github.com/sbt/zinc/pull/493">zinc#493</a> by <a href="https://github.com/exoego">@exoego</a>
</li><li>Perf: Prevents creation of useless <code>URI</code> copies in <code>IO.directoryURI</code>. <a href="https://github.com/sbt/io/pull/132">io#132</a> by <a href="https://github.com/jrudolph">@jrudolph</a>
</li><li>Perf: Avoids reflect universe initialization in <code>initStringCodecs</code>. <a href="https://github.com/sbt/util/pull/153">util#153</a> by <a href="https://github.com/jrudolph">@jrudolph</a>
</li><li>Perf: Speeds up <code>Parsers.validID</code>. <a href="https://github.com/sbt/sbt/pull/3952">#3952</a> by <a href="https://github.com/jrudolph">@jrudolph</a>
</li><li>Perf: Optimizes scope delegation by hand rolling <code>for</code> comprehension. <a href="https://github.com/sbt/sbt/pull/4003">#4003</a> by <a href="https://github.com/jrudolph">@jrudolph</a> and <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Use <code>val</code> instead of <code>var</code> in an internal code. <a href="https://github.com/sbt/sbt/pull/4253">#4253</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Thanks again to everyone who’s helped improve sbt and Zinc 1.
</p><p>sbt 1.2.0 was brought to you by 60 contributors. Dale Wijnand, Eugene Yokota, Kenji Yoshida (xuwei-k), Yasuhiro Tatsuno (exoego), Łukasz Wawrzyk, Jorge Vicente Cantero (jvican), Alistair Johnson, Antonio Cunei, Jason Zaugg, Rikito Taniguchi (tanishiking), Seiya Mizuno, Tim Harper, Aloisia Davì (alodavi), Arnout Engelen, Ethan Atkins, Johannes Rudolph, Krzysztof Romanowski, Allan Renucci, Brian P. Holt, Filipe Regadas, Hiroshi Ito, Martijn Hoekstra, OlegYch, Seth Tisue, natans, Aaron S. Hawley, Alex Khvatov, Alexander Samsig, Andreas Jim-Hartmann, Andrei Pozolotin, Andrey Kaygorodov, Anthony Garo, Christopher Hunt, Colin Dean, Daniel Riquelme, Deokhwan Kim, Gerard Maas, Guillaume Poirier, Heikki Vesalainen, Jason Pickens, Jonas Fonseca, Julien Jerphanion, Justin Pihony, Kazufumi Nishida, Kyle Goodale, Maksym Fedorov, Mark Canlas, Martynas Mickevičius, Michael Pollmeier, Mike Skells, Nafer Sanabria, Naohisa Murakami (tiqwab), PanAeon, Peter Neyens, Rui Gonçalves, Sean Sullivan, Stephen Nancekivell, Veera Venky, blakkan, ortigali. Thank you!
</p><h2 id="sbt+1.1.x+releases">sbt 1.1.x releases<a href="#sbt+1.1.x+releases" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+1.1.6">sbt 1.1.6<a href="#sbt+1.1.6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes file watching for Unix/Linux. <a href="https://github.com/sbt/io/pull/150">io#150</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes packageBin not creating file when deleted. sbt/sbt#4161 by <a href="https://github.com/dadarakt">@dadarakt</a>
</li><li>Fixes help -v rendering of multi-line descriptions. <a href="https://github.com/sbt/sbt/pull/4160">#4160</a> by <a href="https://github.com/ninjalama">@ninjalama</a>
</li><li>Fixes —error etc to set log level. <a href="https://github.com/sbt/sbt/pull/4162">#4162</a> by <a href="https://github.com/holdenk">@holdenk</a>
</li><li>Handles managedSources writing into unmanaged source directories. <a href="https://github.com/sbt/sbt/pull/4099">#4099</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes handling of overflows in EventMonitor. <a href="https://github.com/sbt/io/pull/155">io#155</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Recovers “Resolving…” log under <code>UpdateLogging.Full</code>. <a href="https://github.com/sbt/librarymanagement/pull/240">lm#240</a> by <a href="https://github.com/hodga">@hodga</a>
</li><li>Fixes <code>-Dconfig.resource=/path/to/configFile</code> conflicting with Gigahorse. <a href="https://github.com/sbt/librarymanagement/pull/241">lm#241</a> by <a href="https://github.com/tanishiking">@tanishiking</a> 
</li><li>Removes use of deprecated ModifiedTime methods. <a href="https://github.com/sbt/io/pull/154">io#154</a> by <a href="https://github.com/dwestheide">@dwestheide</a>
</li><li>Fixes tests on Windows. <a href="https://github.com/sbt/io/pull/153">io#153</a> by <a href="https://github.com/OlegYch">@OlegYch</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>sbt 1.1.6 was brought to you by 15 contributors, according to <code>git shortlog -sn --no-merges v1.1.5...v1.1.6</code> on sbt, zinc, librarymanagement, util, io, launcher-package, and website: Ethan Atkins, Eugene Yokota, Dale Wijnand, Aaron S. Hawley, OlegYch, Richard Summerhayes, Jannis (dadarakt), Rikito Taniguchi (tanishiking), Øyvind Høisæther, Daniel Westheide, Harrison Houghton, Holden Karau, Håkon Wold, Jason Zaugg, and tekay.
</p><hr/><h3 id="sbt+1.1.5">sbt 1.1.5<a href="#sbt+1.1.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes the latency between file modification events and triggered execution. <a href="https://github.com/sbt/io/pull/142">io#142</a> and <a href="https://github.com/sbt/sbt/pull/4096">sbt#4096</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes NPE that could arise from WatchEvent <a href="https://github.com/sbt/io/pull/140">io#140</a> by <a href="https://github.com/oneill">@oneill</a>
</li><li>Fixes deleted files not triggering <code>~</code>. <a href="https://github.com/sbt/sbt/pull/4098">sbt#4098</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes MacOSXWatchService to meet the WatchService API. <a href="https://github.com/sbt/io/pull/142">io#142</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Avoids printing <code>RejectedExectionExeption</code> stack trace after cancellation. <a href="https://github.com/sbt/sbt/pull/4058">sbt#4058</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes Java version checking on Windows. <a href="https://github.com/sbt/sbt-launcher-package/pull/227">lp#227</a> / <a href="https://github.com/sbt/sbt-launcher-package/pull/228">lp#228</a> by <a href="https://github.com/jessicah">@jessicah</a> and <a href="https://github.com/spangaer">@spangaer</a>
</li><li>Fixes unexpected responses from sbt server. <a href="https://github.com/sbt/sbt/pull/4093">sbt#4093</a> by <a href="https://github.com/laughedelic">@laughedelic</a>
</li><li>Re-fix console and JLine bug. <a href="https://github.com/sbt/sbt/pull/4123">sbt#4123</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes grammar for contributors guide. <a href="https://github.com/sbt/sbt/pull/4133">sbt#4133</a> by <a href="https://github.com/som-snytt">@som-snytt</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Performance optimization for Zinc. <a href="https://github.com/sbt/zinc/pull/492">zinc#492</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Adds support for detecting Dotty compiler plugins. <a href="https://github.com/sbt/zinc/pull/529">zinc#529</a> by <a href="https://github.com/liufengyun">@liufengyun</a>
</li><li>Bumps Scala to 2.12.6. <a href="https://github.com/sbt/sbt/pull/4129">sbt#4129</a> by <a href="https://github.com/SethTisue">@SethTisue</a>
</li><li>Updates to JLine 2.14.6. <a href="https://github.com/sbt/sbt/pull/4087">sbt#4087</a> by <a href="https://github.com/hvesalai">@hvesalai</a>
</li><li>Start sbt in VS Code terminal window. See below.
</li></ul><h4 id="Watcher+improvements">Watcher improvements<a href="#Watcher+improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Continuing from sbt 1.1.4, Ethan Atkins contributed fixes and improvements for triggered execution <code>~</code> watcher. sbt 1.1.5 should fix the latency between file modification events and the command execution.
</p><h4 id="VS+Code+extension+update">VS Code extension update<a href="#VS+Code+extension+update" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>We released a new sbt VS Code extension that starts sbt session in the embedded terminal window. This was contributed by Robert Walker (<a href="https://twitter.com/WalkingOlof">@WalkingOlof</a>) in <a href="https://github.com/sbt/sbt/pull/4130">sbt#4130</a>.
</p><h4 id="sbt+by+example">sbt by example<a href="#sbt+by+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>We added <a href="https://www.scala-sbt.org/1.x/docs/sbt-by-example.html">sbt by example</a> to the sbt documentation.
This is a single-page guide that takes you from zero to building an app on Docker, inspired by, and largely based on William Narmontas (<a href="https://twitter.com/ScalaWilliam">@ScalaWilliam</a>)’s <a href="https://www.scalawilliam.com/essential-sbt/">Essential sbt</a>.
</p><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>sbt 1.1.5 was brought to you by 21 contributors, according to <code>git shortlog -sn --no-merges v1.1.4...v1.1.5</code> on sbt, zinc, librarymanagement, util, io, launcher-package, and website: Eugene Yokota, Ethan Atkins, Jason Zaugg, Liu Fengyun, Antonio Cunei, Dale Wijnand, Roberto Bonvallet, Alexey Alekhin, Daniel Parks, Heikki Vesalainen, Jean-Luc Deprez, Jessica Hamilton, Kenji Yoshida (xuwei-k), Nikita Gazarov, OlegYch, Richard Summerhayes, Robert Walker, Seth Tisue, Som Snytt, oneill, and 杨博 (Yang Bo)
</p><hr/><h3 id="sbt+1.1.4">sbt 1.1.4<a href="#sbt+1.1.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes triggered execution on macOS. See below for details.
</li><li>Fixes running <code>console</code> twice messing up JLine. <a href="https://github.com/sbt/sbt/issues/3482">#3482</a>/<a href="https://github.com/sbt/sbt/pull/4054">#4054</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes <code>updateSbtClassifiers</code>. <a href="https://github.com/sbt/sbt/pull/4070">#4070</a>/<a href="https://github.com/sbt/sbt/issues/3432">#3432</a> by <a href="https://github.com/steinybot">@steinybot</a>
</li><li>Fixes Java error message handling. <a href="https://github.com/sbt/zinc/pull/524">zinc#524</a>/<a href="https://github.com/sbt/zinc/pull/525">zinc#525</a> by <a href="https://github.com/retronym">@retronym</a> and <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes the error message linking to the migration guide. <a href="https://github.com/sbt/sbt/pull/4063">#4063</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes batch script so sbt runs on JDK 10 on Windows. <a href="https://github.com/sbt/sbt-launcher-package/pull/225">lp#225</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes bash script so <code>sbt -debug</code> changes log level to debug. <a href="https://github.com/sbt/sbt-launcher-package/pull/226">lp#226</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Exposes <code>sbt.io.JavaMilli</code>. <a href="https://github.com/sbt/io/pull/139">io#139</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Adds <code>-Dsbt.launcher.cp.prepend</code> JVM flag that is used for monkey patching sbt. <a href="https://github.com/sbt/launcher/pull/50">launcher#50</a> by <a href="https://github.com/fommil">@fommil</a>
</li></ul><h4 id="Triggered+execution+on+macOS">Triggered execution on macOS<a href="#Triggered+execution+on+macOS" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt has long had issues with triggered execution on macOS. Ethan Atkins has contributed a fix for this problem by merging MacOSXWatchService from his <a href="https://github.com/swoval/swoval/tree/master/plugin">CloseWatch</a>. Thanks, Ethan!
</p><p>Credit also goes to Greg Methvin and Takari’s directory-watcher. <a href="https://github.com/sbt/sbt/issues/3860">#3860</a>/<a href="https://github.com/sbt/sbt/pull/4071">#4071</a>/<a href="https://github.com/sbt/io/pull/138">io#138</a> by <a href="https://github.com/eatkins">@eatkins</a>
</p><h4 id="Running+sbt+with+standby">Running sbt with standby<a href="#Running+sbt+with+standby" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>One of the tricky things you come across while profiling is figuring out the process ID,
while wanting to profile the beginning of the application.
</p><p>For this purpose, we’ve added <code>sbt.launcher.standby</code> JVM flag. Starting sbt 1.1.4, you can run:
</p><pre><code class="">$ sbt -J-Dsbt.launcher.standby=20s exit
</code></pre><p>This will count down for 20s before doing anything else. <a href="https://github.com/sbt/launcher/pull/51">launcher#51</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h4 id="Loading+performance+improvement">Loading performance improvement<a href="#Loading+performance+improvement" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Using Flame graph (if you haven’t yet, check out <a href="../2018-04-09-profiling-JVM-applications/">Profiling JVM applications</a> post), Jason Zaugg identified hashing code of the build file to be one of the hot paths during sbt startup. Flame graph supports <code>Ctrl+F</code> to filter on method names; and when I ran it, it showed 4.5% of the time was spent in <code>Eval#evalCommon</code> method.
</p><p>Instead of creating an intermediate <code>Array[Byte]</code> and passing it to <code>MessageDigest</code> at the end, Jason suggested that we pass the arrays to <code>MessageDigest#update</code> in a more procedural style. After confirming that it worked, we’ve next identified file timestamp code to be the next bottle neck using Flame graph, so that was switched to using NIO. After both changes, <code>Eval#evalCommon</code>’s footprint reduced to 2.3%.
</p><p>This means that your build loads slightly faster on sbt 1.1.4 (about 0.54s faster on akka/akka, for example). <a href="https://github.com/sbt/sbt/pull/4067">#4067</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h3 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>sbt 1.1.4 was brought to you by 11 contributors, according to <code>git shortlog -sn --no-merges v1.1.2...v1.1.4</code> on sbt, zinc, librarymanagement, util, io, launcher-package, and website: Eugene Yokota, Dale Wijnand, 杨博 (Yang Bo), Ethan Atkins, Sam Halliday, Aaron S. Hawley, Gabriele Petronella, Jason Steenstra-Pickens, Jason Zaugg, Julien Jean Paul Sirocchi, and aumann.
</p><hr/><h3 id="sbt+1.1.2">sbt 1.1.2<a href="#sbt+1.1.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes triggered execution’s resource leak by caching the watch service. <a href="https://github.com/sbt/sbt/pull/3999">#3999</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes classloader inheriting the dependencies of Scala compiler during <code>run</code> <a href="https://github.com/sbt/zinc/pull/505">zinc#505</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes forked test concurrency issue. <a href="https://github.com/sbt/sbt/pull/4030">#4030</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes <code>new</code> command leaving behind target directory <a href="https://github.com/sbt/sbt/pull/4033">#4033</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes handling on null Content-Type. <a href="https://github.com/sbt/librarymanagement/pull/214">lm214</a> by <a href="https://github.com/staale">@staale</a>
</li><li>Fixes null handling of <code>managedChecksums</code> in <code>ivySettings</code> file. <a href="https://github.com/sbt/librarymanagement/pull/218">lm#218</a> by <a href="https://github.com/IanGabes">@IanGabes</a>
</li><li>Adds <code>sbt.boot.lock</code> as a JVM property to opt-out of locking. <a href="https://github.com/sbt/sbt/pull/3927">#3927</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Provides <code>SBT_GLOBAL_SERVER_DIR</code> env var as a workaround to long socket file path on UNIX. <a href="https://github.com/sbt/sbt/pull/3932">#3932</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes forked runs reporting noisy “Stream closed” exception. <a href="https://github.com/sbt/sbt/pull/3970">#3970</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes test compilation not getting included in VS Code save trigger. <a href="https://github.com/sbt/sbt/pull/4022">#4022</a> by <a href="https://github.com/tmiyamon">@tmiyamon</a>
</li><li>Fixes sbt server responding with string id when number id passed. <a href="https://github.com/sbt/sbt/pull/4025">#4025</a> by <a href="https://github.com/tiqwab">@tiqwab</a>
</li><li>Fixes <code>getDecoder</code> in Analysis format <a href="https://github.com/sbt/zinc/pull/502">zinc#502</a> by <a href="https://github.com/jilen">@jilen</a>
</li><li>Fixes equal / hashCode inconsistencies around Array. <a href="https://github.com/sbt/zinc/pull/513">zinc#513</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Whitelists <code>java9-rt-ext-output</code> in rt export process <a href="https://github.com/sbt/sbt-launcher-package/pull/211">lp#211</a> by <a href="https://github.com/eatkins">@eatkins</a>
</li><li>Fixes JDK version detection for Java 10 friendliness. <a href="https://github.com/sbt/sbt-launcher-package/pull/219">lp#219</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a> and <a href="https://github.com/2m">@2m</a>
</li><li>Fixes quoting in Windows bat file. <a href="https://github.com/sbt/sbt-launcher-package/pull/220">lp#220</a> by <a href="https://github.com/ForNeVeR">@ForNeVeR</a>
</li><li>Fixes <code>-error</code> not suppressing startup logs. <a href="https://github.com/sbt/sbt/pull/4036">#4036</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Performance optimization around logging. <a href="https://github.com/sbt/util/pull/152">util#152</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Performance fix by caching the hashCode of <code>Configuration</code>. <a href="https://github.com/sbt/librarymanagement/pull/213">lm#213</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Returns error code <code>-33000L</code> on sbt server when a command fails. <a href="https://github.com/sbt/sbt/pull/3991">#3991</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Allows wildcards in organization and artifact. <a href="https://github.com/sbt/librarymanagement/pull/215">#215</a> by <a href="https://github.com/dhs3000">@dhs3000</a>
</li><li>Updates to latest Jsch to support stronger key exchange algorithms. <a href="https://github.com/sbt/librarymanagement/pull/217">lm#217</a> by <a href="https://github.com/ryandbair">@ryandbair</a>
</li><li>Fixes preloading of compiler bridge. <a href="https://github.com/sbt/sbt-launcher-package/pull/222">lp#222</a> by <a href="https://github.com/analytically">@analytically</a>
</li></ul><h4 id="Internal">Internal<a href="#Internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Updates <a href="https://github.com/sbt/sbt/blob/1.x/CONTRIBUTING.md">contribution guide</a>. <a href="https://github.com/sbt/sbt/pull/3960">#3960</a>/<a href="https://github.com/sbt/sbt/pull/4019">#4019</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a> and <a href="https://github.com/itohiro73">@itohiro73</a>
</li><li>Deletes <code>buildinfo.BuildInfo</code> from sbt main that was intended for testing. <a href="https://github.com/sbt/sbt/pull/3967">3967</a> by <a href="https://github.com/dwijnand">@dwijnand</a> and <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Various improvements around Zinc benchmark by <a href="https://github.com/retronym">@retronym</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.1.2 was brought to you by 23 contributors, according to <code>git shortlog -sn --no-merges v1.1.1...v1.1.2</code> on sbt, zinc, librarymanagement, util, io, launcher-package, and website: Dale Wijnand, Eugene Yokota, Jason Zaugg, Kenji Yoshida (xuwei-k), Ethan Atkins, Martijn Hoekstra, Martynas Mickevičius, Dennis Hörsch, Hosam Aly, Antonio Cunei, Friedrich von Never, Hiroshi Ito, Ian Gabes, Jilen Zhang, Mathias Bogaert, Naohisa Murakami (tiqwab), Philippus Baalman, Ryan Bair, Seth Tisue, Ståle Undheim, Takuya Miyamoto (tmiyamon), Yasuhiro Tatsuno. Thank you!
</p><hr/><h3 id="sbt+1.1.1">sbt 1.1.1<a href="#sbt+1.1.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes “Modified names for (class) is empty” error. <a href="https://github.com/sbt/zinc/issues/292">zinc#292</a> / <a href="https://github.com/sbt/zinc/pull/484">zinc#484</a> by <a href="https://github.com/jvican">@jvican</a> (Scala Center)
</li><li>Fixes tab completion in <code>console</code> while running in batch mode as <code>sbt console</code>. <a href="https://github.com/sbt/sbt/issues/3841">#3841</a>/<a href="https://github.com/sbt/sbt/pull/3876">#3876</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes file timestamp retrieval of missing files on Windows. <a href="https://github.com/sbt/sbt/issues/3871">#3871</a> / <a href="https://github.com/sbt/io/pull/120">io#120</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Aligns the errors thrown by file timestamp implementations. Fixes <a href="https://github.com/sbt/sbt/issues/3894">#3894</a> / <a href="https://github.com/sbt/io/pull/121">io#121</a> by <a href="https://github.com/j-keck">@j-keck</a>
</li><li>Adds file timestamps native support for FreeBSD. <a href="https://github.com/sbt/sbt/issues/3894">#3894</a> / <a href="https://github.com/sbt/io/pull/124">io#124</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Fixes JDK 10 version string parsing. <a href="https://github.com/sbt/sbt-launcher-package/pull/209">sbt/sbt-launcher-package#209</a> by <a href="https://github.com/2m">@2m</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Deprecates <code>Extracted#append</code> in favour of <code>appendWithSession</code> or <code>appendWithoutSession</code>.  <a href="https://github.com/sbt/sbt/pull/3865">#3865</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Adds a new global <code>Boolean</code> setting called <code>autoStartServer</code>. See below.
</li><li>Upgrades Scala versions used for sbt cross building <code>^^</code>. <a href="https://github.com/sbt/sbt/pull/3923">#3923</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Many documentation maintenance changes by <a href="https://github.com/xuwei-k">@xuwei-k</a>.
</li></ul><h4 id="autoStartServer+setting">autoStartServer setting<a href="#autoStartServer+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.1.1 adds a new global <code>Boolean</code> setting called <code>autoStartServer</code>, which is set to <code>true</code> by default.
When set to <code>true</code>, sbt shell will automatically start sbt server. Otherwise, it will not start the server until <code>startSever</code> command is issued. This could be used to opt out of server for security reasons.
</p><p><a href="https://github.com/sbt/sbt/pull/3922">#3922</a> by <a href="https://github.com/swaldman">@swaldman</a>
</p><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.1.1 was brought to you by 16 contributors, according to <code>git shortlog -sn --no-merges v1.1.0 ..v1.1.0</code> on sbt, zinc, librarymanagement, util, io, and website: Kenji Yoshida (xuwei-k), Eugene Yokota, Dale Wijnand, Antonio Cunei, Steve Waldman, Arnout Engelen, Deokhwan Kim, OlegYch, Robert Walker, Jorge Vicente Cantero (jvican), Claudio Bley, Eric Peters, Lena Brüder, Seiya Mizuno, Seth Tisue, j-keck. Thank you!
</p><hr/><h3 id="sbt+1.1.0">sbt 1.1.0<a href="#sbt+1.1.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is a feature release for sbt 1.0.x series.
</p><h4 id="Features%2C+fixes%2C+changes+with+compatibility+implications">Features, fixes, changes with compatibility implications<a href="#Features%2C+fixes%2C+changes+with+compatibility+implications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt server feature is reworked in sbt 1.1.0. See below.
</li><li>Changes <code>version</code> setting default to <code>0.1.0-SNAPSHOT</code> for compatibility with Semantic Versioning. <a href="https://github.com/sbt/sbt/pull/3577">#3577</a> by <a href="https://github.com/laughedelic">@laughedelic</a>
</li></ul><h4 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Unifies sbt shell and build.sbt syntax. See below.
</li></ul><h4 id="Fixes">Fixes<a href="#Fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes <code>ClasspathFilter</code> that was causing <code>Class.forName</code> to not work in <code>run</code>. <a href="https://github.com/sbt/zinc/pull/473">zinc#473</a> / <a href="https://github.com/sbt/sbt/issues/3736">#3736</a> / <a href="https://github.com/sbt/sbt/issues/3733">#3733</a> / <a href="https://github.com/sbt/sbt/issues/3647">#3647</a> / <a href="https://github.com/sbt/sbt/issues/3608">#3608</a> by <a href="https://github.com/ravwojdyla">@ravwojdyla</a>
</li><li>Fixes Java compilation causing <code>NullPointerException</code> by making PositionImpl thread-safe. <a href="https://github.com/sbt/zinc/pull/465">zinc#465</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes <code>PollingWatchService</code> by preventing concurrent modification of <code>keysWithEvents</code> map. <a href="https://github.com/sbt/io/pull/90">io#90</a> by <a href="https://github.com/mechkg">@mechkg</a>, which fixes <code>~</code> related issues <a href="https://github.com/sbt/sbt/issues/3687">#3687</a>, <a href="https://github.com/sbt/sbt/issues/3695">#3695</a>, and <a href="https://github.com/sbt/sbt/issues/3775">#3775</a>.
</li><li>Provides workaround for <code>File#lastModified()</code> losing millisecond-precision by using native code when possible. <a href="https://github.com/sbt/io/pull/92">io#92</a>/<a href="https://github.com/sbt/io/pull/106">io#106</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Fixes <code>IO.relativize</code> not working with relative path. <a href="https://github.com/sbt/io/pull/108">io#108</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes warning message when multiple instances are detected. <a href="https://github.com/sbt/sbt/pull/3828">#3828</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes over-compilation bug with Java 9. <a href="https://github.com/sbt/zinc/pull/450">zinc#450</a> by <a href="https://github.com/retronym">@retronym</a>
</li><li>Fixes handling of deeply nested Java classes. <a href="https://github.com/sbt/zinc/pull/423">zinc#423</a> by <a href="https://github.com/romanowski">@romanowski</a>
</li><li>Fixes JavaDoc not printing all errors. <a href="https://github.com/sbt/zinc/issues/415">zinc#415</a> by <a href="https://github.com/raboof">@raboof</a>
</li><li>Preserves JAR order in <code>ScalaInstance.otherJars</code>. <a href="https://github.com/sbt/zinc/pull/411">zinc#411</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes used name when it contains NL. <a href="https://github.com/sbt/zinc/pull/449">zinc#449</a> by <a href="https://github.com/jilen">@jilen</a>
</li><li>Fixes handling of <code>ThisProject</code>. <a href="https://github.com/sbt/sbt/pull/3609">#3609</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Escapes imports from sbt files, so if user creates a backquoted definition then task evaluation will not fail. <a href="https://github.com/sbt/sbt/pull/3635">#3635</a> by <a href="https://github.com/panaeon">@panaeon</a>
</li><li>Removes reference to version 0.14.0 from a warning message. <a href="https://github.com/sbt/sbt/issues/3693">#3693</a> by <a href="https://github.com/saniyatech">@saniyatech</a>
</li><li>Fixes screpl throwing “Not a valid key: console-quick”. <a href="https://github.com/sbt/sbt/pull/3762">#3762</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Restores Scala 2.13.0-M1 support. #461 by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes the encoding of Unix-like file path to use <code>file:///</code>. <a href="https://github.com/sbt/sbt/pull/3805">#3805</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes Log4J2 initialization error during startup. <a href="https://github.com/sbt/sbt/pull/3814">#3814</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Filters scripted tests based on optional <code>project/build.properties</code>. See below.
</li><li>Adds <code>Project#withId</code> to change a project’s id. <a href="https://github.com/sbt/sbt/pull/3601">#3601</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Adds <code>reboot dev</code> command, which deletes the current artifact from the boot directory. This is useful when working with development versions of sbt. <a href="https://github.com/sbt/sbt/pull/3659">#3659</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Adds a check for a change in sbt version before <code>reload</code>. <a href="https://github.com/sbt/sbt/issues/1055">#1055</a>/<a href="https://github.com/sbt/sbt/pull/3673">#3673</a> by <a href="https://github.com/RomanIakovlev">@RomanIakovlev</a>
</li><li>Adds a new setting <code>insideCI</code>, which indicates that sbt is likely running in an Continuous Integration environment. <a href="https://github.com/sbt/sbt/pull/3672">#3672</a> by <a href="https://github.com/RomanIakovlev">@RomanIakovlev</a>
</li><li>Adds <code>nameOption</code> to <code>Command</code> trait. <a href="https://github.com/sbt/sbt/pull/3671">#3671</a> by <a href="https://github.com/miklos-martin">@miklos-martin</a>
</li><li>Adds POSIX permission operations in IO, such as <code>IO.chmod(..)</code>. <a href="https://github.com/sbt/io/pull/76">io#76</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Treat sbt 1 modules using Semantic Versioning in the eviction warning. <a href="https://github.com/sbt/librarymanagement/pull/188">lm#188</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Uses kind-projector in the code. <a href="https://github.com/sbt/sbt/pull/3650">#3650</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Make <code>displayOnly</code> etc methods strict in <code>Completions</code>. <a href="https://github.com/sbt/sbt/pull/3763">#3763</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li></ul><h4 id="Unified+slash+syntax+for+sbt+shell+and+build.sbt">Unified slash syntax for sbt shell and build.sbt<a href="#Unified+slash+syntax+for+sbt+shell+and+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This adds unified slash syntax for both sbt shell and the build.sbt DSL.
Instead of the current <code>&lt;project-id&gt;/config:intask::key</code>, this adds
<code>&lt;project-id&gt;/&lt;config-ident&gt;/intask/key</code> where <code>&lt;config-ident&gt;</code> is the Scala identifier
notation for the configurations like <code>Compile</code> and <code>Test</code>. (The old shell syntax will continue to function)
</p><p>These examples work both from the shell and in build.sbt.
</p><pre><code>Global / cancelable
ThisBuild / scalaVersion
Test / test
root / Compile / compile / scalacOptions
ProjectRef(uri(&quot;file:/xxx/helloworld/&quot;),&quot;root&quot;)/Compile/scalacOptions
Zero / Zero / name
</code></pre><p>The inspect command now outputs something that can be copy-pasted:
</p><pre><code>&gt; inspect compile
[info] Task: sbt.inc.Analysis
[info] Description:
[info]  Compiles sources.
[info] Provided by:
[info]  ProjectRef(uri(&quot;file:/xxx/helloworld/&quot;),&quot;root&quot;)/Compile/compile
[info] Defined at:
[info]  (sbt.Defaults) Defaults.scala:326
[info] Dependencies:
[info]  Compile/manipulateBytecode
[info]  Compile/incCompileSetup
....
</code></pre><p><a href="https://github.com/sbt/sbt/issues/1812">#1812</a>/<a href="https://github.com/sbt/sbt/pull/3434">#3434</a>/<a href="https://github.com/sbt/sbt/pull/3617">#3617</a>/<a href="https://github.com/sbt/sbt/pull/3620">#3620</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a> and <a href="https://github.com/dwijnand">@dwijnand</a>
</p><h4 id="sbt+server">sbt server<a href="#sbt+server" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt server feature was reworked to use Language Server Protocol 3.0 (LSP) as the wire protocol, a protocol created by Microsoft for Visual Studio Code.
</p><p>To discover a running server, sbt 1.1.0 creates a port file at <code>./project/target/active.json</code> relative to a build:
</p><pre><code class="">{&quot;uri&quot;:&quot;local:///Users/foo/.sbt/1.0/server/0845deda85cb41abcdef/sock&quot;}
</code></pre><p><code>local:</code> indicates a UNIX domain socket. Here’s how we can say hello to the server using <code>nc</code>. (<code>^M</code> can be sent <code>Ctrl-V</code> then <code>Return</code>):
</p><pre><code class="">$ nc -U /Users/foo/.sbt/1.0/server/0845deda85cb41abcdef/sock
Content-Length: 99^M
^M
{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: { &quot;initializationOptions&quot;: { } } }^M
</code></pre><p>sbt server adds network access to sbt’s shell command so, in addition to accepting input from the terminal, server also to accepts input from the network. Here’s how we can call <code>compile</code>:
</p><pre><code class="">Content-Length: 93^M
^M
{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 2, &quot;method&quot;: &quot;sbt/exec&quot;, &quot;params&quot;: { &quot;commandLine&quot;: &quot;compile&quot; } }^M
</code></pre><p>The running sbt session should now queue <code>compile</code>, and return back with compiler warnings and errors, if any:
</p><pre><code class="">Content-Length: 296
Content-Type: application/vscode-jsonrpc; charset=utf-8

{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;textDocument/publishDiagnostics&quot;,&quot;params&quot;:{&quot;uri&quot;:&quot;file:/Users/foo/work/hellotest/Hello.scala&quot;,&quot;diagnostics&quot;:[{&quot;range&quot;:{&quot;start&quot;:{&quot;line&quot;:2,&quot;character&quot;:26},&quot;end&quot;:{&quot;line&quot;:2,&quot;character&quot;:27}},&quot;severity&quot;:1,&quot;source&quot;:&quot;sbt&quot;,&quot;message&quot;:&quot;object X is not a member of package foo&quot;}]}}
</code></pre><p><a href="https://github.com/sbt/sbt/pull/3524">#3524</a>/<a href="https://github.com/sbt/sbt/pull/3556">#3556</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h4 id="VS+Code+extension">VS Code extension<a href="#VS+Code+extension" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The primary use case we have in mind for the sbt server is tooling integration such as editors and IDEs. As a proof of concept, we created a Visual Studio Code extension called <a href="https://marketplace.visualstudio.com/items?itemName=lightbend.vscode-sbt-scala">Scala (sbt)</a>.
</p><p>Currently this extension is able to:
</p><ul><li>Run <code>compile</code> at the root project when <code>*.scala</code> files are saved. <a href="https://github.com/sbt/sbt/pull/3524">#3524</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Display compiler errors.
</li><li>Display log messages. <a href="https://github.com/sbt/sbt/pull/3740">#3740</a> by <a href="https://github.com/laughedelic">@laughedelic</a>
</li><li>Jump to class definitions. <a href="https://github.com/sbt/sbt/pull/3660">#3660</a> by <a href="https://github.com/wpopielarski">@wpopielarski</a>
</li></ul><h4 id="Filtering+scripted+tests+using">Filtering scripted tests using <code>project/build.properties</code><a href="#Filtering+scripted+tests+using" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For all scripted tests in which <code>project/build.properties</code> exist, the value of the <code>sbt.version</code> property is read. If its binary version is different from <code>sbtBinaryVersion in pluginCrossBuild</code> the test will be skipped and a message indicating this will be logged.
</p><p>This allows you to define scripted tests that track the minimum supported sbt versions, e.g. 0.13.9 and 1.0.0-RC2. <a href="https://github.com/sbt/sbt/issues/3564">#3564</a>/<a href="https://github.com/sbt/sbt/pull/3566">#3566</a> by <a href="https://github.com/jonas">@jonas</a>
</p><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.1.0 was brought to you by 33 contributors, according to <code>git shortlog -sn --no-merges v1.0.4..v1.1.0</code> on sbt, zinc, librarymanagement, util, io, and website: Eugene Yokota, Dale Wijnand, Antonio Cunei, Kenji Yoshida (xuwei-k), Alexey Alekhin, Simon Schäfer, Jorge Vicente Cantero (jvican), Miklos Martin, Jeffrey Olchovy, Jonas Fonseca, Andrey Artemov, Arnout Engelen, Dominik Winter, Krzysztof Romanowski, Roman Iakovlev, Wiesław Popielarski, Age Mooij, Allan Timothy Leong, Ivan Poliakov, Jason Zaugg, Jilen Zhang, Long Jinwei, Martin Duhem, Michael Stringer, Michael Wizner, Nud Teeraworamongkol, OlegYch, PanAeon, Philippus Baalman, Pierre Dal-Pra, Rafal Wojdyla, Saniya Tech, Tom Walford, and many others who contributed ideas. Thank you!
</p><h2 id="sbt+1.0.x+releases">sbt 1.0.x releases<a href="#sbt+1.0.x+releases" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+1.0.4">sbt 1.0.4<a href="#sbt+1.0.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is a hotfix release for sbt 1.0.x series.
</p><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes undercompilation of value classes when the underlying type changes. <a href="https://github.com/sbt/zinc/pull/444">zinc#444</a> by <a href="https://github.com/smarter">@smarter</a>
</li><li>Fixes <code>ArrayIndexOutOfBoundsException</code> on Ivy when running on Java 9. <a href="https://github.com/sbt/ivy/pull/27">ivy#27</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Fixes Java 9 warning by upgrading to launcher 1.0.2. <a href="https://github.com/sbt/ivy/pull/26">ivy#26</a>/<a href="https://github.com/sbt/launcher/pull/45">launcher#45</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes <code>-jvm-debug</code> on Java 9. <a href="https://github.com/sbt/sbt-launcher-package/pull/197">launcher-package197</a> by <a href="https://github.com/mkurz">@mkurz</a>
</li><li>Fixes <code>run</code> outputting debug level logs. <a href="https://github.com/sbt/sbt/issues/3655">#3655</a>/<a href="https://github.com/sbt/sbt/pull/3717">#3717</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Fixes performance regression caused by classpath hashing. <a href="https://github.com/sbt/zinc/pull/452">zinc#452</a> by <a href="https://github.com/jvican">@jvican</a>, <a href="https://github.com/fommil">@fommil</a> provided reproduction, and <a href="https://github.com/eed3si9n">@eed3si9n</a> fixed https://github.com/sbt/zinc/issues/457
</li><li>Fixes performance regression of <code>testQuick</code>. <a href="https://github.com/sbt/sbt/issues/3680">#3680</a>/<a href="https://github.com/sbt/sbt/pull/3720">#3720</a> by <a href="https://github.com/OlegYch">@OlegYch</a>
</li><li>Disables Ivy log4j caller location calculation for performance regression reported in <a href="https://github.com/sbt/sbt/issues/3711">#3711</a>. <a href="https://github.com/sbt/util/pull/132">util#132</a> by <a href="https://github.com/leonardehrenfried">@leonardehrenfried</a>
</li><li>Works around Scala compiler’s <code>templateStats()</code> not being thread-safe. <a href="https://github.com/sbt/sbt/pull/3743">#3743</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Fixes “Attempting to overwrite” error message. <a href="https://github.com/sbt/librarymanagement/pull/174">lm#174</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes incorrect eviction warning message. <a href="https://github.com/sbt/librarymanagement/pull/179">lm#179</a> by <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Registers Ivy protocol only for <code>http:</code> and <code>https:</code> to be more plugin friendly. <a href="https://github.com/sbt/librarymanagement/pull/183">lm183</a> by <a href="https://github.com/tpunder">@tpunder</a>
</li><li>Fixes script issues related to <code>bc</code> by using <code>expr</code>. <a href="https://github.com/sbt/sbt-launcher-package/pull/199">launcher-package#199</a> by <a href="https://github.com/thatfulvioguy">@thatfulvioguy</a>
</li></ul><h4 id="Enhancement">Enhancement<a href="#Enhancement" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Adds Scala 2.13.0-M2 support. <a href="https://github.com/sbt/zinc/pull/453">zinc#453</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a> and <a href="https://github.com/jan0sch">@jan0sch</a>
</li></ul><h4 id="Internal">Internal<a href="#Internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Improves Zinc scripted testing. <a href="https://github.com/sbt/zinc/pull/440">zinc#440</a> by <a href="https://github.com/jvican">@jvican</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>This release was brought to you by 17 contributors, according to <code>git shortlog -sn --no-merges v1.0.3..v1.0.4</code> on sbt, zinc, librarymanagement, util, io, and website: Eugene Yokota, Kenji Yoshida (xuwei-k), Jorge Vicente Cantero (jvican), Dale Wijnand, Leonard Ehrenfried, Antonio Cunei, Brett Randall, Guillaume Martres, Arnout Engelen, Fulvio Valente, Jens Grassel, Matthias Kurz, OlegYch, Philippus Baalman, Sam Halliday, Tim Underwood, Tom Most. Thank you!
</p><hr/><h3 id="sbt+1.0.3">sbt 1.0.3<a href="#sbt+1.0.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is a hotfix release for sbt 1.0.x series.
</p><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes <code>~</code> recompiling in loop (when a source generator or sbt-buildinfo is present). <a href="https://github.com/sbt/sbt/issues/3501">#3501</a>/<a href="https://github.com/sbt/sbt/pull/3634">#3634</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes undercompilation on inheritance on same source. <a href="https://github.com/sbt/zinc/pull/424">zinc#424</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes the compilation of package-protected objects. <a href="https://github.com/sbt/zinc/pull/431">zinc#431</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Workaround for Java returning <code>null</code> for <code>getGenericParameterTypes</code>. <a href="https://github.com/sbt/zinc/pull/446">zinc#446</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Fixes test detection regression. sbt 1.0.3 filters out nested objects/classes from the list, restoring compatibility with 0.13. <a href="https://github.com/sbt/sbt/pull/3669">#3669</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Uses Scala 2.12.4 for the build definition. This includes fix for runtime reflection of empty package members under Java 9. <a href="https://github.com/sbt/sbt/issues/3587">#3587</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes extra <code>/</code> in Ivy style patterns. <a href="https://github.com/sbt/librarymanagement/pull/170">lm#170</a> by <a href="https://github.com/laughedelic">@laughedelic</a>
</li><li>Fixes “destination file exist” error message by including the file name. <a href="https://github.com/sbt/librarymanagement/pull/171">lm171</a> by <a href="https://github.com/leonardehrenfried">@leonardehrenfried</a>
</li><li>Fixes JDK 9 warning “Illegal reflective access” in library management module and Ivy. <a href="https://github.com/sbt/librarymanagement/pull/173">lm173</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Adds <code>sbt.watch.mode</code> system property to allow switching back to old polling behaviour for watch. See below for more details.
</li></ul><h4 id="Alternative+watch+mode">Alternative watch mode<a href="#Alternative+watch+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 1.0.0 introduced a new mechanism for watching for source changes based on the NIO <code>WatchService</code> in Java 1.7. On
some platforms (namely macOS) this has led to long delays before changes are picked up. An alternative <code>WatchService</code>
for these platforms is planned for sbt 1.1.0 (<a href="https://github.com/sbt/sbt/issues/3527">#3527</a>), in the meantime an option to select which watch service
has been added.
</p><p>The new <code>sbt.watch.mode</code> JVM flag has been added with the following supported values:
</p><ul><li><code>polling</code>: (default for macOS) poll the filesystem for changes (mechanism used in sbt 0.13).
</li><li><code>nio</code> (default for other platforms): use the NIO based <code>WatchService</code>.
</li></ul><p>If you are experiencing long delays on a non-macOS machine then try adding <code>-Dsbt.watch.mode=polling</code> to your sbt
options.
</p><p><a href="https://github.com/sbt/sbt/pull/3597">#3597</a> by <a href="https://github.com/stringbean">@stringbean</a>
</p><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting builds, porting plugins, and submitting and reviewing pull requests.
</p><p>This release was brought to you by 15 contributors, according to <code>git shortlog -sn --no-merges v1.0.2..v1.0.3</code> on sbt, zinc, librarymanagement, util, io, and website: Eugene Yokota, Dale Wijnand, Michael Stringer, Jorge Vicente Cantero (jvican), Alexey Alekhin, Antonio Cunei, Andrey Artemov, Jeffrey Olchovy, Kenji Yoshida (xuwei-k), Dominik Winter, Long Jinwei, Arnout Engelen, Justin Kaeser, Leonard Ehrenfried, Sakib Hadžiavdić. Thank you!
</p><hr/><h3 id="sbt+1.0.2">sbt 1.0.2<a href="#sbt+1.0.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is a hotfix release for sbt 1.0.x series.
</p><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes terminal echo issue. <a href="https://github.com/sbt/sbt/pull/3507">#3507</a> by <a href="https://github.com/kczulko">@kczulko</a>
</li><li>Fixes <code>deliver</code> task, and adds <code>makeIvyXml</code> as a more sensibly named task. <a href="https://github.com/sbt/sbt/pull/3487">#3487</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Replaces the deprecated use of <code>OkUrlFactory</code>, and fixes connection leaks. <a href="https://github.com/sbt/librarymanagement/pull/164">lm#164</a> by <a href="https://github.com/dpratt">@dpratt</a>
</li><li>Refixes false positive in DSL checker for setting keys. <a href="https://github.com/sbt/sbt/pull/3513">#3513</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes <code>run</code> and <code>bgRun</code> not picking up changes to directories in the classpath. <a href="https://github.com/sbt/sbt/pull/3517">#3517</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes <code>++</code> so it won’t change the value of <code>crossScalaVersion</code>. <a href="https://github.com/sbt/sbt/issues/3495">#3495</a>/<a href="https://github.com/sbt/sbt/pull/3526">#3526</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes sbt server missing some messages. <a href="https://github.com/sbt/sbt/pull/3523">#3523</a> by <a href="https://github.com/guillaumebort">@guillaumebort</a>
</li><li>Refixes <code>consoleProject</code>. <a href="https://github.com/sbt/zinc/pull/386">zinc#386</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Adds JVM flag <code>sbt.gigahorse</code> to enable/disable the internal use of Gigahorse to workaround NPE in <code>JavaNetAuthenticator</code> when used in conjunction with <code>repositories</code> override. <a href="https://github.com/sbt/librarymanagement/pull/167">lm#167</a> by <a href="https://github.com/cunei">@cunei</a>
</li><li>Adds JVM flag <code>sbt.server.autostart</code> to enable/disable the automatic starting of sbt server with the sbt shell. This also adds new <code>startServer</code> command to manually start the server. by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li></ul><h4 id="Internal">Internal<a href="#Internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes unused import warnings. <a href="https://github.com/sbt/sbt/pull/3533">#3533</a> by <a href="https://github.com/razvan-panda">@razvan-panda</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A huge thank you to everyone who’s helped improve sbt and Zinc 1 by using them, reporting bugs, improving our documentation, porting plugins, and submitting and reviewing pull requests.
</p><p>This release was brought to you by 19 contributors, according to <code>git shortlog -sn --no-merges v1.0.1..v1.0.2</code> on sbt, zinc, librarymanagement, and website: Dale Wijnand, Eugene Yokota, Kenji Yoshida (xuwei-k), Antonio Cunei, David Pratt, Karol Cz (kczulko), Amanj Sherwany, Emanuele Blanco, Eric Peters, Guillaume Bort, James Roper, Joost de Vries, Marko Elezovic, Martynas Mickevičius, Michael Stringer, Răzvan Flavius Panda, Peter Vlugter, Philippus Baalman, and Wiesław Popielarski. Thank you!
</p><hr/><h3 id="sbt+1.0.1">sbt 1.0.1<a href="#sbt+1.0.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is a hotfix release for sbt 1.0.x series.
</p><h4 id="Bug+fixes">Bug fixes<a href="#Bug+fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes command support for cross building <code>+</code> command. The <code>+</code> added to sbt 1.0 traveres over the subprojects, respecting <code>crossScalaVersions</code>; however, it no longer accepted commands as arguments. This brings back the support for it. <a href="https://github.com/sbt/sbt/pull/3446">#3446</a> by <a href="https://github.com/jroper">@jroper</a>
</li><li>Fixes <code>addSbtPlugin</code> to use the correct version of sbt during cross building. <a href="https://github.com/sbt/sbt/pull/3442">#3442</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes <code>run in Compile</code> task not including <code>Runtime</code> configuration, by reimplementing <code>run</code> in terms of <code>bgRun</code>. <a href="https://github.com/sbt/sbt/pull/3477">#3477</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Shows <code>actual</code> as a potential option of <code>inspect</code> <a href="https://github.com/sbt/sbt/pull/3335">#3335</a> by <a href="https://github.com/Duhemm">@Duhemm</a>
</li><li>Includes base directory to watched sources. <a href="https://github.com/sbt/sbt/pull/3439">#3439</a> by <a href="https://github.com/Duhemm">@Duhemm</a>
</li><li>Adds an attempt to workaround intermittent <code>NullPointerException</code> arround logging. <a href="https://github.com/sbt/util/pull/121">util#121</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Reverts a bad forward porting. <a href="https://github.com/sbt/sbt/pull/3481">#3481</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li></ul><h4 id="WatchSource">WatchSource<a href="#WatchSource" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The watch source feature went through a major change from sbt 0.13 to sbt 1.0 using NIO; however, it did not have clear migration path, so we are rectifying that in sbt 1.0.1.
</p><p>First, <code>sbt.WatchSource</code> is a new alias for <code>sbt.internal.io.Source</code>. Hopefully this is easy enough to remember because the key is named <code>watchSources</code>. Next, <code>def apply(base: File)</code> and <code>def apply(base: File, includeFilter: FileFilter, excludeFilter: FileFilter)</code> constructors were added to the companion object of <code>sbt.WatchSource</code>.
</p><p>For backward compatiblity, sbt 1.0.1 adds <code>+=</code> support (<code>Append</code> instance) from <code>File</code> to <code>Seq[WatchSource]</code>.
</p><p>So, if you have a directory you want to watch:
</p><pre><code>watchSources += WatchSource(sourceDirectory.value)
</code></pre><p>If you have a list of files:
</p><pre><code>watchSources ++= (sourceDirectory.value ** &quot;*.scala&quot;).get
</code></pre><p><a href="https://github.com/sbt/sbt/pull/3438">#3438</a> by <a href="https://github.com/Duhemm">@Duhemm</a>; <a href="https://github.com/sbt/sbt/pull/3478">#3478</a> and <a href="https://github.com/sbt/io/pull/74">io#74</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><hr/><h3 id="sbt+1.0.0">sbt 1.0.0<a href="#sbt+1.0.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Features%2C+fixes%2C+changes+with+compatibility+implications">Features, fixes, changes with compatibility implications<a href="#Features%2C+fixes%2C+changes+with+compatibility+implications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Migrating-from-sbt-013x.html">Migrating from sbt 0.13.x</a> also.
</p><ul><li>sbt 1.0 uses <strong>Scala 2.12</strong> for build definitions and plugins. This also requires JDK 8.
</li><li>Many of the case classes are replaced with pseudo case classes generated using Contraband. Migrate <code>.copy(foo = xxx)</code> to <code>withFoo(xxx)</code>.
For example, <code>UpdateConfiguration</code>, <code>RetrieveConfiguration</code>, <code>PublishConfiguration</code> are refactored to use builder pattern.
</li><li>Zinc 1 drops support for Scala 2.9 and earlier. Scala 2.10 must use 2.10.2 and above. Scala 2.11 must use 2.11.2 and above. (latest patch releases are recommended)
</li><li><code>config(&quot;xyz&quot;)</code> must be directly assigned to a <em>capitalized</em> <code>val</code>, like <code>val Xyz = config(&quot;xyz&quot;)</code>. This captures the lhs identifier into the configuration so we can use it from the shell later.
</li><li>Changes <code>publishTo</code> and <code>otherResolvers</code> from SettingKeys to TaskKeys. <a href="https://github.com/sbt/sbt/issues/2059">#2059</a>/<a href="https://github.com/sbt/sbt/pull/2662">#2662</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li><code>Path.relativizeFile(baseFile, file)</code> is renamed to <code>IO.relativizeFile(baseFile, file)</code>.
</li><li><code>PathFinder</code>’s <code>.***</code> method is renamed to <code>.allPaths</code> method.
</li><li><code>PathFinder.x_!(mapper)</code> is moved to <code>def pair</code> on <code>PathFinder</code>.
</li><li>A number of the methods on <code>sbt.Path</code> (such as <code>relativeTo</code> and <code>rebase</code> and <code>flat</code>) are now no longer in the
default namespace by virtue of being mixed into the sbt package object. Use <code>sbt.io.Path</code> to access them
again.
</li><li>sbt 1.0 renames <code>Global</code> as scope component to <code>Zero</code> to disambiguate from <code>GlobalScope</code>. <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>sbt 1.0 uses <code>ConfigRef</code> in places where <code>String</code> was used to reference configuration, such as <code>update.value.configuration(...)</code>. Pass in <code>Configuration</code>, which implicitly converts to <code>ConfigRef</code>.
</li><li>Changes <code>sourceArtifactTypes</code> and <code>docArtifactTypes</code> from <code>Set[String]</code> to <code>Seq[String]</code> settings.
</li><li>Renames early command feature from <code>--&lt;command&gt;</code> to <code>early(&lt;command&gt;)</code>.
</li><li>Drops sbt 0.12 style hyphen-separated key names (use <code>publishLocal</code> instead of <code>publish-local</code>).
</li><li>Log options <code>-error</code>, <code>-warn</code>, <code>-info</code>, <code>-debug</code> are added as shorthand for <code>&quot;early(error)&quot;</code> etc.
</li><li><code>sbt.Process</code> and <code>sbt.ProcessExtra</code> are dropped. Use <code>scala.sys.process</code> instead.
</li><li><code>incOptions.value.withNameHashing(...)</code> option is removed because name hashing is always on.
</li><li><code>TestResult.Value</code> is now called <code>TestResult</code>.
</li><li>The scripted plugin is cross-versioned now, so you must use <code>%%</code> when depending on it.
</li></ul><p><strong>Dropped dreprecations</strong>:
</p><ul><li>sbt 0.12 style <code>Build</code> trait that was deprecated in sbt 0.13.12, is removed. Please <a href="Migrating-from-sbt-013x.html#Migrating+from+the+Build+trait">migrate to build.sbt</a>. Auto plugins and <code>Build</code> trait do not work well together, and its feature is now largely subsumed by multi-project build.sbt.
</li><li>sbt 0.12 style <code>Project(...)</code> constructor is restricted down to two parameters. This is because <code>settings</code> parameter does not work well with Auto Plugins. Use <code>project</code> instead.
</li><li>sbt 0.12 style key dependency operators <code>&lt;&lt;=</code>, <code>&lt;+=</code>, <code>&lt;++=</code> are removed. Please <a href="Migrating-from-sbt-013x.html#Migrating+simple+expressions">migrate to :=, +=, and ++=</a>. These operators have been sources of confusion for many users, and have long been removed from 0.13 docs, and have been formally deprecated since sbt 0.13.13.
</li><li>Non-auto <code>sbt.Plugin</code> trait is dropped. Please migrate to AutoPlugin. Auto plugins are easier to configure, and work better with each other.
</li><li>Removes the <code>settingsSets</code> method from <code>Project</code> (along with <code>add/setSbtFiles</code>).
</li><li>Drops deprecated <code>InputTask</code> <code>apply</code> method and <code>inputTask</code> DSL method. Use <code>Def.inputTask</code> and <code>Def.spaceDelimited().parsed</code>.
</li><li>Drops deprecated <code>ProjectReference</code> implicit lifts. Use <code>RootProject(&lt;uri&gt;)</code>, <code>RootProject(&lt;file&gt;)</code> or <code>LocalProject(&lt;string&gt;)</code>.
</li><li>Drops deprecated <code>seq(..)</code> DSL method. Use <code>Seq</code> or pass in the settings without wrapping.
</li><li>Drops deprecated <code>File</code>/<code>Seq[File]</code> setting enrichments. Use <code>.value</code> and <code>Def.setting</code>.
</li><li>Drops deprecated <code>SubProcess</code> <code>apply</code> overload. Use <code>SubProcess(ForkOptions(runJVMOptions = ..))</code>.
</li><li>Drops <code>toError(opt: Option[String]): Unit</code> (equivalent to <code>opt foreach sys.error</code>); if used to wrap
<code>ScalaRun#run</code> then the replacement is <code>scalaRun.run(...).failed foreach (sys error _.getMessage)</code>
</li></ul><h4 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>New incremental compiler called Zinc 1. Details below.
</li><li>The interactive shell is adds network API. Details below.
</li></ul><h4 id="Fixes">Fixes<a href="#Fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Fixes test content log not showing up. <a href="https://github.com/sbt/sbt/issues/3198">#3198</a>/<a href="https://github.com/sbt/util/pull/80">util#80</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes confusing log about “Unable to parse”. <a href="https://github.com/sbt/librarymanagement/pull/98">lm#98</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Fixes <code>console</code> task. <a href="https://github.com/sbt/zinc/pull/295">zinc#295</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li><li>Fixes spurious recompilations when unrelated constructor changes. <a href="https://github.com/sbt/zinc/pull/288">zinc#288</a> by <a href="https://github.com/smarter">@smarter</a>
</li><li>Fixes restligeist macro for old operators. <a href="https://github.com/sbt/sbt/pull/3218">#3218</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes task caching of <code>update</code> task. <a href="https://github.com/sbt/sbt/pull/3233">#3233</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Fixes ncurses-JLine issue by updating to JLine 2.14.4. <a href="https://github.com/sbt/util/pull/81">util#81</a> by <a href="https://github.com/Rogach">@Rogach</a>
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Scala Center contributed a Java-friendly Zinc API. This was a overhaul of the Zinc internal API for a good Scala integration with other build tools. <a href="https://github.com/sbt/zinc/pull/304">zinc#304</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Scala Center contributed a binary format for Zinc’s internal storage. See below
</li><li>Scala Center contributed static validation of <code>build.sbt</code>. See below
</li><li>Library management API and parallel artifact download. See below.
</li><li>The startup log level is dropped to <code>-error</code> in script mode using <code>scalas</code>. <a href="https://github.com/sbt/sbt/issues/840">#840</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Replace cross building support with sbt-doge. This allows builds with projects that have multiple different combinations of cross scala versions to be cross built correctly.  The behaviour of ++ is changed so that it only updates the Scala version of projects that support that Scala version, but the Scala version can be post fixed with ! to force it to change for all projects. A -v argument has been added that prints verbose information about which projects are having their settings changed along with their cross scala versions. <a href="https://github.com/sbt/sbt/pull/2613">#2613</a> by <a href="https://github.com/jroper">@jroper</a>
</li><li><code>ivyLoggingLevel</code> is dropped to <code>UpdateLogging.Quiet</code> when CI environment is detected. <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Add logging of the name of the different <code>build.sbt</code> (matching <code>*.sbt</code>) files used. <a href="https://github.com/sbt/sbt/issues/1911">#1911</a> by <a href="https://github.com/valydia">@valydia</a>
</li><li>Add the ability to call <a href="Multi-Project.html#Aggregation"><code>aggregate</code></a> for the current project inside a build sbt file. By <a href="https://github.com/xuwei-k">@xuwei-k</a>
</li><li>Add new global setting <code>asciiGraphWidth</code> that controls the maximum width of the ASCII graphs printed by commands like <code>inspect tree</code>. Default value corresponds to the previously hardcoded value of 40 characters. By <a href="https://github.com/RomanIakovlev">@RomanIakovlev</a>.
</li><li>Revamped documentation for <a href="www.scala-sbt.org/0.13/docs/Scopes.html">Scopes</a>, and added <a href="www.scala-sbt.org/0.13/docs/Scope-Delegation.html">Scope Delegation</a>. <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Ports sbt-cross-building’s <code>^</code> and <code>^^</code> commands for plugin cross building. See below.
</li><li>Adds support for cross-versioned exclusions. <a href="https://github.com/sbt/sbt/issues/1518">#1518</a>/<a href="https://github.com/sbt/librarymanagement/pull/88">lm#88</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Adds new offline mode to the Ivy-based library management. <a href="https://github.com/sbt/librarymanagement/pull/92">lm#92</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>A number of features related to dependency locking. See below.
</li><li>Improved eviction warning presentation. See below.
</li><li>A better main class detection. <a href="https://github.com/sbt/zinc/pull/287">zinc#287</a> by <a href="https://github.com/smarter">@smarter</a>
</li><li>For faster startup, sbt will use Java refection to discover <code>autoImport</code> . <a href="https://github.com/sbt/sbt/pull/3115">#3115</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>For faster startup, reuse the same global instance for parsing. <a href="https://github.com/sbt/sbt/pull/3115">#3115</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>Adds <code>InteractionService</code> from sbt-core-next to keep compatibility with sbt 0.13. <a href="https://github.com/sbt/sbt/pull/3182">#3182</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</li><li>Adds new <code>WatchService</code> that abstracts <code>PollingWatchService</code> and Java NIO. <a href="https://github.com/sbt/io/pull/47">io#47</a> by <a href="https://github.com/Duhemm">@Duhemm</a> on behalf of The Scala Center.
</li><li>Adds variants of <code>IO.copyFile</code> and <code>IO.copyDirectory</code> that accept <code>sbt.io.CopyOptions()</code>. See below for details.
</li><li><code>Path.directory</code> and <code>Path.contentOf</code> are donated from sbt-native-packager <a href="https://github.com/sbt/io/pull/38">io#38</a> by <a href="https://github.com/muuki88">@muuki88</a>
</li><li>ApiDiff feature used to debug Zinc uses Scala implementation borrowed from Dotty. <a href="https://github.com/sbt/zinc/pull/346">zinc#346</a> by <a href="https://github.com/Krever">@Krever</a>
</li><li>In Zinc internal, make ExtractAPI use perRunCaches. <a href="https://github.com/sbt/zinc/pull/347">zinc#347</a> by <a href="https://github.com/gheine">@gheine</a>
</li></ul><h4 id="Internals">Internals<a href="#Internals" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Adopted Scalafmt for formatting the source code using neo-scalafmt.
</li><li>Scala Center contributed a redesign of the scripted test framework that has batch mode execution. Scripted now reuses the same sbt instance to run sbt tests, which reduces the CI build times by 50% <a href="https://github.com/sbt/sbt/pull/3151">#3151</a> by <a href="https://github.com/jvican">@jvican</a>
</li><li>sbt 1.0.0-M6 is built using sbt 1.0.0-M5. <a href="https://github.com/sbt/sbt/pull/3184">#3184</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</li></ul><h4 id="Details+of+major+changes">Details of major changes<a href="#Details+of+major+changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><h4 id="Zinc+1%3A+Class-based+name+hashing">Zinc 1: Class-based name hashing<a href="#Zinc+1%3A+Class-based+name+hashing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A major improvement brought into Zinc 1.0 by Grzegorz Kossakowski (commissioned by Lightbend) is class-based name hashing, which will speed up the incremental compilation of Scala in large projects.
</p><p>Zinc 1.0’s name hashing tracks your code dependendencies at the class level, instead of at the source file level. The GitHub issue <a href="https://github.com/sbt/sbt/issues/1104">sbt/sbt#1104</a> lists some comparisons of adding a method to an existing class in some projects:
</p><pre><code class="">ScalaTest   AndHaveWord class:          Before 49s, After 4s (12x)
Specs2      OptionResultMatcher class:  Before 48s, After 1s (48x)
scala/scala Platform class:             Before 59s, After 15s (3.9x)
scala/scala MatchCodeGen class:         Before 48s, After 17s (2.8x)
</code></pre><p>This depends on some factors such as how your classes are organized, but you can see 3x ~ 40x improvements. The reason for the speedup is because it compiles fewer source files than before by untangling the classes from source files. In the example adding a method to scala/scala’s Platform class, sbt 0.13’s name hashing used to compile 72 sources, but the new Zinc compiles 6 sources.
</p><h5 id="Zinc+API+changes">Zinc API changes<a href="#Zinc+API+changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><ul><li>Java classes under the <code>xsbti.compile</code> package such as <code>IncOptions</code> hides the constructor. Use the factory method <code>xsbti.compile.Foo.of(...)</code>.
</li><li>Renames <code>ivyScala: IvyScala</code> key to <code>scalaModuleInfo: ScalaModuleInfo</code>.
</li><li><code>xsbti.Reporter#log(...)</code> takes <code>xsbti.Problem</code> as the parameter. Call <code>log(problem.position, problem.message, problem.severity)</code> to delegate to the older <code>log(...)</code>.
</li><li><code>xsbi.Maybe</code>, <code>xsbti.F0</code>, and <code>sxbti.F1</code> are changed to corresponding Java 8 classes <code>java.util.Optional</code>, <code>java.util.Supplier</code> and <code>java.util.Function</code>.
</li><li>Removes unused “resident” option. <a href="https://github.com/sbt/zinc/pull/345">zinc#345</a> by <a href="https://github.com/lukeindykiewicz">@lukeindykiewicz</a>
</li></ul><h5 id="sbt+server%3A+JSON+API+for+tooling+integration">sbt server: JSON API for tooling integration<a href="#sbt+server%3A+JSON+API+for+tooling+integration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt 1.0 includes server feature, which allows IDEs and other tools to query the build for settings, and invoke commands via a JSON API. Similar to the way that the interactive shell in sbt 0.13 is implemented with <code>shell</code> command, “server” is also just <code>shell</code> command that listens to both human input and network input. As a user, there should be minimal impact because of the server.
</p><p>In March 2016, we <a href="http://eed3si9n.com/sbt-server-reboot">rebooted</a> the “server” feature to make it as small as possible. We worked in collaboration with JetBrains’ @jastice who works on IntelliJ’s sbt interface to narrow down the feature list. sbt 1.0 will not have all the things we originally wanted, but in the long term, we hope to see better integration between IDE and sbt ecosystem using this system. For example, IDEs will be able to issue the compile task and retrieve compiler warning as JSON events:
</p><pre><code class="">{&quot;type&quot;:&quot;xsbti.Problem&quot;,&quot;message&quot;:{&quot;category&quot;:&quot;&quot;,&quot;severity&quot;:&quot;Warn&quot;,&quot;message&quot;:&quot;a pure expression does nothing in statement position; you may be omitting necessary parentheses&quot;,&quot;position&quot;:{&quot;line&quot;:2,&quot;lineContent&quot;:&quot;  1&quot;,&quot;offset&quot;:29,&quot;pointer&quot;:2,&quot;pointerSpace&quot;:&quot;  &quot;,&quot;sourcePath&quot;:&quot;/tmp/hello/Hello.scala&quot;,&quot;sourceFile&quot;:&quot;file:/tmp/hello/Hello.scala&quot;}},&quot;level&quot;:&quot;warn&quot;}
</code></pre><p>Another related feature that was added is the <code>bgRun</code> task which, for example, enables a server process to be run in the background while you run tests against it.
</p><h5 id="Static+validation+of+build.sbt">Static validation of build.sbt<a href="#Static+validation+of+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt 1.0 prohibits <code>.value</code> calls inside the bodies of if expressions and anonymous functions in a task, <code>@sbtUnchecked</code> annotation can be used to override the check.
</p><p>The static validation also catches if you forget to call <code>.value</code> in a body of a task.
</p><p><a href="https://github.com/sbt/sbt/pull/3216">#3216</a> and <a href="https://github.com/sbt/sbt/pull/3225">#3225</a> by <a href="https://github.com/jvican">@jvican</a>
</p><h5 id="Eviction+warning+presentation">Eviction warning presentation<a href="#Eviction+warning+presentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt 1.0 improves the eviction warning presetation.
</p><p>Before:
</p><pre><code>[warn] There may be incompatibilities among your library dependencies.
[warn] Here are some of the libraries that were evicted:
[warn]  * com.google.code.findbugs:jsr305:2.0.1 -&gt; 3.0.0
[warn] Run 'evicted' to see detailed eviction warnings
</code></pre><p>After:
</p><pre><code>[warn] Found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
[warn]
[warn]      * com.typesafe.akka:akka-actor_2.12:2.5.0 is selected over 2.4.17
[warn]          +- de.heikoseeberger:akka-log4j_2.12:1.4.0            (depends on 2.5.0)
[warn]          +- com.typesafe.akka:akka-parsing_2.12:10.0.6         (depends on 2.4.17)
[warn]          +- com.typesafe.akka:akka-stream_2.12:2.4.17 ()       (depends on 2.4.17)
[warn]
[warn] Run 'evicted' to see detailed eviction warnings
</code></pre><p><a href="https://github.com/sbt/sbt/pull/3202">#3202</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>
</p><h5 id="sbt-cross-building">sbt-cross-building<a href="#sbt-cross-building" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><a href="https://github.com/jrudolph">@jrudolph</a>’s sbt-cross-building is a plugin author’s plugin.
It adds cross command <code>^</code> and sbtVersion switch command <code>^^</code>, similar to <code>+</code> and <code>++</code>,
but for switching between multiple sbt versions across major versions.
sbt 0.13.16 merges these commands into sbt because the feature it provides is useful as we migrate plugins to sbt 1.0.
</p><p>To switch the <code>sbtVersion in pluginCrossBuild</code> from the shell use:
</p><pre><code class="">^^ 1.0.0-M5
</code></pre><p>Your plugin will now build with sbt 1.0.0-M5 (and its Scala version 2.12.2).
</p><p>If you need to make changes specific to a sbt version, you can now include them into <code>src/main/scala-sbt-0.13</code>,
and <code>src/main/scala-sbt-1.0.0-M5</code>, where the binary sbt version number is used as postfix.
</p><p>To run a command across multiple sbt versions, set:
</p><pre><code class="prettyprint lang-scala">crossSbtVersions := Vector(&quot;0.13.15&quot;, &quot;1.0.0-M5&quot;)
</code></pre><p>Then, run:
</p><pre><code class="">^ compile
</code></pre><p><a href="https://github.com/sbt/sbt/pull/3133">#3133</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a> (forward ported from 0.13.16-M1)
</p><h5 id="CopyOptions">CopyOptions<a href="#CopyOptions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt IO 1.0 add variant of <code>IO.copyFile</code> and <code>IO.copyDirectory</code> that accept <code>sbt.io.CopyOptions()</code>.
<code>CopyOptions()</code> is an example of pseudo case class similar to the builder pattern.
</p><pre><code class="prettyprint lang-scala">import sbt.io.{ IO, CopyOptions }

IO.copyDirectory(source, target)

// The above is same as the following
IO.copyDirectory(source, target, CopyOptions()
  .withOverwrite(false)
  .withPreserveLastModified(true)
  .withPreserveExecutable(true))
</code></pre><p><a href="https://github.com/sbt/io/pull/53">io#53</a> by <a href="https://github.com/dwijnand">@dwijnand</a>
</p><h5 id="Library+management+API+and+parallel+artifact+download">Library management API and parallel artifact download<a href="#Library+management+API+and+parallel+artifact+download" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt 1.0 adds Library management API co-authored by Eugene Yokota (<a href="https://github.com/eed3si9n">@eed3si9n</a>) from Lightbend and Martin Duhem (<a href="https://github.com/Duhemm">@Duhemm</a>) from Scala Center.
This API aims to abstract Apache Ivy as well as alternative dependency resolution engines Ivy, cached resolution, and Coursier.
</p><p>Parallel artifact download for Ivy engine was contributed by Jorge (<a href="https://github.com/jvican">@jvican</a>) from Scala Center.
It also introduces Gigahorse OkHttp as the Network API, and it uses Square OkHttp for artifact download as well.
</p><p><a href="https://github.com/sbt/librarymanagement/pull/124">lm#124</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>/<a href="https://github.com/Duhemm">@Duhemm</a>,
<a href="https://github.com/sbt/librarymanagement/pull/90">lm#90</a> by <a href="https://github.com/jvican">@jvican</a>/<a href="https://github.com/jsuereth">@jsuereth</a>
and <a href="https://github.com/sbt/librarymanagement/pull/104">lm#104</a> by <a href="https://github.com/eed3si9n">@eed3si9n</a>.
</p><h5 id="Binary+format+for+Zinc%E2%80%99s+internal+storage">Binary format for Zinc’s internal storage<a href="#Binary+format+for+Zinc%E2%80%99s+internal+storage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Jorge (<a href="https://github.com/jvican">@jvican</a>) from Scala Center contributed a binary format for Zinc’s internal storage using Google Procol Buffer.
The new format provides us with three main advantages:
</p><ol><li>Backwards and forwards binary compatibility at the analysis format level.
</li><li>Faster (1.5 ~ 2x) serialization/deserialization of the analysis file.
</li><li>Provides a better way to make the analysis file machine-independent.
</li></ol><p><a href="https://github.com/sbt/zinc/pull/351">zinc#351</a> by <a href="https://github.com/jvican">@jvican</a>
</p><h5 id="Dependency+locking">Dependency locking<a href="#Dependency+locking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Dependency locking feature is still in progress, but Jorge (<a href="https://github.com/jvican">@jvican</a>) from Scala Center has added a number of related features
that would should work together to allow dependency locking.
</p><ul><li>Frozen mode to the Ivy-based library management, which makes sure that the resolution is always intransitive. <a href="https://github.com/sbt/librarymanagement/pull/100">lm#100</a>
</li><li>Adds support to specify a resolver for dependencies. <a href="https://github.com/sbt/librarymanagement/pull/97">lm#97</a>
</li><li>Adds “managed checksums”, which tells Ivy to skip the checksum process. <a href="https://github.com/sbt/librarymanagement/pull/111">lm#111</a>
</li></ul><h4 id="Contributors">Contributors<a href="#Contributors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Too many people to thank here. See <a href="Credits.html">Credits</a>
</p><h2 id="Detailed+Topics">Detailed Topics<a href="#Detailed+Topics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><p>Other resources include the
<a href="Howto.html">How to</a> and
<a href="Developers-Guide.html">Developer’s Guide</a>
sections in this reference, and the
<a href="../api/index.html">API Documentation</a>
</p><h2 id="Using+sbt">Using sbt<a href="#Using+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Command+Line+Reference">Command Line Reference<a href="#Command+Line+Reference" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page is a relatively complete list of command line options,
commands, and tasks you can use from the sbt interactive prompt or in
batch mode. See <a href="Running.html">Running</a> in the Getting
Started Guide for an intro to the basics, while this page has a lot more
detail.
</p><h3 id="Notes+on+the+command+line">Notes on the command line<a href="#Notes+on+the+command+line" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>There is a technical distinction in sbt between <em>tasks</em>, which are
“inside” the build definition, and <em>commands</em>, which manipulate the
build definition itself. If you’re interested in creating a command,
see <a href="Commands.html">Commands</a>. This specific sbt meaning of “command”
means there’s no good general term for “thing you can type at the
sbt prompt”, which may be a setting, task, or command.
</li><li>Some tasks produce useful values. The <code>toString</code> representation of
these values can be shown using <code>show &lt;task&gt;</code> to run the task
instead of just <code>&lt;task&gt;</code>.
</li><li>In a multi-project build, execution dependencies and the aggregate
setting control which tasks from which projects are executed. See
<a href="Multi-Project.html">multi-project builds</a>.
</li></ul><h3 id="Project-level+tasks">Project-level tasks<a href="#Project-level+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>clean</code> Deletes all generated files (the <code>target</code> directory).
</li><li><code>publishLocal</code> Publishes artifacts (such as jars) to the local Ivy
repository as described in Publishing.
</li><li><code>publish</code> Publishes artifacts (such as jars) to the repository
defined by the publishTo setting, described in Publishing.
</li><li><code>update</code> Resolves and retrieves external dependencies as described
in <a href="Library-Dependencies.html">library dependencies</a>.
</li></ul><h3 id="Configuration-level+tasks">Configuration-level tasks<a href="#Configuration-level+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Configuration-level tasks are tasks associated with a configuration. For
example, <code>compile</code>, which is equivalent to <code>compile:compile</code>, compiles
the main source code (the <code>compile</code> configuration). <code>test:compile</code>
compiles the test source code (test <code>test</code> configuration). Most tasks
for the <code>compile</code> configuration have an equivalent in the <code>test</code>
configuration that can be run using a <code>test:</code> prefix.
</p><ul><li><code>compile</code> Compiles the main sources (in the <code>src/main/scala</code>
directory). <code>test:compile</code> compiles test sources (in the
src/test/scala/ directory).
</li><li><code>console</code> Starts the Scala interpreter with a classpath including
the compiled sources, all jars in the lib directory, and managed
libraries. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z
(Windows). Similarly, test:console starts the interpreter with the
test classes and classpath.
</li><li><code>consoleQuick</code> Starts the Scala interpreter with the project’s
compile-time dependencies on the classpath. test:consoleQuick uses
the test dependencies. This task differs from console in that it
does not force compilation of the current project’s sources.
</li><li><code>consoleProject</code> Enters an interactive session with sbt and the
build definition on the classpath. The build definition and related
values are bound to variables and common packages and values are
imported. See the <a href="Console-Project.html">consoleProject documentation</a>
for more information.
</li><li><code>doc</code> Generates API documentation for Scala source files in
<code>src/main/scala</code> using scaladoc. <code>test:doc</code> generates API documentation
for source files in <code>src/test/scala</code>.
</li><li><code>package</code> Creates a jar file containing the files in
<code>src/main/resources</code> and the classes compiled from <code>src/main/scala</code>.
<code>test:package</code> creates a jar containing the files in
<code>src/test/resources</code> and the class compiled from <code>src/test/scala</code>.
</li><li><code>packageDoc</code> Creates a jar file containing API documentation
generated from Scala source files in src/main/scala. test:packageDoc
creates a jar containing API documentation for test sources files in
src/test/scala.
</li><li><code>packageSrc</code>: Creates a jar file containing all main source files
and resources. The packaged paths are relative to src/main/scala and
src/main/resources. Similarly, test:packageSrc operates on test
source files and resources.
</li><li><code>run &lt;argument&gt;*</code> Runs the main class for the project in the same
virtual machine as sbt. The main class is passed the arguments
provided. Please see
<a href="Running-Project-Code.html">Running Project Code</a> for details on the use of
System.exit and multithreading (including GUIs) in code run by this
action. <code>test:run</code> runs a main class in the test code.
</li><li><code>runMain &lt;main-class&gt; &lt;argument&gt;*</code> Runs the specified main class for
the project in the same virtual machine as sbt. The main class is
passed the arguments provided. Please see
<a href="Running-Project-Code.html">Running Project Code</a> for
details on the use of System.exit and multithreading (including
GUIs) in code run by this action. <code>test:runMain</code> runs the specified
main class in the test code.
</li><li><code>test</code> Runs all tests detected during test compilation. See <a href="Testing.html">Testing</a>
for details.
</li><li><code>testOnly &lt;test&gt;*</code> Runs the tests provided as arguments. <code>*</code> (will
be) interpreted as a wildcard in the test name. See <a href="Testing.html">Testing</a> for
details.
</li><li><p><code>testQuick &lt;test&gt;*</code> Runs the tests specified as arguments (or all
tests if no arguments are given) that:
</p><ol><li>have not been run yet OR
</li><li>failed the last time they were run OR
</li><li>had any transitive dependencies recompiled since the last
successful run <code>*</code> (will be) interpreted as a wildcard in the
test name. See [Testing][Testing] for details.
</li></ol></li></ul><h3 id="General+commands">General commands<a href="#General+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>exit</code> or <code>quit</code> End the current interactive session or build.
Additionally, Ctrl+D (Unix) or Ctrl+Z (Windows) will exit the
interactive prompt.
</li><li><code>help &lt;command&gt;</code> Displays detailed help for the specified command.
If the command does not exist, help lists detailed help for commands
whose name or description match the argument, which is interpreted
as a regular expression. If no command is provided, displays brief
descriptions of the main commands. Related commands are tasks and
settings.
</li><li><code>projects [add|remove &lt;URI&gt;]</code> List all available projects if no
arguments provided or adds/removes the build at the provided URI.
(See <a href="Multi-Project.html">multi-project builds</a> for details on multi-project
builds.)
</li><li><code>project &lt;project-id&gt;</code> Change the current project to the project
with ID <code>&lt;project-id&gt;</code>. Further operations will be done in the
context of the given project. (See <a href="Multi-Project.html">multi-project builds</a> for
details on multiple project builds.)
</li><li><code>~ &lt;command&gt;</code> Executes the project specified action or method
whenever source files change. See
<a href="Triggered-Execution.html">Triggered Execution</a> for details.
</li><li><code>&lt; filename</code> Executes the commands in the given file. Each command
should be on its own line. Empty lines and lines beginning with ’#’
are ignored
</li><li><code>+ &lt;command&gt;</code> Executes the project specified action or method for
all versions of Scala defined in the crossScalaVersions setting.
</li><li><code>++ &lt;version|home-directory&gt; &lt;command&gt;</code> Temporarily changes the
version of Scala building the project and executes the provided
command. <code>&lt;command&gt;</code> is optional. The specified version of Scala is
used until the project is reloaded, settings are modified (such as
by the set or session commands), or ++ is run again. <code>&lt;version&gt;</code>
does not need to be listed in the build definition, but it must be
available in a repository. Alternatively, specify the path to a
Scala installation.
</li><li><code>; A ; B</code> Execute A and if it succeeds, run B. Note that the leading
semicolon is required.
</li><li><p><code>eval &lt;Scala-expression&gt;</code> Evaluates the given Scala expression and
returns the result and inferred type. This can be used to set system
properties, as a calculator, to fork processes, etc … For example:
</p><pre><code>&gt; eval System.setProperty(&quot;demo&quot;, &quot;true&quot;)
&gt; eval 1+1
&gt; eval &quot;ls -l&quot; !
</code></pre></li></ul><h3 id="Commands+for+managing+the+build+definition">Commands for managing the build definition<a href="#Commands+for+managing+the+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>reload [plugins|return]</code> If no argument is specified, reloads the
build, recompiling any build or plugin definitions as necessary.
reload plugins changes the current project to the build definition
project (in project/). This can be useful to directly manipulate the
build definition. For example, running clean on the build definition
project will force snapshots to be updated and the build definition
to be recompiled. reload return changes back to the main project.
</li><li><code>set &lt;setting-expression&gt;</code> Evaluates and applies the given setting
definition. The setting applies until sbt is restarted, the build is
reloaded, or the setting is overridden by another set command or
removed by the session command. See
[.sbt build definition][Basic-Def] and
[inspecting settings][Inspecting-Settings] for details.
</li><li><code>session &lt;command&gt;</code> Manages session settings defined by the <code>set</code>
command. It can persist settings configured at the prompt. See
Inspecting-Settings for details.
</li><li><code>inspect &lt;setting-key&gt;</code> Displays information about settings, such as
the value, description, defining scope, dependencies, delegation
chain, and related settings. See
<a href="Inspecting-Settings.html">Inspecting Settings</a> for details.
</li></ul><h3 id="Command+Line+Options">Command Line Options<a href="#Command+Line+Options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>System properties can be provided either as JVM options, or as SBT
arguments, in both cases as <code>-Dprop=value</code>. The following properties
influence SBT execution. Also see <a href="Sbt-Launcher.html">sbt launcher</a>.
</p><table class="table table-striped">
  <tr>
    <th>Property</th>
    <th>Values</th>
    <th>Default</th>
    <th>Meaning</th>
  </tr>

  <tr>
    <td><tt>sbt.banner</tt></td>
    <td>Boolean</td>
    <td><tt>true</tt> (in 1.3+)</td>
    <td>Show a welcome banner advertising new features.</td>
  </tr>

  <tr>
    <td><tt>sbt.boot.directory</tt></td>
    <td>Directory</td>
    <td><tt>~/.sbt/boot</tt></td>
    <td>Path to shared boot directory.  You should define <tt>sbt.boot.directory</tt> explicitly if you are using sbt in a CI environment and want to cache sbt boot classes between runs.</td>
  </tr>

  <tr>
    <td><tt>sbt.boot.properties</tt></td>
    <td>File</td>
    <td>Roughly <tt>sbt.boot.properties</tt> internal to the sbt launcher and specific to the sbt version.</td>
    <td>The path to find the sbt <a href="Launcher-Configuration.html">boot
        properties</a> file. This can be a
        relative path, relative to the sbt base directory, the users
        home directory or the location of the sbt jar file, or it can
        be an absolute path or an absolute file URI.</td>
  </tr>

  <tr>
    <td><tt>sbt.ci</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt> (unless then env var <tt>BUILD_NUMBER</tt> is set)</td>
    <td>For continuous integration environments. Suppress supershell and color.</td>
  </tr>

  <tr>
    <td><tt>sbt.client</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td></td>
  </tr>

  <tr>
    <td><tt>sbt.color</tt></td>
    <td>String</td>
    <td><tt>auto</tt></td>
    <td>Supercedes <tt>sbt.log.format</tt>.
    To turn on color, use <tt>always</tt> or <tt>true</tt>.
    To turn off color, use <tt>never</tt> or <tt>false>.
    To use color if the output is a terminal (not a pipe) that supports color, use <tt>auto</tt>.</td>
  </tr>

  <tr>
    <td><tt>sbt.coursier</tt></td>
    <td>Boolean</td>
    <td><tt>true</tt> (in 1.3+)</td>
    <td>Use coursier to retrieve packages. (See also <tt>sbt.ivy</tt>.)</td>
  </tr>

  <tr>
    <td><tt>sbt.coursier.home</tt></td>
    <td>Directory</td>
    <!-- https://github.com/sbt/sbt/blob/v1.3.1/main/src/main/scala/sbt/coursierint/LMCoursier.scala#L40-L44 -->
    <td><tt>CoursierDependencyResolution.defaultCacheLocation</tt> (in 1.3+)</td>
    <td>Location of coursier artifact cache, where the default is defined by <a href="https://get-coursier.io/docs/cache.html#default-location">Coursier cache resolution logic</a>.  You should define <tt>sbt.coursier.home</tt> explicitly if you are using coursier in a CI environment and want to cache artifacts between runs.</td>
  </tr>

  <tr>
    <td><tt>sbt.extraClasspath</tt></td>
    <td>Classpath Entries</td>
    <td><tt></tt></td>
    <td>(jar files or directories) that are added to sbt's classpath.
        Note that the entries are delimited by comma, e.g.:
        <tt>entry1, entry2,..</tt>. See also <tt>resource</tt> in the
        <a href="Launcher-Configuration.html">sbt launcher</a> documentation.
        </td>
  </tr>

  <tr>
    <td><tt>sbt.genbuildprops</tt></td>
    <td>Boolean</td>
    <td><tt>true</tt></td>
    <td>Generate <tt>build.properties</tt> if missing.
        If unset, this defers to <tt>sbt.skip.version.write</tt>.</td>
  </tr>

  <tr>
    <td><tt>sbt.global.base</tt></td>
    <td>Directory</td>
    <td><tt>$HOME/.sbt/1.0</tt></td>
    <td>The directory containing global settings and plugins.</td>
  </tr>

  <tr>
    <td><tt>xsbt.inc.debug</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Extra debugging for the incremental debugger.</td>
  </tr>

  <tr>
    <td><tt>sbt.ivy</tt></td>
    <td>Boolean</td>
    <td><tt>true</tt> (in <1.3)</td>
    <td>Use ivy to retrieve packages.</td>
  </tr>

  <tr>
    <td><tt>sbt.ivy.home</tt></td>
    <td>Directory</td>
    <td><tt>~/.ivy2</tt></td>
    <td>The directory containing the local Ivy repository and artifact cache.  You should define <tt>sbt.ivy.home</tt> explicitly if you are using sbt in a CI environment and want to cache ivy artifacts between runs.</td>
  </tr>

  <tr>
    <td><tt>sbt.log.noformat</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>If true, disable ANSI color
        codes. Useful on build servers
        or terminals that do not support
        color.</td>
  </tr>

  <tr>
    <td><tt>sbt.main.class</tt></td>
    <td>String</td>
    <td><tt>sbt.xMain</tt></td>
    <td>The sbt class to use (<a
        href="Scripts.html#Manual+Setup">alternatives</a> include
        <tt>sbt.ConsoleMain</tt> and <tt>sbt.ScriptMain</tt>).</td>
  </tr>

  <tr>
    <td><tt>sbt.offline</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Avoid retrieving classes from repositories.</td>
  </tr>

  <tr>
    <td><tt>sbt.override.build.repos</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>If true, repositories configured in a build definition
        are ignored and the repositories configured for the launcher are
        used instead. See <tt>sbt.repository.config</tt> and the
        <a href="Launcher-Configuration.html">sbt launcher</a> documentation.</td>
  </tr>

  <tr>
    <td><tt>sbt.progress</tt></td>
    <td>String</td>
    <td><tt>?</tt></td>
    <td>Use <tt>always</tt> to show progress ("supershell").</td>
  </tr>

  <tr>
    <td><tt>sbt.repository.config</tt></td>
    <td>File</td>
    <td><tt>~/.sbt/repositories</tt></td>
    <td>A file containing the repositories to use for the
        launcher. The format is the same as a
        <tt>[repositories]</tt> section for a
        <a href="Launcher-Configuration.html">sbt launcher</a> configuration file.
        This setting is typically used in conjunction with setting
        <tt>sbt.override.build.repos</tt> to
        <tt>true</tt> (see <tt>sbt.override.build.repos</tt> and the
        <a href="Launcher-Configuration.html">sbt launcher</a> documentation).</td>
  </tr>

  <tr>
    <td><tt>sbt.resident.limit</tt></td>
    <td>Number</td>
    <td><tt>0</tt></td>
    <td>The number of scala compilers to keep around.
        This experimental feature was intended to improve compilation time.
        It does not appear to have succeeded and this flag will probably be removed.</td>
  </tr>

  <tr>
    <td><tt>sbt.skip.version.write</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Generate <tt>build.properties</tt> if missing. See <tt>sbt.genbuildprops</tt>.</td>
  </tr>

  <tr>
    <td><tt>sbt.supershell</tt></td>
    <td>Boolean</td>
    <td><tt>true</tt> if color is enabled</td>
    <td>Use supershell (show progress at bottom of shell).</td>
  </tr>

  <tr>
    <td><tt>sbt.supershell.sleep</tt></td>
    <td>Number</td>
    <td><tt>100</tt></td>
    <td>Time to wait between updating the supershell progress area.</td>
  </tr>

  <tr>
    <td><tt>sbt.task.timings</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Measure the time elapsed for running tasks.</td>
  </tr>

  <tr>
    <td><tt>sbt.task.timings.omit.paths</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Omit paths when reporting timings.</td>
  </tr>

  <tr>
    <td><tt>sbt.task.timings.on.shutdown</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Report timings at JVM shutdown (instead of at task completion).</td>
  </tr>

  <tr>
    <td><tt>sbt.task.timings.threshold</tt></td>
    <td>String</td>
    <td><tt>0</tt></td>
    <td>Omit items from timing report if they are below this threshold.</td>
  </tr>

  <tr>
    <td><tt>sbt.traces</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Generate Chrome Trace Event Format log for tasks.</td>
  </tr>

  <tr>
    <td><tt>sbt.turbo</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>Use additional layered class loaders.</td>
  </tr>

  <tr>
    <td><tt>sbt.version</tt></td>
    <td>Version</td>
    <td><tt>1.4.7</tt></td>
    <td>sbt version to use, usually taken from <tt>project/build.properties</tt>.</td>
  </tr>

  <tr>
    <td><tt>sbt.watch.mode</tt></td>
    <td>String</td>
    <td><tt>auto</tt></td>
    <td>If <tt>polling</tt>, check file system periodically for updates.</td>
  </tr>
</table><h2 id="Console+Project">Console Project<a href="#Console+Project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Description">Description<a href="#Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>consoleProject</code> task starts the Scala interpreter with access to
your project definition and to <code>sbt</code>. Specifically, the interpreter is
started up with these commands already executed:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._
import &lt;your-project-definition&gt;._
import currentState._
import extracted._
import cpHelpers._
</code></pre><p>For example, running external processes with sbt’s process library (to
be included in the standard library in Scala 2.9):
</p><pre><code class="">&gt; &quot;tar -zcvf project-src.tar.gz src&quot; !
&gt; &quot;find project -name *.jar&quot; !
&gt; &quot;cat build.sbt&quot; #| &quot;grep version&quot; #&gt; new File(&quot;sbt-version&quot;) !
&gt; &quot;grep -r null src&quot; #|| &quot;echo null-free&quot; !
&gt; uri(&quot;http://databinder.net/dispatch/About&quot;).toURL #&gt; file(&quot;About.html&quot;) !
</code></pre><p><code>consoleProject</code> can be useful for creating and modifying your build in
the same way that the Scala interpreter is normally used to explore
writing code. Note that this gives you raw access to your build. Think
about what you pass to <code>IO.delete</code>, for example.
</p><h3 id="Accessing+settings">Accessing settings<a href="#Accessing+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To get a particular setting, use the form:
</p><pre><code class="prettyprint lang-scala">&gt; val value = (&lt;scope&gt; / &lt;key&gt;).eval
</code></pre><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">&gt; IO.delete( (Compile / classesDirectory).eval )
</code></pre><p>Show current compile options:
</p><pre><code class="prettyprint lang-scala">&gt; (Compile / scalacOptions).eval foreach println
</code></pre><p>Show additionally configured repositories.
</p><pre><code class="prettyprint lang-scala">&gt; resolvers.eval foreach println
</code></pre><h3 id="Evaluating+tasks">Evaluating tasks<a href="#Evaluating+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To evaluate a task (and its dependencies), use the same form:
</p><pre><code class="prettyprint lang-scala">&gt; val value = (&lt;scope&gt; / &lt;key&gt;).eval
</code></pre><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Show all repositories, including defaults.
</p><pre><code class="prettyprint lang-scala">&gt; fullResolvers.eval foreach println
</code></pre><p>Show the classpaths used for compilation and testing:
</p><pre><code class="prettyprint lang-scala">&gt; (Compile / fullClasspath).eval.files foreach println
&gt; (Test / fullClasspath).eval.files foreach println
</code></pre><h3 id="State">State<a href="#State" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The current <a href="Build-State.html">build State</a> is available as
<code>currentState</code>. The contents of <code>currentState</code> are imported by default
and can be used without qualification.
</p><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Show the remaining commands to be executed in the build (more
interesting if you invoke <code>consoleProject</code> like
<code>; consoleProject ; clean ; compile</code>):
</p><pre><code class="prettyprint lang-scala">&gt; remainingCommands
</code></pre><p>Show the number of currently registered commands:
</p><pre><code class="prettyprint lang-scala">&gt; definedCommands.size
</code></pre><h2 id="Cross-building">Cross-building<a href="#Cross-building" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Different versions of Scala can be binary incompatible, despite
maintaining source compatibility. This page describes how to use <code>sbt</code>
to build and publish your project against multiple versions of Scala and
how to use libraries that have done the same.
</p><p>For cross building sbt plugins see also <a href="Cross-Build-Plugins.html">Cross building plugins</a>.
</p><h3 id="Publishing+conventions">Publishing conventions<a href="#Publishing+conventions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The underlying mechanism used to indicate which version of Scala a
library was compiled against is to append <code>_&lt;scala-binary-version&gt;</code> to the
library’s name. For example, the artifact name <code>dispatch-core_2.12</code> is used
when compiled against Scala 2.12.0, 2.12.1 or any 2.12.x version. This fairly simple approach
allows interoperability with users of Maven, Ant and other build tools.
</p><p>For pre-prelease versions of Scala such as 2.13.0-RC1 and for versions prior to 2.10.x,
full version is used as the suffix.
</p><p>The rest of this page describes how sbt handles this for you as part
of cross-building.
</p><h3 id="Using+cross-built+libraries">Using cross-built libraries<a href="#Using+cross-built+libraries" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To use a library built against multiple versions of Scala, double the
first <code>%</code> in an inline dependency to be <code>%%</code>. This tells <code>sbt</code> that it
should append the current version of Scala being used to build the
library to the dependency’s name. For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;net.databinder.dispatch&quot; %% &quot;dispatch-core&quot; % &quot;0.13.3&quot;
</code></pre><p>A nearly equivalent, manual alternative for a fixed version of Scala is:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;net.databinder.dispatch&quot; % &quot;dispatch-core_2.12&quot; % &quot;0.13.3&quot;
</code></pre><h3 id="Cross+building+a+project+using+sbt-projectmatrix">Cross building a project using sbt-projectmatrix<a href="#Cross+building+a+project+using+sbt-projectmatrix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Consider using <a href="https://github.com/sbt/sbt-projectmatrix">sbt-projectmatrix</a> that
is capable of cross building across Scala versions and different platforms in parallel.
</p><h3 id="Cross+building+a+project+statefully">Cross building a project statefully<a href="#Cross+building+a+project+statefully" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Define the versions of Scala to build against in the
<code>crossScalaVersions</code> setting. Versions of Scala 2.10.2 or later are
allowed. For example, in a <code>.sbt</code> build definition:
</p><pre><code class="prettyprint lang-scala">lazy val scala212 = &quot;2.12.13&quot;
lazy val scala211 = &quot;2.11.12&quot;
lazy val supportedScalaVersions = List(scala212, scala211)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := scala212

lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)
  .settings(
    // crossScalaVersions must be set to Nil on the aggregating project
    crossScalaVersions := Nil,
    publish / skip := true
  )

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    crossScalaVersions := supportedScalaVersions,
    // other settings
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    crossScalaVersions := supportedScalaVersions,
    // other settings
  )
</code></pre><p><strong>Note</strong>: <code>crossScalaVersions</code> must be set to <code>Nil</code> on the root project to avoid double publishing.
</p><p>To build against all versions listed in <code>crossScalaVersions</code>, prefix
the action to run with <code>+</code>. For example:
</p><pre><code class="">&gt; + test
</code></pre><p>A typical way to use this feature is to do development on a single Scala
version (no <code>+</code> prefix) and then cross-build (using <code>+</code>) occasionally
and when releasing.
</p><h3 id="Change+settings+depending+on+the+Scala+version">Change settings depending on the Scala version<a href="#Change+settings+depending+on+the+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here’s how we can change some settings depending on the Scala version.
<code>CrossVersion.partialVersion(scalaVersion.value)</code> returns <code>Option[(Int, Int)]</code> containing
the first two segments of the Scala version.
</p><p>This can be useful for instance if you include a dependency that requires the macro paradise
compiler plugin for Scala 2.12 and the <code>-Ymacro-annotations</code> compiler option for Scala 2.13.
</p><pre><code class="prettyprint lang-scala">lazy val core = (project in file(&quot;core&quot;))
  .settings(
    crossScalaVersions := supportedScalaVersions,
    libraryDependencies ++= {
      CrossVersion.partialVersion(scalaVersion.value) match {
        case Some((2, n)) if n &lt;= 12 =&gt;
          List(compilerPlugin(&quot;org.scalamacros&quot; % &quot;paradise&quot; % &quot;2.1.1&quot; cross CrossVersion.full))
        case _                       =&gt; Nil
      }
    },
    Compile / scalacOptions ++= {
      CrossVersion.partialVersion(scalaVersion.value) match {
        case Some((2, n)) if n &lt;= 12 =&gt; Nil
        case _                       =&gt; List(&quot;-Ymacro-annotations&quot;)
      }
    },
  )
</code></pre><a name="crossPaths"></a><h4 id="Scala-version+specific+source+directory">Scala-version specific source directory<a href="#Scala-version+specific+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to <code>src/main/scala/</code> directory, <code>src/main/scala-&lt;scala binary version&gt;/</code>
directory is included as a source directory.
For, example if the current subproject’s <code>scalaVersion</code> is 2.12.10, then
<code>src/main/scala-2.12</code> is included as a Scala-version specific source.
</p><p>By <code>crossPaths</code> setting to <code>false</code> you can opt out of both Scala-version source directory
and the <code>_&lt;scala-binary-version&gt;</code> publishing convention. This might be useful for non-Scala projects.
</p><p>Similarly, the build products such as <code>*.class</code> files are written into
<code>crossTarget</code> directory, which by default is <code>target/scala-&lt;scala binary version&gt;</code>.
</p><h4 id="Cross+building+with+a+Java+project">Cross building with a Java project<a href="#Cross+building+with+a+Java+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A special care must be taken when cross building involves pure Java project.
Let’s say in the following example, <code>network</code> is a Java project, and <code>core</code> is
a Scala project that depends on <code>network</code>.
</p><pre><code class="prettyprint lang-scala">lazy val scala212 = &quot;2.12.13&quot;
lazy val scala211 = &quot;2.11.12&quot;
lazy val supportedScalaVersions = List(scala212, scala211)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := scala212

lazy val root = (project in file(&quot;.&quot;))
  .aggregate(network, core)
  .settings(
    // crossScalaVersions must be set to Nil on the aggregating project
    crossScalaVersions := Nil,
    publish / skip := false
  )

// example Java project
lazy val network = (project in file(&quot;network&quot;))
  .settings(
    // set to exactly one Scala version
    crossScalaVersions := List(scala212),
    crossPaths := false,
    autoScalaLibrary := false,
    // other settings
  )

lazy val core = (project in file(&quot;core&quot;))
  .dependsOn(network)
  .settings(
    crossScalaVersions := supportedScalaVersions,
    // other settings
  )
</code></pre><ol><li><code>crossScalaVersions</code> must be set to <code>Nil</code> on the aggregating projects such as the root.
</li><li>Java subprojects should set <code>crossPaths</code> to false, which turns off the <code>_&lt;scala-binary-version&gt;</code> publishing convention and the Scala-version specific source directory.
</li><li>Java subprojects should have exactly one Scala version in <code>crossScalaVersions</code> to avoid double publishing, typically <code>scala212</code>.
</li><li>Scala subprojects can have multiple Scala versions in <code>crossScalaVersions</code>, but must avoid aggregating Java subprojects.
</li></ol><h4 id="Switching+Scala+version">Switching Scala version<a href="#Switching+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You can use <code>++ &lt;version&gt; [command]</code> to temporarily switch the Scala version currently
being used to build the subprojects given that <code>&lt;version&gt;</code> is listed in their <code>crossScalaVersions</code>.
</p><p>For example:
</p><pre><code class="">&gt; ++ 2.12.13
[info] Setting version to 2.12.13
&gt; ++ 2.11.12
[info] Setting version to 2.11.12
&gt; compile
</code></pre><p><code>&lt;version&gt;</code> should be either a version for Scala published to a repository or
the path to a Scala home directory, as in <code>++ /path/to/scala/home</code>.
See <a href="Command-Line-Reference.html">Command Line Reference</a> for details.
</p><p>When a <code>[command]</code> is passed in to <code>++</code>, it will execute the command
on the subprojects that supports the given <code>&lt;version&gt;</code>.
</p><p>For example:
</p><pre><code class="">&gt; ++ 2.11.12 -v test
[info] Setting Scala version to 2.11.12 on 1 projects.
[info] Switching Scala version on:
[info]     core (2.12.13, 2.11.12)
[info] Excluding projects:
[info]   * root ()
[info]     network (2.12.13)
[info] Reapplying settings...
[info] Set current project to core (in build file:/Users/xxx/hello/)
</code></pre><p>Sometimes you might want to force the Scala version switch regardless of the <code>crossScalaVersions</code> values.
You can use <code>++ &lt;version&gt;!</code> with exclamation mark for that.
</p><p>For example:
</p><pre><code class="">&gt; ++ 2.13.0-M5! -v
[info] Forcing Scala version to 2.13.0-M5 on all projects.
[info] Switching Scala version on:
[info]   * root ()
[info]     core (2.12.13, 2.11.12)
[info]     network (2.12.13)
</code></pre><h4 id="Cross+publishing">Cross publishing<a href="#Cross+publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The ultimate purpose of <code>+</code> is to cross-publish your
project. That is, by doing:
</p><pre><code class="">&gt; + publishSigned
</code></pre><p>you make your project available to users for different versions of
Scala. See <a href="Publishing.html">Publishing</a> for more details on publishing your project.
</p><p>In order to make this process as quick as possible, different output and
managed dependency directories are used for different versions of Scala.
For example, when building against Scala 2.12.7,
</p><ul><li><code>./target/</code> becomes <code>./target/scala_2.12/</code>
</li><li><code>./lib_managed/</code> becomes <code>./lib_managed/scala_2.12/</code>
</li></ul><p>Packaged jars, wars, and other artifacts have <code>_&lt;scala-version&gt;</code>
appended to the normal artifact ID as mentioned in the Publishing
Conventions section above.
</p><p>This means that the outputs of each build against each version of Scala
are independent of the others. sbt will resolve your dependencies for
each version separately. This way, for example, you get the version of
Dispatch compiled against 2.11 for your 2.11.x build, the version
compiled against 2.12 for your 2.12.x builds, and so on.
</p><h4 id="Overriding+the+publishing+convention">Overriding the publishing convention<a href="#Overriding+the+publishing+convention" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>crossVersion</code> setting can override the publishing convention:
</p><ul><li><code>CrossVersion.disabled</code> (no suffix)
</li><li><code>CrossVersion.binary</code> (<code>_&lt;scala-binary-version&gt;</code>)
</li><li><code>CrossVersion.full</code> (<code>_&lt;scala-version&gt;</code>)
</li></ul><p>The default is either <code>CrossVersion.binary</code> or <code>CrossVersion.diabled</code>
depending on the value of <code>crossPaths</code>.
</p><p>Because (unlike Scala library) Scala compiler is not forward compatible among
the patch releases, compiler plugins should use <code>CrossVersion.full</code>.
</p><h4 id="More+about+using+cross-built+libraries">More about using cross-built libraries<a href="#More+about+using+cross-built+libraries" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You can have fine-grained control over the behavior for different Scala versions
by using the <code>cross</code> method on <code>ModuleID</code> These are equivalent:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;
(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;).cross(CrossVersion.disabled)
</code></pre><p>These are equivalent:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; %% &quot;b&quot; % &quot;1.0&quot;
(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;).cross(CrossVersion.binary)
</code></pre><p>This overrides the defaults to always use the full Scala version instead
of the binary Scala version:
</p><pre><code class="prettyprint lang-scala">(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;).cross(CrossVersion.full)
</code></pre><p><code>CrossVersion.patch</code> sits between <code>CrossVersion.binary</code> and <code>CrossVersion.full</code>
in that it strips off any trailing <code>-bin-...</code> suffix which is used to
distinguish variant but binary compatible Scala toolchain builds.
</p><pre><code class="prettyprint lang-scala">(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;).cross(CrossVersion.patch)
</code></pre><p>This uses a custom function to determine the Scala version to use based
on the binary Scala version:
</p><pre><code class="prettyprint lang-scala">(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;) cross CrossVersion.binaryMapped {
  case &quot;2.9.1&quot; =&gt; &quot;2.9.0&quot; // remember that pre-2.10, binary=full
  case &quot;2.10&quot; =&gt; &quot;2.10.0&quot; // useful if a%b was released with the old style
  case x =&gt; x
}
</code></pre><p>This uses a custom function to determine the Scala version to use based
on the full Scala version:
</p><pre><code class="prettyprint lang-scala">(&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;) cross CrossVersion.fullMapped {
  case &quot;2.9.1&quot; =&gt; &quot;2.9.0&quot;
  case x =&gt; x
}
</code></pre><p>A custom function is mainly used when cross-building and a dependency
isn’t available for all Scala versions or it uses a different convention
than the default.
</p><h4 id="Note+about+sbt-release">Note about sbt-release<a href="#Note+about+sbt-release" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt-release implemented cross building support by copy-pasting sbt 0.13’s <code>+</code> implementation,
so at least as of sbt-release 1.0.10, it does not work correctly with sbt 1.x’s cross building,
which was prototyped originally as sbt-doge.
</p><p>To cross publish using sbt-release with sbt 1.x, use the following workaround:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := scala212

import ReleaseTransformations._
lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)
  .settings(
    // crossScalaVersions must be set to Nil on the aggregating project
    crossScalaVersions := Nil,
    publish / skip := true,

    // don't use sbt-release's cross facility
    releaseCrossBuild := false,
    releaseProcess := Seq[ReleaseStep](
      checkSnapshotDependencies,
      inquireVersions,
      runClean,
      releaseStepCommandAndRemaining(&quot;+test&quot;),
      setReleaseVersion,
      commitReleaseVersion,
      tagRelease,
      releaseStepCommandAndRemaining(&quot;+publishSigned&quot;),
      setNextVersion,
      commitNextVersion,
      pushChanges
    )
  )
</code></pre><p>This will then use the real cross (<code>+</code>) implementation for testing and publishing.
Credit for this technique goes to James Roper at <a href="https://github.com/playframework/playframework/pull/4520">playframework#4520</a> and later inventing <code>releaseStepCommandAndRemaining</code>.
</p><h2 id="Interacting+with+the+Configuration+System">Interacting with the Configuration System<a href="#Interacting+with+the+Configuration+System" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Central to sbt is the new configuration system, which is designed to
enable extensive customization. The goal of this page is to explain the
general model behind the configuration system and how to work with it.
The Getting Started Guide (see
<a href="Basic-Def.html">.sbt files</a>) describes how to define
settings; this page describes interacting with them and exploring them
at the command line.
</p><h3 id="Selecting+commands%2C+tasks%2C+and+settings">Selecting commands, tasks, and settings<a href="#Selecting+commands%2C+tasks%2C+and+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A fully-qualified reference to a setting or task looks like:
</p><pre><code class="">{&lt;build-uri&gt;}&lt;project-id&gt;/config:intask::key
</code></pre><p>This “scoped key” reference is used by commands like <code>last</code> and
<code>inspect</code> and when selecting a task to run. Only <code>key</code> is usually
required by the parser; the remaining optional pieces select the scope.
These optional pieces are individually referred to as scope axes. In the
above description, <code>{&lt;build-uri&gt;}</code> and <code>&lt;project-id&gt;/</code> specify the
project axis, <code>config:</code> is the configuration axis, and <code>intask</code> is the
task-specific axis. Unspecified components are taken to be the current
project (project axis) or auto-detected (configuration and task axes).
An asterisk (<code>*</code>) is used to explicitly refer to the <code>Global</code> context,
as in <code>*/*:key</code>.
</p><h4 id="Selecting+the+configuration">Selecting the configuration<a href="#Selecting+the+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In the case of an unspecified configuration (that is, when the <code>config:</code>
part is omitted), if the key is defined in <code>Global</code>, that is selected.
Otherwise, the first configuration defining the key is selected, where
order is determined by the project definition’s <code>configurations</code> member.
By default, this ordering is <code>compile, test, ...</code>
</p><p>For example, the following are equivalent when run in a project <code>root</code>
in the build in <code>/home/user/sample/</code>:
</p><pre><code class="">&gt; compile
&gt; compile:compile
&gt; root/compile
&gt; root/compile:compile
&gt; {file:/home/user/sample/}root/compile:compile
</code></pre><p>As another example, <code>run</code> by itself refers to <code>compile:run</code> because
there is no global <code>run</code> task and the first configuration searched,
<code>compile</code>, defines a <code>run</code>. Therefore, to reference the <code>run</code> task for
the <code>Test</code> configuration, the configuration axis must be specified like
<code>test:run</code>. Some other examples that require the explicit <code>test:</code> axis:
</p><pre><code class="">&gt; test:consoleQuick
&gt; test:console
&gt; test:doc
&gt; test:package
</code></pre><h4 id="Task-specific+Settings">Task-specific Settings<a href="#Task-specific+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some settings are defined per-task. This is used when there are several
related tasks, such as <code>package</code>, <code>packageSrc</code>, and <code>packageDoc</code>, in the
same configuration (such as <code>compile</code> or <code>test</code>). For package tasks,
their settings are the files to package, the options to use, and the
output file to produce. Each package task should be able to have
different values for these settings.
</p><p>This is done with the task axis, which selects the task to apply a
setting to. For example, the following prints the output jar for the
different package tasks.
</p><pre><code class="">&gt; package::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1.jar

&gt; packageSrc::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1-src.jar

&gt; packageDoc::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1-doc.jar

&gt; test:package::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/root_2.8.1-0.1-test.jar
</code></pre><p>Note that a single colon <code>:</code> follows a configuration axis and a double
colon <code>::</code> follows a task axis.
</p><h3 id="Discovering+Settings+and+Tasks">Discovering Settings and Tasks<a href="#Discovering+Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This section discusses the <code>inspect</code> command, which is useful for
exploring relationships between settings. It can be used to determine
which setting should be modified in order to affect another setting, for
example.
</p><h4 id="Value+and+Provided+By">Value and Provided By<a href="#Value+and+Provided+By" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first piece of information provided by <code>inspect</code> is the type of a
task or the value and type of a setting. The following section of output
is labeled “Provided by”. This shows the actual scope where the setting
is defined. For example,
</p><pre><code class="">&gt; inspect libraryDependencies
[info] Setting: scala.collection.Seq[sbt.ModuleID] = List(org.scalaz:scalaz-core:6.0-SNAPSHOT, org.scala-tools.testing:scalacheck:1.8:test)
[info] Provided by:
[info]  {file:/home/user/sample/}root/*:libraryDependencies
...
</code></pre><p>This shows that <code>libraryDependencies</code> has been defined on the current
project (<code>{file:/home/user/sample/}root</code>) in the global configuration
(<code>*:</code>). For a task like <code>update</code>, the output looks like:
</p><pre><code class="">&gt; inspect update
[info] Task: sbt.UpdateReport
[info] Provided by:
[info]  {file:/home/user/sample/}root/*:update
...
</code></pre><h4 id="Related+Settings">Related Settings<a href="#Related+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The “Related” section of <code>inspect</code> output lists all of the definitions
of a key. For example,
</p><pre><code class="">&gt; inspect compile
...
[info] Related:
[info]  test:compile
</code></pre><p>This shows that in addition to the requested <code>compile:compile</code> task,
there is also a <code>test:compile</code> task.
</p><h4 id="Dependencies">Dependencies<a href="#Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Forward dependencies show the other settings (or tasks) used to define a
setting (or task). Reverse dependencies go the other direction, showing
what uses a given setting. <code>inspect</code> provides this information based on
either the requested dependencies or the actual dependencies. Requested
dependencies are those that a setting directly specifies. Actual
settings are what those dependencies get resolved to. This distinction
is explained in more detail in the following sections.
</p><h5 id="Requested+Dependencies">Requested Dependencies<a href="#Requested+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As an example, we’ll look at <code>console</code>:
</p><pre><code class="">&gt; inspect console
...
[info] Dependencies:
[info]  Compile / console / initialCommands
[info]  Compile / console / streams
[info]  Compile / console / compilers
[info]  Compile / console / cleanupCommands
[info]  Compile / console / taskTemporaryDirectory
[info]  Compile / console / scalaInstance
[info]  Compile / console / scalacOptions
[info]  Compile / console / fullClasspath

...
</code></pre><p>This shows the inputs to the <code>console</code> task. We can see that it gets its
classpath and options from <code>Compile / console / fullClasspath</code> and
<code>Compile / console / scalacOptions</code>. The information provided by the <code>inspect</code>
command can thus assist in finding the right setting to change. The
convention for keys, like <code>console</code> and <code>fullClasspath</code>, is that the
Scala identifier is camel case, while the String representation is
lowercase and separated by dashes. The Scala identifier for a
configuration is uppercase to distinguish it from tasks like <code>compile</code>
and <code>test</code>. For example, we can infer from the previous example how to
add code to be run when the Scala interpreter starts up:
</p><pre><code class="">&gt; set Compile / console / initialCommands := &quot;import mypackage._&quot;
&gt; console
...
import mypackage._
...
</code></pre><p><code>inspect</code> showed that <code>console</code> used the setting
<code>Compile / console / initialCommands</code>. Translating the <code>initialCommands</code>
string to the Scala identifier gives us <code>initialCommands</code>. <code>compile</code>
indicates that this is for the main sources. <code>console /</code> indicates that
the setting is specific to <code>console</code>. Because of this, we can set the
initial commands on the <code>console</code> task without affecting the
<code>consoleQuick</code> task, for example.
</p><h5 id="Actual+Dependencies">Actual Dependencies<a href="#Actual+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>inspect actual &lt;scoped-key&gt;</code> shows the actual dependency used. This is
useful because delegation means that the dependency can come from a
scope other than the requested one. Using <code>inspect actual</code>, we see
exactly which scope is providing a value for a setting. Combining
<code>inspect actual</code> with plain <code>inspect</code>, we can see the range of scopes
that will affect a setting. Returning to the example in Requested
Dependencies,
</p><pre><code class="">&gt; inspect actual console
...
[info] Dependencies:
[info]  Compile / console / streams
[info]  Global / taskTemporaryDirectory
[info]  scalaInstance
[info]  Compile / scalacOptions
[info]  Global / initialCommands
[info]  Global / cleanupCommands
[info]  Compile / fullClasspath
[info]  console / compilers
...
</code></pre><p>For <code>initialCommands</code>, we see that it comes from the global scope
(<code>Global</code>). Combining this with the relevant output from
<code>inspect console</code>:
</p><pre><code class="">Compile / console / initialCommands
</code></pre><p>we know that we can set <code>initialCommands</code> as generally as the global
scope, as specific as the current project’s <code>console</code> task scope, or
anything in between. This means that we can, for example, set
<code>initialCommands</code> for the whole project and will affect <code>console</code>:
</p><pre><code class="">&gt; set initialCommands := &quot;import mypackage._&quot;
...
</code></pre><p>The reason we might want to set it here this is that other console tasks
will use this value now. We can see which ones use our new setting by
looking at the reverse dependencies output of <code>inspect actual</code>:
</p><pre><code class="">&gt; inspect actual initialCommands
...
[info] Reverse dependencies:
[info]  Compile / console
[info]  Test / console
[info]  consoleProject
[info]  Test / consoleQuick
[info]  Compile / consoleQuick
...
</code></pre><p>We now know that by setting <code>initialCommands</code> on the whole project, we
affect all console tasks in all configurations in that project. If we
didn’t want the initial commands to apply for <code>consoleProject</code>, which
doesn’t have our project’s classpath available, we could use the more
specific task axis:
</p><pre><code class="">&gt; set console / initialCommands := &quot;import mypackage._&quot;
&gt; set consoleQuick / initialCommands := &quot;import mypackage._&quot;`
</code></pre><p>or configuration axis:
</p><pre><code class="">&gt; set Compile/　initialCommands := &quot;import mypackage._&quot;
&gt; set Test / initialCommands := &quot;import mypackage._&quot;
</code></pre><p>The next part describes the Delegates section, which shows the chain of
delegation for scopes.
</p><h4 id="Delegates">Delegates<a href="#Delegates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A setting has a key and a scope. A request for a key in a scope A may be
delegated to another scope if A doesn’t define a value for the key. The
delegation chain is well-defined and is displayed in the Delegates
section of the <code>inspect</code> command. The Delegates section shows the order
in which scopes are searched when a value is not defined for the
requested key.
</p><p>As an example, consider the initial commands for <code>console</code> again:
</p><pre><code class="">&gt; inspect console/initialCommands
...
[info] Delegates:
[info]  console / initialCommands
[info]  initialCommands
[info]  ThisBuild / console / initialCommands
[info]  ThisBuild / initialCommands
[info]  Zero / console / initialCommands
[info]  Global / initialCommands
...
</code></pre><p>This means that if there is no value specifically for
<code>console/initialCommands</code>, the scopes listed under Delegates will be
searched in order until a defined value is found.
</p><h2 id="Triggered+Execution">Triggered Execution<a href="#Triggered+Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt provides the ability to monitor the input files for a particular task
and repeat the task when changes to those files occur.
</p><p>Some example usages are described below:
</p><h3 id="Compile">Compile<a href="#Compile" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common use-case is continuous compilation. The following commands will make
sbt watch for source changes in the Test and Compile (default) configurations
respectively and re-run the compile command.
</p><pre><code class="">&gt; ~ Test / compile

&gt; ~ compile
</code></pre><p>Note that because <code>Test / compile</code> depends on <code>Compile / compile</code>,
source changes in the main source directory will trigger recompilation
of the test sources.
</p><h3 id="Testing">Testing<a href="#Testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Triggered execution is often used when developing in a test driven development
(TDD) style. The following command will monitor changes to both the main and
test source sources for the build and re-run only the tests that reference
classes that have been re-compiled since the last test run.
</p><pre><code class="">&gt; ~ testQuick
</code></pre><p>It is also possible to re-run only a particular test if its dependencies
have changed.
</p><pre><code class="">&gt; ~ testQuick foo.BarTest
</code></pre><p>It is possible to always re-run a test when source changes are
detected regardless of whether the test depends on any of the updated
source files.
</p><pre><code class="">&gt; ~ testOnly foo.BarTest
</code></pre><p>To run all of the tests in the project when any sources change, use
</p><pre><code class="">&gt; ~test
</code></pre><h3 id="Running+Multiple+Commands">Running Multiple Commands<a href="#Running+Multiple+Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt supports watching multiple, semicolon separated, commands. For example, the
following command will monitor for source file changes and run <code>clean</code> and
<code>test</code>:
</p><pre><code class="">&gt; ~ clean; test
</code></pre><h3 id="Build+sources">Build sources<a href="#Build+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If the build is configured to automatically reload when build source changes
are made by setting <code>Global / onChangedBuildSource := ReloadOnSourceChanges</code>,
then sbt will monitor the build sources (i.e. <code>*.sbt</code> and <code>*.{java,scala}</code>
files in the <code>project</code> directory). When build source changes are detected,
the build will be reloaded and sbt will re-enter triggered execution mode
when the reload completes.
</p><p>The following snippet can be added as a <a href="../api/sbt/Global-Settings.html">global setting</a> to <code>~/.sbt/1.0/config.sbt</code> to enable <code>ReloadOnSourceChanges</code> for all sbt 1.3+ builds without breaking earlier versions:
</p><pre><code class="">Def.settings {
  try {
    val value = Class.forName(&quot;sbt.nio.Keys$ReloadOnSourceChanges$&quot;).getDeclaredField(&quot;MODULE$&quot;).get(null)
    val clazz = Class.forName(&quot;sbt.nio.Keys$WatchBuildSourceOption&quot;)
    val manifest = new scala.reflect.Manifest[AnyRef]{ def runtimeClass = clazz }
    Seq(
      SettingKey[AnyRef](&quot;onChangedBuildSource&quot;)(manifest, sbt.util.NoJsonWriter()) in Global := value
    )
  } catch {
    case e: Throwable =&gt;
      Nil
  }
}
</code></pre><h3 id="Clearing+the+screen">Clearing the screen<a href="#Clearing+the+screen" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt can clear the console screen before it evaluates the task or after it
triggers an event. To configure sbt to clear the screen after an event is
triggered add
</p><pre><code class="">ThisBuild / watchTriggeredMessage := Watch.clearScreenOnTrigger
</code></pre><p>to the build settings. To clear the screen before running the task, add
</p><pre><code class="">ThisBuild  / watchBeforeCommand := Watch.clearScreen
</code></pre><p>to the build settings.
</p><h3 id="Configuration">Configuration<a href="#Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The behavior of triggered execution can be configured via a number of settings.
</p><ul><li><code>watchTriggers: Seq[Glob]</code> adds search queries for files that should task
trigger evaluation but that the task does not directly depend on. For
example, if the project build.sbt file contains <code>foo / watchTriggers +=
baseDirectory.value.toGlob / &quot;*.txt&quot;</code>, then any modifications to files
ending with the <code>txt</code> extension will cause the <code>foo</code> command to trigger
when in triggered execution mode.
</li><li><code>watchTriggeredMessage: (Int, Path, Seq[String]) =&gt; Option[String]</code>
sets the message that is displayed when a file modification triggers a
new build. Its input parameters are the current watch iteration count,
the file that triggered the build and the command(s) that are going to
be run. By default, it prints a message indicating what file triggered
the build and what commands its going to run. No message is printed when
the function returns <code>None</code>. To clear the screen before printing the
message, just add <code>Watch.clearScreen()</code> inside of the task definition.
This will ensure that the screen is cleared and that the message, if
any is defined, will be printed after the screen clearing.
</li><li><code>watchInputOptions: Seq[Watch.InputOption]</code> allows the build to
override the default watch options. For example, to add the ability to
reload the build by typing the ‘l’ key, add
<code>ThisBuild / watchInputOptions += Watch.InputOption('l', &quot;reload&quot;,
Watch.Reload)</code> to the <code>build.sbt</code> file. When using the default
<code>watchStartMessage</code>, this will also add the option to the list displayed
by the ’?’ option.
</li><li><code>watchBeforeCommand: () =&gt; Unit</code> provides a callback to run before
evaluating the task.  It can be used to clear the console screen by
adding <code>ThisBuild / watchBeforeCommand := Watch.clearScreen</code> to the
project build.sbt file. By default it is no-op.
</li><li><code>watchLogLevel</code> sets the logging level of the file monitoring system.
This can be useful if the triggered execution is not being evaluated
when source files or modified or if is unexpectedly triggering due to
modifications to files that should not be monitored.
</li><li><code>watchInputParser: Parser[Watch.Action]</code> changes how the monitor
handles input events. For example, setting <code>watchInputParser := 'l' ^^^
Watch.Reload | '\r' ^^^ new Watch.Run(&quot;&quot;)</code> will make it so that
typing the ‘l’ key will reload the build and typing a newline will
return to the shell. By default this is automatically derived from the
<code>watchInputOptions</code>.
</li><li><code>watchStartMessage: (Int, ProjectRef, Seq[String]) =&gt; Option[String]</code>
sets the banner that is printed while the watch process is waiting for
file or input events. The inputs are the iteration count, the current
project and the commands to run. The default message includes
instructions for terminating the watch or displaying all available
options. This banner is only displayed if <code>watchOnIteration</code> logs the
result of <code>watchStartMessage</code>.
</li><li><code>watchOnIteration: (Int, ProjectRef, Seq[String]) =&gt; Watch.Action</code> a
function that is evaluated before waiting for source or input events. It
can be used to terminate the watch early if, for example, a certain
number of iterations have been reached. By default, it just logs the
result of <code>watchStartMessage</code>.
</li><li><code>watchForceTriggerOnAnyChange: Boolean</code> configures whether or not the
contents of a source file must change in order to trigger a build. The default
value is false.
</li><li><code>watchPersistFileStamps: Boolean</code> toggles whether or not sbt will
persist the file hashes computed for source files across multiple task
evaluation runs. This can improve performance for projects with many
source files. Because the file hashes are cached, it is possible for the
evaluated task to read an invalid hash if many source files are being
concurrently modified. The default value is false.
</li><li><code>watchAntiEntropy: FiniteDuration</code> controls the time that must elapse
before a build is re-triggered by the same file that previously
triggered the build. This is intended to prevent spurious builds that
can occur when a file is modified in short bursts. The default value is 500ms.
</li></ul><h2 id="Scripts%2C+REPL%2C+and+Dependencies">Scripts, REPL, and Dependencies<a href="#Scripts%2C+REPL%2C+and+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt has two alternative entry points that may be used to:
</p><ul><li>Compile and execute a Scala script containing dependency
declarations or other sbt settings
</li><li>Start up the Scala REPL, defining the dependencies that should be on
the classpath
</li></ul><p>These entry points should be considered experimental. A notable
disadvantage of these approaches is the startup time involved.
</p><h3 id="Setup">Setup<a href="#Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To set up these entry points, you can either use
<a href="https://github.com/foundweekends/conscript">conscript</a> or manually construct
the startup scripts. In addition, there is a
<a href="https://github.com/paulp/sbt-extras">setup script</a> for the script
mode that only requires a JRE installed.
</p><h4 id="Setup+with+Conscript">Setup with Conscript<a href="#Setup+with+Conscript" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Install <a href="https://github.com/foundweekends/conscript">conscript</a>.
</p><pre><code class="">$ cs sbt/sbt --branch 1.4.7
</code></pre><p>This will create two scripts: <code>screpl</code> and <code>scalas</code>.
</p><h4 id="Manual+Setup">Manual Setup<a href="#Manual+Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Duplicate your standard <code>sbt</code> script, which was set up according to
<a href="Setup.html">Setup</a>, as <code>scalas</code> and <code>screpl</code> (or whatever
names you like).
</p><p><code>scalas</code> is the script runner and should use <code>sbt.ScriptMain</code> as the
main class, by adding the <code>-Dsbt.main.class=sbt.ScriptMain</code> parameter to
the <code>java</code> command. Its command line should look like:
</p><pre><code class="">$ java -Dsbt.main.class=sbt.ScriptMain -Dsbt.boot.directory=/home/user/.sbt/boot -jar sbt-launch.jar &quot;$@&quot;
</code></pre><p>For the REPL runner <code>screpl</code>, use <code>sbt.ConsoleMain</code> as the main class:
</p><pre><code class="">$ java -Dsbt.main.class=sbt.ConsoleMain -Dsbt.boot.directory=/home/user/.sbt/boot -jar sbt-launch.jar &quot;$@&quot;
</code></pre><p>In each case, <code>/home/user/.sbt/boot</code> should be replaced with wherever
you want sbt’s boot directory to be; you might also need to give more
memory to the JVM via <code>-Xms512M -Xmx1536M</code> or similar options, just like
shown in <a href="Setup.html">Setup</a>.
</p><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="sbt+Script+runner">sbt Script runner<a href="#sbt+Script+runner" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The script runner can run a standard Scala script, but with the
additional ability to configure sbt. sbt settings may be embedded in the
script in a comment block that opens with <code>/***</code>.
</p><h5 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Copy the following script and make it executable. You may need to adjust
the first line depending on your script name and operating system. When
run, the example should retrieve Scala, the required dependencies,
compile the script, and run it directly. For example, if you name it
<code>shout.scala</code>, you would do on Unix:
</p><pre><code class="">chmod u+x shout.scala
./shout.scala
</code></pre><nbsp>
<pre><code class="prettyprint lang-scala">#!/usr/bin/env scalas
 
/***         
scalaVersion := &quot;2.12.13&quot;
 
libraryDependencies += &quot;org.scala-sbt&quot; %% &quot;io&quot; % &quot;1.4.7&quot;
*/         
 
import sbt.io.IO
import sbt.io.Path._
import sbt.io.syntax._
import java.io.File
import java.net.{URI, URL}
import sys.process._
def file(s: String): File = new File(s)
def uri(s: String): URI = new URI(s)
 
val targetDir = file(&quot;./target/&quot;)
val srcDir = file(&quot;./src/&quot;)
val toTarget = rebase(srcDir, targetDir)
 
def processFile(f: File): Unit = {
  val newParent = toTarget(f.getParentFile) getOrElse {sys.error(&quot;wat&quot;)}
  val file1 = newParent / f.name
  println(s&quot;&quot;&quot;$f =&gt; $file1&quot;&quot;&quot;)
  val xs = IO.readLines(f) map { _ + &quot;!&quot; }
  IO.writeLines(file1, xs)
}

val fs: Seq[File] = (srcDir ** &quot;*.scala&quot;).get
fs foreach { processFile }
</code></pre><p>This script will take all <code>*.scala</code> files under <code>src/</code>, append ”!” at the end of the
line, and write them under <code>target/</code>.
</p><h4 id="sbt+REPL+with+dependencies">sbt REPL with dependencies<a href="#sbt+REPL+with+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The arguments to the REPL mode configure the dependencies to use when
starting up the REPL. An argument may be either a jar to include on the
classpath, a dependency definition to retrieve and put on the classpath,
or a resolver to use when retrieving dependencies.
</p><p>A dependency definition looks like:
</p><pre><code class="">organization%module%revision
</code></pre><p>Or, for a cross-built dependency:
</p><pre><code class="">organization%%module%revision
</code></pre><p>A repository argument looks like:
</p><pre><code class="">&quot;id at url&quot;
</code></pre><h5 id="Example%3A">Example:<a href="#Example%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>To add the Sonatype snapshots repository and add Scalaz 7.0-SNAPSHOT to
REPL classpath:
</p><pre><code class="">$ screpl &quot;sonatype-releases at https://oss.sonatype.org/content/repositories/snapshots/&quot; &quot;org.scalaz%%scalaz-core%7.0-SNAPSHOT&quot;
</code></pre><h2 id="sbt+Server">sbt Server<a href="#sbt+Server" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt server is a feature that is newly introduced in sbt 1.x, and it’s still a work in progress.
You might at first imagine server to be something that runs on remote servers, and does great things, but for now sbt server is not that.
</p><p>Actually, sbt server just adds network access to sbt’s shell command so,
in addition to accepting input from the terminal, server also to accepts input from the network.
This allows multiple clients to connect to a <em>single session</em> of sbt.
The primary use case we have in mind for the client is tooling integration such as editors and IDEs.
</p><h3 id="Metals+integration">Metals integration<a href="#Metals+integration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As of sbt 1.4.x, sbt server implements <a href="https://build-server-protocol.github.io/">Build Server Protocol</a> used by Metals.
Here is how to use sbt server as Metals backend.
</p><ol><li>Delete existing <code>.bsp</code>, <code>.metals</code>, <code>.bloop</code> directories if any
</li><li>Open VS Code in the working directory
</li><li>Ignore the prompt to import the project
</li><li>Add <code>Global / semanticdbEnabled := true</code> in <code>build.sbt</code>
</li><li>Start <code>sbt</code> in the View &gt; Terminal tab. Wait till it displays “sbt server started”
</li><li>From command palette (Cmd-Shift-P in VS Code) issue “Metals: Switch Build Server”, and select “sbt”
</li><li>Reload the sbt session to make sure <code>project/metals.sbt</code> gets loaded
</li><li>Navigate to Metals view, and select “Connect to build server”
</li><li>It should start compiling all your subprojects automatically
</li><li>Once Metals finishes indexing, it should be able to perform code completion etc
</li></ol><img src="files/metals-switch-build-server.png" style="margin-bottom: 1em">
<img src="files/metals-completion.png" style="width: 100%; height: 100%; margin-bottom: 1em">
<p>Use the following setting to opt-out some of the subprojects from BSP.
</p><pre><code class="prettyprint lang-scala">bspEnabled := false
</code></pre><h3 id="Language+Server+Protocol+3.0">Language Server Protocol 3.0<a href="#Language+Server+Protocol+3.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The wire protocol we use is <a href="https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md">Language Server Protocol 3.0</a> (LSP), which in turn is based on <a href="http://www.jsonrpc.org/specification">JSON-RPC</a>.
</p><p>The base protocol consists of a header and a content part (comparable to HTTP). The header and content part are separated by a <code>\r\n</code>.
</p><p>Currently the following header fields are supported:
</p><ul><li><code>Content-Length</code>: The length of the content part in bytes. If you don’t provide this header, we’ll read until the end of the line.
</li><li><code>Content-Type</code>: Must be set to <code>application/vscode-jsonrpc; charset=utf-8</code> or omit it.
</li></ul><p>Here is an example:
</p><pre><code class="">Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n
Content-Length: ...\r\n
\r\n
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: 1,
  &quot;method&quot;: &quot;textDocument/didSave&quot;,
  &quot;params&quot;: {
    ...
  }
}
</code></pre><p>A JSON-RPC request consists of an <code>id</code> number, a <code>method</code> name, and an optional <code>params</code> object.
So all LSP requests are pairs of method name and <code>params</code> JSON.
</p><p>An example response to the JSON-RPC request is:
</p><pre><code class="">Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n
Content-Length: ...\r\n
\r\n
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: 1,
  &quot;result&quot;: {
    ...
  }
}
</code></pre><p>Or the server might return an error response:
</p><pre><code class="">Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n
Content-Length: ...\r\n
\r\n
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: 1,
  &quot;error&quot;: {
    &quot;code&quot;: -32602,
    &quot;message&quot;: &quot;some error message&quot;
  }
}
</code></pre><p>In addition to the responses, the server might also send events (“notifications” in LSP terminology).
</p><pre><code class="">Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n
Content-Length: ...\r\n
\r\n
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;textDocument/publishDiagnostics&quot;,
  &quot;params&quot;: {
    ...
  }
}
</code></pre><h3 id="Server+modes">Server modes<a href="#Server+modes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sbt server can run in two modes, which differ in wire protocol and initialization. The default mode since sbt 1.1.x is <em>domain socket mode</em>, which uses either Unix domain sockets (on Unix) or named pipes (on Windows) for data transfer between server and client. In addition, there is a <em>TCP mode</em>, which uses TCP for data transfer.
</p><p>The mode which sbt server starts in is governed by the key <code>serverConnectionType</code>, which can be set to <code>ConnectionType.Local</code> for domain socket/named pipe mode, or to <code>ConnectionType.Tcp</code> for TCP mode.
</p><h3 id="Server+discovery+and+authentication">Server discovery and authentication<a href="#Server+discovery+and+authentication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To discover a running server, we use a <em>port file</em>.
</p><p>By default, sbt server will be running when a sbt shell session is active. When the server is up, it will create a file called the port file. The port file is located at <code>./project/target/active.json</code>. The port file will look different depending on whether the server is running in TCP mode or domain socket/named pipe mode. They will look something like this:
</p><p>In domain socket/named pipe mode, on Unix:
</p><pre><code class="prettyprint lang-json">{&quot;uri&quot;:&quot;local:///Users/someone/.sbt/1.0/server/0845deda85cb41abdb9f/sock&quot;}
</code></pre><p>where the <code>uri</code> key will contain a string starting with <code>local://</code> followed by the socket address sbt server is listening on.
</p><p>In domain socket/named pipe mode, on Windows, it will look something like
</p><pre><code class="prettyprint lang-json">{&quot;uri&quot;:&quot;local:sbt-server-0845deda85cb41abdb9f&quot;}
</code></pre><p>where the <code>uri</code> key will contain a string starting with <code>local:</code> followed by the name of the named pipe. In this example, the path of the named pipe will be <code>\.\pipe\sbt-server-0845deda85cb41abdb9f</code>.
</p><p>In TCP mode it will look something like the following:
</p><pre><code class="prettyprint lang-json">{
  &quot;uri&quot;:&quot;tcp://127.0.0.1:5010&quot;,
  &quot;tokenfilePath&quot;:&quot;/Users/xxx/.sbt/1.0/server/0845deda85cb41abdb9f/token.json&quot;,
  &quot;tokenfileUri&quot;:&quot;file:/Users/xxx/.sbt/1.0/server/0845deda85cb41abdb9f/token.json&quot;
}
</code></pre><p>In this case, the <code>uri</code> key will hold a TCP uri with the address the server is listening on. In this mode, the port file will contain two additional keys, <code>tokenfilePath</code> and <code>tokenfileUri</code>. These point to the location of a <em>token file</em>.
</p><p>The location of the token file will not change between runs. It’s contents will look something like this:
</p><pre><code class="prettyprint lang-json">{
  &quot;uri&quot;:&quot;tcp://127.0.0.1:5010&quot;,
  &quot;token&quot;:&quot;12345678901234567890123456789012345678&quot;
}
</code></pre><p>The <code>uri</code> field is the same, and the <code>token</code> field contains a 128-bits non-negative integer.
</p><h3 id="Initialize+request">Initialize request<a href="#Initialize+request" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To initiate communication with sbt server, the client (such as a tool like VS Code) must first send an <a href="https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#initialize">`initialize` request</a>. This means that the client must send a request with method set to “initialize” and the <code>InitializeParams</code> datatype as the <code>params</code> field.
</p><p>If the server is running in TCP mode, to authenticate yourself, you must pass in the token in <code>initializationOptions</code> as follows:
</p><pre><code class="">type InitializationOptionsParams {
  token: String!
}
</code></pre><p>On telnet it would look as follows:
</p><pre><code class="">$ telnet 127.0.0.1 5010
Content-Type: application/vscode-jsonrpc; charset=utf-8
Content-Length: 149

{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: { &quot;initializationOptions&quot;: { &quot;token&quot;: &quot;84046191245433876643612047032303751629&quot; } } }
</code></pre><p>If the server is running in named pipe mode, no token is needed, and the <code>initializationOptions</code> should be the empty object <code>{}</code>.
</p><p>On Unix, using netcat, sending the initialize message in domain socket/named pipe mode will look something like this:
</p><pre><code class="">$ nc -U /Users/foo/.sbt/1.0/server/0845deda85cb41abcdef/sock
Content-Length: 99^M
^M
{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: { &quot;initializationOptions&quot;: { } } }^M
</code></pre><p>Connections to the server when it’s running in named pipe mode are exclusive to the first process that connects to the socket or pipe.
</p><p>After sbt receives the request, it will send an <a href="https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#initialized">`initialized` event</a>.
</p><h3 id="event"><code>textDocument/publishDiagnostics</code> event<a href="#event" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The compiler warnings and errors are sent to the client using the <code>textDocument/publishDiagnostics</code> event.
</p><ul><li>method: <code>textDocument/publishDiagnostics</code>
</li><li>params: <a href="https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#publishdiagnostics-notification">`PublishDiagnosticsParams`</a>
</li></ul><p>Here’s an example output (with JSON-RPC headers omitted):
</p><pre><code class="">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;textDocument/publishDiagnostics&quot;,
  &quot;params&quot;: {
    &quot;uri&quot;: &quot;file:/Users/xxx/work/hellotest/Hello.scala&quot;,
    &quot;diagnostics&quot;: [
      {
        &quot;range&quot;: {
          &quot;start&quot;: {
            &quot;line&quot;: 2,
            &quot;character&quot;: 0
          },
          &quot;end&quot;: {
            &quot;line&quot;: 2,
            &quot;character&quot;: 1
          }
        },
        &quot;severity&quot;: 1,
        &quot;source&quot;: &quot;sbt&quot;,
        &quot;message&quot;: &quot;')' expected but '}' found.&quot;
      }
    ]
  }
}
</code></pre><h3 id="event"><code>textDocument/didSave</code> event<a href="#event" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As of sbt 1.1.0, sbt will execute the <code>compile</code> task upon receiving a <code>textDocument/didSave</code> notification.
This behavior is subject to change.
</p><h3 id="request"><code>sbt/exec</code> request<a href="#request" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <code>sbt/exec</code> request emulates the user typing into the shell.
</p><ul><li>method: <code>sbt/exec</code>
</li><li>params:
</li></ul><pre><code class="">type SbtExecParams {
  commandLine: String!
}
</code></pre><p>On telnet it would look as follows:
</p><pre><code class="">Content-Length: 91

{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 2, &quot;method&quot;: &quot;sbt/exec&quot;, &quot;params&quot;: { &quot;commandLine&quot;: &quot;clean&quot; } }
</code></pre><p>Note that there might be other commands running on the build, so in that case the request will be queued up.
</p><h3 id="request"><code>sbt/setting</code> request<a href="#request" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <code>sbt/setting</code> request can be used to query settings.
</p><ul><li>method: <code>sbt/setting</code>
</li><li>params:
</li></ul><pre><code class="">type SettingQuery {
  setting: String!
}
</code></pre><p>On telnet it would look as follows:
</p><pre><code class="">Content-Length: 102

{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 3, &quot;method&quot;: &quot;sbt/setting&quot;, &quot;params&quot;: { &quot;setting&quot;: &quot;root/scalaVersion&quot; } }
Content-Length: 87
Content-Type: application/vscode-jsonrpc; charset=utf-8

{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;3&quot;,&quot;result&quot;:{&quot;value&quot;:&quot;2.12.2&quot;,&quot;contentType&quot;:&quot;java.lang.String&quot;}}
</code></pre><p>Unlike the command execution, this will respond immediately.
</p><h3 id="request"><code>sbt/completion</code> request<a href="#request" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><strong>(sbt 1.3.0+)</strong>
</p><p>A <code>sbt/completion</code> request is used to emulate tab completions for sbt shell.
</p><ul><li>method: <code>sbt/completion</code>
</li><li>params:
<code>`
type CompletionParams {
query: String!
}
</code>`
</li></ul><p>On telnet it would look as follows:
</p><pre><code class="">Content-Length: 100

{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 15, &quot;method&quot;: &quot;sbt/completion&quot;, &quot;params&quot;: { &quot;query&quot;: &quot;testOnly org.&quot; } }
Content-Length: 79
Content-Type: application/vscode-jsonrpc; charset=utf-8

{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:15,&quot;result&quot;:{&quot;items&quot;:[&quot;testOnly org.sbt.ExampleSpec&quot;]}}
</code></pre><p>This will respond immediately based on the last available state of sbt.
</p><h3 id=""><code>sbt/cancelRequest</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><strong>(sbt 1.3.0+)</strong>
</p><p>A <code>sbt/cancelRequest</code> request can be used to terminate the execution of an on-going task.
</p><ul><li>method: <code>sbt/cancelRequest</code>
</li><li>params:
<code>`
type CancelRequestParams {
id: String!
}
</code>`
</li></ul><p>On telnet it would look as follows (assuming a task with Id “foo” is currently running):
</p><pre><code class="">Content-Length: 93

{ &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;bar&quot;, &quot;method&quot;: &quot;sbt/cancelRequest&quot;, &quot;params&quot;: { &quot;id&quot;: &quot;foo&quot; } }
Content-Length: 126
Content-Type: application/vscode-jsonrpc; charset=utf-8

{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;bar&quot;,&quot;result&quot;:{&quot;status&quot;:&quot;Task cancelled&quot;,&quot;channelName&quot;:&quot;network-1&quot;,&quot;execId&quot;:&quot;foo&quot;,&quot;commandQueue&quot;:[]}}
</code></pre><p>This will respond back with the result of the action.
</p><h2 id="Understanding+Incremental+Recompilation">Understanding Incremental Recompilation<a href="#Understanding+Incremental+Recompilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Compiling Scala code with scalac is slow, but sbt often makes it faster.
By understanding how, you can even understand how to make compilation even
faster. Modifying source files with many dependencies might require
recompiling only those source files
(which might take 5 seconds for instance)
instead of all the dependencies
(which might take 2 minutes for instance).
Often you can control which will be your case and make
development faster with a few coding practices.
</p><p>Improving the Scala compilation performance is a major goal of sbt,
and thus the speedups it gives are one of the major motivations to use it.
A significant portion of sbt’s sources and development efforts deal
with strategies for speeding up compilation.
</p><p>To reduce compile times, sbt uses two strategies:
</p><ol>
<li>Reduce the overhead for restarting Scalac
    <ul>
    <li>Implement smart and transparent strategies for incremental
      recompilation, so that only modified files and the needed
      dependencies are recompiled.</li>
    <li>sbt always runs Scalac in the same virtual machine. If one compiles
      source code using sbt, keeps sbt alive, modifies source code and
      triggers a new compilation, this compilation will be faster because
      (part of) Scalac will have already been JIT-compiled.</li>
    </ul>
</li>
<li>Reduce the number of recompiled source. 
    <ul>
    <li>When a source file <code>A.scala</code> is modified, sbt goes to great effort
        to recompile other source files depending on A.scala only if
        required - that is, only if the interface of A.scala was modified.
        With other build management tools (especially for Java, like ant),
        when a developer changes a source file in a non-binary-compatible
        way, she needs to manually ensure that dependencies are also
        recompiled - often by manually running the clean command to remove
        existing compilation output; otherwise compilation might succeed
        even when dependent class files might need to be recompiled. What is
        worse, the change to one source might make dependencies incorrect,
        but this is not discovered automatically: One might get a
        compilation success with incorrect source code. Since Scala compile
        times are so high, running clean is particularly undesirable.
    </li>
    </ul>
</li>
</ol><p>By organizing your source code appropriately, you can minimize the
amount of code affected by a change. sbt cannot determine precisely
which dependencies have to be recompiled; the goal is to compute a
conservative approximation, so that whenever a file must be recompiled,
it will, even though we might recompile extra files.
</p><h3 id="sbt+heuristics">sbt heuristics<a href="#sbt+heuristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt tracks source dependencies at the granularity of source files. For
each source file, sbt tracks files which depend on it directly; if the
<strong>interface</strong> of classes, objects or traits in a file changes, all files
dependent on that source must be recompiled. At the moment sbt uses the
following algorithm to calculate source files dependent on a given
source file:
</p><ul><li>dependencies introduced through inheritance are included <em>transitively</em>;
a dependency is introduced through inheritance if
a class/trait in one file inherits from a trait/class in another file
</li><li>all other direct dependencies are considered by name hashing optimization;
other dependencies are also called “member reference” dependencies because
they are introduced by referring to a member (class, method, type, etc.)
defined in some other source file
</li><li>name hashing optimization considers all member reference dependencies in
context of interface changes of a given source file; it tries to prune
irrelevant dependencies by looking at names of members that got modified
and checking if dependent source files mention those names
</li></ul><p>The name hashing optimization is enabled by default since sbt 0.13.6.
</p><h3 id="How+to+take+advantage+of+sbt+heuristics">How to take advantage of sbt heuristics<a href="#How+to+take+advantage+of+sbt+heuristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The heuristics used by sbt imply the following user-visible
consequences, which determine whether a change to a class affects other
classes.
</p><ol><li>Adding, removing, modifying <code>private</code> methods does not require
recompilation of client classes. Therefore, suppose you add a method
to a class with a lot of dependencies, and that this method is only
used in the declaring class; marking it private will prevent
recompilation of clients. However, this only applies to methods
which are not accessible to other classes, hence methods marked with
private or private[this]; methods which are private to a package,
marked with private[name], are part of the API.
</li><li>Modifying the interface of a non-private method triggers name
hashing optimization
</li><li>Modifying one class does require recompiling dependencies of other
classes defined in the same file (unlike said in a previous version
of this guide). Hence separating different classes in different
source files might reduce recompilations.
</li><li>Changing the implementation of a method should <em>not</em> affect its
clients, unless the return type is inferred, and the new
implementation leads to a slightly different type being inferred.
Hence, annotating the return type of a non-private method
explicitly, if it is more general than the type actually returned,
can reduce the code to be recompiled when the implementation of such
a method changes. (Explicitly annotating return types of a public
API is a good practice in general.)
</li></ol><p>All the above discussion about methods also applies to fields and
members in general; similarly, references to classes also extend to
objects and traits.
</p><h2 id="Implementation+of+incremental+recompilation">Implementation of incremental recompilation<a href="#Implementation+of+incremental+recompilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This sections goes into details of incremental compiler implementation. It’s
starts with an overview of the problem incremental compiler tries to solve
and then discusses design choices that led to the current implementation.
</p><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The goal of incremental compilation is detect changes to source files or to the classpath and
determine a small set of files to be recompiled in such a way that it’ll yield the final result
identical to the result from a full, batch compilation. When reacting to changes the incremental
compiler has to goals that are at odds with each other:
</p><ul><li>recompile as little source files as possible cover all changes to type checking and produced
</li><li>byte code triggered by changed source files and/or classpath
</li></ul><p>The first goal is about making recompilation fast and it’s a sole point of incremental compiler
existence. The second goal is about correctness and sets a lower limit on the size of a set of
recompiled files. Determining that set is the core problem incremental compiler tries to solve.
We’ll dive a little bit into this problem in the overview to understand what makes implementing
incremental compiler a challenging task.
</p><p>Let’s consider this very simple example:
</p><pre><code class="prettyprint lang-scala">// A.scala
package a
class A {
  def foo(): Int = 12
}

// B.scala
package b
class B {
  def bar(x: a.A): Int = x.foo()
}
</code></pre><p>Let’s assume both of those files are already compiled and user changes <code>A.scala</code> so it looks like
this:
</p><pre><code class="prettyprint lang-scala">// A.scala
package a
class A {
  def foo(): Int = 23 // changed constant
}
</code></pre><p>The first step of incremental compilation is to compile modified source files. That’s minimal set of
files incremental compiler has to compile. Modified version of <code>A.scala</code> will be compiled
successfully as changing the constant doesn’t introduce type checking errors. The next step of
incremental compilation is determining whether changes applied to <code>A.scala</code> may affect other files.
In the example above only the constant returned by method <code>foo</code> has changed and that does not affect
compilation results of other files.
</p><p>Let’s consider another change to <code>A.scala</code>:
</p><pre><code class="prettyprint lang-scala">// A.scala
package a
class A {
  def foo(): String = &quot;abc&quot; // changed constant and return type
}
</code></pre><p>As before, the first step of incremental compilation is to compile modified files. In this case we
compile <code>A.scala</code> and compilation will finish successfully. The second step is again determining
whether changes to <code>A.scala</code> affect other files. We see that the return type of the <code>foo</code> public
method has changed so this might affect compilation results of other files. Indeed, <code>B.scala</code>
contains call to the <code>foo</code> method so has to be compiled in the second step. Compilation of <code>B.scala</code>
will fail because of type mismatch in <code>B.bar</code> method and that error will be reported back to the
user. That’s where incremental compilation terminates in this case.
</p><p>Let’s identify the two main pieces of information that were needed to make decisions in the examples
presented above. The incremental compiler algorithm needs to:
</p><ul><li>index source files so it knows whether there were API changes that might affect other source
files; e.g. it needs to detect changes to method signatures as in the example above
</li><li>track dependencies between source files; once the change to an API is detected the algorithm
needs to determine the set of files that might be potentially affected by this change
</li></ul><p>Both of those pieces of information are extracted from the Scala compiler.
</p><h3 id="Interaction+with+the+Scala+compiler">Interaction with the Scala compiler<a href="#Interaction+with+the+Scala+compiler" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Incremental compiler interacts with Scala compiler in many ways:
</p><ul>
  <li>provides three phases additional phases that extract needed information:
  <ul>
    <li>api phase extracts public interface of compiled sources by walking trees and indexing types</li>
    <li>dependency phase which extracts dependencies between source files (compilation units)</li>
    <li>analyzer phase which captures the list of emitted class files</li>
  </ul>
  </li>
  <li>defines a custom reporter which allows sbt to gather errors and warnings</li>
  <li>subclasses Global to:
  <ul>
    <li>add the api, dependency and analyzer phases</li>
    <li>set the custom reporter</li>
  </ul>
  </li>
  <li>manages instances of the custom Global and uses them to compile files it determined that need
    to be compiled</li>
</ul><h4 id="API+extraction+phase">API extraction phase<a href="#API+extraction+phase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The API extraction phase extracts information from Trees, Types and Symbols and maps it to
incremental compiler’s internal data structures described in the
<a href="https://raw.github.com/sbt/sbt/0.13/api.specification">api.specification</a> file.Those data
structures allow to express an API in a way that is independent from Scala compiler version. Also,
such representation is persistent so it is serialized on disk and reused between compiler runs or
even sbt runs.
</p><p>The API extraction phase consist of two major components:
</p><ol><li>mapping Types and Symbols to incremental compiler representation of an extracted API
</li><li>hashing that representation
</li></ol><h5 id="Mapping+Types+and+Symbols">Mapping Types and Symbols<a href="#Mapping+Types+and+Symbols" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The logic responsible for mapping Types and Symbols is implemented in
<a href="https://github.com/sbt/sbt/blob/0.13/compile/interface/src/main/scala/xsbt/API.scala">API.scala</a>.
With introduction of Scala reflection we have multiple variants of Types and Symbols. The
incremental compiler uses the variant defined in <code>scala.reflect.internal</code> package.
</p><p>Also, there’s one design choice that might not be obvious. When type corresponding to a class or a
trait is mapped then all inherited members are copied instead of declarations in that class/trait.
The reason for doing so is that it greatly simplifies analysis of API representation because all
relevant information to a class is stored in one place so there’s no need for looking up parent type
representation. This simplicity comes at a price: the same information is copied over and over again
resulting in a performance hit. For example, every class will have members of <code>java.lang.Object</code>
duplicated along with full information about their signatures.
</p><h5 id="Hashing+an+API+representation">Hashing an API representation<a href="#Hashing+an+API+representation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The incremental compiler (as it’s implemented right now) doesn’t need very fine grained information
about the API. The incremental compiler just needs to know whether an API has changed since the last
time it was indexed. For that purpose hash sum is enough and it saves a lot of memory. Therefore,
API representation is hashed immediately after single compilation unit is processed and only hash
sum is stored persistently.
</p><p>In earlier versions the incremental compiler wouldn’t hash. That resulted in a very high memory
consumption and poor serialization/deserialization performance.
</p><p>The hashing logic is implemented in the <a href="https://github.com/sbt/sbt/blob/0.13/compile
/api/src/main/scala/xsbt/api/HashAPI.scala">HashAPI.scala</a> file.
</p><h4 id="Dependency+phase">Dependency phase<a href="#Dependency+phase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The incremental compiler extracts all Symbols given compilation unit depends on (refers to) and then
tries to map them back to corresponding source/class files. Mapping a Symbol back to a source file
is performed by using <code>sourceFile</code> attribute that Symbols derived from source files have set.
Mapping a Symbol back to (binary) class file is more tricky because Scala compiler does not track
origin of Symbols derived from binary files. Therefore simple heuristic is used which maps a
qualified class name to corresponding classpath entry. This logic is implemented in dependency phase
which has an access to the full classpath.
</p><p>The set of Symbols given compilation unit depend on is obtained by performing a tree walk. The tree
walk examines all tree nodes that can introduce a dependency (refer to another Symbol) and gathers
all Symbols assigned to them. Symbols are assigned to tree nodes by Scala compiler during type
checking phase.
</p><p><em>Incremental compiler used to rely on <code>CompilationUnit.depends</code> for collecting dependencies.
However, name hashing requires a more precise dependency information. Check <a href="https://github.com/sbt/sbt/issues/1002">#1002</a> for
details</em>.
</p><h4 id="Analyzer+phase">Analyzer phase<a href="#Analyzer+phase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Collection of produced class files is extracted by inspecting contents <code>CompilationUnit.icode</code>
property which contains  all ICode classes that backend will emit as JVM class files.
</p><h3 id="Name+hashing+algorithm">Name hashing algorithm<a href="#Name+hashing+algorithm" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Motivation">Motivation<a href="#Motivation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Let’s consider the following example:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A {
  def inc(x: Int): Int = x+1
}

// B.scala
class B {
  def foo(a: A, x: Int): Int = a.inc(x)
}
</code></pre><p>Let’s assume both of those files are compiled and user changes <code>A.scala</code> so it looks like this:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A {
  def inc(x: Int): Int = x+1
  def dec(x: Int): Int = x-1
}
</code></pre><p>Once user hits save and asks incremental compiler to recompile it’s project it will do the
following:
</p><ol><li>Recompile <code>A.scala</code> as the source code has changed (first iteration)
</li><li>While recompiling it will reindex API structure of <code>A.scala</code> and detect it has changed
</li><li>It will determine that <code>B.scala</code> depends on <code>A.scala</code> and since the API structure of <code>A.scala</code> has changed <code>B.scala</code> has to be recompiled as well (<code>B.scala</code> has been invalidated)
</li><li>Recompile <code>B.scala</code> because it was invalidated in 3. due to dependency change
</li><li>Reindex API structure of <code>B.scala</code> and find out that it hasn’t changed so we are done
</li></ol><p>To summarize, we’ll invoke Scala compiler twice: one time to recompile <code>A.scala</code> and then to
recompile <code>B.scala</code> because <code>A</code> has a new method <code>dec</code>.
</p><p>However, one can easily see that in this simple scenario recompilation of <code>B.scala</code> is not needed
because addition of <code>dec</code> method to <code>A</code> class is irrelevant to the <code>B</code> class as its not using it
and it is not affected by it in any way.
</p><p>In case of two files the fact that we recompile too much doesn’t sound too bad. However, in
practice, the dependency graph is rather dense so one might end up recompiling the whole project
upon a change that is irrelevant to almost all files in the whole project. That’s exactly what
happens in Play projects when routes are modified. The nature of routes and reversed routes is that
every template and every controller depends on some methods defined in those two classes (<code>Routes</code>
and <code>ReversedRoutes</code>) but changes to specific route definition usually affects only small subset of
all templates and controllers.
</p><p>The idea behind name hashing is to exploit that observation and make the invalidation algorithm
smarter about changes that can possibly affect a small number of files.
</p><h4 id="Detection+of+irrelevant+dependencies+%28direct+approach%29">Detection of irrelevant dependencies (direct approach)<a href="#Detection+of+irrelevant+dependencies+%28direct+approach%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A change to the API of a given source file <code>X.scala</code> can be called irrelevant if it doesn’t affect the compilation
result of file <code>Y.scala</code> even if <code>Y.scala</code> depends on <code>X.scala</code>.
</p><p>From that definition one can easily see that a change can be declared irrelevant only with respect to
a given dependency. Conversely, one can declare a dependency between two source files irrelevant with
respect to a given change of API in one of the files if the change doesn’t affect the compilation
result of the other file. From now on we’ll focus on detection of irrelevant dependencies.
</p><p>A very naive way of solving a problem of detecting irrelevant dependencies would be to say that we
keep track of all used methods in <code>Y.scala</code> so if a method in <code>X.scala</code> is added/removed/modified we
just check if it’s being used in <code>Y.scala</code> and if it’s not then we consider the dependency of <code>Y.scala</code>
on <code>X.scala</code> irrelevant in this particular case.
</p><p>Just to give you a sneak preview of problems that quickly arise if you consider that strategy let’s
consider those two scenarios.
</p><h5 id="Inheritance">Inheritance<a href="#Inheritance" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>We’ll see how a method not used in another source file might affect its compilation result. Let’s
consider this structure:
</p><pre><code class="prettyprint lang-scala">// A.scala
abstract class A

// B.scala
class B extends A
</code></pre><p>Let’s add an abstract method to class <code>A</code>:
</p><pre><code class="prettyprint lang-scala">// A.scala
abstract class A {
  def foo(x: Int): Int
}
</code></pre><p>Now, once we recompile <code>A.scala</code> we could just say that since <code>A.foo</code> is not used in <code>B</code> class then
we don’t need to recompile <code>B.scala</code>. However, this is not true because <code>B</code> doesn’t implement a newly
introduced, abstract method and an error should be reported.
</p><p>Therefore, a simple strategy of looking at used methods for determining whether a given dependency
is relevant or not is not enough.
</p><h5 id="Enrichment+pattern">Enrichment pattern<a href="#Enrichment+pattern" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Here we’ll see another case of newly introduced method (that is not used anywhere yet) that affects
compilation results of other files. This time, no inheritance will be involved but we’ll use
enrichment pattern (implicit conversions) instead.
</p><p>Let’s assume we have the following structure:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A

// B.scala
class B {
  class AOps(a: A) {
    def foo(x: Int): Int = x+1
  }
  implicit def richA(a: A): AOps = new AOps(a)
  def bar(a: A): Int = a.foo(12) // this is expanded to richA(a).foo so we are calling AOPs.foo method
}
</code></pre><p>Now, let’s add a <code>foo</code> method directly to <code>A</code>:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A {
  def foo(x: Int): Int = x-1
}
</code></pre><p>Now, once we recompile <code>A.scala</code> and detect that there’s a new method defined in the <code>A</code> class we would
need to consider whether this is relevant to the dependency of <code>B.scala</code> on <code>A.scala</code>. Notice that in
<code>B.scala</code> we do not use <code>A.foo</code> (it didn’t exist at the time <code>B.scala</code> was compiled) but we use
<code>AOps.foo</code> and it’s not immediately clear that <code>AOps.foo</code> has anything to do with <code>A.foo</code>. One would
need to detect the fact that a call to <code>AOps.foo</code> as a result of implicit conversion <code>richA</code> that
was inserted because we failed to find <code>foo</code> on <code>A</code> before.
</p><p>This kind of analysis gets us very quickly to the implementation complexity of Scala’s type checker and
is not feasible to implement in a general case.
</p><h5 id="Too+much+information+to+track">Too much information to track<a href="#Too+much+information+to+track" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>All of the above assumed we actually have full information about the structure of the API and used methods
preserved so we can make use of it. However, as described in
<a href="#hashing-an-api-representation">Hashing an API representation</a> we do not store the whole
representation of the API but only its hash sum. Also, dependencies are tracked at source file
level and not at class/method level.
</p><p>One could imagine reworking the current design to track more information but it would be a very big
undertaking. Also, the incremental compiler used to preserve the whole API structure but it switched to
hashing due to the resulting infeasible memory requirements.
</p><h4 id="Detection+of+irrelevant+dependencies+%28name+hashing%29">Detection of irrelevant dependencies (name hashing)<a href="#Detection+of+irrelevant+dependencies+%28name+hashing%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As we saw in the previous chapter, the direct approach of tracking more information about what’s being
used in the source files becomes tricky very quickly. One would wish to come up with a simpler and less
precise approach that would still yield big improvements over the existing implementation.
</p><p>The idea is to not track all the used members and reason very precisely about when a given change to some
members affects the result of the compilation of other files. We would track just the used <em>simple names</em>
instead and we would also track the hash sums for all members with the given simple name. The simple name
means just an unqualified name of a term or a type.
</p><p>Let’s see first how this simplified strategy addresses the problem with the
<a href="#enrichment-pattern">enrichment pattern</a>. We’ll do that by simulating the name hashing algorithm.
Let’s start with the original code:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A

// B.scala
class B {
  class AOps(a: A) {
    def foo(x: Int): Int = x+1
  }
  implicit def richA(a: A): AOps = new AOps(a)
  def bar(a: A): Int = a.foo(12) // this is expanded to richA(a).foo so we are calling AOPs.foo method
}
</code></pre><p>During the compilation of those two files we’ll extract the following information:
</p><pre><code class="">usedNames(&quot;A.scala&quot;): A
usedNames(&quot;B.scala&quot;): B, AOps, a, A, foo, x, Int, richA, AOps, bar

nameHashes(&quot;A.scala&quot;): A -&gt; ...
nameHashes(&quot;B.scala&quot;): B -&gt; ..., AOps -&gt; ..., foo -&gt; ..., richA -&gt; ..., bar -&gt; ...
</code></pre><p>The <code>usedNames</code> relation track all the names mentioned in the given source file. The <code>nameHashes</code> relation
gives us a hash sum of the groups of members that are put together in one bucket if they have the same
simple name. In addition to the information presented above we still track the dependency of <code>B.scala</code> on
<code>A.scala</code>.
</p><p>Now, if we add a <code>foo</code> method to <code>A</code> class:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A {
  def foo(x: Int): Int = x-1
}
</code></pre><p>and recompile, we’ll get the following (updated) information:
</p><pre><code class="">usedNames(&quot;A.scala&quot;): A, foo
nameHashes(&quot;A.scala&quot;): A -&gt; ..., foo -&gt; ...
</code></pre><p>The incremental compiler compares the name hashes before and after the change and detects that the hash
sum of <code>foo</code> has changed (it’s been added). Therefore, it looks at all the source files that depend
on <code>A.scala</code>, in our case it’s just <code>B.scala</code>, and checks whether <code>foo</code> appears as a used name. It
does, therefore it recompiles <code>B.scala</code> as intended.
</p><p>You can see now, that if we added another method to <code>A</code> like <code>xyz</code> then <code>B.scala</code> wouldn’t be
recompiled because nowhere in <code>B.scala</code> is the name <code>xyz</code> mentioned. Therefore, if you have
reasonably non-clashing names you should benefit from a lot of dependencies between source files
marked as irrelevant.
</p><p>It’s very nice that this simple, name-based heuristic manages to withstand the “enrichment pattern”
test. However, name-hashing fails to pass the other test of <a href="#inheritance">inheritance</a>. In order to
address that problem, we’ll need to take a closer look at the dependencies introduced by inheritance vs
dependencies introduced by member references.
</p><h4 id="Dependencies+introduced+by+member+reference+and+inheritance">Dependencies introduced by member reference and inheritance<a href="#Dependencies+introduced+by+member+reference+and+inheritance" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The core assumption behind the name-hashing algorithm is that if a user adds/modifies/removes a member
of a class (e.g. a method) then the results of compilation of other classes won’t be affected unless
they are using that particular member. Inheritance with its various override checks makes the whole
situation much more complicated; if you combine it with mix-in composition that introduces new
fields to classes inheriting from traits then you quickly realize that inheritance requires special
handling.
</p><p>The idea is that for now we would switch back to the old scheme whenever inheritance is involved.
Therefore, we track dependencies introduced by member reference separately from dependencies
introduced by inheritance. All dependencies introduced by inheritance are <em>not</em> subject to name-hashing
analysis so they are never marked as irrelevant.
</p><p>The intuition behind the dependency introduced by inheritance is very simple: it’s a dependency a
class/trait introduces by inheriting from another class/trait. All other dependencies are called
dependencies by member reference because they are introduced by referring (selecting) a member
(method, type alias, inner class, val, etc.) from another class. Notice that in order to inherit from
a class you need to refer to it so dependencies introduced by inheritance are a strict subset of
member reference dependencies.
</p><p>Here’s an example which illustrates the distinction:
</p><pre><code class="prettyprint lang-scala">// A.scala
class A {
  def foo(x: Int): Int = x+1
}

// B.scala
class B(val a: A)

// C.scala
trait C

// D.scala
trait D[T]

// X.scala
class X extends A with C with D[B] {
  // dependencies by inheritance: A, C, D
  // dependencies by member reference: A, C, D, B
}

// Y.scala
class Y {
  def test(b: B): Int = b.a.foo(12)
  // dependencies by member reference: B, Int, A
}
</code></pre><p>There are two things to notice:
</p><ol><li><p><code>X</code> does not depend on <code>B</code> by inheritance because <code>B</code> is passed as a type parameter to <code>D</code>; we
</p><p> consider only types that appear as parents to <code>X</code>
</p></li><li><p><code>Y</code> <em>does</em> depend on <code>A</code> even if there’s no explicit mention of <code>A</code> in the source file; we
</p><p> select a method <code>foo</code> defined in <code>A</code> and that’s enough to introduce a dependency
</p></li></ol><p>To sum it up, the way we want to handle inheritance and the problems it introduces is to track all
dependencies introduced by inheritance separately and have a much more strict way of invalidating
dependencies. Essentially, whenever there’s a dependency by inheritance it will react to any
(even minor) change in parent types.
</p><h4 id="Computing+name+hashes">Computing name hashes<a href="#Computing+name+hashes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>One thing we skimmed over so far is how name hashes are actually computed.
</p><p>As mentioned before, all definitions are grouped together by their simple name and then hashed as one
bucket. If a definition (for example a class) contains other definition then those nested
definitions do <em>not</em> contribute to a hash sum. The nested definitions will contribute to hashes of
buckets selected by their name.
</p><h3 id="What+is+included+in+the+interface+of+a+Scala+class">What is included in the interface of a Scala class<a href="#What+is+included+in+the+interface+of+a+Scala+class" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It is surprisingly tricky to understand which changes to a class require
recompiling its clients. The rules valid for Java are much simpler (even
if they include some subtle points as well); trying to apply them to
Scala will prove frustrating. Here is a list of a few surprising points,
just to illustrate the ideas; this list is not intended to be complete.
</p><ol><li>Since Scala supports named arguments in method invocations, the name
of method arguments are part of its interface.
</li><li>Adding a method to a trait requires recompiling all implementing
classes. The same is true for most changes to a method signature in
a trait.
</li><li>Calls to <code>super.methodName</code> in traits are resolved to calls to an
abstract method called <code>fullyQualifiedTraitName$$super$methodName</code>;
such methods only exist if they are used. Hence, adding the first
call to <code>super.methodName</code> for a specific method name changes the
interface. At present, this is not yet handled—see <a href="https://github.com/sbt/sbt/issues/466">#466</a>.
</li><li><code>sealed</code> hierarchies of case classes allow to check exhaustiveness
of pattern matching. Hence pattern matches using case classes must
depend on the complete hierarchy - this is one reason why
dependencies cannot be easily tracked at the class level (see Scala
issue <a href="https://github.com/scala/bug/issues/2559">SI-2559</a> for an
example.). Check <a href="https://github.com/sbt/sbt/issues/1104">#1104</a> for detailed discussion of tracking
dependencies at class level.
</li></ol><h4 id="Debugging+an+interface+representation">Debugging an interface representation<a href="#Debugging+an+interface+representation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you see spurious incremental recompilations or you want to understand
what changes to an extracted interface cause incremental recompilation
then sbt 0.13 has the right tools for that.
</p><p>In order to debug the interface representation and its changes as you
modify and recompile source code you need to do two things:
</p><ol><li>Enable the incremental compiler’s <code>apiDebug</code> option.
</li><li>Add <a href="https://code.google.com/p/java-diff-utils/">diff-utils library</a> to sbt’s
classpath. Check documentation of <code>sbt.extraClasspath</code> system
property in the Command-Line-Reference.
</li></ol><blockquote><p><strong>warning</strong>
</p><p>Enabling the <code>apiDebug</code> option increases significantly
the memory consumption and degrades the performance of the incremental
compiler. The underlying reason is that in order to produce
meaningful debugging information about interface differences
the incremental compiler has to retain the full representation of the
interface instead of just the hash sum as it does by default.
</p><p>Keep this option enabled when you are debugging the incremental compiler
problem only.
</p></blockquote><p>Below is a complete transcript which shows how to enable interface
debugging in your project. First, we download the <code>diffutils</code> jar and
pass it to sbt:
</p><pre><code class="prettyprint lang-">curl -O https://java-diff-utils.googlecode.com/files/diffutils-1.2.1.jar
sbt -Dsbt.extraClasspath=diffutils-1.2.1.jar
[info] Loading project definition from /Users/grek/tmp/sbt-013/project
[info] Set current project to sbt-013 (in build file:/Users/grek/tmp/sbt-013/)
&gt; set incOptions := incOptions.value.withApiDebug(true)
[info] Defining *:incOptions
[info] The new value will be used by compile:incCompileSetup, test:incCompileSetup
[info] Reapplying settings...
[info] Set current project to sbt-013 (in build file:/Users/grek/tmp/sbt-013/)
</code></pre><p>Let’s suppose you have the following source code in <code>Test.scala</code>:
</p><pre><code class="prettyprint lang-scala">class A {
  def b: Int = 123
}
</code></pre><p>compile it and then change the <code>Test.scala</code> file so it looks like:
</p><pre><code class="prettyprint lang-scala">class A {
   def b: String = &quot;abc&quot;
}
</code></pre><p>and run <code>compile</code> again. Now if you run <code>last compile</code> you should
see the following lines in the debugging log
</p><pre><code class="prettyprint lang-">&gt; last compile
[...]
[debug] Detected a change in a public API:
[debug] --- /Users/grek/tmp/sbt-013/Test.scala
[debug] +++ /Users/grek/tmp/sbt-013/Test.scala
[debug] @@ -23,7 +23,7 @@
[debug]  ^inherited^ final def ##(): scala.this#Int
[debug]  ^inherited^ final def synchronized[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](x$1: &lt;java.lang.Object.T0&gt;): &lt;java.lang.Object.T0&gt;
[debug]  ^inherited^ final def $isInstanceOf[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](): scala.this#Boolean
[debug]  ^inherited^ final def $asInstanceOf[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](): &lt;java.lang.Object.T0&gt;
[debug]  def &lt;init&gt;(): this#A
[debug] -def b: scala.this#Int
[debug] +def b: java.lang.this#String
[debug]  }
</code></pre><p>You can see a unified diff of the two interface textual represetantions. As
you can see, the incremental compiler detected a change to the return
type of <code>b</code> method.
</p><h4 id="Why+changing+the+implementation+of+a+method+might+affect+clients%2C+and+why+type+annotations+help">Why changing the implementation of a method might affect clients, and why type annotations help<a href="#Why+changing+the+implementation+of+a+method+might+affect+clients%2C+and+why+type+annotations+help" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This section explains why relying on type inference for return types of
public methods is not always appropriate. However this is an important
design issue, so we cannot give fixed rules. Moreover, this change is
often invasive, and reducing compilation times is not often a good
enough motivation. That is also why we discuss some of the implications
from the point of view of binary compatibility and software engineering.
</p><p>Consider the following source file <code>A.scala</code>:
</p><pre><code class="prettyprint lang-scala">import java.io._
object A {
  def openFiles(list: List[File]) = 
    list.map(name =&gt; new FileWriter(name))
}
</code></pre><p>Let us now consider the public interface of trait <code>A</code>. Note that the
return type of method <code>openFiles</code> is not specified explicitly, but
computed by type inference to be <code>List[FileWriter]</code>. Suppose that after
writing this source code, we introduce some client code and then modify
<code>A.scala</code> as follows:
</p><pre><code class="prettyprint lang-scala">import java.io._
object A {
  def openFiles(list: List[File]) =
    Vector(list.map(name =&gt; new BufferedWriter(new FileWriter(name))): _*)
}
</code></pre><p>Type inference will now compute the result type as <code>Vector[BufferedWriter]</code>;
in other words, changing the implementation lead to a change to the
public interface, with two undesirable consequences:
</p><ol><li>Concerning our topic, the client code needs to be recompiled, since
changing the return type of a method, in the JVM, is a
binary-incompatible interface change.
</li><li>If our component is a released library, using our new version
requires recompiling all client code, changing the version number,
and so on. Often not good, if you distribute a library where binary
compatibility becomes an issue.
</li><li>More in general, the client code might now even be invalid. The
following code will for instance become invalid after the change:
</li></ol><pre><code class="prettyprint lang-scala">val res: List[FileWriter] = A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><p>Also the following code will break:
</p><pre><code class="prettyprint lang-scala">val a: Seq[Writer] = new BufferedWriter(new FileWriter(&quot;bar.input&quot;))
A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><p>How can we avoid these problems?
</p><p>Of course, we cannot solve them in general: if we want to alter the
interface of a module, breakage might result. However, often we can
remove <em>implementation details</em> from the interface of a module. In the
example above, for instance, it might well be that the intended return
type is more general - namely <code>Seq[Writer]</code>. It might also not be the
case - this is a design choice to be decided on a case-by-case basis. In
this example I will assume however that the designer chooses
<code>Seq[Writer]</code>, since it is a reasonable choice both in the above
simplified example and in a real-world extension of the above code.
</p><p>The client snippets above will now become
</p><pre><code class="prettyprint lang-scala">val res: Seq[Writer] =
  A.openFiles(List(new File(&quot;foo.input&quot;)))

val a: Seq[Writer] =
  new BufferedWriter(new FileWriter(&quot;bar.input&quot;)) +:
  A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><h3 id="Bytecode+Enhancers">Bytecode Enhancers<a href="#Bytecode+Enhancers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt added an extension point whereby users can effectively manipulate
Java bytecode (<code>.class</code> files) <em>before</em> the incremental compiler
attempts to cache the classfile hashes.  This allows libraries like
Ebean to function with sbt without corrupting the compiler cache and
rerunning compile every few seconds.
</p><p>This splits the compile task into several subTasks:
</p><ol><li><code>previousCompile</code>: This task returns the previously persisted
<code>Analysis</code> object for this project.
</li><li><code>compileIncremental</code>: This is the core logic of compiling
Scala/Java files together.  This task actually does the work of
compiling a project incrementally, including ensuring a minimum
number of source files are compiled.  After this method, all
.class files that would be generated by scalac + javac will be
available.
</li><li><code>manipulateByteCode</code>: This is a stub task which takes the
<code>compileIncremental</code> result and returns it.  Plugins which need to
manipulate bytecode are expected to override this task with their
own implementation, ensuring to call the previous behavior.
</li><li><code>compile</code>: This task depends on <code>manipulateBytecode</code> and then
persists the <code>Analysis</code> object containing all incremental compiler
information.
</li></ol><p>Here’s an example of how to hook the new <code>manipulateBytecode</code> key in
your own plugin:
</p><pre><code class="prettyprint lang-scala">    Compile / manipulateBytecode := {
      val previous = (Compile / manipulateBytecode).value
      // Note: This must return a new Compiler.CompileResult with our changes.
      doManipulateBytecode(previous)
    }
</code></pre><h3 id="Further+references">Further references<a href="#Further+references" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The incremental compilation logic is implemented in
<a href="https://github.com/sbt/sbt/blob/0.13/compile/inc/src/main/scala/inc/Incremental.scala">https://github.com/sbt/sbt/blob/0.13/compile/inc/src/main/scala/inc/Incremental.scala</a>.
Some discussion on the incremental recompilation policies is available
in issue <a href="https://github.com/sbt/sbt/issues/322">#322</a>, <a href="https://github.com/sbt/sbt/issues/288">#288</a> and <a href="https://github.com/sbt/sbt/issues/1010">#1010</a>.
</p><h2 id="Configuration">Configuration<a href="#Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Classpaths%2C+sources%2C+and+resources">Classpaths, sources, and resources<a href="#Classpaths%2C+sources%2C+and+resources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page discusses how sbt builds up classpaths for different actions,
like <code>compile</code>, <code>run</code>, and <code>test</code> and how to override or augment these
classpaths.
</p><h3 id="Basics">Basics<a href="#Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt, the classpath includes the Scala library and
(when declared as a dependency) the Scala compiler. Classpath-related
settings and tasks typically provide a value of type <code>Classpath</code>. This
is an alias for <code>Seq[Attributed[File]]</code>.
<a href="../api/sbt/internal/util/Attributed.html">Attributed</a> is a type that associates
a heterogeneous map with each classpath entry. Currently, this allows
sbt to associate the <code>Analysis</code> resulting from compilation with the
corresponding classpath entry and for managed entries, the <code>ModuleID</code>
and <code>Artifact</code> that defined the dependency.
</p><p>To explicitly extract the raw <code>Seq[File]</code>, use the <code>files</code> method
implicitly added to <code>Classpath</code>:
</p><pre><code class="prettyprint lang-scala">val cp: Classpath = ...
val raw: Seq[File] = cp.files
</code></pre><p>To create a <code>Classpath</code> from a <code>Seq[File]</code>, use <code>classpath</code> and to
create an <code>Attributed[File]</code> from a <code>File</code>, use <code>Attributed.blank</code>:
</p><pre><code class="prettyprint lang-scala">val raw: Seq[File] = ...
val cp: Classpath = raw.classpath

val rawFile: File = ..
val af: Attributed[File] = Attributed.blank(rawFile)
</code></pre><h4 id="Unmanaged+vs+managed">Unmanaged vs managed<a href="#Unmanaged+vs+managed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Classpaths, sources, and resources are separated into two main
categories: unmanaged and managed. Unmanaged files are manually created
files that are outside of the control of the build. They are the inputs
to the build. Managed files are under the control of the build. These
include generated sources and resources as well as resolved and
retrieved dependencies and compiled classes.
</p><p>Tasks that produce managed files should be inserted as follows:
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators +=
    generate( (Compile / sourceManaged).value / &quot;some_directory&quot;)
</code></pre><p>In this example, <code>generate</code> is some function of type <code>File =&gt; Seq[File]</code>
that actually does the work. So, we are appending a new task to the list
of main source generators (<code>Compile / sourceGenerators</code>).
</p><p>To insert a named task, which is the better approach for plugins:
</p><pre><code class="prettyprint lang-scala">val mySourceGenerator = taskKey[Seq[File]](...)

Compile / mySourceGenerator :=
  generate( (Compile / sourceManaged).value / &quot;some_directory&quot;)

Compile / sourceGenerators += (Compile / mySourceGenerator)
</code></pre><p>The <code>task</code> method is used to refer to the actual task instead of the
result of the task.
</p><p>For resources, there are similar keys <code>resourceGenerators</code> and
<code>resourceManaged</code>.
</p><h5 id="Excluding+source+files+by+name">Excluding source files by name<a href="#Excluding+source+files+by+name" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The project base directory is by default a source directory in addition
to <code>src/main/scala</code>. You can exclude source files by name
(<code>butler.scala</code> in the example below) like:
</p><pre><code class="prettyprint lang-scala">unmanagedSources / excludeFilter := &quot;butler.scala&quot;
</code></pre><p>Read more on
<a href="https://groups.google.com/group/simple-build-tool/browse_thread/thread/cd5332a164405568?hl=en">How to exclude .scala source file in project folder - Google Groups</a>
</p><h4 id="External+vs+internal">External vs internal<a href="#External+vs+internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Classpaths are also divided into internal and external dependencies. The
internal dependencies are inter-project dependencies. These effectively
put the outputs of one project on the classpath of another project.
</p><p>External classpaths are the union of the unmanaged and managed
classpaths.
</p><h4 id="Keys">Keys<a href="#Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For classpaths, the relevant keys are:
</p><ul><li><code>unmanagedClasspath</code>
</li><li><code>managedClasspath</code>
</li><li><code>externalDependencyClasspath</code>
</li><li><code>internalDependencyClasspath</code>
</li></ul><p>For sources:
</p><ul><li><code>unmanagedSources</code> These are by default built up from
unmanagedSourceDirectories, which consists of scalaSource and
javaSource.
</li><li><code>managedSources</code> These are generated sources.
</li><li><code>sources</code> Combines <code>managedSources</code> and <code>unmanagedSources</code>.
</li><li><code>sourceGenerators</code> These are tasks that generate source files.
Typically, these tasks will put sources in the directory provided by
sourceManaged.
</li></ul><p>For resources
</p><ul><li><code>unmanagedResources</code> These are by default built up from
unmanagedResourceDirectories, which by default is resourceDirectory,
excluding files matched by defaultExcludes.
</li><li><code>managedResources</code> By default, this is empty for standard projects.
sbt plugins will have a generated descriptor file here.
</li><li><code>resourceGenerators</code> These are tasks that generate resource files.
Typically, these tasks will put resources in the directory provided
by resourceManaged.
</li></ul><p>Use the <a href="Inspecting-Settings.html">inspect command</a> for
more details.
</p><p>See also a related
<a href="https://stackoverflow.com/a/7862872/850196">StackOverflow answer</a>.
</p><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You have a standalone project which uses a library that loads
xxx.properties from classpath at run time. You put xxx.properties inside
directory “config”. When you run “sbt run”, you want the directory to be
in classpath.
</p><pre><code class="prettyprint lang-scala">Runtime / unmanagedClasspath += baseDirectory.value / &quot;config&quot;
</code></pre><h2 id="Compiler+Plugin+Support">Compiler Plugin Support<a href="#Compiler+Plugin+Support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There is some special support for using compiler plugins. You can set
<code>autoCompilerPlugins</code> to <code>true</code> to enable this functionality.
</p><pre><code class="prettyprint lang-scala">autoCompilerPlugins := true
</code></pre><p>To use a compiler plugin, you either put it in your unmanaged library
directory (<code>lib/</code> by default) or add it as managed dependency in the
<code>plugin</code> configuration. <code>addCompilerPlugin</code> is a convenience method for
specifying <code>plugin</code> as the configuration for a dependency:
</p><pre><code class="prettyprint lang-scala">addCompilerPlugin(&quot;org.scala-tools.sxr&quot; %% &quot;sxr&quot; % &quot;0.3.0&quot;)
</code></pre><p>The <code>compile</code> and <code>testCompile</code> actions will use any compiler plugins
found in the <code>lib</code> directory or in the <code>plugin</code> configuration. You are
responsible for configuring the plugins as necessary. For example, Scala
X-Ray requires the extra option:
</p><pre><code class="prettyprint lang-scala">// declare the main Scala source directory as the base directory
scalacOptions :=
    scalacOptions.value :+ (&quot;-Psxr:base-directory:&quot; + (Compile / scalaSource).value.getAbsolutePath)
</code></pre><p>You can still specify compiler plugins manually. For example:
</p><pre><code class="prettyprint lang-scala">scalacOptions += &quot;-Xplugin:&lt;path-to-sxr&gt;/sxr-0.3.0.jar&quot;
</code></pre><h3 id="Continuations+Plugin+Example">Continuations Plugin Example<a href="#Continuations+Plugin+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Support for continuations in Scala 2.12 is implemented as a compiler
plugin. You can use the compiler plugin support for this, as shown here.
</p><pre><code class="prettyprint lang-scala">val continuationsVersion = &quot;1.0.3&quot;

autoCompilerPlugins := true

addCompilerPlugin(&quot;org.scala-lang.plugins&quot; % &quot;scala-continuations-plugin_2.12.2&quot; % continuationsVersion)

libraryDependencies += &quot;org.scala-lang.plugins&quot; %% &quot;scala-continuations-library&quot; % continuationsVersion

scalacOptions += &quot;-P:continuations:enable&quot;
</code></pre><h3 id="Version-specific+Compiler+Plugin+Example">Version-specific Compiler Plugin Example<a href="#Version-specific+Compiler+Plugin+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Adding a version-specific compiler plugin can be done as follows:
</p><pre><code class="prettyprint lang-scala">val continuationsVersion = &quot;1.0.3&quot;

autoCompilerPlugins := true

libraryDependencies +=
    compilerPlugin(&quot;org.scala-lang.plugins&quot; % (&quot;scala-continuations-plugin_&quot; + scalaVersion.value) % continuationsVersion)

libraryDependencies += &quot;org.scala-lang.plugins&quot; %% &quot;scala-continuations-library&quot; % continuationsVersion

scalacOptions += &quot;-P:continuations:enable&quot;
</code></pre><h2 id="Configuring+Scala">Configuring Scala<a href="#Configuring+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt needs to obtain Scala for a project and it can do this automatically
or you can configure it explicitly. The Scala version that is configured
for a project will compile, run, document, and provide a REPL for the
project code. When compiling a project, sbt needs to run the Scala
compiler as well as provide the compiler with a classpath, which may
include several Scala jars, like the reflection jar.
</p><h3 id="Automatically+managed+Scala">Automatically managed Scala<a href="#Automatically+managed+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The most common case is when you want to use a version of Scala that is
available in a repository. The only required configuration is the Scala
version you want to use. For example,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.10.0&quot;
</code></pre><p>This will retrieve Scala from the repositories configured via the
<code>resolvers</code> setting. It will use this version for building your project:
compiling, running, scaladoc, and the REPL.
</p><h4 id="Configuring+the+scala-library+dependency">Configuring the scala-library dependency<a href="#Configuring+the+scala-library+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, the standard Scala library is automatically added as a
dependency. If you want to configure it differently than the default or
you have a project with only Java sources, set:
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false
</code></pre><p>In order to compile Scala sources, the Scala library needs to be on the
classpath. When <code>autoScalaLibrary</code> is true, the Scala library will be on
all classpaths: test, runtime, and compile. Otherwise, you need to add
it like any other dependency. For example, the following dependency
definition uses Scala only for tests:
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false

libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-library&quot; % scalaVersion.value % &quot;test&quot;
</code></pre><h4 id="Configuring+additional+Scala+dependencies">Configuring additional Scala dependencies<a href="#Configuring+additional+Scala+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When using a Scala dependency other than the standard library, add it as
a normal managed dependency. For example, to depend on the Scala
compiler,
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-compiler&quot; % scalaVersion.value
</code></pre><p>Note that this is necessary regardless of the value of the
<code>autoScalaLibrary</code> setting described in the previous section.
</p><h4 id="Configuring+Scala+tool+dependencies">Configuring Scala tool dependencies<a href="#Configuring+Scala+tool+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In order to compile Scala code, run scaladoc, and provide a Scala REPL,
sbt needs the <code>scala-compiler</code> jar. This should not be a normal
dependency of the project, so sbt adds a dependency on <code>scala-compiler</code>
in the special, private <code>scala-tool</code> configuration. It may be desirable
to have more control over this in some situations. Disable this
automatic behavior with the <code>managedScalaInstance</code> key:
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false
</code></pre><p>This will also disable the automatic dependency on <code>scala-library</code>. If
you do not need the Scala compiler for anything (compiling, the REPL,
scaladoc, etc…), you can stop here. sbt does not need an instance of
Scala for your project in that case. Otherwise, sbt will still need
access to the jars for the Scala compiler for compilation and other
tasks. You can provide them by either declaring a dependency in the
<code>scala-tool</code> configuration or by explicitly defining <code>scalaInstance</code>.
</p><p>In the first case, add the <code>scala-tool</code> configuration and add a
dependency on <code>scala-compiler</code> in this configuration. The organization
is not important, but sbt needs the module name to be <code>scala-compiler</code>
and <code>scala-library</code> in order to handle those jars appropriately. For
example,
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false

// Add the configuration for the dependencies on Scala tool jars
// You can also use a manually constructed configuration like:
//   config(&quot;scala-tool&quot;).hide
ivyConfigurations += Configurations.ScalaTool

// Add the usual dependency on the library as well on the compiler in the
//  'scala-tool' configuration
libraryDependencies ++= Seq(
   &quot;org.scala-lang&quot; % &quot;scala-library&quot; % scalaVersion.value,
   &quot;org.scala-lang&quot; % &quot;scala-compiler&quot; % scalaVersion.value % &quot;scala-tool&quot;
)
</code></pre><p>In the second case, directly construct a value of type
<a href="../api/sbt/internal/inc/ScalaInstance.html">ScalaInstance</a>, typically using a
method in the <a href="../api/sbt/internal/inc/ScalaInstance$.html">companion object</a>,
and assign it to <code>scalaInstance</code>. You will also need to add the
<code>scala-library</code> jar to the classpath to compile and run Scala sources.
For example,
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false
scalaInstance := ...
Compile / unmanagedJars += scalaInstance.value.libraryJar
</code></pre><h4 id="Switching+to+a+local+Scala+version">Switching to a local Scala version<a href="#Switching+to+a+local+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To use a locally built Scala version, configure Scala home as described
in the following section. Scala will still be resolved as before, but
the jars will come from the configured Scala home directory.
</p><h3 id="Using+Scala+from+a+local+directory">Using Scala from a local directory<a href="#Using+Scala+from+a+local+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The result of building Scala from source is a Scala home directory
<code>&lt;base&gt;/build/pack/</code> that contains a subdirectory <code>lib/</code> containing the
Scala library, compiler, and other jars. The same directory layout is
obtained by downloading and extracting a Scala distribution. Such a
Scala home directory may be used as the source for jars by setting
<code>scalaHome</code>. For example,
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))
</code></pre><p>By default, <code>lib/scala-library.jar</code> will be added to the unmanaged
classpath and <code>lib/scala-compiler.jar</code> will be used to compile Scala
sources and provide a Scala REPL. No managed dependency is recorded on
<code>scala-library</code>. This means that Scala will only be resolved from a
repository if you explicitly define a dependency on Scala or if Scala is
depended on indirectly via a dependency. In these cases, the artifacts
for the resolved dependencies will be substituted with jars in the Scala
home <code>lib/</code> directory.
</p><h4 id="Mixing+with+managed+dependencies">Mixing with managed dependencies<a href="#Mixing+with+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As an example, consider adding a dependency on <code>scala-reflect</code> when
<code>scalaHome</code> is configured:
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))

libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value
</code></pre><p>This will be resolved as normal, except that sbt will see if
<code>/home/user/scala-2.10/lib/scala-reflect.jar</code> exists. If it does, that
file will be used in place of the artifact from the managed dependency.
</p><h4 id="Using+unmanaged+dependencies+only">Using unmanaged dependencies only<a href="#Using+unmanaged+dependencies+only" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Instead of adding managed dependencies on Scala jars, you can directly
add them. The <code>scalaInstance</code> task provides structured access to the
Scala distribution. For example, to add all jars in the Scala home
<code>lib/</code> directory,
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))

Compile / unmanagedJars ++= scalaInstance.value.jars
</code></pre><p>To add only some jars, filter the jars from <code>scalaInstance</code> before
adding them.
</p><h3 id="sbt%E2%80%99s+Scala+version">sbt’s Scala version<a href="#sbt%E2%80%99s+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt needs Scala jars to run itself since it is written in Scala. sbt
uses that same version of Scala to compile the build definitions that
you write for your project because they use sbt APIs. This version of
Scala is fixed for a specific sbt release and cannot be changed. For sbt
1.4.7, this version is Scala 2.12.13. Because this Scala
version is needed before sbt runs, the repositories used to retrieve
this version are configured in the sbt
<a href="Sbt-Launcher.html">launcher</a>.
</p><h2 id="Forking">Forking<a href="#Forking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>By default, the <code>run</code> task runs in the same JVM as sbt. Forking is
required under <a href="Running-Project-Code.html">certain circumstances</a>, however.
Or, you might want to fork Java processes when implementing new tasks.
</p><p>By default, a forked process uses the same Java and Scala versions being
used for the build and the working directory and JVM options of the
current process. This page discusses how to enable and configure forking
for both <code>run</code> and <code>test</code> tasks. Each kind of task may be configured
separately by scoping the relevant keys as explained below.
</p><h3 id="Enable+forking">Enable forking<a href="#Enable+forking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fork</code> setting controls whether forking is enabled (true) or not
(false). It can be set in the <code>run</code> scope to only fork <code>run</code> commands or
in the <code>test</code> scope to only fork <code>test</code> commands.
</p><p>To fork all test tasks (<code>test</code>, <code>testOnly</code>, and <code>testQuick</code>) and run
tasks (<code>run</code>, <code>runMain</code>, <code>Test / run</code>, and <code>Test / runMain</code>),
</p><pre><code class="prettyprint lang-scala">fork := true
</code></pre><p>To only fork <code>Compile / run</code> and <code>Compile / runMain</code>:
</p><pre><code class="prettyprint lang-scala">Compile / run / fork := true
</code></pre><p>To only fork <code>Test / run</code> and <code>Test / runMain</code>:
</p><pre><code class="prettyprint lang-scala">Test / run / fork := true
</code></pre><p><em>Note:</em> <code>run</code> and <code>runMain</code> share the same configuration and cannot be configured separately.
</p><p>To enable forking all <code>test</code> tasks only, set <code>fork</code> to <code>true</code> in the
<code>Test</code> scope:
</p><pre><code class="prettyprint lang-scala">Test / fork := true
</code></pre><p>See <a href="Testing.html">Testing</a> for more control over how tests are assigned to JVMs and
what options to pass to each group.
</p><h3 id="Change+working+directory">Change working directory<a href="#Change+working+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To change the working directory when forked, set <code>Compile / run / baseDirectory</code>
or <code>Test / baseDirectory</code>:
</p><pre><code class="prettyprint lang-scala">// sets the working directory for all `run`-like tasks
run / baseDirectory := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `run` and `runMain` only
Compile / run / baseDirectory := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `Test / run` and `Test / runMain` only
Test / run / baseDirectory := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `test`, `testQuick`, and `testOnly`
Test / baseDirectory := file(&quot;/path/to/working/directory/&quot;)
</code></pre><h3 id="Forked+JVM+options">Forked JVM options<a href="#Forked+JVM+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify options to be provided to the forked JVM, set <code>javaOptions</code>:
</p><pre><code class="prettyprint lang-scala">run / javaOptions += &quot;-Xmx8G&quot;
</code></pre><p>or specify the configuration to affect only the main or test <code>run</code>
tasks:
</p><pre><code class="prettyprint lang-scala">Test / run / javaOptions += &quot;-Xmx8G&quot;
</code></pre><p>or only affect the <code>test</code> tasks:
</p><pre><code class="prettyprint lang-scala">Test / javaOptions += &quot;-Xmx8G&quot;
</code></pre><h3 id="Java+Home">Java Home<a href="#Java+Home" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Select the Java installation to use by setting the <code>javaHome</code> directory:
</p><pre><code class="prettyprint lang-scala">javaHome := Some(file(&quot;/path/to/jre/&quot;))
</code></pre><p>Note that if this is set globally, it also sets the Java installation
used to compile Java sources. You can restrict it to running only by
setting it in the <code>run</code> scope:
</p><pre><code class="prettyprint lang-scala">run / javaHome := Some(file(&quot;/path/to/jre/&quot;))
</code></pre><p>As with the other settings, you can specify the configuration to affect
only the main or test <code>run</code> tasks or just the <code>test</code> tasks.
</p><h3 id="Configuring+output">Configuring output<a href="#Configuring+output" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, forked output is sent to the Logger, with standard output
logged at the <code>Info</code> level and standard error at the <code>Error</code> level. This
can be configured with the <code>outputStrategy</code> setting, which is of type
<a href="../api/sbt/OutputStrategy.html">OutputStrategy</a>.
</p><pre><code class="prettyprint lang-scala">// send output to the build's standard output and error
outputStrategy := Some(StdoutOutput)

// send output to the provided OutputStream `someStream`
outputStrategy := Some(CustomOutput(someStream: OutputStream))

// send output to the provided Logger `log` (unbuffered)
outputStrategy := Some(LoggedOutput(log: Logger))

// send output to the provided Logger `log` after the process terminates
outputStrategy := Some(BufferedOutput(log: Logger))
</code></pre><p>As with other settings, this can be configured individually for main or
test <code>run</code> tasks or for <code>test</code> tasks.
</p><h3 id="Configuring+Input">Configuring Input<a href="#Configuring+Input" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the standard input of the sbt process is not forwarded to
the forked process. To enable this, configure the <code>connectInput</code>
setting:
</p><pre><code class="prettyprint lang-scala">run / connectInput := true
</code></pre><h3 id="Direct+Usage">Direct Usage<a href="#Direct+Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To fork a new Java process, use the
<a href="../api/sbt/Fork$.html">Fork API</a>. The values of interest are
<code>Fork.java</code>, <code>Fork.javac</code>, <code>Fork.scala</code>, and <code>Fork.scalac</code>. These are of
type <a href="../api/sbt/Fork.html">Fork</a> and provide <code>apply</code> and <code>fork</code>
methods. For example, to fork a new Java process, :
</p><pre><code class="prettyprint lang-scala">val options = ForkOptions(...)
val arguments: Seq[String] = ...
val mainClass: String = ...
val exitCode: Int = Fork.java(options, mainClass +: arguments)
</code></pre><p><a href="../api/sbt/ForkOptions.html">ForkOptions</a> defines the Java
installation to use, the working directory, environment variables, and
more. For example, :
</p><pre><code class="prettyprint lang-scala">val cwd: File = ...
val javaDir: File = ...
val options = ForkOptions(
   envVars = Map(&quot;KEY&quot; -&gt; &quot;value&quot;),
   workingDirectory = Some(cwd),
   javaHome = Some(javaDir)
)
</code></pre><h2 id="Global+Settings">Global Settings<a href="#Global+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Basic+global+configuration+file">Basic global configuration file<a href="#Basic+global+configuration+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Settings that should be applied to all projects can go in
<code>$HOME/.sbt/1.0/global.sbt</code> (or any file in <code>$HOME/.sbt/1.0</code> with a <code>.sbt</code>
extension). Plugins that are defined globally in <code>$HOME/.sbt/1.0/plugins/</code>
are available to these settings. For example, to change the default
<code>shellPrompt</code> for your projects:
</p><p><code>$HOME/.sbt/1.0/global.sbt</code>
</p><pre><code class="prettyprint lang-scala">shellPrompt := { state =&gt;
  &quot;sbt (%s)&gt; &quot;.format(Project.extract(state).currentProject.id)
}
</code></pre><p>You can also configure plugins globally added in <code>$HOME/.sbt/1.0/plugins/build.sbt</code>
(see next paragraph) in that file, but you need to use fully qualified
names for their properties. For example, for sbt-eclipse property <code>withSource</code>
documented in https://github.com/sbt/sbteclipse/wiki/Using-sbteclipse,
you need to use:
</p><pre><code class="prettyprint lang-scala">com.typesafe.sbteclipse.core.EclipsePlugin.EclipseKeys.withSource := true
</code></pre><h3 id="Global+Settings+using+a+Global+Plugin">Global Settings using a Global Plugin<a href="#Global+Settings+using+a+Global+Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>$HOME/.sbt/1.0/plugins/</code> directory is a global plugin project. This
can be used to provide global commands, plugins, or other code.
</p><p>To add a plugin globally, create <code>$HOME/.sbt/1.0/plugins/build.sbt</code> containing
the dependency definitions. For example:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.example&quot; % &quot;plugin&quot; % &quot;1.0&quot;)
</code></pre><p>To change the default <code>shellPrompt</code> for every project using this
approach, create a local plugin <code>$HOME/.sbt/1.0/plugins/ShellPrompt.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object ShellPrompt extends AutoPlugin {
  override def trigger = allRequirements

  override def projectSettings = Seq(
    shellPrompt := { state =&gt;
      &quot;sbt (%s)&gt; &quot;.format(Project.extract(state).currentProject.id) }
  )
}
</code></pre><p>The <code>$HOME/.sbt/1.0/plugins/</code> directory is a full project that is
included as an external dependency of every plugin project. In practice,
settings and code defined here effectively work as if they were defined
in a project’s <code>project/</code> directory. This means that
<code>$HOME/.sbt/1.0/plugins/</code> can be used to try out ideas for plugins such as
shown in the <code>shellPrompt</code> example.
</p><h2 id="Java+Sources">Java Sources<a href="#Java+Sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt has support for compiling Java sources with the limitation that
dependency tracking is limited to the dependencies present in compiled
class files.
</p><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>compile</code> will compile the sources under <code>src/main/java</code> by default.
</li><li><code>testCompile</code> will compile the sources under <code>src/test/java</code> by
default.
</li></ul><p>Pass options to the Java compiler by setting <code>javacOptions</code>:
</p><pre><code class="prettyprint lang-scala">javacOptions += &quot;-g:none&quot;
</code></pre><p>As with options for the Scala compiler, the arguments are not parsed by
sbt. Multi-element options, such as <code>-source 1.5</code>, are specified like:
</p><pre><code class="prettyprint lang-scala">javacOptions ++= Seq(&quot;-source&quot;, &quot;1.5&quot;)
</code></pre><p>You can specify the order in which Scala and Java sources are built with
the <code>compileOrder</code> setting. Possible values are from the <code>CompileOrder</code>
enumeration: <code>Mixed</code>, <code>JavaThenScala</code>, and <code>ScalaThenJava</code>. If you have
circular dependencies between Scala and Java sources, you need the
default, <code>Mixed</code>, which passes both Java and Scala sources to <code>scalac</code>
and then compiles the Java sources with <code>javac</code>. If you do not have
circular dependencies, you can use one of the other two options to speed
up your build by not passing the Java sources to <code>scalac</code>. For example,
if your Scala sources depend on your Java sources, but your Java sources
do not depend on your Scala sources, you can do:
</p><pre><code class="prettyprint lang-scala">compileOrder := CompileOrder.JavaThenScala
</code></pre><p>To specify different orders for main and test sources, scope the setting
by configuration:
</p><pre><code class="prettyprint lang-scala">// Java then Scala for main sources
Compile / compileOrder := CompileOrder.JavaThenScala

// allow circular dependencies for test sources
Test / compileOrder := CompileOrder.Mixed
</code></pre><p>Note that in an incremental compilation setting, it is not practical to
ensure complete isolation between Java sources and Scala sources because
they share the same output directory. So, previously compiled classes
not involved in the current recompilation may be picked up. A clean
compile will always provide full checking, however.
</p><h3 id="Known+issues+in+mixed+mode+compilation">Known issues in mixed mode compilation<a href="#Known+issues+in+mixed+mode+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Scala compiler does not identify compile-time constant variables
(Java specification <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4">4.12.4</a>)
in Java source code if their definition is not a literal.
This issue has several symptoms, described in the Scala ticket <a href="https://github.com/scala/bug/issues/5333">SI-5333</a>:
</p><ol><li>The selection of a (non-literal) constant variable is rejected when used as an argument
to a Java annotation (a compile-time constant expression is required).
</li><li>The selection of a constant variable is not replaced by its value, but compiled
as an actual field load (the
<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#value-declarations-and-definitions">Scala specification 4.1</a>
defines that constant expressions should be replaced by their values).
</li></ol><p>Since Scala 2.11.4, a similar issue arises when using a Java-defined annotation in
a Scala class. The Scala compiler does not recognize <code>@Retention</code> annotations when
parsing the annotation <code>@interface</code> from source and therefore emits the annotation
with visibility <code>RUNTIME</code> (<a href="https://github.com/scala/bug/issues/8928">SI-8928</a>).
</p><h3 id="Ignoring+the+Scala+source+directories">Ignoring the Scala source directories<a href="#Ignoring+the+Scala+source+directories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt includes <code>src/main/scala</code> and <code>src/main/java</code> in its
list of unmanaged source directories. For Java-only projects, the
unnecessary Scala directories can be ignored by modifying
<code>unmanagedSourceDirectories</code>:
</p><pre><code class="prettyprint lang-scala">// Include only src/main/java in the compile configuration
Compile / unmanagedSourceDirectories := (Compile / javaSource).value :: Nil

// Include only src/test/java in the test configuration
Test / unmanagedSourceDirectories := (Test / javaSource).value :: Nil
</code></pre><p>However, there should not be any harm in leaving the Scala directories
if they are empty.
</p><h2 id="Mapping+Files">Mapping Files<a href="#Mapping+Files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Tasks like <code>package</code>, <code>packageSrc</code>, and <code>packageDoc</code> accept mappings of
type <code>Seq[(File, String)]</code> from an input file to the path to use in the
resulting artifact (jar). Similarly, tasks that copy files accept
mappings of type <code>Seq[(File, File)]</code> from an input file to the
destination file. There are some methods on
<a href="../api/sbt/io/PathFinder.html">PathFinder</a> and
<a href="../api/sbt/io/Path$.html">Path</a> that can be useful for constructing
the <code>Seq[(File, String)]</code> or <code>Seq[(File, File)]</code> sequences.
</p><p>A common way of making this sequence is to start with a <code>PathFinder</code> or
<code>Seq[File]</code> (which is implicitly convertible to <code>PathFinder</code>) and then
call the <code>pair</code> method. See the
<a href="../api/sbt/io/PathFinder.html">PathFinder</a> API for details, but
essentially this method accepts a function <code>File =&gt; Option[String]</code> or
<code>File =&gt; Option[File]</code> that is used to generate mappings.
</p><h3 id="Relative+to+a+directory">Relative to a directory<a href="#Relative+to+a+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.relativeTo</code> method is used to map a <code>File</code> to its path
<code>String</code> relative to a base directory or directories. The <code>relativeTo</code>
method accepts a base directory or sequence of base directories to
relativize an input file against. The first directory that is an
ancestor of the file is used in the case of a sequence of base
directories.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">import Path.relativeTo
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair relativeTo(baseDirectories)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;b/C.scala&quot;) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Rebase">Rebase<a href="#Rebase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.rebase</code> method relativizes an input file against one or more
base directories (the first argument) and then prepends a base String or
File (the second argument) to the result. As with <code>relativeTo</code>, the
first base directory that is an ancestor of the input file is used in
the case of multiple base directories.
</p><p>For example, the following demonstrates building a <code>Seq[(File, String)]</code>
using <code>rebase</code>:
</p><pre><code class="prettyprint lang-scala">import Path.rebase
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair rebase(baseDirectories, &quot;pre/&quot;)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;pre/b/C.scala&quot; ) :: Nil
assert( mappings == expected )
</code></pre><p>Or, to build a <code>Seq[(File, File)]</code>:
</p><pre><code class="prettyprint lang-scala">import Path.rebase
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val newBase: File = file(&quot;/new/base&quot;)
val mappings: Seq[(File,File)] = files pair rebase(baseDirectories, newBase)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; file(&quot;/new/base/b/C.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Flatten">Flatten<a href="#Flatten" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.flat</code> method provides a function that maps a file to the last
component of the path (its name). For a File to File mapping, the input
file is mapped to a file with the same name in a given target directory.
For example:
</p><pre><code class="prettyprint lang-scala">import Path.flat
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair flat

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;C.scala&quot; ) :: Nil
assert( mappings == expected )
</code></pre><p>To build a <code>Seq[(File, File)]</code> using <code>flat</code>:
</p><pre><code class="prettyprint lang-scala">import Path.flat
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val newBase: File = file(&quot;/new/base&quot;)
val mappings: Seq[(File,File)] = files pair flat(newBase)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; file(&quot;/new/base/C.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Alternatives">Alternatives<a href="#Alternatives" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To try to apply several alternative mappings for a file, use <code>|</code>, which
is implicitly added to a function of type <code>A =&gt; Option[B]</code>. For example,
to try to relativize a file against some base directories but fall back
to flattening:
</p><pre><code class="prettyprint lang-scala">import Path.relativeTo
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: file(&quot;/zzz/D.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair ( relativeTo(baseDirectories) | flat )

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;b/C.scala&quot;) ) :: (file(&quot;/zzz/D.scala&quot;) -&gt; &quot;D.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h2 id="Local+Scala">Local Scala<a href="#Local+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>To use a locally built Scala version, define the <code>scalaHome</code> setting,
which is of type <code>Option[File]</code>. This Scala version will only be used
for the build and not for sbt, which will still use the version it was
compiled against.
</p><p>Example:
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/path/to/scala&quot;))
</code></pre><p>Using a local Scala version will override the <code>scalaVersion</code> setting and
will not work with <a href="Cross-Build.html">cross building</a>.
</p><p>sbt reuses the class loader for the local Scala version. If you
recompile your local Scala version and you are using sbt interactively,
run
</p><pre><code class="">&gt; reload
</code></pre><p>to use the new compilation results.
</p><h2 id="Macro+Projects">Macro Projects<a href="#Macro+Projects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Some common problems arise when working with macros.
</p><ol><li>The current macro implementation in the compiler requires that macro
implementations be compiled before they are used. The solution is
typically to put the macros in a subproject or in their own
configuration.
</li><li>Sometimes the macro implementation should be distributed with the
main code that uses them and sometimes the implementation should not
be distributed at all.
</li></ol><p>The rest of the page shows example solutions to these problems.
</p><h3 id="Defining+the+Project+Relationships">Defining the Project Relationships<a href="#Defining+the+Project+Relationships" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The macro implementation will go in a subproject in the <code>macro/</code>
directory. The core project in the <code>core/</code> directory will depend
on this subproject and use the macro. This configuration is shown in the
following build definition. <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val commonSettings = Seq(
  scalaVersion := &quot;2.12.13&quot;,
  organization := &quot;com.example&quot;
)
lazy val scalaReflect = Def.setting { &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value }

lazy val core = (project in file(&quot;core&quot;))
  .dependsOn(macroSub)
  .settings(
    commonSettings,
    // other settings here
  )

lazy val macroSub = (project in file(&quot;macro&quot;))
  .settings(
    commonSettings,
    libraryDependencies += scalaReflect.value
    // other settings here
  )
</code></pre><p>This specifies that the macro implementation goes in
<code>macro/src/main/scala/</code> and tests go in <code>macro/src/test/scala/</code>. It also
shows that we need a dependency on the compiler for the macro
implementation. As an example macro, we’ll use <code>desugar</code> from
<a href="https://github.com/retronym/macrocosm">macrocosm</a>. <code>macro/src/main/scala/demo/Demo.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

import language.experimental.macros
import scala.reflect.macros.Context

object Demo {

  // Returns the tree of `a` after the typer, printed as source code.
  def desugar(a: Any): String = macro desugarImpl

  def desugarImpl(c: Context)(a: c.Expr[Any]) = {
    import c.universe._

    val s = show(a.tree)
    c.Expr(
      Literal(Constant(s))
    )
  }
}
</code></pre><p><code>macro/src/test/scala/demo/Usage.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

object Usage {
   def main(args: Array[String]): Unit = {
      val s = Demo.desugar(List(1, 2, 3).reverse)
      println(s)
   }
}
</code></pre><p>This can be then run at the console:
</p><pre><code class="">$ sbt
&gt; macroSub/test:run
scala.collection.immutable.List.apply[Int](1, 2, 3).reverse
</code></pre><p>Actual tests can be defined and run as usual with <code>macro/test</code>.
</p><p>The main project can use the macro in the same way that the tests do.
For example,
</p><p><code>core/src/main/scala/MainUsage.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

object Usage {
   def main(args: Array[String]): Unit = {
      val s = Demo.desugar(List(6, 4, 5).sorted)
      println(s)
   }
}
</code></pre><pre><code class="">$ sbt
&gt; core/run
scala.collection.immutable.List.apply[Int](6, 4, 5).sorted[Int](math.this.Ordering.Int)
</code></pre><h3 id="Common+Interface">Common Interface<a href="#Common+Interface" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes, the macro implementation and the macro usage should share
some common code. In this case, declare another subproject for the
common code and have the main project and the macro subproject depend on
the new subproject. For example, the project definitions from above
would look like:
</p><pre><code class="prettyprint lang-scala">lazy val commonSettings = Seq(
  scalaVersion := &quot;2.12.13&quot;,
  organization := &quot;com.example&quot;
)
lazy val scalaReflect = Def.setting { &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value }

lazy val core = (project in file(&quot;core&quot;))
  .dependsOn(macroSub, util)
  .settings(
    commonSettings,
    // other settings here
  )

lazy val macroSub = (project in file(&quot;macro&quot;))
  .dependsOn(util)
  .settings(
    commonSettings,
    libraryDependencies += scalaReflect.value
    // other settings here
  )

lazy util = (project in file(&quot;util&quot;))
  .settings(
    commonSettings,
    // other setting here
  )
</code></pre><p>Code in <code>util/src/main/scala/</code> is available for both the <code>macroSub</code> and
<code>main</code> projects to use.
</p><h3 id="Distribution">Distribution<a href="#Distribution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To include the macro code with the core code, add the binary and source
mappings from the macro subproject to the core project. And also
macro subproject should be removed from core project dependency in
publishing. For example, the <code>core</code> Project definition above would now
look like:
</p><pre><code class="prettyprint lang-scala">lazy val core = (project in file(&quot;core&quot;))
  .dependsOn(macroSub % &quot;compile-internal, test-internal&quot;)
  .settings(
    commonSettings,
    // include the macro classes and resources in the main jar
    Compile / packageBin / mappings ++= (macroSub / Compile / packageBin / mappings).value,
    // include the macro sources in the main source jar
    Compile / packageSrc / mappings ++= (macroSub / Compile / packageSrc / mappings).value
  )
</code></pre><p>You may wish to disable publishing the macro implementation. This is
done by overriding <code>publish</code> and <code>publishLocal</code> to do nothing:
</p><pre><code class="prettyprint lang-scala">lazy val macroSub = (project in file(&quot;macro&quot;))
  .settings(
    commonSettings,
    libraryDependencies += scalaReflect.value,
    publish := {},
    publishLocal := {}
  )
</code></pre><p>The techniques described here may also be used for the common interface
described in the previous section.
</p><h2 id="Paths">Paths<a href="#Paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes files, sequences of files, and file filters. The
base type used is
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html">java.io.File</a>,
but several methods are augmented through implicits:
</p><ul><li><a href="../api/sbt/io/RichFile.html">RichFile</a> adds methods to File
</li><li><a href="../api/sbt/io/PathFinder.html">PathFinder</a> adds methods to File
and Seq[File]
</li><li><a href="../api/sbt/io/Path$.html">Path</a> and <a href="../api/sbt/io/IO$.html">IO</a>
provide general methods related to files and I/O.
</li></ul><h3 id="Constructing+a+File">Constructing a File<a href="#Constructing+a+File" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt uses
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html">java.io.File</a>
to represent a file
and defines the type alias <code>File</code> for <code>java.io.File</code> so
that an extra import is not necessary. The <code>file</code> method is an alias for
the single-argument <code>File</code> constructor to simplify constructing a new
file from a String:
</p><pre><code class="prettyprint lang-scala">val source: File = file(&quot;/home/user/code/A.scala&quot;)
</code></pre><p>Additionally, sbt augments File with a <code>/</code> method, which is an alias for
the two-argument <code>File</code> constructor for building up a path:
</p><pre><code class="prettyprint lang-scala">def readme(base: File): File = base / &quot;README&quot;
</code></pre><p>Relative files should only be used when defining the base directory of a
<code>Project</code>, where they will be resolved properly.
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;root&quot;, file(&quot;.&quot;))
</code></pre><p>Elsewhere, files should be absolute or be built up from an absolute base
<code>File</code>. The <code>baseDirectory</code> setting defines the base directory of the
build or project depending on the scope.
</p><p>For example, the following setting sets the unmanaged library directory
to be the “custom_lib” directory in a project’s base directory:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value /&quot;custom_lib&quot;
</code></pre><p>Or, more concisely:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value /&quot;custom_lib&quot;
</code></pre><p>This setting sets the location of the shell history to be in the base
directory of the build, irrespective of the project the setting is
defined in:
</p><pre><code class="prettyprint lang-scala">historyPath := Some( (ThisBuild / baseDirectory).value / &quot;.history&quot;),
</code></pre><a name="path-finder"></a><h3 id="Path+Finders">Path Finders<a href="#Path+Finders" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <code>PathFinder</code> computes a <code>Seq[File]</code> on demand. It is a way to build a
sequence of files. There are several methods that augment <code>File</code> and
<code>Seq[File]</code> to construct a <code>PathFinder</code>. Ultimately, call <code>get</code> on the
resulting <code>PathFinder</code> to evaluate it and get back a <code>Seq[File]</code>.
</p><h4 id="Selecting+descendants">Selecting descendants<a href="#Selecting+descendants" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>**</code> method accepts a <code>java.io.FileFilter</code> and selects all files
matching that filter.
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): PathFinder = (base / &quot;src&quot;) ** &quot;*.scala&quot;
</code></pre><h4 id="get">get<a href="#get" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This selects all files that end in <code>.scala</code> that are in <code>src</code> or a
descendent directory. The list of files is not actually evaluated until
<code>get</code> is called:
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): Seq[File] = {
  val finder: PathFinder = (base / &quot;src&quot;) ** &quot;*.scala&quot; 
  finder.get
}
</code></pre><p>If the filesystem changes, a second call to <code>get</code> on the same
<code>PathFinder</code> object will reflect the changes. That is, the <code>get</code> method
reconstructs the list of files each time. Also, <code>get</code> only returns
<code>File</code>s that existed at the time it was called.
</p><h4 id="Selecting+children">Selecting children<a href="#Selecting+children" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Selecting files that are immediate children of a subdirectory is done
with a single <code>*</code>:
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): PathFinder = (base / &quot;src&quot;) * &quot;*.scala&quot;
</code></pre><p>This selects all files that end in <code>.scala</code> that are in the <code>src</code>
directory.
</p><h4 id="Existing+files+only">Existing files only<a href="#Existing+files+only" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If a selector, such as <code>/</code>, <code>**</code>, or <code>*</code>, is used on a path that does
not represent a directory, the path list will be empty:
</p><pre><code class="prettyprint lang-scala">def emptyFinder(base: File) = (base / &quot;lib&quot; / &quot;ivy.jar&quot;) * &quot;not_possible&quot;
</code></pre><h4 id="Name+Filter">Name Filter<a href="#Name+Filter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument to the child and descendent selectors <code>*</code> and <code>**</code> is
actually a <code>NameFilter</code>. An implicit is used to convert a <code>String</code> to a
<code>NameFilter</code> that interprets <code>*</code> to represent zero or more characters of
any value. See the Name Filters section below for more information.
</p><h4 id="Combining+PathFinders">Combining PathFinders<a href="#Combining+PathFinders" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Another operation is concatenation of <code>PathFinder</code>s:
</p><pre><code class="prettyprint lang-scala">def multiPath(base: File): PathFinder =
   (base / &quot;src&quot; / &quot;main&quot;) +++
   (base / &quot;lib&quot;) +++
   (base / &quot;target&quot; / &quot;classes&quot;)
</code></pre><p>When evaluated using <code>get</code>, this will return <code>src/main/</code>, <code>lib/</code>, and
<code>target/classes/</code>. The concatenated finder supports all standard
methods. For example,
</p><pre><code class="prettyprint lang-scala">def jars(base: File): PathFinder =
   (base / &quot;lib&quot; +++ base / &quot;target&quot;) * &quot;*.jar&quot;
</code></pre><p>selects all jars directly in the “lib” and “target” directories.
</p><p>A common problem is excluding version control directories. This can be
accomplished as follows:
</p><pre><code class="prettyprint lang-scala">def sources(base: File) =
   ( (base / &quot;src&quot;) ** &quot;*.scala&quot;) --- ( (base / &quot;src&quot;) ** &quot;.svn&quot; ** &quot;*.scala&quot;)
</code></pre><p>The first selector selects all Scala sources and the second selects all
sources that are a descendent of a <code>.svn</code> directory. The <code>---</code> method
removes all files returned by the second selector from the sequence of
files returned by the first selector.
</p><a name="file-filter"></a><h4 id="Filtering">Filtering<a href="#Filtering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a <code>filter</code> method that accepts a predicate of type
<code>File =&gt; Boolean</code> and is non-strict:
</p><pre><code class="prettyprint lang-scala">// selects all directories under &quot;src&quot;
def srcDirs(base: File) = ( (base / &quot;src&quot;) ** &quot;*&quot;) filter { _.isDirectory }

// selects archives (.zip or .jar) that are selected by 'somePathFinder'
def archivesOnly(base: PathFinder) = base filter ClasspathUtilities.isArchive
</code></pre><h4 id="Empty+PathFinder">Empty PathFinder<a href="#Empty+PathFinder" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>PathFinder.empty</code> is a <code>PathFinder</code> that returns the empty sequence
when <code>get</code> is called:
</p><pre><code class="prettyprint lang-scala">assert( PathFinder.empty.get == Seq[File]() )
</code></pre><h4 id="PathFinder+to+String+conversions">PathFinder to String conversions<a href="#PathFinder+to+String+conversions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Convert a <code>PathFinder</code> to a String using one of the following methods:
</p><ul><li><code>toString</code> is for debugging. It puts the absolute path of each
component on its own line.
</li><li><code>absString</code> gets the absolute paths of each component and separates
them by the platform’s path separator.
</li><li><code>getPaths</code> produces a <code>Seq[String]</code> containing the absolute paths of
each component
</li></ul><h4 id="Mappings">Mappings<a href="#Mappings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The packaging and file copying methods in sbt expect values of type
<code>Seq[(File,String)]</code> and <code>Seq[(File,File)]</code>, respectively. These are
mappings from the input file to its (String) path in the jar or its
(File) destination. This approach replaces the relative path approach
(using the <code>##</code> method) from earlier versions of sbt.
</p><p>Mappings are discussed in detail on the <code>Mapping-Files</code> page.
</p><h3 id="File+Filters">File Filters<a href="#File+Filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The argument to <code>*</code> and <code>**</code> is of type
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileFilter.html">java.io.FileFilter</a>.
sbt provides combinators for constructing <code>FileFilter</code>s.
</p><p>First, a String may be implicitly converted to a <code>FileFilter</code>. The
resulting filter selects files with a name matching the string, with a
<code>*</code> in the string interpreted as a wildcard. For example, the following
selects all Scala sources with the word “Test” in them:
</p><pre><code class="prettyprint lang-scala">def testSrcs(base: File): PathFinder =  (base / &quot;src&quot;) * &quot;*Test*.scala&quot;
</code></pre><p>There are some useful combinators added to <code>FileFilter</code>. The <code>||</code> method
declares alternative <code>FileFilter</code>s. The following example selects all
Java or Scala source files under “src”:
</p><pre><code class="prettyprint lang-scala">def sources(base: File): PathFinder  =  (base / &quot;src&quot;) ** (&quot;*.scala&quot; || &quot;*.java&quot;)
</code></pre><p>The <code>--</code> method excludes a files matching a second filter from the files
matched by the first:
</p><pre><code class="prettyprint lang-scala">def imageResources(base: File): PathFinder =
   (base/&quot;src&quot;/&quot;main&quot;/&quot;resources&quot;) * (&quot;*.png&quot; -- &quot;logo.png&quot;)
</code></pre><p>This will get <code>right.png</code> and <code>left.png</code>, but not <code>logo.png</code>, for
example.
</p><h2 id="Parallel+Execution">Parallel Execution<a href="#Parallel+Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Task+ordering">Task ordering<a href="#Task+ordering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Task ordering is specified by declaring a task’s inputs. Correctness of
execution requires correct input declarations. For example, the
following two tasks do not have an ordering specified:
</p><pre><code class="prettyprint lang-scala">write := IO.write(file(&quot;/tmp/sample.txt&quot;), &quot;Some content.&quot;)

read := IO.read(file(&quot;/tmp/sample.txt&quot;))
</code></pre><p>sbt is free to execute <code>write</code> first and then <code>read</code>, <code>read</code> first and
then <code>write</code>, or <code>read</code> and <code>write</code> simultaneously. Execution of these
tasks is non-deterministic because they share a file. A correct
declaration of the tasks would be:
</p><pre><code class="prettyprint lang-scala">write := {
  val f = file(&quot;/tmp/sample.txt&quot;)
  IO.write(f, &quot;Some content.&quot;)
  f
}

read := IO.read(write.value)
</code></pre><p>This establishes an ordering: <code>read</code> must run after <code>write</code>. We’ve also
guaranteed that <code>read</code> will read from the same file that <code>write</code>
created.
</p><h3 id="Practical+constraints">Practical constraints<a href="#Practical+constraints" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Note: The feature described in this section is experimental. The default
configuration of the feature is subject to change in particular.
</p><h4 id="Background">Background<a href="#Background" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Declaring inputs and dependencies of a task ensures the task is properly
ordered and that code executes correctly. In practice, tasks share
finite hardware and software resources and can require control over
utilization of these resources. By default, sbt executes tasks in
parallel (subject to the ordering constraints already described) in an
effort to utilize all available processors. Also by default, each test
class is mapped to its own task to enable executing tests in parallel.
</p><p>Prior to sbt 0.12, user control over this process was restricted to:
</p><ol><li>Enabling or disabling all parallel execution
(parallelExecution := false, for example).
</li><li>Enabling or disabling mapping tests to their own tasks
(Test / parallelExecution := false, for example).
</li></ol><p>(Although never exposed as a setting, the maximum number of tasks
running at a given time was internally configurable as well.)
</p><p>The second configuration mechanism described above only selected between
running all of a project’s tests in the same task or in separate tasks.
Each project still had a separate task for running its tests and so test
tasks in separate projects could still run in parallel if overall
execution was parallel. There was no way to restriction execution such
that only a single test out of all projects executed.
</p><h3 id="Configuration">Configuration<a href="#Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.12.0 introduces a general infrastructure for restricting task
concurrency beyond the usual ordering declarations. There are two parts
to these restrictions.
</p><ol><li>A task is tagged in order to classify its purpose and resource
utilization. For example, the compile task may be tagged as
Tags.Compile and Tags.CPU.
</li><li>A list of rules restrict the tasks that may execute concurrently.
For example, Tags.limit(Tags.CPU, 4) would allow up to four
computation-heavy tasks to run at a time.
</li></ol><p>The system is thus dependent on proper tagging of tasks and then on a
good set of rules.
</p><h4 id="Tagging+Tasks">Tagging Tasks<a href="#Tagging+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In general, a tag is associated with a weight that represents the task’s
relative utilization of the resource represented by the tag. Currently,
this weight is an integer, but it may be a floating point in the future.
<code>Initialize[Task[T]]</code> defines two methods for tagging the constructed
Task: <code>tag</code> and <code>tagw</code>. The first method, <code>tag</code>, fixes the weight to be
1 for the tags provided to it as arguments. The second method, <code>tagw</code>,
accepts pairs of tags and weights. For example, the following associates
the <code>CPU</code> and <code>Compile</code> tags with the <code>compile</code> task (with a weight of
1).
</p><pre><code class="prettyprint lang-scala">def myCompileTask = Def.task { ... } tag(Tags.CPU, Tags.Compile)

compile := myCompileTask.value
</code></pre><p>Different weights may be specified by passing tag/weight pairs to
<code>tagw</code>:
</p><pre><code class="prettyprint lang-scala">def downloadImpl = Def.task { ... } tagw(Tags.Network -&gt; 3)

download := downloadImpl.value
</code></pre><h4 id="Defining+Restrictions">Defining Restrictions<a href="#Defining+Restrictions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Once tasks are tagged, the <code>concurrentRestrictions</code> setting sets
restrictions on the tasks that may be concurrently executed based on the
weighted tags of those tasks. This is necessarily a global set of rules,
so it must be scoped <code>Global /</code>. For example,
</p><pre><code class="prettyprint lang-scala">Global / concurrentRestrictions := Seq(
  Tags.limit(Tags.CPU, 2),
  Tags.limit(Tags.Network, 10),
  Tags.limit(Tags.Test, 1),
  Tags.limitAll( 15 )
)
</code></pre><p>The example limits:
</p><ul><li>the number of CPU-using tasks to be no more than 2
</li><li>the number of tasks using the network to be no more than 10
</li><li>test execution to only one test at a time across all projects
</li><li>the total number of tasks to be less than or equal to 15
</li></ul><p>Note that these restrictions rely on proper tagging of tasks. Also, the
value provided as the limit must be at least 1 to ensure every task is
able to be executed. sbt will generate an error if this condition is not
met.
</p><p>Most tasks won’t be tagged because they are very short-lived. These
tasks are automatically assigned the label <code>Untagged</code>. You may want to
include these tasks in the CPU rule by using the <code>limitSum</code> method. For
example:
</p><pre><code class="prettyprint lang-scala">...
Tags.limitSum(2, Tags.CPU, Tags.Untagged)
...
</code></pre><p>Note that the limit is the first argument so that tags can be provided
as varargs.
</p><p>Another useful convenience function is <code>Tags.exclusive</code>. This specifies
that a task with the given tag should execute in isolation. It starts
executing only when no other tasks are running (even if they have the
exclusive tag) and no other tasks may start execution until it
completes. For example, a task could be tagged with a custom tag
<code>Benchmark</code> and a rule configured to ensure such a task is executed by
itself:
</p><pre><code class="prettyprint lang-scala">...
Tags.exclusive(Benchmark)
...
</code></pre><p>Finally, for the most flexibility, you can specify a custom function of
type <code>Map[Tag,Int] =&gt; Boolean</code>. The <code>Map[Tag,Int]</code> represents the
weighted tags of a set of tasks. If the function returns <code>true</code>, it
indicates that the set of tasks is allowed to execute concurrently. If
the return value is <code>false</code>, the set of tasks will not be allowed to
execute concurrently. For example, <code>Tags.exclusive(Benchmark)</code> is
equivalent to the following:
</p><pre><code class="prettyprint lang-scala">...
Tags.customLimit { (tags: Map[Tag,Int]) =&gt;
  val exclusive = tags.getOrElse(Benchmark, 0)
   //  the total number of tasks in the group
  val all = tags.getOrElse(Tags.All, 0)
   // if there are no exclusive tasks in this group, this rule adds no restrictions
  exclusive == 0 ||
    // If there is only one task, allow it to execute.
    all == 1
}
...
</code></pre><p>There are some basic rules that custom functions must follow, but the
main one to be aware of in practice is that if there is only one task,
it must be allowed to execute. sbt will generate a warning if the user
defines restrictions that prevent a task from executing at all and will
then execute the task anyway.
</p><h5 id="Built-in+Tags+and+Rules">Built-in Tags and Rules<a href="#Built-in+Tags+and+Rules" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Built-in tags are defined in the <code>Tags</code> object. All tags listed below
must be qualified by this object. For example, <code>CPU</code> refers to the
<code>Tags.CPU</code> value.
</p><p>The built-in semantic tags are:
</p><ul><li><code>Compile</code> - describes a task that compiles sources.
</li><li><code>Test</code> - describes a task that performs a test.
</li><li><code>Publish</code>
</li><li><code>Update</code>
</li><li><code>Untagged</code> - automatically added when a task doesn’t explicitly
define any tags.
</li><li><code>All</code>- automatically added to every task.
</li></ul><p>The built-in resource tags are:
</p><ul><li><code>Network</code> - describes a task’s network utilization.
</li><li><code>Disk</code> - describes a task’s filesystem utilization.
</li><li><code>CPU</code> - describes a task’s computational utilization.
</li></ul><p>The tasks that are currently tagged by default are:
</p><ul><li><code>compile</code> : <code>Compile</code>, <code>CPU</code>
</li><li><code>test</code> : <code>Test</code>
</li><li><code>update</code> : <code>Update</code>, <code>Network</code>
</li><li><code>publish</code>, <code>publishLocal</code> : <code>Publish</code>, <code>Network</code>
</li></ul><p>Of additional note is that the default <code>test</code> task will propagate its
tags to each child task created for each test class.
</p><p>The default rules provide the same behavior as previous versions of sbt:
</p><pre><code class="prettyprint lang-scala">Global / concurrentRestrictions := {
  val max = Runtime.getRuntime.availableProcessors
  Tags.limitAll(if(parallelExecution.value) max else 1) :: Nil
}
</code></pre><p>As before, <code>Test / parallelExecution</code> controls whether tests are mapped
to separate tasks. To restrict the number of concurrently executing
tests in all projects, use:
</p><pre><code class="prettyprint lang-scala">Global / concurrentRestrictions += Tags.limit(Tags.Test, 1)
</code></pre><h4 id="Custom+Tags">Custom Tags<a href="#Custom+Tags" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To define a new tag, pass a String to the <code>Tags.Tag</code> method. For
example:
</p><pre><code class="prettyprint lang-scala">val Custom = Tags.Tag(&quot;custom&quot;)
</code></pre><p>Then, use this tag as any other tag. For example:
</p><pre><code class="prettyprint lang-scala">def aImpl = Def.task { ... } tag(Custom)

aCustomTask := aImpl.value

Global / concurrentRestrictions +=
  Tags.limit(Custom, 1)
</code></pre><h3 id="Future+work">Future work<a href="#Future+work" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is an experimental feature and there are several aspects that may
change or require further work.
</p><h4 id="Tagging+Tasks">Tagging Tasks<a href="#Tagging+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Currently, a tag applies only to the immediate computation it is defined
on. For example, in the following, the second compile definition has no
tags applied to it. Only the first computation is labeled.
</p><pre><code class="prettyprint lang-scala">def myCompileTask = Def.task { ... } tag(Tags.CPU, Tags.Compile)

compile := myCompileTask.value

compile := {
  val result = compile.value
  ... do some post processing ...
}
</code></pre><p>Is this desirable? expected? If not, what is a better, alternative
behavior?
</p><h4 id="Fractional+weighting">Fractional weighting<a href="#Fractional+weighting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Weights are currently <code>int</code>s, but could be changed to be <code>double</code>s if
fractional weights would be useful. It is important to preserve a
consistent notion of what a weight of 1 means so that built-in and
custom tasks share this definition and useful rules can be written.
</p><h4 id="Default+Behavior">Default Behavior<a href="#Default+Behavior" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User feedback on what custom rules work for what workloads will help
determine a good set of default tags and rules.
</p><h4 id="Adjustments+to+Defaults">Adjustments to Defaults<a href="#Adjustments+to+Defaults" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Rules should be easier to remove or redefine, perhaps by giving them
names. As it is, rules must be appended or all rules must be completely
redefined. Also, tags can only be defined for tasks at the original
definition site when using the <code>:=</code> syntax.
</p><p>For removing tags, an implementation of <code>removeTag</code> should follow from
the implementation of <code>tag</code> in a straightforward manner.
</p><h4 id="Other+characteristics">Other characteristics<a href="#Other+characteristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The system of a tag with a weight was selected as being reasonably
powerful and flexible without being too complicated. This selection is
not fundamental and could be enhance, simplified, or replaced if
necessary. The fundamental interface that describes the constraints the
system must work within is <code>sbt.ConcurrentRestrictions</code>. This interface
is used to provide an intermediate scheduling queue between task
execution (<code>sbt.Execute</code>) and the underlying thread-based parallel
execution service (<code>java.util.concurrent.CompletionService</code>). This
intermediate queue restricts new tasks from being forwarded to the
<code>j.u.c.CompletionService</code> according to the <code>sbt.ConcurrentRestrictions</code>
implementation. See the
<a href="https://github.com/sbt/sbt/blob/v1.0.3/tasks/src/main/scala/sbt/ConcurrentRestrictions.scala">sbt.ConcurrentRestrictions</a>
API documentation for details.
</p><h2 id="External+Processes">External Processes<a href="#External+Processes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scala includes a process library to simplify working with external
processes. Use <code>import scala.sys.process._</code> to bring the implicit
conversions into scope.
</p><p>To run an external command, follow it with an exclamation mark <code>!</code>:
</p><pre><code class="prettyprint lang-scala">&quot;find project -name *.jar&quot; !
</code></pre><p>An implicit converts the <code>String</code> to <code>scala.sys.process.ProcessBuilder</code>,
which defines the <code>!</code> method. This method runs the constructed command,
waits until the command completes, and returns the exit code.
Alternatively, the <code>run</code> method defined on <code>ProcessBuilder</code> runs the
command and returns an instance of <code>scala.sys.process.Process</code>, which
can be used to <code>destroy</code> the process before it completes. With no
arguments, the <code>!</code> method sends output to standard output and standard
error. You can pass a <code>Logger</code> to the <code>!</code> method to send output to the
<code>Logger</code>:
</p><pre><code class="prettyprint lang-scala">&quot;find project -name *.jar&quot; ! log
</code></pre><p>You can get a <code>Logger</code> with:
</p><pre><code class="prettyprint lang-scala">val log = streams.value.log
</code></pre><p>If you need to set the working directory or modify the environment, call
<code>scala.sys.process.Process</code> explicitly, passing the command sequence
(command and argument list) or command string first and the working
directory second.  Any environment variables can be passed as a vararg
list of key/value String pairs.
</p><pre><code class="prettyprint lang-scala">Process(&quot;ls&quot; :: &quot;-l&quot; :: Nil, Path.userHome, &quot;key1&quot; -&gt; value1, &quot;key2&quot; -&gt; value2) ! log
</code></pre><p>Operators are defined to combine commands. These operators start with
<code>#</code> in order to keep the precedence the same and to separate them from
the operators defined elsewhere in <code>sbt</code> for filters. In the following
operator definitions, <code>a</code> and <code>b</code> are subcommands.
</p><ul><li><code>a #&amp;&amp; b</code> Execute <code>a</code>. If the exit code is nonzero, return that exit
code and do not execute b. If the exit code is zero, execute b and
return its exit code.
</li><li><code>a #|| b</code> Execute <code>a</code>. If the exit code is zero, return zero for the
exit code and do not execute b. If the exit code is nonzero, execute
b and return its exit code.
</li><li><code>a #| b</code> Execute <code>a</code> and <code>b</code>, piping the output of <code>a</code> to the input
of b.
</li></ul><p>There are also operators defined for redirecting output to <code>File</code>s and
input from <code>File</code>s and <code>URL</code>s. In the following definitions, <code>url</code> is an
instance of <code>URL</code> and <code>file</code> is an instance of <code>File</code>.
</p><ul><li><code>a #&lt; url</code> or <code>url #&gt; a</code> Use <code>url</code> as the input to <code>a</code>. <code>a</code> may be a
File or a command.
</li><li><code>a #&lt; file</code> or <code>file #&gt; a</code> Use <code>file</code> as the input to <code>a</code>. a may be
a File or a command.
</li><li><code>a #&gt; file</code> or <code>file #&lt; a</code> Write the output of <code>a</code> to <code>file</code>. a may
be a File, URL, or a command.
</li><li><code>a #&gt;&gt; file</code> or <code>file #&lt;&lt; a</code> Append the output of <code>a</code> to file. a may
be a File, URL, or a command.
</li></ul><p>There are some additional methods to get the output from a forked
process into a <code>String</code> or the output lines as a <code>Stream[String]</code>. Here
are some examples, but see the
<a href="https://www.scala-lang.org/api/2.12.x/scala/sys/process/ProcessBuilder.html">ProcessBuilder API</a> for details.
</p><pre><code class="prettyprint lang-scala">val listed: String = &quot;ls&quot; !!
val lines2: Stream[String] = &quot;ls&quot; lines_!
</code></pre><p>Finally, there is a <code>cat</code> method to send the contents of <code>File</code>s and
<code>URL</code>s to standard output.
</p><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Download a <code>URL</code> to a <code>File</code>:
</p><pre><code class="prettyprint lang-scala">url(&quot;http://databinder.net/dispatch/About&quot;) #&gt; file(&quot;About.html&quot;) !
// or
file(&quot;About.html&quot;) #&lt; url(&quot;http://databinder.net/dispatch/About&quot;) !
</code></pre><p>Copy a <code>File</code>:
</p><pre><code class="prettyprint lang-scala">file(&quot;About.html&quot;) #&gt; file(&quot;About_copy.html&quot;) !
// or
file(&quot;About_copy.html&quot;) #&lt; file(&quot;About.html&quot;) !
</code></pre><p>Append the contents of a <code>URL</code> to a <code>File</code> after filtering through
<code>grep</code>:
</p><pre><code class="prettyprint lang-scala">url(&quot;http://databinder.net/dispatch/About&quot;) #&gt; &quot;grep JSON&quot; #&gt;&gt; file(&quot;About_JSON&quot;) !
// or
file(&quot;About_JSON&quot;) #&lt;&lt; ( &quot;grep JSON&quot; #&lt; url(&quot;http://databinder.net/dispatch/About&quot;) )  !
</code></pre><p>Search for uses of <code>null</code> in the source directory:
</p><pre><code class="prettyprint lang-scala">&quot;find src -name *.scala -exec grep null {} ;&quot;  #|  &quot;xargs test -z&quot;  #&amp;&amp;  &quot;echo null-free&quot;  #||  &quot;echo null detected&quot;  !
</code></pre><p>Use <code>cat</code>:
</p><pre><code class="prettyprint lang-scala">val spde = url(&quot;http://technically.us/spde/About&quot;)
val dispatch = url(&quot;http://databinder.net/dispatch/About&quot;)
val build = file(&quot;project/build.properties&quot;)
cat(spde, dispatch, build) #| &quot;grep -i scala&quot; !
</code></pre><h2 id="Running+Project+Code">Running Project Code<a href="#Running+Project+Code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The <code>run</code> and <code>console</code> actions provide a means for running user code in
the same virtual machine as sbt.
</p><p><code>run</code> also exists in a variant called <code>runMain</code> that takes an
additional initial argument allowing you to specify the fully
qualified name of the main class you want to run.  <code>run</code> and<code>runMain</code>
share the same configuration and cannot be configured separately.
</p><p>This page describes the problems with running user code in the same
virtual machine as sbt, how sbt handles these problems, what types of
code can use this feature, and what types of code must use a
<a href="Forking.html">forked jvm</a>.  Skip to User Code if you just want to see when
you should use a <a href="Forking.html">forked jvm</a>.
</p><h3 id="Problems">Problems<a href="#Problems" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="System.exit">System.exit<a href="#System.exit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code can call <code>System.exit</code>, which normally shuts down the JVM.
Because the <code>run</code> and <code>console</code> actions run inside the same JVM as sbt,
this also ends the build and requires restarting sbt.
</p><h4 id="Threads">Threads<a href="#Threads" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code can also start other threads. Threads can be left running
after the main method returns. In particular, creating a GUI creates
several threads, some of which may not terminate until the JVM
terminates. The program is not completed until either <code>System.exit</code> is
called or all non-daemon threads terminate.
</p><h4 id="Deserialization+and+class+loading">Deserialization and class loading<a href="#Deserialization+and+class+loading" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>During deserialization, the wrong class loader might be used for various
complex reasons. This can happen in many scenarios, and running under
SBT is just one of them. This is discussed for instance in issues
#163 and #136. The reason is
explained
<a href="https://issues.apache.org/jira/browse/GROOVY-1627">here</a>.
</p><h3 id="sbt%E2%80%99s+Solutions">sbt’s Solutions<a href="#sbt%E2%80%99s+Solutions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="System.exit">System.exit<a href="#System.exit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code is run with a custom <code>SecurityManager</code> that throws a custom
<code>SecurityException</code> when <code>System.exit</code> is called. This exception is
caught by sbt. sbt then disposes of all top-level windows, interrupts
(not stops) all user-created threads, and handles the exit code. If the
exit code is nonzero, <code>run</code> and <code>console</code> complete unsuccessfully. If
the exit code is zero, they complete normally.
</p><h4 id="Threads">Threads<a href="#Threads" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt makes a list of all threads running before executing user code.
After the user code returns, sbt can then determine the threads created
by the user code. For each user-created thread, sbt replaces the
uncaught exception handler with a custom one that handles the custom
<code>SecurityException</code> thrown by calls to <code>System.exit</code> and delegates to
the original handler for everything else. sbt then waits for each
created thread to exit or for <code>System.exit</code> to be called. sbt handles a
call to <code>System.exit</code> as described above.
</p><p>A user-created thread is one that is not in the <code>system</code> thread group
and is not an <code>AWT</code> implementation thread (e.g. <code>AWT-XAWT</code>,
<code>AWT-Windows</code>). User-created threads include the <code>AWT-EventQueue-*</code>
thread(s).
</p><h4 id="User+Code">User Code<a href="#User+Code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Given the above, when can user code be run with the <code>run</code> and <code>console</code>
actions?
</p><p>The user code cannot rely on shutdown hooks and at least one of the
following situations must apply for user code to run in the same JVM:
</p><ol><li>User code creates no threads.
</li><li>User code creates a GUI and no other threads.
</li><li>The program ends when user-created threads terminate on their own.
</li><li><code>System.exit</code> is used to end the program and user-created threads
terminate when interrupted.
</li><li>No deserialization is done, or the deserialization code
ensures that the right class loader is used, as in
<a href="https://github.com/NetLogo/NetLogo/blob/5.x/src/main/org/nlogo/util/ClassLoaderObjectInputStream.scala">https://github.com/NetLogo/NetLogo/blob/5.x/src/main/org/nlogo/util/ClassLoaderObjectInputStream.scala</a>
or
<a href="https://github.com/scala/scala/blob/2.11.x/src/actors/scala/actors/remote/JavaSerializer.scala#L20">https://github.com/scala/scala/blob/2.11.x/src/actors/scala/actors/remote/JavaSerializer.scala#L20</a>.
</li></ol><p>The requirements on threading and shutdown hooks are required because
the JVM does not actually shut down. So, shutdown hooks cannot be run
and threads are not terminated unless they stop when interrupted. If
these requirements are not met, code must run in a
<a href="Forking.html">forked jvm</a>.
</p><p>The feature of allowing <code>System.exit</code> and multiple threads to be used
cannot completely emulate the situation of running in a separate JVM and
is intended for development. Program execution should be checked in a
<a href="Forking.html">forked jvm</a> when using multiple threads or <code>System.exit</code>.
</p><p>As of sbt 0.13.1, multiple <code>run</code> instances can be managed. There can
only be one application that uses AWT at a time, however.
</p><h2 id="Testing">Testing<a href="#Testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Basics">Basics<a href="#Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The standard source locations for testing are:
</p><ul><li>Scala sources in <code>src/test/scala/</code>
</li><li>Java sources in <code>src/test/java/</code>
</li><li>Resources for the test classpath in <code>src/test/resources/</code>
</li></ul><p>The resources may be accessed from tests by using the <code>getResource</code>
methods of <code>java.lang.Class</code> or <code>java.lang.ClassLoader</code>.
</p><p>The main Scala testing frameworks (
<a href="https://scalacheck.org/">ScalaCheck</a>,
<a href="https://scalatest.org/">ScalaTest</a>, and
<a href="http://specs2.org/">specs2</a>) provide an implementation of the
common test interface and only need to be added to the classpath to work
with sbt. For example, ScalaCheck may be used by declaring it as a
<a href="../tutorial/Library-Dependencies.html">managed dependency</a>:
</p><pre><code class="prettyprint lang-scala">lazy val scalacheck = &quot;org.scalacheck&quot; %% &quot;scalacheck&quot; % &quot;1.13.4&quot;
libraryDependencies += scalacheck % Test
</code></pre><p><code>Test</code> is the <a href="Library-Management.html#ivy-configurations">configuration</a> and means that ScalaCheck will
only be on the test classpath and it isn’t needed by the main sources.
This is generally good practice for libraries because your users don’t
typically need your test dependencies to use your library.
</p><p>With the library dependency defined, you can then add test sources in
the locations listed above and compile and run tests. The tasks for
running tests are <code>test</code> and <code>testOnly</code>. The <code>test</code> task accepts no
command line arguments and runs all tests:
</p><pre><code class="">&gt; test
</code></pre><h4 id="testOnly">testOnly<a href="#testOnly" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>testOnly</code> task accepts a whitespace separated list of test names to
run. For example:
</p><pre><code class="">&gt; testOnly org.example.MyTest1 org.example.MyTest2
</code></pre><p>It supports wildcards as well:
</p><pre><code class="">&gt; testOnly org.example.*Slow org.example.MyTest1
</code></pre><h4 id="testQuick">testQuick<a href="#testQuick" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>testQuick</code> task, like <code>testOnly</code>, allows to filter the tests to run
to specific tests or wildcards using the same syntax to indicate the
filters. In addition to the explicit filter, only the tests that satisfy
one of the following conditions are run:
</p><ul><li>The tests that failed in the previous run
</li><li>The tests that were not run before
</li><li>The tests that have one or more transitive dependencies, maybe in a
different project, recompiled.
</li></ul><h5 id="Tab+completion">Tab completion<a href="#Tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Tab completion is provided for test names based on the results of the
last <code>test:compile</code>. This means that a new sources aren’t available for
tab completion until they are compiled and deleted sources won’t be
removed from tab completion until a recompile. A new test source can
still be manually written out and run using <code>testOnly</code>.
</p><h4 id="Other+tasks">Other tasks<a href="#Other+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Tasks that are available for main sources are generally available for
test sources, but are prefixed with <code>Test /</code> on the command line and are
referenced in Scala code with <code>Test /</code> as well. These tasks include:
</p><ul><li><code>Test / compile</code>
</li><li><code>Test / console</code>
</li><li><code>Test / consoleQuick</code>
</li><li><code>Test / run</code>
</li><li><code>Test / runMain</code>
</li></ul><p>See <a href="Running.html">Running</a> for details on these tasks.
</p><h3 id="Output">Output<a href="#Output" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, logging is buffered for each test source file until all
tests for that file complete. This can be disabled by setting
<code>logBuffered</code>:
</p><pre><code class="prettyprint lang-scala">Test / logBuffered := false
</code></pre><h4 id="Test+Reports">Test Reports<a href="#Test+Reports" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, sbt will generate JUnit XML test reports for all tests in
the build, located in the <code>target/test-reports</code> directory for a project.
This can be disabled by disabling the <code>JUnitXmlReportPlugin</code>
</p><pre><code class="prettyprint lang-scala">val myProject = (project in file(&quot;.&quot;)).disablePlugins(plugins.JUnitXmlReportPlugin)
</code></pre><h3 id="Options">Options<a href="#Options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Test+Framework+Arguments">Test Framework Arguments<a href="#Test+Framework+Arguments" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Arguments to the test framework may be provided on the command line to
the <code>testOnly</code> tasks following a <code>--</code> separator. For example:
</p><pre><code class="">&gt; testOnly org.example.MyTest -- -verbosity 1
</code></pre><p>To specify test framework arguments as part of the build, add options
constructed by <code>Tests.Argument</code>:
</p><pre><code class="prettyprint lang-scala">Test / testOptions += Tests.Argument(&quot;-verbosity&quot;, &quot;1&quot;)
</code></pre><p>To specify them for a specific test framework only:
</p><pre><code class="prettyprint lang-scala">Test / testOptions += Tests.Argument(TestFrameworks.ScalaCheck, &quot;-verbosity&quot;, &quot;1&quot;)
</code></pre><h4 id="Setup+and+Cleanup">Setup and Cleanup<a href="#Setup+and+Cleanup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Specify setup and cleanup actions using <code>Tests.Setup</code> and
<code>Tests.Cleanup</code>. These accept either a function of type <code>() =&gt; Unit</code> or
a function of type <code>ClassLoader =&gt; Unit</code>. The variant that accepts a
ClassLoader is passed the class loader that is (or was) used for running
the tests. It provides access to the test classes as well as the test
framework classes.
</p><blockquote><p><strong>Note</strong>: When forking, the ClassLoader containing the test classes cannot be
provided because it is in another JVM. Only use the () =&gt; Unit
variants in this case.
</p></blockquote><p>Examples:
</p><pre><code class="prettyprint lang-scala">Test / testOptions += Tests.Setup( () =&gt; println(&quot;Setup&quot;) )
Test / testOptions += Tests.Cleanup( () =&gt; println(&quot;Cleanup&quot;) )
Test / testOptions += Tests.Setup( loader =&gt; ... )
Test / testOptions += Tests.Cleanup( loader =&gt; ... )
</code></pre><h4 id="Disable+Parallel+Execution+of+Tests">Disable Parallel Execution of Tests<a href="#Disable+Parallel+Execution+of+Tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, sbt runs all tasks in parallel and within the same JVM as sbt itself. 
Because each test is mapped to a task, tests are also run in parallel by default. 
To make tests within a given project execute serially: :
</p><pre><code class="prettyprint lang-scala">Test / parallelExecution := false
</code></pre><p><code>Test</code> can be replaced with <code>IntegrationTest</code> to only execute
integration tests serially. Note that tests from different projects may
still execute concurrently.
</p><h4 id="Filter+classes">Filter classes<a href="#Filter+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you want to only run test classes whose name ends with “Test”, use
<code>Tests.Filter</code>:
</p><pre><code class="prettyprint lang-scala">Test / testOptions := Seq(Tests.Filter(s =&gt; s.endsWith(&quot;Test&quot;)))
</code></pre><h4 id="Forking+tests">Forking tests<a href="#Forking+tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The setting:
</p><pre><code class="prettyprint lang-scala">Test / fork := true
</code></pre><p>specifies that all tests will be executed in a single external JVM. See
<a href="Forking.html">Forking</a> for configuring standard options for forking. By default,
tests executed in a forked JVM are executed <em>sequentially</em>.   More control
over how tests are assigned to JVMs and what options to pass to those is
available with <code>testGrouping</code> key. For example in build.sbt:
</p><pre><code class="prettyprint lang-scala">import Tests._

{
  def groupByFirst(tests: Seq[TestDefinition]) =
    tests groupBy (_.name(0)) map {
      case (letter, tests) =&gt;
        val options = ForkOptions().withRunJVMOptions(Vector(&quot;-Dfirst.letter&quot;+letter))
        new Group(letter.toString, tests, SubProcess(options))
    } toSeq

    Test / testGrouping := groupByFirst( (Test / definedTests).value )
}
</code></pre><p>The tests in a single group are run sequentially. Control the number of
forked JVMs allowed to run at the same time by setting the limit on
<code>Tags.ForkedTestGroup</code> tag, which is 1 by default. <code>Setup</code> and <code>Cleanup</code>
actions cannot be provided with the actual test class loader when a
group is forked.
</p><p>In addition, forked tests can optionally be run in parallel within the
forked JVM(s), using the following setting:
</p><pre><code class="prettyprint lang-scala">Test / testForkedParallel := true
</code></pre><a name="additional-test-configurations"></a><h3 id="Additional+test+configurations">Additional test configurations<a href="#Additional+test+configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can add an additional test configuration to have a separate set of
test sources and associated compilation, packaging, and testing tasks
and settings. The steps are:
</p><ul><li>Define the configuration
</li><li>Add the tasks and settings
</li><li>Declare library dependencies
</li><li>Create sources
</li><li>Run tasks
</li></ul><p>The following two examples demonstrate this. The first example shows how
to enable integration tests. The second shows how to define a customized
test configuration. This allows you to define multiple types of tests
per project.
</p><h4 id="Integration+Tests">Integration Tests<a href="#Integration+Tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following full build configuration demonstrates integration tests.
</p><pre><code class="prettyprint lang-scala">lazy val scalatest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .configs(IntegrationTest)
  .settings(
    Defaults.itSettings,
    libraryDependencies += scalatest % &quot;it,test&quot;
    // other settings here
  )
</code></pre><ul><li><code>configs(IntegrationTest)</code> adds the predefined integration test
configuration. This configuration is referred to by the name it.
</li><li><code>settings(Defaults.itSettings)</code> adds compilation, packaging,
and testing actions and settings in the IntegrationTest
configuration.
</li><li><code>settings(libraryDependencies += scalatest % &quot;it,test&quot;)</code> adds scalatest to both the
standard test configuration and the integration test configuration
it. To define a dependency only for integration tests, use “it” as
the configuration instead of “it,test”.
</li></ul><p>The standard source hierarchy is used:
</p><ul><li><code>src/it/scala</code> for Scala sources
</li><li><code>src/it/java</code> for Java sources
</li><li><code>src/it/resources</code> for resources that should go on the integration
test classpath
</li></ul><p>The standard testing tasks are available, but must be prefixed with
<code>IntegrationTest/</code>. For example to run all integration tests:
</p><pre><code class="">&gt; IntegrationTest/test
</code></pre><p>Or to run a specific test:
</p><pre><code class="">&gt; IntegrationTest/testOnly org.example.AnIntegrationTest
</code></pre><p>Similarly the standard settings may be configured for the
<code>IntegrationTest</code> configuration. If not specified directly, most
<code>IntegrationTest</code> settings delegate to <code>Test</code> settings by default. For
example, if test options are specified as:
</p><pre><code class="prettyprint lang-scala">Test / testOptions += ...
</code></pre><p>then these will be picked up by the <code>Test</code> configuration and in turn by
the <code>IntegrationTest</code> configuration. Options can be added specifically
for integration tests by putting them in the <code>IntegrationTest</code>
configuration:
</p><pre><code class="prettyprint lang-scala">IntegrationTest / testOptions += ...
</code></pre><p>Or, use <code>:=</code> to overwrite any existing options, declaring these to be
the definitive integration test options:
</p><pre><code class="prettyprint lang-scala">IntegrationTest / testOptions := Seq(...)
</code></pre><h4 id="Custom+test+configuration">Custom test configuration<a href="#Custom+test+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The previous example may be generalized to a custom test configuration.
</p><pre><code class="prettyprint lang-scala">lazy val scalatest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
lazy val FunTest = config(&quot;fun&quot;) extend(Test)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testSettings),
    libraryDependencies += scalatest % FunTest
    // other settings here
  )
</code></pre><p>Instead of using the built-in configuration, we defined a new one:
</p><pre><code class="prettyprint lang-scala">lazy val FunTest = config(&quot;fun&quot;) extend(Test)
</code></pre><p>The <code>extend(Test)</code> part means to delegate to <code>Test</code> for undefined
<code>FunTest</code> settings. The line that adds the tasks and settings for the
new test configuration is:
</p><pre><code class="prettyprint lang-scala">settings(inConfig(FunTest)(Defaults.testSettings))
</code></pre><p>This says to add test and settings tasks in the <code>FunTest</code> configuration.
We could have done it this way for integration tests as well. In fact,
<code>Defaults.itSettings</code> is a convenience definition:
<code>val itSettings = inConfig(IntegrationTest)(Defaults.testSettings)</code>.
</p><p>The comments in the integration test section hold, except with
<code>IntegrationTest</code> replaced with <code>FunTest</code> and <code>&quot;it&quot;</code> replaced with
<code>&quot;fun&quot;</code>. For example, test options can be configured specifically for
<code>FunTest</code>:
</p><pre><code class="prettyprint lang-scala">FunTest / testOptions += ...
</code></pre><p>Test tasks are run by prefixing them with <code>fun:</code>
</p><pre><code class="">&gt; FunTest / test
</code></pre><h4 id="Additional+test+configurations+with+shared+sources">Additional test configurations with shared sources<a href="#Additional+test+configurations+with+shared+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An alternative to adding separate sets of test sources (and
compilations) is to share sources. In this approach, the sources are
compiled together using the same classpath and are packaged together.
However, different tests are run depending on the configuration.
</p><pre><code class="prettyprint lang-scala">lazy val scalatest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
lazy val FunTest = config(&quot;fun&quot;) extend(Test)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

def itFilter(name: String): Boolean = name endsWith &quot;ITest&quot;
def unitFilter(name: String): Boolean = (name endsWith &quot;Test&quot;) &amp;&amp; !itFilter(name)

lazy val root = (project in file(&quot;.&quot;))
  .configs(FunTest)
  .settings(
    inConfig(FunTest)(Defaults.testTasks),
    libraryDependencies += scalatest % FunTest,
    Test / testOptions := Seq(Tests.Filter(unitFilter)),
    FunTest / testOptions := Seq(Tests.Filter(itFilter))
    // other settings here
  )
</code></pre><p>The key differences are:
</p><ul><li>We are now only adding the test tasks
(inConfig(FunTest)(Defaults.testTasks)) and not compilation and
packaging tasks and settings.
</li><li>We filter the tests to be run for each configuration.
</li></ul><p>To run standard unit tests, run <code>test</code> (or equivalently, <code>Test / test</code>):
</p><pre><code class="">&gt; test
</code></pre><p>To run tests for the added configuration (here, <code>&quot;FunTest&quot;</code>), prefix it with
the configuration name as before:
</p><pre><code class="">&gt; FunTest / test
&gt; FunTest / testOnly org.example.AFunTest
</code></pre><h5 id="Application+to+parallel+execution">Application to parallel execution<a href="#Application+to+parallel+execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>One use for this shared-source approach is to separate tests that can
run in parallel from those that must execute serially. Apply the
procedure described in this section for an additional configuration.
Let’s call the configuration <code>serial</code>:
</p><pre><code class="prettyprint lang-scala">lazy val Serial = config(&quot;serial&quot;) extend(Test)
</code></pre><p>Then, we can disable parallel execution in just that configuration
using:
</p><pre><code class="prettyprint lang-scala">parallelExecution in Serial := false
</code></pre><p>The tests to run in parallel would be run with <code>test</code> and the ones to
run in serial would be run with <code>serial:test</code>.
</p><h3 id="JUnit">JUnit<a href="#JUnit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Support for JUnit is provided by
<a href="https://github.com/sbt/junit-interface">junit-interface</a>. To add
JUnit support into your project, add the junit-interface dependency in
your project’s main build.sbt file.
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;com.novocode&quot; % &quot;junit-interface&quot; % &quot;0.11&quot; % Test
</code></pre><h3 id="Extensions">Extensions<a href="#Extensions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This page describes adding support for additional testing libraries and
defining additional test reporters. You do this by implementing <code>sbt</code>
interfaces (described below). If you are the author of the testing
framework, you can depend on the test interface as a provided
dependency. Alternatively, anyone can provide support for a test
framework by implementing the interfaces in a separate project and
packaging the project as an sbt <a href="Plugins.html">Plugin</a>.
</p><h4 id="Custom+Test+Framework">Custom Test Framework<a href="#Custom+Test+Framework" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The main Scala testing libraries have built-in support for sbt. To add
support for a different framework, implement the
<a href="https://github.com/sbt/test-interface">uniform test interface</a>.
</p><h4 id="Custom+Test+Reporters">Custom Test Reporters<a href="#Custom+Test+Reporters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Test frameworks report status and results to test reporters. You can
create a new test reporter by implementing either
<a href="../api/sbt/TestReportListener.html">TestReportListener</a> or
<a href="../api/sbt/TestsListener.html">TestsListener</a>.
</p><h4 id="Using+Extensions">Using Extensions<a href="#Using+Extensions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To use your extensions in a project definition:
</p><p>Modify the <code>testFrameworks</code> setting to reference your test framework:
</p><pre><code class="prettyprint lang-scala">testFrameworks += new TestFramework(&quot;custom.framework.ClassName&quot;)
</code></pre><p>Specify the test reporters you want to use by overriding the
<code>testListeners</code> setting in your project definition.
</p><pre><code class="prettyprint lang-scala">testListeners += customTestListener
</code></pre><p>where <code>customTestListener</code> is of type <code>sbt.TestReportListener</code>.
</p><h3 id="In+process+class+loading">In process class loading<a href="#In+process+class+loading" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt executes the <code>run</code> and <code>test</code> tasks within its own JVM instance.
It emulates running an external java command by invoking the task in an isolated
<code>ClassLoader</code>. Compared to <a href="Forking.html">forking</a>, this approach reduces the start
start up latency and total runtime. The performance benefit from simply reusing
the JVM is modest. Class loading and linking of the application dependencies
dominate the start up time of many applications. sbt reduces this start up
latency by re-using some of the loaded classes between runs. It does this by
creating a layered <code>ClassLoader</code> following the standard delegation model of a java
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">ClassLoader</a>.
The outermost layer, which always contains the class files and jars specific to
the project, is discarded between runs. The inner layers, however, can be
reused.
</p><p>Starting with sbt 1.3.0, it is possible to configure the particular approach
that sbt takes to generate layered <code>ClassLoader</code> instances. It is specified via
the <code>classLoaderLayeringStrategy</code>. There are three possible values:
</p><ol><li><code>ScalaLibrary</code> - The parent of the outermost layer is able to load the
scala standard library as well as the scala reflect library provided it is on
the application classpath. This is the default strategy. It is most similar to
the layered <code>ClassLoaders</code> provided by sbt versions &lt; 1.3.0.
</li><li><code>AllLibraryJars</code> - Adds an additional layer for all of the dependency jars
between the scala library layer and the outermost layer. It is the default
strategy when turbo mode is enabled. This strategy can significantly improve the
startup and total runtime performance compared to <code>ScalaLibrary</code>. Results may be
inconsistent if any of the libraries have mutable global state because, unlike
<code>ScalaLibrary</code>, the global state persists between runs. When any libraries use
java serialization, <code>AllLibraryJars</code> should be avoided.
</li><li>Flat - No layering is used. The full classpath, as specified by the
<code>fullClasspath</code> key of the task is loaded in the outermost layer. Consider using
as an alternative to fork if any issues are experienced with <code>ScalaLibrary</code> or
if the application requires all classes to be loaded in the same <code>ClassLoader</code>,
which may be the case for some uses of java serialization.
</li></ol><p>The <code>classLoaderLayeringStrategy</code> can be set in different configurations. For
example, to use the <code>AllLibraryJars</code> strategy in the <code>Test</code> configuration, add
</p><pre><code class="">Test / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.AllLibraryJars
</code></pre><p>to the <code>build.sbt</code> file. Assuming no other changes to the <code>build.sbt</code> file, The
<code>run</code> task will still use <code>ScalaLibrary</code> strategy.
</p><h3 id="Troubleshooting">Troubleshooting<a href="#Troubleshooting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Java reflection may cause issues when used with layered classloaders because it
is possible that the class method that loads another class via reflection may
not have access to that class to be loaded. This is particularly likely if the
class is loaded using <code>Class.forName</code> or
<code>Thread.currentThread.getContextClassLoader.loadClass</code>. Consider the following
example:
</p><pre><code class="prettyprint lang-scala">package example

import scala.concurrent.{ Await, Future }
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration

object ReflectionExample {
  def main(args: Array[String]): Unit = Await.result(Future {
      val cl = Thread.currentThread.getContextClassLoader
      println(cl.loadClass(&quot;example.Foo&quot;))
  }, Duration.Inf)
}
class Foo
</code></pre><p>If one runs <code>ReflectionExample</code> with <code>sbt run</code> using the sbt default <code>ScalaLibrary</code>
strategy, it will fail with a <code>ClassNotFoundException</code> because the context
classloader of the thread that backs the future is the scala library classloader
which is not able to load project classes. To work around this limitation
without changing the layering strategy to <code>Flat</code>, one can do the following:
</p><ol><li>Use <code>Class.forName</code> instead of <code>ClassLoader.loadClass</code>. The jvm implicitly
uses the loader of the calling class for loading classes using <code>Class.forName</code>.
In this case, <code>ReflectionExample</code> is the calling class and it will be in the
same classloader as <code>Foo</code> since they are both part of the project classpath.
</li><li>Provide a classloader for loading. In the example above, this can be done by
replacing <code>val cl = Thread.currentThread.getContextClassLoader</code> with <code>val cl =
getClass.getClassLoader</code>.
</li></ol><p>For case (2), if the name lookup is performed by a library, then a
<code>ClassLoader</code> parameter could be added to the library method that does the
lookup. For example,
</p><pre><code class="prettyprint lang-scala">object Library {
  def lookup(name: String): Class[_] =
    Thread.currentThread.getContextClassLoader.loadClass(name)
}
</code></pre><p>could be rewritten to
</p><pre><code class="prettyprint lang-scala">object Library {
  def lookup(name: String): Class[_] =
    lookup(name, Thread.currentThread.getContextClassLoader)
  def lookup(name: String, loader: ClassLoader): Class[_] =
    loader.loadClass(name)
}
</code></pre><h2 id="Globs">Globs<a href="#Globs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 1.3.0 introduces the <code>Glob</code> type which can be used to specify a file system
query. The design is inspired by shell
<a href="https://en.wikipedia.org/wiki/Glob_%28programming%29">globs</a>. <code>Glob</code> has
only one public method, <code>matches(java.nio.file.Path)</code>, that can be used to
check if a path matches the glob pattern.
</p><h3 id="Constructing+Globs">Constructing Globs<a href="#Constructing+Globs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs can be constructed explicitly or using a dsl that uses the <code>/</code> operator to
extend queries. In all of the examples provided, we use <code>java.nio.file.Path</code>,
but <code>java.io.File</code> may also be used.
</p><p>The simplest Glob represents a single path. Explicitly create a single path glob
with:
</p><pre><code class="prettyprint lang-scala">val glob = Glob(Paths.get(&quot;foo/bar&quot;))
println(glob.matches(Paths.get(&quot;foo&quot;))) // prints false
println(glob.matches(Paths.get(&quot;foo/bar&quot;))) // prints true
println(glob.matches(Paths.get(&quot;foo/bar/baz&quot;))) // prints false
</code></pre><p>It can also be created using the glob dsl with:
</p><pre><code class="prettyprint lang-scala">val glob = Paths.get(&quot;foo/bar&quot;).toGlob
</code></pre><p>There are two special glob objects:
1) <code>AnyPath</code> (aliased by <code>*</code>) matches any path with just one name component
2) <code>RecursiveGlob</code> (aliased by <code>**</code>) matches all paths
</p><p>Using <code>AnyPath</code>, we can explicitly construct a glob that matches all children of
a directory:
</p><pre><code class="prettyprint lang-scala">val path = Paths.get(&quot;/foo/bar&quot;)
val children = Glob(path, AnyPath)
println(children.matches(path)) // prints false
println(children.matches(path.resolve(&quot;baz&quot;)) // prints true
println(children.matches(path.resolve(&quot;baz&quot;).resolve(&quot;buzz&quot;) // prints false
</code></pre><p>Using the dsl, the above becomes:
</p><pre><code class="prettyprint lang-scala">val children    = Paths.get(&quot;/foo/bar&quot;).toGlob / AnyPath
val dslChildren = Paths.get(&quot;/foo/bar&quot;).toGlob / *
// these two definitions have identical results
</code></pre><p>Recursive globs are similar:
</p><pre><code class="prettyprint lang-scala">val path = Paths.get(&quot;/foo/bar&quot;)
val allDescendants = Glob(path, RescursiveGlob)
println(allDescendants.matches(path)) // prints false
println(allDescendants.matches(path.resolve(&quot;baz&quot;)) // prints true
println(allDescendants.matches(path.resolve(&quot;baz&quot;).resolve(&quot;buzz&quot;) // prints true
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">val allDescendants = Paths.get(&quot;/foo/bar&quot;).toGlob / **
</code></pre><h3 id="Path+names">Path names<a href="#Path+names" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs may also be constructed using path names. The following three globs are
equivalent:
</p><pre><code class="prettyprint lang-scala">val pathGlob = Paths.get(&quot;foo&quot;).resolve(&quot;bar&quot;)
val glob = Glob(&quot;foo/bar&quot;)
val altGlob = Glob(&quot;foo&quot;) / &quot;bar&quot;
</code></pre><p>When parsing glob paths, any <code>/</code> characters are automatically converted to <code>\</code>
on windows.
</p><h3 id="Filters">Filters<a href="#Filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs can apply name filters at each path level. For example,
</p><pre><code class="prettyprint lang-scala">val scalaSources = Paths.get(&quot;/foo/bar&quot;).toGlob / ** / &quot;src&quot; / &quot;*.scala&quot;
</code></pre><p>specifies all of the descendants of <code>/foo/bar</code> that have the <code>scala</code> file
extension whose parent directory is named <code>src</code>.
</p><p>More advanced queries are also possible:
</p><pre><code class="prettyprint lang-scala">val scalaAndJavaSources =
  Paths.get(&quot;/foo/bar&quot;).toGlob / ** / &quot;src&quot; / &quot;*.{scala,java}&quot;
</code></pre><h3 id="Depth">Depth<a href="#Depth" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>AnyPath</code> special glob can be used to control the depth of the query. For
example, the glob
</p><pre><code class="prettyprint lang-scala">  val twoDeep = Glob(&quot;/foo/bar&quot;) / * / * / *
</code></pre><p>matches any path that is a descendant of <code>/foo/bar</code> that has exactly two
parents, e.g. <code>/foo/bar/a/b/c.txt</code> would be accepted but not <code>/foo/bar/a/b</code> or
<code>/foo/bar/a/b/c/d.txt</code>.
</p><h3 id="Regular+expressions">Regular expressions<a href="#Regular+expressions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Glob</code> apis use glob syntax (see
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)">PathMatcher</a>
for details). <a href="https://www.scala-lang.org/api/2.12.8/scala/util/matching/Regex.html">Regular
expressions</a>
can be used instead:
</p><pre><code class="prettyprint lang-scala">val digitGlob = Glob(&quot;/foo/bar&quot;) / &quot;.*-\d{2,3}[.]txt&quot;.r
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-1.txt&quot;)) // false
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-23.txt&quot;)) // true
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-123.txt&quot;)) // true
</code></pre><p>It is possible to specify multiple path components in the regex:
</p><pre><code class="prettyprint lang-scala">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/.*/foo.txt&quot;
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/buzz/foo.txt&quot;)) // true
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-12/buzz/foo.txt&quot;)) // false
</code></pre><p>Recursive globs cannot be expressed using regex syntax because <code>**</code> is not valid
in a regex and paths are matched component wise (so <code>&quot;foo/.*/foo.txt&quot;</code> is actually
split into three regular expressions <code>{&quot;foo&quot;, &quot;.*&quot;, &quot;foo.txt&quot;}</code> for matching
purposes. To make the <code>multiRegex</code> from above recursive, one could write:
</p><pre><code class="">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/&quot;.r / ** / &quot;foo.txt&quot;
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/buzz/foo.txt&quot;)) // true
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/fizz/buzz/foo.txt&quot;)) // true
</code></pre><p>In regex syntax, <code>\</code> is an escape character and cannot be used as a path
separator. If the regex covers multiple path components, <code>/</code> must be used as the
path separator, even on Windows:
</p><pre><code class="">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/foo\.txt&quot;.r
val validRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz/Foo[.].txt&quot;.r
// throws java.util.regex.PatternSyntaxException because \F is not a valid
// regex construct
val invalidRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz\Foo[.].txt&quot;.r
</code></pre><a name="file-tree-view"></a><h3 id="Querying+the+file+system+with+FileTreeView">Querying the file system with FileTreeView<a href="#Querying+the+file+system+with+FileTreeView" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Querying the file system for the files that match one or more <code>Glob</code> patterns is
done via the <code>sbt.nio.file.FileTreeView</code> trait. It provides two methods
</p><ol><li><code>def list(glob: Glob): Seq[(Path, FileAttributes)]</code>
</li><li><code>def list(globs: Seq[Glob]): Seq[(Path, FileAttributes)]</code>
</li></ol><p>that can be used to retrieve all of the paths matching the provided patterns.
</p><pre><code class="prettyprint lang-scala">val scalaSources: Glob = ** / &quot;*.scala&quot;
val regularSources: Glob = &quot;/foo/src/main/scala&quot; / scalaSources
val scala212Sources: Glob = &quot;/foo/src/main/scala-2.12&quot;
val sources: Seq[Path] = FileTreeView.default.list(regularSources).map(_._1)
val allSources: Seq[Path] =
  FileTreeView.default.list(Seq(regularSources, scala212Sources)).map(_._1)
</code></pre><p>In the variant that takes <code>Seq[Glob]</code> as input, sbt will aggregate all of the
globs in such a way that it will only ever list any directory on the file system
once. It should return all of the files whose path name matches <em>any</em> of the
provided <code>Glob</code> patterns in the input <code>Seq[Glob]</code>.
</p><h4 id="File+attributes">File attributes<a href="#File+attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>FileTreeView</code> trait is parameterized by a type, <code>T</code>, that is always
<code>(java.nio.file.Path, sbt.nio.file.FileAttributes)</code> in sbt. The <code>FileAttributes</code>
trait provides access to the following properties:
</p><ol><li><code>isDirectory</code> — returns true if the <code>Path</code> represents a directory.
</li><li><code>isRegularFile</code> — returns true if the <code>Path</code> represents a regular file. This
should usually be the inverse of <code>isDirectory</code>.
</li><li><code>isSymbolicLink</code> — returns true if the <code>Path</code> is a symbolic link. The
default <code>FileTreeView</code> implementation always follows symbolic links. If the
symbolic link targets a regular file, both <code>isSymbolicLink</code> and <code>isRegularFile</code>
will be true. Similarly, if the link targets a directory, both <code>isSymbolicLink</code>
and <code>isDirectory</code> will be true. If the link is broken, <code>isSymbolicLink</code> will be
true but both <code>isDirectory</code> and <code>isRegularFile</code> will be false.
</li></ol><p>The reason that the <code>FileTreeView</code> always provides the attributes is because
checking the type of a file requires a system call, which can be slow. All of
the major desktop operating systems provide apis for listing a directory where
both the file names and file node types are returned. This allows sbt to provide
this information without making an extra system call. We can use this to
efficiently filter paths:
</p><pre><code class="prettyprint lang-scala">// No additional io is performed in the call to attributes.isRegularFile
val scalaSourcePaths =
  FileTreeView.default.list(Glob(&quot;/foo/src/main/scala/**/*.scala&quot;)).collect {
    case (path, attributes) if attributes.isRegularFile =&gt; path
  }
</code></pre><a name="path-filters"></a><h4 id="Filtering">Filtering<a href="#Filtering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to the <code>list</code> methods described above, there two additional
overloads that take an <code>sbt.nio.file.PathFilter</code> argument:
</p><ol><li><code>def list(glob: Glob, filter: PathFilter): Seq[(Path, FileAttributes)]</code>
</li><li><code>def list(globs: Seq[Glob], filter: PathFilter): Seq[(Path, FileAttributes)]</code>
</li></ol><p>The <code>PathFilter</code> has a single abstract method:
</p><pre><code class="prettyprint lang-scala">def accept(path: Path, attributes: FileAttributes): Boolean
</code></pre><p>It can be used to further filter the query specified by the glob patterns:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (_, a) =&gt; a.isRegularFile
val scalaSourceFiles =
  FileTreeView.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), regularFileFilter)
</code></pre><p>A <code>Glob</code> may be used as a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val filter: PathFilter = ** / &quot;*include*&quot;
val scalaSourceFiles =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), filter)
</code></pre><p>Instances of <code>PathFilter</code> can be negated with the <code>!</code> unary operator:
</p><pre><code class="prettyprint lang-scala">val hiddenFileFilter: PathFilter = (p, _) =&gt; Try(Files.isHidden(p)).getOrElse(false)
val notHiddenFileFilter: PathFilter = !hiddenFileFilter
</code></pre><p>They can be combined with the <code>&amp;&amp;</code> operator:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (_, a) =&gt; a.isRegularFile
val notHiddenFileFilter: PathFilter = (p, _) =&gt; Try(Files.isHidden(p)).getOrElse(false)
val andFilter = regularFileFilter &amp;&amp; notHiddenFileFilter
val scalaSources =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), andFilter)
</code></pre><p>They can be combined with the <code>||</code> operator:
</p><pre><code class="prettyprint lang-scala">val scalaSources: PathFilter = ** / &quot;*.scala&quot;
val javaSources: PathFilter = ** / &quot;*.java&quot;
val jvmSourceFilter = scalaSources || javaSources
val jvmSourceFiles =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/**&quot;), jvmSourceFilter)
</code></pre><p>There is also an implicit conversion from <code>String</code> to <code>PathFilter</code> that converts
the <code>String</code> to a <code>Glob</code> and converts the <code>Glob</code> to a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (p, a) =&gt; a.isRegularFile
val regularScalaFiles: PathFilter = regularFileFilter &amp;&amp; &quot;**/*.scala&quot;
</code></pre><p>In addition to the ad-hoc filters, there are some commonly used filters that are
available in the default sbt scope:
</p><ol><li><code>sbt.io.HiddenFileFilter</code> — accepts any file that is hidden according to
<code>Files.isHidden</code>. On posix systems, this will just check if the name starts with
<code>.</code> while on Windows, it will need to perform io to extract the <code>dos:hidden</code>
attribute.
</li><li><code>sbt.io.RegularFileFilter</code> — equivalent to <code>(_, a: FileAttributes) =&gt;
a.isRegularFile</code>
</li><li><code>sbt.io.DirectoryFilter</code> — equivalent to <code>(_, a: FileAttributes) =&gt;
a.isDirectory</code>
</li></ol><p>There is also a converter from <code>sbt.io.FileFilter</code> to <code>sbt.nio.file.PathFilter</code>
that can be invoked by calling <code>toNio</code> on the <code>sbt.io.FileFilter</code> instance:
</p><pre><code class="prettyprint lang-scala">val excludeFilter: sbt.io.FileFilter = HiddenFileFilter || DirectoryFilter
val excludePathFilter: sbt.nio.file.PathFilter = excludeFilter.toNio
</code></pre><p>The <code>HiddenFileFilter</code>, <code>RegularFileFilter</code> and <code>DirectoryFilter</code> inherit both
<code>sbt.io.FileFilter</code> and <code>sbt.nio.file.PathFilter</code>. They typically can be treated
like a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val regularScalaFiles: PathFilter = RegularFileFilter &amp;&amp; (** / &quot;*.scala&quot;)
</code></pre><p>This will not work when the implicit conversion from <code>String</code> to <code>PathFinder</code> is
required.
</p><pre><code class="prettyprint lang-scala"> val regularScalaFiles = RegularFileFilter &amp;&amp; &quot;**/*.scala&quot;
// won't compile because it gets interpreted as
// (RegularFileFilter: sbt.io.FileFilter).&amp;&amp;((&quot;**/*.scala&quot;): sbt.io.NameFilter)
</code></pre><p>In these situations, use <code>toNio</code>:
</p><pre><code class="prettyprint lang-scala"> val regularScalaFiles = RegularFileFilter.toNio &amp;&amp; &quot;**/*.scala&quot;
</code></pre><p>It is important to note that semantics of <code>Glob</code> are different from
<code>NameFilter</code>. When using the <code>sbt.io.FileFilter</code>, in order to filter files
ending with the <code>.scala</code> extension, one would write:
</p><pre><code class="prettyprint lang-scala">val scalaFilter: NameFilter = &quot;*.scala&quot;
</code></pre><p>An equivalent <code>PathFilter</code> is written
</p><pre><code class="prettyprint lang-scala">val scalaFilter: PathFilter = &quot;**/*.scala&quot;
</code></pre><p>The glob represented <code>&quot;*.scala&quot;</code> matches a path with a single component ending
in scala. In general, when converting <code>sbt.io.NameFilter</code> to
<code>sbt.nio.file.PathFilter</code>, it will be necessary to add a <code>&quot;**/&quot;</code> prefix.
</p><h4 id="Streaming">Streaming<a href="#Streaming" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to <code>FileTreeView.list</code>, there is also <code>FileTreeView.iterator</code>. The
latter may be used to reduce memory pressure:
</p><pre><code class="">// Prints all of the files on the root file system
FileTreeView.iterator(Glob(&quot;/**&quot;)).foreach { case (p, _) =&gt; println(p) }
</code></pre><p>In the context of sbt, the type parameter, <code>T</code>, is always <code>(java.nio.file.Path,
sbt.nio.file.FileAttributes)</code>. An implementation of <code>FileTreeView</code> is provided in sbt with the <code>fileTreeView</code>
key:
</p><pre><code class="">fileTreeView.value.list(baseDirectory.value / ** / &quot;*.txt&quot;)
</code></pre><h4 id="Implementation">Implementation<a href="#Implementation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>FileTreeView[+T]</code> trait has a single abstract method:
</p><pre><code class="">def list(path: Path): Seq[T]
</code></pre><p>sbt only provides implementations of <code>FileTreeView[(Path, FileAttributes)]</code>. In
this context, the <code>list</code> method should return the <code>(Path, FileAttributes)</code> pairs
for all of the direct children of the input <code>path</code>.
</p><p>There are two implementations of <code>FileTreeView[(Path, FileAttribute)]</code>
provided by sbt:
1. <code>FileTreeView.native</code> — this uses a native jni library to efficiently
extract the file names and attributes from the file system without performing
additional io. Native implementations are available for 64 bit FreeBSD, Linux,
Mac OS and Windows. If no native implementation is available, it falls back to a
<code>java.nio.file</code> based implementation.
2. <code>FileTreeView.nio</code> — uses apis in <code>java.nio.file</code> to implement
<code>FileTreeView</code>
</p><p>The <code>FileTreeView.default</code> method returns <code>FileTreeView.native</code>.
</p><p>The <code>list</code> and <code>iterator</code> methods that take <code>Glob</code> or <code>Seq[Glob]</code> as arguments
are provided as extension methods to <code>FileTreeView[(Path, FileAttributes)]</code>.
Since any implementation of <code>FileTreeView[(Path, FileAttributes)]</code> automatically
receives these extensions, it is easy to write an alternative implementation
that will still correctly work with <code>Glob</code> and <code>Seq[Glob]</code>:
</p><pre><code class="prettyprint lang-scala">val listedDirectories = mutable.Set.empty[Path]
val trackingView: FileTreeView[(Path, FileAttributes)] = path =&gt; {
  val results = FileTreeView.default.list(path)
  listedDirectories += path
  results
}
val scalaSources =
  trackingView.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;)).map(_._1)
println(listedDirectories) // prints all of the directories traversed by list
</code></pre><a name="glob-vs-pathfinder"></a><h3 id="Globs+vs.+PathFinder">Globs vs. PathFinder<a href="#Globs+vs.+PathFinder" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt has long had the <a href="Paths.html#path-finder">PathFinder</a> api which provides a dsl for collecting
files. While there is overlap, Globs are a less powerful abstraction than
PathFinder. This makes them more suitable for optimization. Globs describe the
what, but not the how, of a query. PathFinders combine the what and the how,
which makes them more difficult to optimize. For example, the following sbt snippet:
</p><pre><code class="">val paths = fileTreeView.value.list(
    baseDirectory.value / ** / &quot;*.scala&quot;,
    baseDirectory.value / ** / &quot;*.java&quot;).map(_._1)
</code></pre><p>will only traverse the file system once to collect all of the scala and java
sources in the project. By contrast,
</p><pre><code class="">val paths =
    (baseDirectory.value ** &quot;*.scala&quot; +++
     baseDirectory.value ** &quot;*.java&quot;).allPaths
</code></pre><p>will make two passes and will thus take about twice as long to run when compared
to the Glob version.
</p><h2 id="Remote+Caching">Remote Caching<a href="#Remote+Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 1.4.0 / Zinc 1.4.0 virtualizes the file paths tracked during incremental compilation, and uses content hash for change detection. With these combination, we can realize repeatable build, also known as <em>build as function</em>.
</p><p>This enables <strong>experimental</strong> remote caching (cached compilation) feature. The idea is for a team of developers and/or a continuous integration (CI) system to share build outputs. If the build is repeatable, the output from one machine can be reused by another machine, which can make the build significantly faster.
</p><h4 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">ThisBuild / pushRemoteCacheTo := Some(MavenCache(&quot;local-cache&quot;, file(&quot;/tmp/remote-cache&quot;)))
</code></pre><p>Then from machine 1, call <code>pushRemoteCache</code>. This will publish the <code>*.class</code> and Zinc Analysis artifacts to the location. Next, from machine 2, call <code>pullRemoteCache</code>.
</p><h4 id="Remote+caching+via+Maven+repository">Remote caching via Maven repository<a href="#Remote+caching+via+Maven+repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As of sbt 1.4.0, we’re reusing the Maven publishing and resolution mechanism to exchange the cached build outputs. This is likely to easy to get started using existing infrastructure such as Bintray.
</p><p>In the future, we might consider simpler cache server like plain HTTP server that uses <code>PUT</code> and <code>GET</code>. This would require someone to host an HTTP server somewhere, but provisioning them might become simpler.
</p><h4 id="ThisBuild+%2F+rootPaths">ThisBuild / rootPaths<a href="#ThisBuild+%2F+rootPaths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To abstract machine-specific paths such as your working directory and Coursier cache directory, sbt keeps a map of root paths in <code>ThisBuild / rootPaths</code>. If your build adds special paths for your source or output directory, add them to <code>ThisBuild / rootPaths</code>.
</p><h4 id="remoteCacheId">remoteCacheId<a href="#remoteCacheId" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As of sbt 1.4.2, <code>remoteCacheId</code> uses hash of content hashes for input sources.
</p><h2 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Artifacts">Artifacts<a href="#Artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Selecting+default+artifacts">Selecting default artifacts<a href="#Selecting+default+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the published artifacts are the main binary jar, a jar
containing the main sources and resources, and a jar containing the API
documentation. You can add artifacts for the test classes, sources, or
API or you can disable some of the main artifacts.
</p><p>To add all test artifacts:
</p><pre><code class="prettyprint lang-scala">lazy val app = (project in file(&quot;app&quot;))
  .settings(
    Test / publishArtifact := true,
  )
</code></pre><p>To add them individually:
</p><pre><code class="prettyprint lang-scala">lazy val app = (project in file(&quot;app&quot;))
  .settings(
    // enable publishing the jar produced by `Test/package`
    Test / packageBin / publishArtifact := true,

    // enable publishing the test API jar
    Test / packageDoc / publishArtifact := true,

    // enable publishing the test sources jar
    Test / packageSrc / publishArtifact := true,
  )
</code></pre><p>To disable main artifacts individually:
</p><pre><code class="prettyprint lang-scala">lazy val app = (project in file(&quot;app&quot;))
  .settings(
    // disable publishing the main jar produced by `package`
    Compile / packageBin / publishArtifact := false,

    // disable publishing the main API jar
    Compile / packageDoc / publishArtifact := false,

    // disable publishing the main sources jar
    Compile / packageSrc / publishArtifact := false,
  )
</code></pre><h3 id="Modifying+default+artifacts">Modifying default artifacts<a href="#Modifying+default+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Each built-in artifact has several configurable settings in addition to
<code>publishArtifact</code>. The basic ones are <code>artifact</code> (of type
<code>SettingKey[Artifact]</code>), <code>mappings</code> (of type <code>TaskKey[(File, String)]</code>),
and <code>artifactPath</code> (of type <code>SettingKey[File]</code>).
They are scoped by <code>(Config / &lt;task&gt;)</code> as indicated in the previous section.
</p><p>To modify the type of the main artifact, for example:
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / artifact := {
  val prev: Artifact = (Compile / packageBin / artifact).value
  prev.withType(&quot;bundle&quot;)
}
</code></pre><p>The generated artifact name is determined by the <code>artifactName</code> setting.
This setting is of type <code>(ScalaVersion, ModuleID, Artifact) =&gt; String</code>.
The ScalaVersion argument provides the full Scala version String and the
binary compatible part of the version String. The String result is the
name of the file to produce. The default implementation is
<code>Artifact.artifactName _</code>. The function may be modified to produce
different local names for artifacts without affecting the published
name, which is determined by the <code>artifact</code> definition combined with the
repository pattern.
</p><p>For example, to produce a minimal name without a classifier or cross
path:
</p><pre><code class="prettyprint lang-scala">artifactName := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =&gt;
  artifact.name + &quot;-&quot; + module.revision + &quot;.&quot; + artifact.extension
}
</code></pre><p>(Note that in practice you rarely want to drop the classifier.)
</p><p>Finally, you can get the <code>(Artifact, File)</code> pair for the artifact by
mapping the <code>packagedArtifact</code> task. Note that if you don’t need the
<code>Artifact</code>, you can get just the File from the package task (<code>package</code>,
<code>packageDoc</code>, or <code>packageSrc</code>). In both cases, mapping the task to get
the file ensures that the artifact is generated first and so the file is
guaranteed to be up-to-date.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">val myTask = taskKey[Unit](&quot;My task.&quot;)

myTask :=  {
  val (art, file) = (Compile / packageBin / packagedArtifact).value
  println(&quot;Artifact definition: &quot; + art)
  println(&quot;Packaged file: &quot; + file.getAbsolutePath)
}
</code></pre><h3 id="Defining+custom+artifacts">Defining custom artifacts<a href="#Defining+custom+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to configuring the built-in artifacts, you can declare other
artifacts to publish. Multiple artifacts are allowed when using Ivy
metadata, but a Maven POM file only supports distinguishing artifacts
based on classifiers and these are not recorded in the POM.
</p><p>Basic <code>Artifact</code> construction look like:
</p><pre><code class="prettyprint lang-scala">Artifact(&quot;name&quot;, &quot;type&quot;, &quot;extension&quot;)
Artifact(&quot;name&quot;, &quot;classifier&quot;)
Artifact(&quot;name&quot;, url: URL)
Artifact(&quot;name&quot;, Map(&quot;extra1&quot; -&gt; &quot;value1&quot;, &quot;extra2&quot; -&gt; &quot;value2&quot;))
</code></pre><p>For example:
</p><pre><code class="prettyprint lang-scala">Artifact(&quot;myproject&quot;, &quot;zip&quot;, &quot;zip&quot;)
Artifact(&quot;myproject&quot;, &quot;image&quot;, &quot;jpg&quot;)
Artifact(&quot;myproject&quot;, &quot;jdk15&quot;)
</code></pre><p>See the
<a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency-artifact.html">Ivy documentation</a>
for more details on artifacts. See the
<a href="../api/sbt/librarymanagement/Artifact$.html">Artifact API</a> for combining the
parameters above and specifying [Configurations] and extra attributes.
</p><p>To declare these artifacts for publishing, map them to the task that
generates the artifact:
</p><pre><code class="prettyprint lang-scala">val myImageTask = taskKey[File](...)

myImageTask := {
  val artifact: File = makeArtifact(...)
  artifact
}

addArtifact(Artifact(&quot;myproject&quot;, &quot;image&quot;, &quot;jpg&quot;), myImageTask)
</code></pre><p><code>addArtifact</code> returns a sequence of settings (wrapped in a
<a href="../api/sbt/internal/util/Init$SettingsDefinition.html">SettingsDefinition</a>). In a
full build configuration, usage looks like:
</p><pre><code class="prettyprint lang-scala">lazy val app = (project in file(&quot;app&quot;))
  .settings(
    addArtifact(...)
  )
</code></pre><h3 id="Publishing+.war+files">Publishing .war files<a href="#Publishing+.war+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common use case for web applications is to publish the <code>.war</code> file
instead of the <code>.jar</code> file.
</p><pre><code class="prettyprint lang-scala">lazy val app = (project in file(&quot;app&quot;))
  .settings(
    // disable .jar publishing
    Compile / packageBin / publishArtifact := false,

    // create an Artifact for publishing the .war file
    Compile / packageWar / artifact := {
      val prev: Artifact = (Compile / packageWar / artifact).value
      prev.withType(&quot;war&quot;).withExtension(&quot;war&quot;)
    },

    // add the .war file to what gets published
    addArtifact(Compile / packageWar / artifact, packageWar),
  )
</code></pre><h3 id="Using+dependencies+with+artifacts">Using dependencies with artifacts<a href="#Using+dependencies+with+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify the artifacts to use from a dependency that has custom or
multiple artifacts, use the <code>artifacts</code> method on your dependencies. For
example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += (&quot;org&quot; % &quot;name&quot; % &quot;rev&quot;).artifacts(Artifact(&quot;name&quot;, &quot;type&quot;, &quot;ext&quot;))
</code></pre><p>The <code>from</code> and <code>classifer</code> methods (described on the
<a href="Library-Management.html">Library Management</a> page) are actually convenience
methods that translate to <code>artifacts</code>:
</p><pre><code class="prettyprint lang-scala">def from(url: String) = artifacts(Artifact(name, new URL(url)))
def classifier(c: String) = artifacts(Artifact(name, c))
</code></pre><p>That is, the following two dependency declarations are equivalent:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += (&quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot;).classifier(&quot;jdk15&quot;)

libraryDependencies += (&quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot;).artifacts(Artifact(&quot;testng&quot;, &quot;jdk15&quot;))
</code></pre><h2 id="Dependency+Management+Flow">Dependency Management Flow<a href="#Dependency+Management+Flow" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 0.12.1 addresses several issues with dependency management. These fixes
were made possible by specific, reproducible examples, such as a
situation where the resolution cache got out of date (gh-532). A brief
summary of the current work flow with dependency management in sbt
follows.
</p><h3 id="Background">Background<a href="#Background" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>update</code> resolves dependencies according to the settings in a build
file, such as <code>libraryDependencies</code> and <code>resolvers</code>. Other tasks use the
output of <code>update</code> (an <code>UpdateReport</code>) to form various classpaths. Tasks
that in turn use these classpaths, such as <code>compile</code> or <code>run</code>, thus
indirectly depend on <code>update</code>. This means that before <code>compile</code> can run,
the <code>update</code> task needs to run. However, resolving dependencies on every
<code>compile</code> would be unnecessarily slow and so <code>update</code> must be particular
about when it actually performs a resolution.
</p><h3 id="Caching+and+Configuration">Caching and Configuration<a href="#Caching+and+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Normally, if no dependency management configuration has changed
since the last successful resolution and the retrieved files are
still present, sbt does not ask Ivy to perform resolution.
</li><li>Changing the configuration, such as adding or removing dependencies
or changing the version or other attributes of a dependency, will
automatically cause resolution to be performed. Updates to locally
published dependencies should be detected in sbt 0.12.1 and later
and will force an update. Dependent tasks like compile and run will
get updated classpaths.
</li><li>Directly running the <code>update</code> task (as opposed to a task that
depends on it) will force resolution to run, whether or not
configuration changed. This should be done in order to refresh
remote SNAPSHOT dependencies.
</li><li>When <code>offline := true</code>, remote SNAPSHOTs will not be updated by a
resolution, even an explicitly requested update. This should
effectively support working without a connection to remote
repositories. Reproducible examples demonstrating otherwise are
appreciated. Obviously, update must have successfully run before
going offline.
</li><li>Overriding all of the above, <code>skip in update := true</code> will tell sbt
to never perform resolution. Note that this can cause dependent
tasks to fail. For example, compilation may fail if jars have been
deleted from the cache (and so needed classes are missing) or a
dependency has been added (but will not be resolved because skip is
true). Also, update itself will immediately fail if resolution has
not been allowed to run since the last clean.
</li></ol><h3 id="General+troubleshooting+steps">General troubleshooting steps<a href="#General+troubleshooting+steps" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Run <code>update</code> explicitly. This will typically fix problems with out
of date SNAPSHOTs or locally published artifacts.
</li><li>If a file cannot be found, look at the output of update to see where
Ivy is looking for the file. This may help diagnose an incorrectly
defined dependency or a dependency that is actually not present in a
repository.
</li><li><code>last update</code> contains more information about the most recent
resolution and download. The amount of debugging output from Ivy is
high, so you may want to use last-grep (run help last-grep for usage).
</li><li>Run <code>clean</code> and then <code>update</code>. If this works, it could indicate a
bug in sbt, but the problem would need to be reproduced in order to
diagnose and fix it.
</li><li>Before deleting all of the Ivy cache, first try deleting files in
<code>~/.ivy2/cache</code> related to problematic dependencies. For example, if
there are problems with dependency <code>&quot;org.example&quot; % &quot;demo&quot; % &quot;1.0&quot;</code>,
delete <code>~/.ivy2/cache/org.example/demo/1.0/</code> and retry update. This
avoids needing to redownload all dependencies.
</li><li>Normal sbt usage should not require deleting files from
<code>~/.ivy2/cache</code>, especially if the first four steps have been
followed. If deleting the cache fixes a dependency management issue,
please try to reproduce the issue and submit a test case.
</li></ol><h3 id="Plugins">Plugins<a href="#Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>These troubleshooting steps can be run for plugins by changing to the
build definition project, running the commands, and then returning to
the main project. For example:
</p><pre><code class="">&gt; reload plugins
&gt; update
&gt; reload return
</code></pre><h3 id="Notes">Notes<a href="#Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Configure offline behavior for all projects on a machine by putting
<code>offline := true</code> in <code>$HOME/.sbt/1.0/global.sbt</code>. A command that does this for
the user would make a nice pull request. Perhaps the setting of
offline should go into the output of about or should it be a warning
in the output of update or both?
</li><li>The cache improvements in 0.12.1 address issues in the change
detection for update so that it will correctly re-resolve
automatically in more situations. A problem with an out of date
cache can usually be attributed to a bug in that change detection if
explicitly running update fixes the problem.
</li><li>A common solution to dependency management problems in sbt has been
to remove <code>~/.ivy2/cache</code>. Before doing this with 0.12.1, be sure to
follow the steps in the troubleshooting section first. In
particular, verify that a clean and an explicit update do not solve
the issue.
</li><li>There is no need to mark SNAPSHOT dependencies as <code>changing()</code>
because sbt configures Ivy to know this already.
</li></ol><h2 id="Library+Management">Library Management<a href="#Library+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There’s now a
<a href="Library-Dependencies.html">getting started page</a> about
library management, which you may want to read first.
</p><p><em>Documentation Maintenance Note:</em> it would be nice to remove the overlap
between this page and the getting started page, leaving this page with
the more advanced topics such as checksums and external Ivy files.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two ways for you to manage libraries with sbt: manually or
automatically. These two ways can be mixed as well. This page discusses
the two approaches. All configurations shown here are settings that go
directly in a <a href="Basic-Def.html">.sbt file</a>.
</p><h3 id="Manual+Dependency+Management">Manual Dependency Management<a href="#Manual+Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Manually managing dependencies involves copying any jars that you want
to use to the <code>lib</code> directory. sbt will put these jars on the classpath
during compilation, testing, running, and when using the interpreter.
You are responsible for adding, removing, updating, and otherwise
managing the jars in this directory. No modifications to your project
definition are required to use this method unless you would like to
change the location of the directory you store the jars in.
</p><p>To change the directory jars are stored in, change the <code>unmanagedBase</code>
setting in your project definition. For example, to use <code>custom_lib/</code>:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;custom_lib&quot;
</code></pre><p>If you want more control and flexibility, override the <code>unmanagedJars</code>
task, which ultimately provides the manual dependencies to sbt. The
default implementation is roughly:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedJars := (baseDirectory.value ** &quot;*.jar&quot;).classpath
</code></pre><p>If you want to add jars from multiple directories in addition to the
default directory, you can do:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedJars ++= {
    val base = baseDirectory.value
    val baseDirectories = (base / &quot;libA&quot;) +++ (base / &quot;b&quot; / &quot;lib&quot;) +++ (base / &quot;libC&quot;)
    val customJars = (baseDirectories ** &quot;*.jar&quot;) +++ (base / &quot;d&quot; / &quot;my.jar&quot;)
    customJars.classpath
}
</code></pre><p>See <a href="Paths.html">Paths</a> for more information on building up paths.
</p><h3 id="Automatic+Dependency+Management">Automatic Dependency Management<a href="#Automatic+Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This method of dependency management involves specifying the direct
dependencies of your project and letting sbt handle retrieving and
updating your dependencies.
</p><p>sbt 1.3.0+ uses <a href="https://get-coursier.io/">Coursier</a> to implement dependency management.
Until sbt 1.3.0, sbt has used Apache Ivy for ten years. Coursier does a good job
of keeping the compatibility, but some of the feature might be specific to Apache Ivy.
In those cases, you can use the following setting to switch back to Ivy:
</p><pre><code class="prettyprint lang-scala">ThisBuild / useCoursier := false
</code></pre><h4 id="Inline+Declarations">Inline Declarations<a href="#Inline+Declarations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Inline declarations are a basic way of specifying the dependencies to be
automatically retrieved. They are intended as a lightweight alternative
to a full configuration using Ivy.
</p><h5 id="Dependencies">Dependencies<a href="#Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Declaring a dependency looks like:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre><p>See <a href="#ivy-configurations">configurations</a> for details on configuration
mappings. Also, several dependencies can be declared together:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  groupID %% artifactID % revision,
  groupID %% otherID % otherRevision
)
</code></pre><p>If you are using a dependency that was built with sbt, double the first
<code>%</code> to be <code>%%</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre><p>This will use the right jar for the dependency built with the version of
Scala that you are currently using. If you get an error while resolving
this kind of dependency, that dependency probably wasn’t published for
the version of Scala you are using. See <a href="Cross-Build.html">Cross Build</a> for details.
</p><p>Ivy can select the latest revision of a module according to constraints
you specify. Instead of a fixed revision like <code>&quot;1.6.1&quot;</code>, you specify
<code>&quot;latest.integration&quot;</code>, <code>&quot;2.9.+&quot;</code>, or <code>&quot;[1.0,)&quot;</code>. See the
<a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision">Ivy revisions</a>
documentation for details.
</p><h5 id="Resolvers">Resolvers<a href="#Resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt uses the standard Maven2 repository by default.
</p><p>Declare additional repositories with the form:
</p><pre><code class="prettyprint lang-scala">resolvers += name at location
</code></pre><p>For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
    &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;,
    &quot;org.specs&quot; % &quot;specs&quot; % &quot;1.6.1&quot;
)

resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>sbt can search your local Maven repository if you add it as a
repository:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
</code></pre><p>See <a href="Resolvers.html">Resolvers</a> for details on defining other types of repositories.
</p><h5 id="Override+default+resolvers">Override default resolvers<a href="#Override+default+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>resolvers</code> configures additional, inline user resolvers. By default,
<code>sbt</code> combines these resolvers with default repositories (Maven Central
and the local Ivy repository) to form <code>externalResolvers</code>. To have more
control over repositories, set <code>externalResolvers</code> directly. To only
specify repositories in addition to the usual defaults, configure
<code>resolvers</code>.
</p><p>For example, to use the Sonatype OSS Snapshots repository in addition to
the default repositories,
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>To use the local repository, but not the Maven Central repository:
</p><pre><code class="prettyprint lang-scala">externalResolvers := Resolver.combineDefaultResolvers(resolvers.value, mavenCentral = false)
</code></pre><h5 id="Override+all+resolvers+for+all+builds">Override all resolvers for all builds<a href="#Override+all+resolvers+for+all+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The repositories used to retrieve sbt, Scala, plugins, and application
dependencies can be configured globally and declared to override the
resolvers configured in a build or plugin definition. There are two
parts:
</p><ol><li>Define the repositories used by the launcher.
</li><li>Specify that these repositories should override those in build
definitions.
</li></ol><p>The repositories used by the launcher can be overridden by defining
<code>~/.sbt/repositories</code>, which must contain a <code>[repositories]</code> section
with the same format as the <code>Launcher</code> configuration file. For example:
</p><pre><code class="">[repositories]
local
my-maven-repo: https://example.org/repo
my-ivy-repo: https://example.org/ivy-repo/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre><p>A different location for the repositories file may be specified by the
<code>sbt.repository.config</code> system property in the sbt startup script. The
final step is to set <code>sbt.override.build.repos</code> to true to use these
repositories for dependency resolution and retrieval.
</p><h5 id="Explicit+URL">Explicit URL<a href="#Explicit+URL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>If your project requires a dependency that is not present in a
repository, a direct URL to its jar can be specified as follows:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;slinky&quot; % &quot;slinky&quot; % &quot;2.1&quot; from &quot;https://slinky2.googlecode.com/svn/artifacts/2.1/slinky.jar&quot;
</code></pre><p>The URL is only used as a fallback if the dependency cannot be found
through the configured repositories. Also, the explicit URL is not
included in published metadata (that is, the pom or ivy.xml).
</p><h5 id="Disable+Transitivity">Disable Transitivity<a href="#Disable+Transitivity" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>By default, these declarations fetch all project dependencies,
transitively. In some instances, you may find that the dependencies
listed for a project aren’t necessary for it to build. Projects using
the Felix OSGI framework, for instance, only explicitly require its main
jar to compile and run. Avoid fetching artifact dependencies with either
<code>intransitive()</code> or <code>notTransitive()</code>, as in this example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.felix&quot; % &quot;org.apache.felix.framework&quot; % &quot;1.8.0&quot; intransitive()
</code></pre><h5 id="Classifiers">Classifiers<a href="#Classifiers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>You can specify the classifier for a dependency using the <code>classifier</code>
method. For example, to get the jdk15 version of TestNG:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot; classifier &quot;jdk15&quot;
</code></pre><p>For multiple classifiers, use multiple <code>classifier</code> calls:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;org.lwjgl.lwjgl&quot; % &quot;lwjgl-platform&quot; % lwjglVersion classifier &quot;natives-windows&quot; classifier &quot;natives-linux&quot; classifier &quot;natives-osx&quot;
</code></pre><p>To obtain particular classifiers for all dependencies transitively, run
the <code>updateClassifiers</code> task. By default, this resolves all artifacts
with the <code>sources</code> or <code>javadoc</code> classifier. Select the classifiers to
obtain by configuring the <code>transitiveClassifiers</code> setting. For example,
to only retrieve sources:
</p><pre><code class="prettyprint lang-scala">transitiveClassifiers := Seq(&quot;sources&quot;)
</code></pre><h5 id="Exclude+Transitive+Dependencies">Exclude Transitive Dependencies<a href="#Exclude+Transitive+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>To exclude certain transitive dependencies of a dependency, use the
<code>excludeAll</code> or <code>exclude</code> methods. The <code>exclude</code> method should be used
when a pom will be published for the project. It requires the
organization and module name to exclude. For example,
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; exclude(&quot;javax.jms&quot;, &quot;jms&quot;)
</code></pre><p>The <code>excludeAll</code> method is more flexible, but because it cannot be
represented in a pom.xml, it should only be used when a pom doesn’t need
to be generated. For example,
</p><pre><code class="prettyprint lang-scala">libraryDependencies +=
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; excludeAll(
    ExclusionRule(organization = &quot;com.sun.jdmk&quot;),
    ExclusionRule(organization = &quot;com.sun.jmx&quot;),
    ExclusionRule(organization = &quot;javax.jms&quot;)
  )
</code></pre><p>See <a href="../api/sbt/librarymanagement/ModuleID.html">ModuleID</a> for API details.
</p><p>In certain cases a transitive dependency should be excluded from
all dependencies. This can be achieved by setting up <code>ExclusionRules</code>
in <code>excludeDependencies</code>. 
</p><pre><code class="prettyprint lang-scala">excludeDependencies ++= Seq(
  // commons-logging is replaced by jcl-over-slf4j
  ExclusionRule(&quot;commons-logging&quot;, &quot;commons-logging&quot;)
)
</code></pre><h5 id="Download+Sources">Download Sources<a href="#Download+Sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Downloading source and API documentation jars is usually handled by an
IDE plugin. These plugins use the <code>updateClassifiers</code> and
<code>updateSbtClassifiers</code> tasks, which produce an <code>Update-Report</code>
referencing these jars.
</p><p>To have sbt download the dependency’s sources without using an IDE
plugin, add <code>withSources()</code> to the dependency definition. For API jars,
add <code>withJavadoc()</code>. For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;org.apache.felix&quot; % &quot;org.apache.felix.framework&quot; % &quot;1.8.0&quot; withSources() withJavadoc()
</code></pre><p>Note that this is not transitive. Use the <code>update*Classifiers</code> tasks
for that.
</p><h5 id="Extra+Attributes">Extra Attributes<a href="#Extra+Attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><a href="https://ant.apache.org/ivy/history/2.3.0/concept.html#extra">Extra attributes</a>
can be specified by passing key/value pairs to the <code>extra</code> method.
</p><p>To select dependencies by extra attributes:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org&quot; % &quot;name&quot; % &quot;rev&quot; extra(&quot;color&quot; -&gt; &quot;blue&quot;)
</code></pre><p>To define extra attributes on the current project:
</p><pre><code class="prettyprint lang-scala">projectID := {
    val previous = projectID.value
    previous.extra(&quot;color&quot; -&gt; &quot;blue&quot;, &quot;component&quot; -&gt; &quot;compiler-interface&quot;)
}
</code></pre><h5 id="Inline+Ivy+XML">Inline Ivy XML<a href="#Inline+Ivy+XML" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt additionally supports directly specifying the configurations or
dependencies sections of an Ivy configuration file inline. You can mix
this with inline Scala dependency and repository declarations.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">ivyXML :=
  &lt;dependencies&gt;
    &lt;dependency org=&quot;javax.mail&quot; name=&quot;mail&quot; rev=&quot;1.4.2&quot;&gt;
      &lt;exclude module=&quot;activation&quot;/&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre><h5 id="Ivy+Home+Directory">Ivy Home Directory<a href="#Ivy+Home+Directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>By default, sbt uses the standard Ivy home directory location
<code>${user.home}/.ivy2/</code>. This can be configured machine-wide, for use by
both the sbt launcher and by projects, by setting the system property
<code>sbt.ivy.home</code> in the sbt startup script (described in
<a href="Setup.html">Setup</a>).
</p><p>For example:
</p><pre><code class="">java -Dsbt.ivy.home=/tmp/.ivy2/ ...
</code></pre><h5 id="Checksums">Checksums<a href="#Checksums" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt
(<a href="https://ant.apache.org/ivy/history/latest-milestone/concept.html#checksum">through Ivy</a>)
verifies the checksums of downloaded files by default. It also publishes
checksums of artifacts by default. The checksums to use are specified by
the <em>checksums</em> setting.
</p><p>To disable checksum checking during update:
</p><pre><code class="prettyprint lang-scala">update / checksums := Nil
</code></pre><p>To disable checksum creation during artifact publishing:
</p><pre><code class="prettyprint lang-scala">publishLocal / checksums := Nil

publish / checksums := Nil
</code></pre><p>The default value is:
</p><pre><code class="prettyprint lang-scala">checksums := Seq(&quot;sha1&quot;, &quot;md5&quot;)
</code></pre><a name="conflict-management"></a><h5 id="Conflict+Management">Conflict Management<a href="#Conflict+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The conflict manager decides what to do when dependency resolution
brings in different versions of the same library. By default, the latest
revision is selected. This can be changed by setting <code>conflictManager</code>,
which has type <a href="../api/sbt/librarymanagement/ConflictManager.html">ConflictManager</a>.
See the
<a href="https://ant.apache.org/ivy/history/latest-milestone/settings/conflict-managers.html">Ivy documentation</a>
for details on the different conflict managers. For example, to specify
that no conflicts are allowed,
</p><pre><code class="prettyprint lang-scala">conflictManager := ConflictManager.strict
</code></pre><p>With this set, any conflicts will generate an error. To resolve a
conflict, you must configure a dependency override, which is explained in a later section.
</p><a name="eviction-warning"></a><h5 id="Eviction+warning">Eviction warning<a href="#Eviction+warning" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The following direct dependencies will introduce a conflict on the akka-actor
version because banana-rdf requires akka-actor 2.1.4.
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  &quot;org.w3&quot; %% &quot;banana-rdf&quot; % &quot;0.4&quot;,
  &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.7&quot;,
)
</code></pre><p>The default conflict manager will select the newer version of akka-actor,
2.3.7. This can be confirmed in the output of <code>show update</code>, which
shows the newer version as being selected and the older version as evicted.
</p><pre><code class="">&gt; show update
[info] compile:

[info]  com.typesafe.akka:akka-actor_2.10
[info]    - 2.3.7
...
[info]    - 2.1.4
...
[info]      evicted: true
[info]      evictedReason: latest-revision
...
[info]      callers: org.w3:banana-rdf_2.10:0.4
</code></pre><p>Furthermore, the binary version compatibility of the akka-actor 2.1.4 and 2.3.7 are not guaranteed since the second segment has bumped up. sbt 0.13.6+ detects this automatically and prints out the following warning:
</p><pre><code class="">[warn] There may be incompatibilities among your library dependencies.
[warn] Here are some of the libraries that were evicted:
[warn]  * com.typesafe.akka:akka-actor_2.10:2.1.4 -&gt; 2.3.7
[warn] Run 'evicted' to see detailed eviction warnings
</code></pre><p>Since akka-actor 2.1.4 and 2.3.7 are not binary compatible, the only way to fix this is to downgrade your dependency to akka-actor 2.1.4, or upgrade banana-rdf to use akka-actor 2.3.
</p><h5 id="Overriding+a+version">Overriding a version<a href="#Overriding+a+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>For binary compatible conflicts, sbt provides dependency overrides.
They are configured with the
<code>dependencyOverrides</code> setting, which is a set of <code>ModuleIDs</code>. For
example, the following dependency definitions conflict because spark
uses log4j 1.2.16 and scalaxb uses log4j 1.2.17:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
   &quot;org.spark-project&quot; %% &quot;spark-core&quot; % &quot;0.5.1&quot;,
   &quot;org.scalaxb&quot; %% &quot;scalaxb&quot; % &quot;1.0.0&quot;
)
</code></pre><p>The default conflict manager chooses the latest revision of log4j,
1.2.17:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.17: ...
...
[info]    (EVICTED) log4j:log4j:1.2.16
...
</code></pre><p>To change the version selected, add an override:
</p><pre><code class="prettyprint lang-scala">dependencyOverrides += &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.16&quot;
</code></pre><p>This will not add a direct dependency on log4j, but will force the
revision to be 1.2.16. This is confirmed by the output of <code>show update</code>:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.16
...
</code></pre><blockquote><p><strong>Note:</strong> this is an Ivy-only feature and will not be included in a
published pom.xml.
</p></blockquote><h5 id="Unresolved+dependencies+error">Unresolved dependencies error<a href="#Unresolved+dependencies+error" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Adding the following dependency to your project will result to an unresolved dependencies error of vpp 2.2.1:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.cayenne.plugins&quot; % &quot;maven-cayenne-plugin&quot; % &quot;3.0.2&quot;
</code></pre><p>sbt 0.13.6+ will try to reconstruct dependencies tree when it fails to resolve a managed dependency. This is an approximation, but it should help you figure out where the problematic dependency is coming from. When possible sbt will display the source position next to the modules:
</p><pre><code class="">[warn]  ::::::::::::::::::::::::::::::::::::::::::::::
[warn]  ::          UNRESOLVED DEPENDENCIES         ::
[warn]  ::::::::::::::::::::::::::::::::::::::::::::::
[warn]  :: foundrylogic.vpp#vpp;2.2.1: not found
[warn]  ::::::::::::::::::::::::::::::::::::::::::::::
[warn] 
[warn]  Note: Unresolved dependencies path:
[warn]      foundrylogic.vpp:vpp:2.2.1
[warn]        +- org.apache.cayenne:cayenne-tools:3.0.2
[warn]        +- org.apache.cayenne.plugins:maven-cayenne-plugin:3.0.2 (/foo/some-test/build.sbt#L28)
[warn]        +- d:d_2.10:0.1-SNAPSHOT
</code></pre><h5 id="Cached+resolution">Cached resolution<a href="#Cached+resolution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>See <a href="Cached-Resolution.html">Cached resolution</a> for performance improvement option.
</p><h5 id="Publishing">Publishing<a href="#Publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>See <a href="Publishing.html">Publishing</a> for how to publish your project.
</p><a name="ivy-configurations"></a><h5 id="Configurations">Configurations<a href="#Configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Ivy configurations are a useful feature for your build when you need
custom groups of dependencies, such as for a plugin. Ivy configurations
are essentially named sets of dependencies. You can read the
<a href="https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html">Ivy documentation</a>
for details.
</p><p>The built-in use of configurations in sbt is similar to scopes in Maven.
sbt adds dependencies to different classpaths by the configuration that
they are defined in. See the description of
<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">Maven Scopes</a>
for details.
</p><p>You put a dependency in a configuration by selecting one or more of its
configurations to map to one or more of your project’s configurations.
The most common case is to have one of your configurations <code>A</code> use a
dependency’s configuration <code>B</code>. The mapping for this looks like
<code>&quot;A-&gt;B&quot;</code>. To apply this mapping to a dependency, add it to the end of
your dependency definition:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;2.1.3&quot; % &quot;test-&gt;compile&quot;
</code></pre><p>This says that your project’s <code>&quot;test&quot;</code> configuration uses <code>ScalaTest</code>’s
<code>&quot;compile&quot;</code> configuration. See the
<a href="https://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html">Ivy documentation</a>
for more advanced mappings. Most projects published to Maven
repositories will use the <code>&quot;compile&quot;</code> configuration.
</p><p>A useful application of configurations is to group dependencies that are
not used on normal classpaths. For example, your project might use a
<code>&quot;js&quot;</code> configuration to automatically download jQuery and then include
it in your jar by modifying <code>resources</code>. For example:
</p><pre><code class="prettyprint lang-scala">val JS = config(&quot;js&quot;) hide

ivyConfigurations += JS

libraryDependencies += &quot;jquery&quot; % &quot;jquery&quot; % &quot;3.2.1&quot; % &quot;js-&gt;default&quot; from &quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;

Compile / resources ++= update.value.select(configurationFilter(&quot;js&quot;))
</code></pre><p>The <code>config</code> method defines a new configuration with name <code>&quot;js&quot;</code> and
makes it private to the project so that it is not used for publishing.
See <a href="Update-Report.html">Update Report</a> for more information on selecting
managed artifacts.
</p><p>A configuration without a mapping (no <code>&quot;-&gt;&quot;</code>) is mapped to <code>&quot;default&quot;</code>
or <code>&quot;compile&quot;</code>. The <code>-&gt;</code> is only needed when mapping to a different
configuration than those. The ScalaTest dependency above can then be
shortened to:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;2.1.3&quot; % &quot;test&quot;
</code></pre><h5 id="Forcing+a+revision+%28Not+recommended%29">Forcing a revision (Not recommended)<a href="#Forcing+a+revision+%28Not+recommended%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><strong>Note</strong>: Forcing can create logical inconsistencies so it’s no longer recommended.
</p><p>To say that we prefer the version we’ve specified over the version from
indirect dependencies, use <code>force()</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  &quot;org.spark-project&quot; %% &quot;spark-core&quot; % &quot;0.5.1&quot;,
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.14&quot; force()
)
</code></pre><p><strong>Note:</strong> this is an Ivy-only feature and cannot be included in a
published pom.xml.
</p><h5 id="Known+limitations">Known limitations<a href="#Known+limitations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Maven support is dependent on Coursier or Ivy’s support for Maven POMs. Known issues
with this support:
</p><ul><li>Specifying <code>relativePath</code> in the <code>parent</code> section of a POM will
produce an error.
</li><li>Ivy ignores repositories specified in the POM. A workaround is to
specify repositories inline or in an Ivy <code>ivysettings.xml</code> file.
</li></ul><h2 id="Proxy+Repositories">Proxy Repositories<a href="#Proxy+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>It’s often the case that users wish to set up a maven/ivy proxy
repository inside their corporate firewall, and have developer sbt
instances resolve artifacts through such a proxy. Let’s detail what
exact changes must be made for this to work.
</p><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The situation arises when many developers inside an organization are
attempting to resolve artifacts. Each developer’s machine will hit the
internet and download an artifact, regardless of whether or not another
on the team has already done so. Proxy repositories provide a single
point of remote download for an organization. In addition to control and
security concerns, Proxy repositories are primarily important for
increased speed across a team.
</p><p><img src="files/proxy-cloud-setup.png" alt="image"/>
</p><p>There are many good proxy repository solutions out there:
</p><ul><li><a href="https://jfrog.com/open-source/">JFrog Artifactory Open Source</a>
</li><li><a href="https://jfrog.com/artifactory/">JFrog Artifactory Pro</a>
</li><li><a href="http://www.sonatype.org/nexus/">Sonatype Nexus Repository Manager</a>
</li><li><a href="http://archiva.apache.org/">Apache Archiva</a>
</li><li><a href="https://www.cloudrepo.io">CloudRepo</a>
</li></ul><p>Once you have a proxy repository installed and configured, then it’s
time to configure sbt for your needs. Read the note at the bottom about
proxy issues with ivy repositories.
</p><h3 id="sbt+Configuration">sbt Configuration<a href="#sbt+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt requires configuration in two places to make use of a proxy
repository. The first is the <code>~/.sbt/repositories</code> file, and the second
is the launcher script.
</p><h3 id=""><code>~/.sbt/repositories</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The repositories file is an external configuration for the Launcher. The
exact syntax for the configuration file is detailed in the
<a href="Launcher-Configuration.html">sbt Launcher Configuration</a>.
</p><p>Here’s an example config:
</p><pre><code class="">[repositories]
  local
  my-ivy-proxy-releases: http://repo.company.com/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
  my-maven-proxy-releases: http://repo.company.com/maven-releases/
</code></pre><p>This example configuration has three repositories configured for sbt.
</p><p>The first resolver is <code>local</code>, and is used so that artifacts pushed
using <code>publishLocal</code> will be seen in other sbt projects.
</p><p>The second resolver is <code>my-ivy-proxy-releases</code>. This repository is used
to resolve sbt <em>itself</em> from the company proxy repository, as well as
any sbt plugins that may be required. Note that the ivy resolver pattern
is important, make sure that yours matches the one shown or you may not
be able to resolve sbt plugins.
</p><p>The final resolver is <code>my-maven-proxy-releases</code>. This repository is a
proxy for all standard maven repositories, including maven central.
</p><p>This repositories file is all that’s required to use a proxy repository.  These repositories will get included first in any sbt build, however you can add some additional configuration to force the use of the proxy repository instead of other configurations.
</p><h3 id="Using+credentials+for+the+proxy+repository">Using credentials for the proxy repository<a href="#Using+credentials+for+the+proxy+repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In case you need to define credentials to connect to your proxy repository, define an environment variable <code>SBT_CREDENTIALS</code> that points to the file containing your credentials:
</p><pre><code>export SBT_CREDENTIALS=&quot;$HOME/.ivy2/.credentials&quot;
</code></pre><p>with file contents
</p><pre><code class="">  realm=My Nexus Repository Manager
  host=my.artifact.repo.net
  user=admin
  password=admin123
</code></pre><p>If the above does not work for your system, then another approach is to explicitly provide the boot credentials via:
</p><pre><code>-Dsbt.boot.credentials=&quot;$HOME/.ivy2/.credentials&quot;
</code></pre><p>As well as add the credentials to your build file directly:
</p><pre><code>credentials += Credentials(Path.userHome / &quot;.ivy2&quot; / &quot;.credentials&quot;)

</code></pre><h4 id="Launcher+Script">Launcher Script<a href="#Launcher+Script" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The sbt launcher supports two configuration options that allow the usage
of proxy repositories. The first is the <code>sbt.override.build.repos</code>
setting and the second is the <code>sbt.repository.config</code> setting.
</p><h4 id=""><code>sbt.override.build.repos</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This setting is used to specify that all sbt project added resolvers
should be ignored in favor of those configured in the <code>repositories</code>
configuration. Using this with a properly configured
<code>~/.sbt/repositories</code> file leads to only your proxy repository used for
builds.
</p><p>It is specified like so:
</p><pre><code class="">-Dsbt.override.build.repos=true
</code></pre><p>The value defaults to false and must be explicitly enabled.
</p><h4 id=""><code>sbt.repository.config</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you are unable to create a <code>~/.sbt/repositories</code> file, due to user
permission errors or for convenience of developers, you can modify the
sbt start script directly with the following:
</p><pre><code class="">-Dsbt.repository.config=&lt;path-to-your-repo-file&gt;
</code></pre><p>This is only necessary if users do not already have their own default
repository file.
</p><h3 id="Proxying+Ivy+Repositories">Proxying Ivy Repositories<a href="#Proxying+Ivy+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The most common mistake made when setting up a proxy repository for sbt
is attempting to <em>merge</em> both <em>maven</em> and <em>ivy</em> repositories into
the <em>same</em> proxy repository. While some repository managers will allow
this, it’s not recommended to do so.
</p><p>Even if your company does not use ivy, sbt uses a custom layout to
handle binary compatibility constraints of its own plugins. To ensure
that these are resolved correctly, simply set up two virtual/proxy
repositories, one for maven and one for ivy.
</p><p>Here’s an example setup:
</p><p><img src="files/proxy-ivy-mvn-setup.png" alt="image"/>
</p><p><strong>NOTE</strong>: If using Nexus as the proxy repository, then it is very important that you set the layout policy to
“permissive” for the proxy mapping that you create to the upstream repository
http://repo.scala-sbt.org/scalasbt/sbt-plugin-releases. If you do not, Nexus will stop short of proxying the
original request to this url and issue a HTTP 404 in its place and the dependency will not resolve.
</p><h2 id="Publishing">Publishing<a href="#Publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes how to publish your project. Publishing consists of
uploading a descriptor, such as an Ivy file or Maven POM, and artifacts,
such as a jar or war, to a repository so that other projects can specify
your project as a dependency.
</p><p>The <code>publish</code> action is used to publish your project to a remote
repository. To use publishing, you need to specify the repository to
publish to and the credentials to use. Once these are set up, you can
run <code>publish</code>.
</p><p>The <code>publishLocal</code> action is used to publish your project to your Ivy local
file repository, which is usually located at <code>$HOME/.ivy2/local/</code>. You can
then use this project from other projects on the same machine.
</p><h3 id="Skip+publishing">Skip publishing<a href="#Skip+publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To avoid publishing a project, add the following setting to the subprojects that you want to skip:
</p><pre><code class="prettyprint lang-scala">publish / skip := true
</code></pre><p>Common use case is to prevent publishing of the root project.
</p><h3 id="Define+the+repository">Define the repository<a href="#Define+the+repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify the repository, assign a repository to <code>publishTo</code> and
optionally set the publishing style. For example, to upload to Nexus:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(&quot;Sonatype Snapshots Nexus&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;)
</code></pre><p>To publish to a local maven repository:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(MavenCache(&quot;local-maven&quot;, file(&quot;path/to/maven-repo/releases&quot;)))
</code></pre><p>To publish to a local Ivy repository:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(Resolver.file(&quot;local-ivy&quot;, file(&quot;path/to/ivy-repo/releases&quot;)))
</code></pre><p>If you’re using Maven repositories you will also have to select the
right repository depending on your artifacts: SNAPSHOT versions go to
the /snapshot repository while other versions go to the /releases
repository. Doing this selection can be done by using the value of the
<code>isSnapshot</code> SettingKey:
</p><pre><code class="prettyprint lang-scala">publishTo := {
  val nexus = &quot;https://my.artifact.repo.net/&quot;
  if (isSnapshot.value)
    Some(&quot;snapshots&quot; at nexus + &quot;content/repositories/snapshots&quot;)
  else
    Some(&quot;releases&quot;  at nexus + &quot;service/local/staging/deploy/maven2&quot;)
}
</code></pre><h3 id="Publishing+locally">Publishing locally<a href="#Publishing+locally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>publishLocal</code> task will publish to the “local” Ivy repository.
By default, this is at <code>$HOME/.ivy2/local/</code>. Other builds on the
same machine can then list the project as a dependency. For example, if
the project you are publishing has configuration parameters like:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;org.me&quot;
ThisBuild / version      := &quot;0.1-SNAPSHOT&quot;

name := &quot;My Project&quot;
</code></pre><p>Then another build on the same machine can depend on it:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.me&quot; %% &quot;my-project&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre><p>The version number you select must end with <code>SNAPSHOT</code>, or you must
change the version number each time you publish to indicate that it’s
a changing artifact.
</p><p><strong>Note</strong>: SNAPSHOT dependencies should be avoided beyond local testing since
it makes dependency resolution slower and the build non-repeatable.
</p><p>Similar to <code>publishLocal</code>, <code>publishM2</code> task will publish the user’s Maven local repository.
This is at the location specified by <code>$HOME/.m2/settings.xml</code> or at
<code>$HOME/.m2/repository/</code> by default.
Another build would require <code>Resolver.mavenLocal</code> to resolve out of it:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.mavenLocal
</code></pre><p>See <a href="Resolvers.html">Resolvers</a> for more details.
</p><h3 id="Credentials">Credentials<a href="#Credentials" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two ways to specify credentials for such a repository.
</p><p>The first and better way is to load them from a file, for example:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(Path.userHome / &quot;.sbt&quot; / &quot;.credentials&quot;)
</code></pre><p>The credentials file is a properties file with keys <code>realm</code>, <code>host</code>,
<code>user</code>, and <code>password</code>. For example:
</p><pre><code class="">realm=Sonatype Nexus Repository Manager
host=my.artifact.repo.net
user=admin
password=admin123
</code></pre><p>The second way is to specify them inline:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;, &quot;my.artifact.repo.net&quot;, &quot;admin&quot;, &quot;admin123&quot;)
</code></pre><p><strong>NOTE</strong>: Credentials matching is done using both: <code>realm</code> and <code>host</code> keys.
The <code>realm</code> key is the HTTP WWW-Authenticate header’s realm directive, which is
part of the response of HTTP servers for <a href="https://en.wikipedia.org/wiki/Basic_access_authentication#Server_side">HTTP Basic Authentication</a>.
For a given repository, this can be found by reading all the headers received.
For example:
</p><pre><code class="prettyprint lang-bash">curl -D - my.artifact.repo.net
</code></pre><h3 id="Cross-publishing">Cross-publishing<a href="#Cross-publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To support multiple incompatible Scala versions, enable cross building
and do <code>+ publish</code> (see <a href="Cross-Build.html">Cross Build</a>). See [Resolvers] for other
supported repository types.
</p><h3 id="Published+artifacts">Published artifacts<a href="#Published+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the main binary jar, a sources jar, and a API documentation
jar are published. You can declare other types of artifacts to publish
and disable or modify the default artifacts. See the <a href="Artifacts.html">Artifacts</a> page
for details.
</p><h3 id="Modifying+the+generated+POM">Modifying the generated POM<a href="#Modifying+the+generated+POM" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When <code>publishMavenStyle</code> is <code>true</code>, a POM is generated by the <code>makePom</code>
action and published to the repository instead of an Ivy file. This POM
file may be altered by changing a few settings. Set <code>pomExtra</code> to
provide XML (<code>scala.xml.NodeSeq</code>) to insert directly into the generated
pom. For example:
</p><pre><code class="prettyprint lang-scala">pomExtra := &lt;something&gt;&lt;/something&gt;
</code></pre><p>There is also a <code>pomPostProcess</code> setting that can be used to manipulate
the final XML before it is written. It’s type is <code>Node =&gt; Node</code>.
</p><pre><code class="prettyprint lang-scala">pomPostProcess := { (node: Node) =&gt;
  ...
}
</code></pre><p><code>makePom</code> adds to the POM any Maven-style repositories you have
declared. You can filter these by modifying <code>pomRepositoryFilter</code>, which
by default excludes local repositories. To instead only include local
repositories:
</p><pre><code class="prettyprint lang-scala">pomIncludeRepository := { (repo: MavenRepository) =&gt;
  repo.root.startsWith(&quot;file:&quot;)
}
</code></pre><h3 id="Version+scheme">Version scheme<a href="#Version+scheme" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.4.0 adds a new setting called <code>ThisBuild / versionScheme</code> to track version scheme of the build:
</p><pre><code class="">ThisBuild / versionScheme := Some(&quot;early-semver&quot;)
</code></pre><p>The supported values are <code>&quot;early-semver&quot;</code>, <code>&quot;pvp&quot;</code>, <code>&quot;semver-spec&quot;</code>, and <code>&quot;strict&quot;</code>. sbt will include this information into <code>pom.xml</code> and <code>ivy.xml</code> as a property.
</p><table>
<tr><th>versionScheme</th><th>description</th></tr>
<tr><td><nobr><code>Some("early-semver")</code></nobr></td><td>Early Semantic Versioning that would keep binary compatibility across patch updates within 0.Y.z (for instance 0.13.0 and 0.13.2). Once it goes 1.0.0, it follows the regular Semantic Versioning where 1.1.0 is bincompat with 1.0.0.</td></tr>
<tr><td><nobr><code>Some("semver-spec")</code></nobr></td><td><a href="https://semver.org/">Semantic Versioning</a> where all 0.y.z are treated as initial development (no bincompat guarantees)</td></tr>
<tr><td><code>Some("pvp")</code></td><td><a href="https://pvp.haskell.org/">Haskell Package Versioning Policy</a> where X.Y are treated as major version</td></tr>
<tr><td><code>Some("strict")</code></td><td>Requires exact match of version</td></tr>
</table><h2 id="Resolvers">Resolvers<a href="#Resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Maven+resolvers">Maven resolvers<a href="#Maven+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Resolvers for Maven repositories are added as follows:
</p><pre><code class="prettyprint lang-scala">resolvers +=
  &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>This is the most common kind of user-defined resolvers. The rest of this
page describes how to define other types of repositories.
</p><h3 id="Local+Maven+resolvers">Local Maven resolvers<a href="#Local+Maven+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Following adds a resolver to the Maven local repository:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.mavenLocal
</code></pre><p>To add a resolver for a custom location:
</p><pre><code class="prettyprint lang-scala">resolvers += MavenCache(&quot;local-maven&quot;, file(&quot;path/to/maven-repo/releases&quot;))
</code></pre><h3 id="Predefined+resolvers">Predefined resolvers<a href="#Predefined+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A few predefined repositories are available and are listed below
</p><ul><li><code>Resolver.mavenLocal</code> This is the local Maven repository.
</li><li><code>DefaultMavenRepository</code> This is the main Maven repository at
<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a> and is included by default
</li><li><code>JavaNet2Repository</code> This is the java.net Maven2 Repository at
<a href="https://maven.java.net/content/repositories/public/">https://maven.java.net/content/repositories/public/</a>
</li><li><code>Resolver.sonatypeRepo(&quot;public&quot;)</code> (or “snapshots”, “staging”, “releases”) This is Sonatype OSS Maven Repository at
<a href="https://oss.sonatype.org/content/repositories/public">https://oss.sonatype.org/content/repositories/public</a>
</li><li><code>Resolver.typesafeRepo(&quot;releases&quot;)</code> (or “snapshots”) This is Typesafe Repository at
<a href="https://repo.typesafe.com/typesafe/releases">https://repo.typesafe.com/typesafe/releases</a>
</li><li><code>Resolver.typesafeIvyRepo(&quot;releases&quot;)</code> (or “snapshots”) This is Typesafe Ivy Repository at
<a href="https://repo.typesafe.com/typesafe/ivy-releases">https://repo.typesafe.com/typesafe/ivy-releases</a>
</li><li><code>Resolver.sbtPluginRepo(&quot;releases&quot;)</code> (or “snapshots”) This is sbt Community Repository at
<a href="https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases">https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases</a>
</li><li><code>Resolver.bintrayRepo(&quot;owner&quot;, &quot;repo&quot;)</code> This is the Bintray repository at
<a href="https://dl.bintray.com/[owner]/[repo]/">https://dl.bintray.com/[owner]/[repo]/</a>
</li><li><code>Resolver.jcenterRepo</code> This is the Bintray JCenter repository at
<a href="https://jcenter.bintray.com/">https://jcenter.bintray.com/</a>
</li></ul><p>For example, to use the <code>java.net</code> repository, use the following setting
in your build definition:
</p><pre><code class="prettyprint lang-scala">resolvers += JavaNet2Repository
</code></pre><p>Predefined repositories will go under Resolver going forward so they are
in one place:
</p><pre><code class="prettyprint lang-scala">Resolver.sonatypeRepo(&quot;releases&quot;)  // Or &quot;snapshots&quot;
</code></pre><h3 id="Custom+resolvers">Custom resolvers<a href="#Custom+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt provides an interface to the repository types available in Ivy:
file, URL, SSH, and SFTP. A key feature of repositories in Ivy is using
<a href="https://ant.apache.org/ivy/history/latest-milestone/concept.html#patterns">patterns</a>
to configure repositories.
</p><p>Construct a repository definition using the factory in <code>sbt.Resolver</code>
for the desired type. This factory creates a <code>Repository</code> object that
can be further configured. The following table contains links to the Ivy
documentation for the repository type and the API documentation for the
factory and repository class. The SSH and SFTP repositories are
configured identically except for the name of the factory. Use
<code>Resolver.ssh</code> for SSH and <code>Resolver.sftp</code> for SFTP.
</p><table class="table table-striped">
  <tr>
    <th>Type</th>
    <th>Factory</th>
    <th>Ivy Docs</th>
    <th>Factory API</th>
    <th>Repository Class API</th>
  </tr>

  <tr>
    <td>Filesystem</td>
    <td><tt>Resolver.file</tt></td>
    <td><a href="https://ant.apache.org/ivy/history/latest-milestone/resolver/filesystem.html">Ivy filesystem</a></td>
    <td><a href="../api/sbt/librarymanagement/Resolver$.html#file">filesystem factory</a></td>
    <td><a href="../api/sbt/librarymanagement/FileRepository.html">FileRepository API</a></td>
  </tr>

  <tr>
    <td>SFTP</td>
    <td><tt>Resolver.sftp</tt></td>
    <td><a href="https://ant.apache.org/ivy/history/latest-milestone/resolver/sftp.html">Ivy sftp</a></td>
    <td><a href="../api/sbt/librarymanagement/Resolver$.html#sftp">sftp factory</a></td>
    <td><a href="../api/sbt/librarymanagement/SftpRepository.html">SftpRepository API</a></td>
  </tr>

  <tr>
    <td>SSH</td>
    <td><tt>Resolver.ssh</tt></td>
    <td><a href="https://ant.apache.org/ivy/history/latest-milestone/resolver/ssh.html">Ivy ssh</a></td>
    <td><a href="../api/sbt/librarymanagement/Resolver$.html#ssh">ssh factory</a></td>
    <td><a href="../api/sbt/librarymanagement/SshRepository.html">SshRepository API</a></td>
  </tr>

  <tr>
    <td>URL</td>
    <td><tt>Resolver.url</tt></td>
    <td><a href="https://ant.apache.org/ivy/history/latest-milestone/resolver/url.html">Ivy url</a></td>
    <td><a href="../api/sbt/librarymanagement/Resolver$.html#url">url factory</a></td>
    <td><a href="../api/sbt/librarymanagement/URLRepository.html">URLRepository API</a></td>
  </tr>
</table><h4 id="Basic+Examples">Basic Examples<a href="#Basic+Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These are basic examples that use the default Maven-style repository
layout.
</p><h5 id="Filesystem">Filesystem<a href="#Filesystem" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Define a filesystem repository in the <code>test</code> directory of the current
working directory and declare that publishing to this repository must be
atomic.
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.file(&quot;my-test-repo&quot;, file(&quot;test&quot;)) transactional()
</code></pre><h5 id="URL">URL<a href="#URL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Define a URL repository at <code>&quot;https://example.org/repo-releases/&quot;</code>.
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url(&quot;https://example.org/repo-releases/&quot;))
</code></pre><p>To specify an Ivy repository, use:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url)(Resolver.ivyStylePatterns)
</code></pre><p>or customize the layout pattern described in the Custom Layout section
below.
</p><h5 id="SFTP+and+SSH+Repositories">SFTP and SSH Repositories<a href="#SFTP+and+SSH+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The following defines a repository that is served by SFTP from host
<code>&quot;example.org&quot;</code>:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;)
</code></pre><p>To explicitly specify the port:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;, 22)
</code></pre><p>To specify a base path:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;, &quot;maven2/repo-releases/&quot;)
</code></pre><p>Authentication for the repositories returned by <code>sftp</code> and <code>ssh</code> can be
configured by the <code>as</code> methods.
</p><p>To use password authentication:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, &quot;password&quot;)
</code></pre><p>or to be prompted for the password:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;)
</code></pre><p>To use key authentication:
</p><pre><code class="prettyprint lang-scala">resolvers += {
  val keyFile: File = ...
  Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, keyFile, &quot;keyFilePassword&quot;)
}
</code></pre><p>or if no keyfile password is required or if you want to be prompted for
it:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, keyFile)
</code></pre><p>To specify the permissions used when publishing to the server:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) withPermissions(&quot;0644&quot;)
</code></pre><p>This is a chmod-like mode specification.
</p><h4 id="Custom+Layout">Custom Layout<a href="#Custom+Layout" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These examples specify custom repository layouts using patterns. The
factory methods accept an <code>Patterns</code> instance that defines the patterns
to use. The patterns are first resolved against the base file or URL.
The default patterns give the default Maven-style layout. Provide a
different Patterns object to use a different layout. For example:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url)( Patterns(&quot;[organisation]/[module]/[revision]/[artifact].[ext]&quot;) )
</code></pre><p>You can specify multiple patterns or patterns for the metadata and
artifacts separately. You can also specify whether the repository should
be Maven compatible (as defined by Ivy). See the
<a href="../api/sbt/librarymanagement/Patterns$.html">patterns API</a> for the methods to use.
</p><p>For filesystem and URL repositories, you can specify absolute patterns
by omitting the base URL, passing an empty <code>Patterns</code> instance, and
using <code>ivys</code> and <code>artifacts</code>:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;) artifacts
        &quot;https://example.org/[organisation]/[module]/[revision]/[artifact].[ext]&quot;
</code></pre><h2 id="Update+Report">Update Report<a href="#Update+Report" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><code>update</code> and related tasks produce a value of type
<a href="../api/sbt/librarymanagement/UpdateReport.html">sbt.UpdateReport</a> This data
structure provides information about the resolved configurations,
modules, and artifacts. At the top level, <code>UpdateReport</code> provides
reports of type <code>ConfigurationReport</code> for each resolved configuration. A
<code>ConfigurationReport</code> supplies reports (of type <code>ModuleReport</code>) for each
module resolved for a given configuration. Finally, a <code>ModuleReport</code>
lists each successfully retrieved <code>Artifact</code> and the <code>File</code> it was
retrieved to as well as the <code>Artifact</code>s that couldn’t be downloaded.
This missing <code>Artifact</code> list is always empty for <code>update</code>, which will
fail if it is non-empty. However, it may be non-empty for
<code>updateClassifiers</code> and <code>updateSbtClassifers</code>.
</p><h3 id="Filtering+a+Report+and+Getting+Artifacts">Filtering a Report and Getting Artifacts<a href="#Filtering+a+Report+and+Getting+Artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A typical use of <code>UpdateReport</code> is to retrieve a list of files matching
a filter. A conversion of type <code>UpdateReport =&gt; RichUpdateReport</code>
implicitly provides these methods for <code>UpdateReport</code>. The filters are
defined by the
<a href="../api/sbt/librarymanagement/DependencyFilter.html">DependencyFilter</a>,
<a href="../api/sbt/librarymanagement/ConfigurationFilter.html">ConfigurationFilter</a>,
<a href="../api/sbt/librarymanagement/ModuleFilter.html">ModuleFilter</a>, and
<a href="../api/sbt/librarymanagement/ArtifactFilter.html">ArtifactFilter</a> types. Using
these filter types, you can filter by the configuration name, the module
organization, name, or revision, and the artifact name, type, extension,
or classifier.
</p><p>The relevant methods (implicitly on <code>UpdateReport</code>) are:
</p><pre><code class="prettyprint lang-scala">def matching(f: DependencyFilter): Seq[File]

def select(configuration: ConfigurationFilter = ...,
  module: ModuleFilter = ...,
  artifact: ArtifactFilter = ...): Seq[File]
</code></pre><p>Any argument to <code>select</code> may be omitted, in which case all values are
allowed for the corresponding component. For example, if the
<code>ConfigurationFilter</code> is not specified, all configurations are accepted.
The individual filter types are discussed below.
</p><h4 id="Filter+Basics">Filter Basics<a href="#Filter+Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Configuration, module, and artifact filters are typically built by
applying a <code>NameFilter</code> to each component of a <code>Configuration</code>,
<code>ModuleID</code>, or <code>Artifact</code>. A basic <code>NameFilter</code> is implicitly
constructed from a String, with <code>*</code> interpreted as a wildcard.
</p><pre><code class="prettyprint lang-scala">import sbt._
// each argument is of type NameFilter
val mf: ModuleFilter = moduleFilter(organization = &quot;*sbt*&quot;,
  name = &quot;main&quot; | &quot;actions&quot;, revision = &quot;1.*&quot; - &quot;1.0&quot;)

// unspecified arguments match everything by default
val mf: ModuleFilter = moduleFilter(organization = &quot;net.databinder&quot;)

// specifying &quot;*&quot; is the same as omitting the argument
val af: ArtifactFilter = artifactFilter(name = &quot;*&quot;, `type` = &quot;source&quot;,
  extension = &quot;jar&quot;, classifier = &quot;sources&quot;)

val cf: ConfigurationFilter = configurationFilter(name = &quot;compile&quot; | &quot;test&quot;)
</code></pre><p>Alternatively, these filters, including a <code>NameFilter</code>, may be directly
defined by an appropriate predicate (a single-argument function
returning a Boolean).
</p><pre><code class="prettyprint lang-scala">import sbt._

// here the function value of type String =&gt; Boolean is implicitly converted to a NameFilter
val nf: NameFilter = (s: String) =&gt; s.startsWith(&quot;dispatch-&quot;)

// a Set[String] is a function String =&gt; Boolean
val acceptConfigs: Set[String] = Set(&quot;compile&quot;, &quot;test&quot;)
// implicitly converted to a ConfigurationFilter
val cf: ConfigurationFilter = acceptConfigs

val mf: ModuleFilter = (m: ModuleID) =&gt; m.organization contains &quot;sbt&quot;

val af: ArtifactFilter = (a: Artifact) =&gt; a.classifier.isEmpty
</code></pre><h4 id="ConfigurationFilter">ConfigurationFilter<a href="#ConfigurationFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A configuration filter essentially wraps a <code>NameFilter</code> and is
explicitly constructed by the <code>configurationFilter</code> method:
</p><pre><code class="prettyprint lang-scala">def configurationFilter(name: NameFilter = ...): ConfigurationFilter
</code></pre><p>If the argument is omitted, the filter matches all configurations.
Functions of type <code>String =&gt; Boolean</code> are implicitly convertible to a
<code>ConfigurationFilter</code>. As with <code>ModuleFilter</code>, <code>ArtifactFilter</code>, and
<code>NameFilter</code>, the <code>&amp;</code>, <code>|</code>, and <code>-</code> methods may be used to combine
<code>ConfigurationFilter</code>s.
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ConfigurationFilter = Set(&quot;compile&quot;, &quot;test&quot;)
val b: ConfigurationFilter = (c: String) =&gt; c.startsWith(&quot;r&quot;)
val c: ConfigurationFilter = a | b
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="ModuleFilter">ModuleFilter<a href="#ModuleFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A module filter is defined by three <code>NameFilter</code>s: one for the
organization, one for the module name, and one for the revision. Each
component filter must match for the whole module filter to match. A
module filter is explicitly constructed by the <code>moduleFilter</code> method:
</p><pre><code class="prettyprint lang-scala">def moduleFilter(organization: NameFilter = ..., name: NameFilter = ..., revision: NameFilter = ...): ModuleFilter
</code></pre><p>An omitted argument does not contribute to the match. If all arguments
are omitted, the filter matches all <code>ModuleID</code>s. Functions of type
<code>ModuleID =&gt; Boolean</code> are implicitly convertible to a <code>ModuleFilter</code>. As
with <code>ConfigurationFilter</code>, <code>ArtifactFilter</code>, and <code>NameFilter</code>, the <code>&amp;</code>,
<code>|</code>, and <code>-</code> methods may be used to combine <code>ModuleFilter</code>s:
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ModuleFilter = moduleFilter(name = &quot;dispatch-twitter&quot;, revision = &quot;0.7.8&quot;)
val b: ModuleFilter = moduleFilter(name = &quot;dispatch-*&quot;)
val c: ModuleFilter = b - a
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="ArtifactFilter">ArtifactFilter<a href="#ArtifactFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An artifact filter is defined by four <code>NameFilter</code>s: one for the name,
one for the type, one for the extension, and one for the classifier.
Each component filter must match for the whole artifact filter to match.
An artifact filter is explicitly constructed by the <code>artifactFilter</code>
method:
</p><pre><code class="prettyprint lang-scala">def artifactFilter(name: NameFilter = ..., `type`: NameFilter = ...,
  extension: NameFilter = ..., classifier: NameFilter = ...): ArtifactFilter
</code></pre><p>Functions of type <code>Artifact =&gt; Boolean</code> are implicitly convertible to an
<code>ArtifactFilter</code>. As with <code>ConfigurationFilter</code>, <code>ModuleFilter</code>, and
<code>NameFilter</code>, the <code>&amp;</code>, <code>|</code>, and <code>-</code> methods may be used to combine
<code>ArtifactFilter</code>s:
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ArtifactFilter = artifactFilter(classifier = &quot;javadoc&quot;)
val b: ArtifactFilter = artifactFilter(`type` = &quot;jar&quot;)
val c: ArtifactFilter = b - a
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="DependencyFilter">DependencyFilter<a href="#DependencyFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A <code>DependencyFilter</code> is typically constructed by combining other
<code>DependencyFilter</code>s together using <code>&amp;&amp;</code>, <code>||</code>, and <code>--</code>. Configuration,
module, and artifact filters are <code>DependencyFilter</code>s themselves and can
be used directly as a <code>DependencyFilter</code> or they can build up a
<code>DependencyFilter</code>. Note that the symbols for the <code>DependencyFilter</code>
combining methods are doubled up to distinguish them from the
combinators of the more specific filters for configurations, modules,
and artifacts. These double-character methods will always return a
<code>DependencyFilter</code>, whereas the single character methods preserve the
more specific filter type. For example:
</p><pre><code class="prettyprint lang-scala">import sbt._

val df: DependencyFilter =
  configurationFilter(name = &quot;compile&quot; | &quot;test&quot;) &amp;&amp;
  artifactFilter(`type` = &quot;jar&quot;) ||
  moduleFilter(name = &quot;dispatch-*&quot;)
</code></pre><p>Here, we used <code>&amp;&amp;</code> and <code>||</code> to combine individual component filters into
a dependency filter, which can then be provided to the
<code>UpdateReport.matches</code> method. Alternatively, the <code>UpdateReport.select</code>
method may be used, which is equivalent to calling <code>matches</code> with its
arguments combined with <code>&amp;&amp;</code>.
</p><h2 id="Cached+Resolution">Cached Resolution<a href="#Cached+Resolution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Cached Resolution is an <strong>experimental</strong> feature of sbt added since 0.13.7 to address the scalability performance of dependency resolution.
</p><h3 id="Setup">Setup<a href="#Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To set up Cached Resolution include the following setting in your project’s build:
</p><pre><code class="prettyprint lang-scala">updateOptions := updateOptions.value.withCachedResolution(true)
</code></pre><h3 id="Dependency+as+a+graph">Dependency as a graph<a href="#Dependency+as+a+graph" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A project declares its own library dependency using <code>libraryDependencies</code> setting. The libraries you added also bring in their transitive dependencies. For example, your project may depend on dispatch-core 0.11.2; dispatch-core 0.11.2 depends on async-http-client 1.8.10; async-http-client 1.8.10 depends on netty 3.9.2.Final, and so forth. If we think of each library to be a node with arrows going out to dependent nodes, we can think of the entire dependencies to be a graph — specifically a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>.
</p><p>This graph-like structure, which was adopted from Apache Ivy, allows us to define <a href="Library-Management.html">override rules and exclusions</a> transitively, but as the number of the node increases, the time it takes to resolve dependencies grows significantly. See <a href="#motivation">Motivation</a> section later in this page for the full description.
</p><h3 id="Cached+Resolution">Cached Resolution<a href="#Cached+Resolution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Cached Resolution feature is akin to incremental compilation, which only recompiles the sources that have been changed since the last <code>compile</code>. Unlike the Scala compiler, Ivy does not have the concept of separate compilation, so that needed to be implemented.
</p><p>Instead of resolving the full dependency graph, the Cached Resolution feature creates  minigraphs — one for each direct dependency appearing in all related subprojects. These minigraphs are resolved using Ivy’s resolution engine, and the result is stored locally under <code>$HOME/.sbt/1.0/dependency/</code> (or what’s specified by <code>sbt.dependency.base</code> flag) shared across all builds. After all minigraphs are resolved, they are stitched together by applying the conflict resolution algorithm (typically picking the latest version).
</p><p>When you add a new library to your project, Cached Resolution feature will check for the minigraph files under <code>$HOME/.sbt/1.0/dependency/</code> and load the previously resolved nodes, which incurs negligible I/O overhead, and only resolve the newly added library. The intended performance improvement is that the second and third subprojects can take advantage of the resolved minigraphs from the first one and avoid duplicated work. The following figure illustrates projects A, B, and C, all hitting the same set of json files.
</p><p><br>
<img src="files/cached-resolution.png" alt="fig1"/>
</p><p>The actual speedup will vary case by case, but you should see significant speedup if you have many subprojects. An initial report from a user showed a change from 260s to 25s. Your mileage may vary.
</p><h3 id="Caveats+and+known+issues">Caveats and known issues<a href="#Caveats+and+known+issues" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cached Resolution is an <strong>experimental</strong> feature, and you might run into some issues. When you see them please report to GitHub Issue or sbt-dev list.
</p><h4 id="First+runs">First runs<a href="#First+runs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first time you run, Cached Resolution will likely be slow since it needs to resolve all minigraphs and save the result into the filesystem. Whenever you add a new node the system has not seen, it will save the minigraph. The second run onwards should be faster, but comparing full-resolution <code>update</code> with second run onwards might not be a fair comparison.
</p><h4 id="Ivy+fidelity+is+not+guaranteed">Ivy fidelity is not guaranteed<a href="#Ivy+fidelity+is+not+guaranteed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some of the Ivy behavior doesn’t make sense, especially around Maven emulation. For example, it seems to treat all transitive dependencies introduced by Maven-published library as <code>force()</code> even when the original <code>pom.xml</code> doesn’t say to:
</p><pre><code class="">$ cat ~/.ivy2/cache/com.ning/async-http-client/ivy-1.8.10.xml | grep netty
    &lt;dependency org=&quot;io.netty&quot; name=&quot;netty&quot; rev=&quot;3.9.2.Final&quot; force=&quot;true&quot; conf=&quot;compile-&gt;compile(*),master(*);runtime-&gt;runtime(*)&quot;/&gt;
</code></pre><p>There are also some issues around multiple dependencies to the same library with different <a href="http://maven.apache.org/pom.html#Maven_Coordinates">Maven classifiers</a>. In these cases, reproducing the exact result as normal <code>update</code> may not make sense or is downright impossible.
</p><h4 id="SNAPSHOT+and+dynamic+dependencies">SNAPSHOT and dynamic dependencies<a href="#SNAPSHOT+and+dynamic+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When a minigraph contains either a SNAPSHOT or dynamic dependency, the graph is considered dynamic, and it will be invalidated after a single task execution.
Therefore, if you have any SNAPSHOT in your graph, your experience may degrade.
(This could be improved in the future)
</p><p>A setting key called <code>updateOptions</code> customizes the details of
managed dependency resolution with the <code>update</code> task. One of its flags is
called <code>latestSnapshots</code>, which controls the behavior of the chained
resolver. Up until 0.13.6, sbt was picking the first <code>-SNAPSHOT</code>
revision it found along the chain.  When <code>latestSnapshots</code> is enabled
(default: <code>true</code>), it will look into all resolvers on the chain, and
compare them using the publish date.
</p><p>The tradeoff is probably a longer resolution time if you have many
remote repositories on the build or you live away from the severs. So
here’s how to disable it:
</p><pre><code class="prettyprint lang-scala">    updateOptions := updateOptions.value.withLatestSnapshots(false)
</code></pre><a name="motivation"></a><h3 id="Motivation">Motivation<a href="#Motivation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt internally uses Apache Ivy to resolve library dependencies. While sbt has benefited from not having to reinvent its own dependency resolution engine all these years, we are increasingly seeing scalability challenges especially for projects with both multiple subprojects and large dependency graph. There are several factors involved in sbt’s resolution scalability:
</p><ul><li>Number of transitive nodes (libraries) in the graph
</li><li>Exclusion and override rules
</li><li>Number of subprojects
</li><li>Configurations
</li><li>Number of repositories and their availability
</li><li>Classifiers (additional sources and docs used by IDE)
</li></ul><p>Of the above factors, the one that has the most impact is the number of transitive nodes.
</p><ol><li>The more nodes there are the greater the chance of version conflicts. Conflicts are resolved typically by picking the latest version within the same library.
</li><li>The more nodes there are, the more it needs to backtrack to check for exclusion and override rules.
</li></ol><p>Exclusion and override rules are applied transitively, so any time a new node is introduced to the graph it needs to check its parent node’s rules, its grandparent node’s rules, great-grandparent node’s rules, etc.
</p><p>sbt treats configurations and subprojects to be independent dependency graph. This allows us to include arbitrary libraries for different configurations and subprojects, but if the dependency resolution is slow, the linear scaling starts to hurt. There have been prior efforts to cache the result of library dependencies, but it still resulted in full resolution when <code>libraryDependencies</code> has changed.
</p><h2 id="Tasks+and+Commands">Tasks and Commands<a href="#Tasks+and+Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Tasks">Tasks<a href="#Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Tasks and settings are introduced in the
<a href="Basic-Def.html">getting started guide</a>, which you may wish
to read first. This page has additional details and background and is
intended more as a reference.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Both settings and tasks produce values, but there are two major
differences between them:
</p><ol><li>Settings are evaluated at project load time. Tasks are executed on
demand, often in response to a command from the user.
</li><li>At the beginning of project loading, settings and their dependencies
are fixed. Tasks can introduce new tasks during execution, however.
</li></ol><h3 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are several features of the task system:
</p><ol><li>By integrating with the settings system, tasks can be added,
removed, and modified as easily and flexibly as settings.
</li><li><a href="Input-Tasks.html">Input Tasks</a> use
<a href="Parsing-Input.html">parser combinators</a> to define the syntax for their
arguments. This allows flexible syntax and tab-completions in the
same way as <a href="Commands.html">Commands</a>.
</li><li>Tasks produce values. Other tasks can access a task’s value by
calling <code>value</code> on it within a task definition.
</li><li>Dynamically changing the structure of the task graph is possible.
Tasks can be injected into the execution graph based on the result
of another task.
</li><li>There are ways to handle task failure, similar to
<code>try/catch/finally</code>.
</li><li>Each task has access to its own Logger that by default persists the
logging for that task at a more verbose level than is initially
printed to the screen.
</li></ol><p>These features are discussed in detail in the following sections.
</p><h3 id="Defining+a+Task">Defining a Task<a href="#Defining+a+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Hello+World+example+%28sbt%29">Hello World example (sbt)<a href="#Hello+World+example+%28sbt%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;Prints 'Hello World'&quot;)

hello := println(&quot;hello world!&quot;)
</code></pre><p>Run “sbt hello” from command line to invoke the task. Run “sbt tasks” to
see this task listed.
</p><h4 id="Define+the+key">Define the key<a href="#Define+the+key" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To declare a new task, define a lazy val of type <code>TaskKey</code>:
</p><pre><code class="prettyprint lang-scala">lazy val sampleTask = taskKey[Int](&quot;A sample task.&quot;)
</code></pre><p>The name of the <code>val</code> is used when referring to the task in Scala code
and at the command line. The string passed to the <code>taskKey</code> method is a
description of the task. The type parameter passed to <code>taskKey</code> (here,
<code>Int</code>) is the type of value produced by the task.
</p><p>We’ll define a couple of other keys for the examples:
</p><pre><code class="prettyprint lang-scala">lazy val intTask = taskKey[Int](&quot;An int task&quot;)
lazy val stringTask = taskKey[String](&quot;A string task&quot;)
</code></pre><p>The examples themselves are valid entries in a <code>build.sbt</code> or can be
provided as part of a sequence to <code>Project.settings</code> (see
<a href="Full-Def.html">.scala build definition</a>).
</p><h4 id="Implement+the+task">Implement the task<a href="#Implement+the+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There are three main parts to implementing a task once its key is
defined:
</p><ol><li>Determine the settings and other tasks needed by the task. They are
the task’s inputs.
</li><li>Define the code that implements the task in terms of these inputs.
</li><li>Determine the scope the task will go in.
</li></ol><p>These parts are then combined just like the parts of a setting are
combined.
</p><h5 id="Defining+a+basic+task">Defining a basic task<a href="#Defining+a+basic+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>A task is defined using <code>:=</code>
</p><pre><code class="prettyprint lang-scala">intTask := 1 + 2

stringTask := System.getProperty(&quot;user.name&quot;)

sampleTask := {
   val sum = 1 + 2
   println(&quot;sum: &quot; + sum)
   sum
}
</code></pre><p>As mentioned in the introduction, a task is evaluated on demand. Each
time <code>sampleTask</code> is invoked, for example, it will print the sum. If the
username changes between runs, <code>stringTask</code> will take different values
in those separate runs. (Within a run, each task is evaluated at most
once.) In contrast, settings are evaluated once on project load and are
fixed until the next reload.
</p><h5 id="Tasks+with+inputs">Tasks with inputs<a href="#Tasks+with+inputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Tasks with other tasks or settings as inputs are also defined using
<code>:=</code>. The values of the inputs are referenced by the <code>value</code> method.
This method is special syntax and can only be called when defining a
task, such as in the argument to <code>:=</code>. The following defines a task that
adds one to the value produced by <code>intTask</code> and returns the result.
</p><pre><code class="prettyprint lang-scala">sampleTask := intTask.value + 1
</code></pre><p>Multiple settings are handled similarly:
</p><pre><code class="prettyprint lang-scala">stringTask := &quot;Sample: &quot; + sampleTask.value + &quot;, int: &quot; + intTask.value
</code></pre><h5 id="Task+Scope">Task Scope<a href="#Task+Scope" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As with settings, tasks can be defined in a specific scope. For example,
there are separate <code>compile</code> tasks for the <code>compile</code> and <code>test</code> scopes.
The scope of a task is defined the same as for a setting. In the
following example, <code>test:sampleTask</code> uses the result of
<code>compile:intTask</code>.
</p><pre><code class="prettyprint lang-scala">Test / sampleTask := (Compile / intTask).value * 3
</code></pre><h5 id="On+precedence">On precedence<a href="#On+precedence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As a reminder, infix method precedence is by the name of the method and
postfix methods have lower precedence than infix methods.
</p><ol><li>Assignment methods have the lowest precedence. These are methods
with names ending in <code>=</code>, except for <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, and names that
start with <code>=</code>.
</li><li>Methods starting with a letter have the next highest precedence.
</li><li><p>Methods with names that start with a symbol and aren’t included in
</p><ol><li>have the highest precedence. (This category is divided further
according to the specific character it starts with. See the Scala
specification for details.)
</li></ol></li></ol><p>Therefore, the previous example is equivalent to the following:
</p><pre><code class="prettyprint lang-scala">(Test / sampleTask).:=( (Compile / intTask).value * 3 )
</code></pre><p>Additionally, the braces in the following are necessary:
</p><pre><code class="prettyprint lang-scala">helloTask := { &quot;echo Hello&quot; ! }
</code></pre><p>Without them, Scala interprets the line as
<code>( helloTask.:=(&quot;echo Hello&quot;) ).!</code> instead of the desired
<code>helloTask.:=( &quot;echo Hello&quot;.! )</code>.
</p><h4 id="Separating+implementations">Separating implementations<a href="#Separating+implementations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The implementation of a task can be separated from the binding. For
example, a basic separate definition looks like:
</p><pre><code class="prettyprint lang-scala">// Define a new, standalone task implemention
lazy val intTaskImpl: Initialize[Task[Int]] =
   Def.task { sampleTask.value - 3 }

// Bind the implementation to a specific key
intTask := intTaskImpl.value
</code></pre><p>Note that whenever <code>.value</code> is used, it must be within a task
definition, such as within <code>Def.task</code> above or as an argument to <code>:=</code>.
</p><h4 id="Modifying+an+Existing+Task">Modifying an Existing Task<a href="#Modifying+an+Existing+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In the general case, modify a task by declaring the previous task as an
input.
</p><pre><code class="prettyprint lang-scala">// initial definition
intTask := 3

// overriding definition that references the previous definition
intTask := intTask.value + 1
</code></pre><p>Completely override a task by not declaring the previous task as an
input. Each of the definitions in the following example completely
overrides the previous one. That is, when <code>intTask</code> is run, it will only
print <code>#3</code>.
</p><pre><code class="prettyprint lang-scala">intTask := {
    println(&quot;#1&quot;)
    3
}

intTask := {
    println(&quot;#2&quot;)
    5
}

intTask :=  {
    println(&quot;#3&quot;)
    sampleTask.value - 3
}
</code></pre><a name="multiple-scopes"></a><h3 id="Getting+values+from+multiple+scopes">Getting values from multiple scopes<a href="#Getting+values+from+multiple+scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The general form of an expression that gets values from multiple scopes
is:
</p><pre><code class="prettyprint lang-scala">&lt;setting-or-task&gt;.all(&lt;scope-filter&gt;).value
</code></pre><p><strong>NOTE!</strong> Make sure to assign the <code>ScopeFilter</code> as a <code>val</code>!  This is an
implementation detail requirement of the <code>.all</code> macro.
</p><p>The <code>all</code> method is implicitly added to tasks and settings. It accepts a
<code>ScopeFilter</code> that will select the <code>Scopes</code>. The result has type
<code>Seq[T]</code>, where <code>T</code> is the key’s underlying type.
</p><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A common scenario is getting the sources for all subprojects for
processing all at once, such as passing them to scaladoc. The task that
we want to obtain values for is <code>sources</code> and we want to get the values
in all non-root projects and in the <code>Compile</code> configuration. This looks
like:
</p><pre><code class="prettyprint lang-scala">lazy val core = project

lazy val util = project

val filter = ScopeFilter( inProjects(core, util), inConfigurations(Compile) )

lazy val root = project.settings(
   sources := {
      // each sources definition is of type Seq[File],
      //   giving us a Seq[Seq[File]] that we then flatten to Seq[File]
      val allSources: Seq[Seq[File]] = sources.all(filter).value
      allSources.flatten
   }
)
</code></pre><p>The next section describes various ways to construct a ScopeFilter.
</p><h4 id="ScopeFilter">ScopeFilter<a href="#ScopeFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A basic <code>ScopeFilter</code> is constructed by the <code>ScopeFilter.apply</code> method.
This method makes a <code>ScopeFilter</code> from filters on the parts of a
<code>Scope</code>: a <code>ProjectFilter</code>, <code>ConfigurationFilter</code>, and <code>TaskFilter</code>. The
simplest case is explicitly specifying the values for the parts:
</p><pre><code class="prettyprint lang-scala">val filter: ScopeFilter =
   ScopeFilter(
      inProjects( core, util ),
      inConfigurations( Compile, Test )
   )
</code></pre><h5 id="Unspecified+filters">Unspecified filters<a href="#Unspecified+filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>If the task filter is not specified, as in the example above, the
default is to select scopes without a specific task (global). Similarly,
an unspecified configuration filter will select scopes in the global
configuration. The project filter should usually be explicit, but if
left unspecified, the current project context will be used.
</p><h5 id="More+on+filter+construction">More on filter construction<a href="#More+on+filter+construction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The example showed the basic methods <code>inProjects</code> and
<code>inConfigurations</code>. This section describes all methods for constructing
a <code>ProjectFilter</code>, <code>ConfigurationFilter</code>, or <code>TaskFilter</code>. These methods
can be organized into four groups:
</p><ul><li>Explicit member list (<code>inProjects</code>, <code>inConfigurations</code>, <code>inTasks</code>)
</li><li>Global value (<code>inGlobalProject</code>, <code>inGlobalConfiguration</code>,
<code>inGlobalTask</code>)
</li><li>Default filter (<code>inAnyProject</code>, <code>inAnyConfiguration</code>, <code>inAnyTask</code>)
</li><li>Project relationships (<code>inAggregates</code>, <code>inDependencies</code>)
</li></ul><p>See the <a href="../api/sbt/ScopeFilter$$Make.html">API documentation</a> for
details.
</p><h5 id="Combining+ScopeFilters">Combining ScopeFilters<a href="#Combining+ScopeFilters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>ScopeFilters</code> may be combined with the <code>&amp;&amp;</code>, <code>||</code>, <code>--</code>, and <code>-</code>
methods:
</p><ul><li><code>a &amp;&amp; b</code> Selects scopes that match both a and b
</li><li><code>a || b</code> Selects scopes that match either a or b
</li><li><code>a -- b</code> Selects scopes that match a but not b
</li><li><code>-b</code> Selects scopes that do not match b
</li></ul><p>For example, the following selects the scope for the <code>Compile</code> and
<code>Test</code> configurations of the <code>core</code> project and the global configuration
of the <code>util</code> project:
</p><pre><code class="prettyprint lang-scala">val filter: ScopeFilter =
   ScopeFilter( inProjects(core), inConfigurations(Compile, Test)) ||
   ScopeFilter( inProjects(util), inGlobalConfiguration )
</code></pre><h4 id="More+operations">More operations<a href="#More+operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>all</code> method applies to both settings (values of type
<code>Initialize[T]</code>) and tasks (values of type <code>Initialize[Task[T]]</code>). It
returns a setting or task that provides a <code>Seq[T]</code>, as shown in this
table:
</p><table class="table table-striped">
  <tr>
    <th>Target</th>
    <th>Result</th>
  </tr>

  <tr>
    <td><tt>Initialize[T] </tt></td>
    <td><tt>Initialize[Seq[T]]</tt></td>
  </tr>

  <tr>
    <td><tt>Initialize[Task[T]]</tt></td>
    <td><tt>Initialize[Task[Seq[T]]]</tt></td>
  </tr>
</table><p>This means that the <code>all</code> method can be combined with methods that
construct tasks and settings.
</p><h5 id="Missing+values">Missing values<a href="#Missing+values" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Some scopes might not define a setting or task. The <code>?</code> and <code>??</code> methods
can help in this case. They are both defined on settings and tasks and
indicate what to do when a key is undefined.
</p><table class="table table-striped">
  <tr>
    <td><tt>?</tt></td>
    <td><tt>On a setting or task with underlying type T, this accepts no
    arguments and returns a setting or task (respectively) of type
    Option[T]. The result is None if the setting/task is undefined and
    Some[T] with the value if it is.</tt></td>
  </tr>

  <tr>
    <td><tt>??</tt></td>
    <td><tt>On a setting or task with underlying type T, this accepts an
    argument of type T and uses this argument if the setting/task is
    undefined.</tt></td>
  </tr>
</table><p>The following contrived example sets the maximum errors to be the
maximum of all aggregates of the current project.
</p><pre><code class="prettyprint lang-scala">// select the transitive aggregates for this project, but not the project itself
val filter: ScopeFilter =
   ScopeFilter( inAggregates(ThisProject, includeRoot=false) )

maxErrors := {
   // get the configured maximum errors in each selected scope,
   // using 0 if not defined in a scope
   val allVersions: Seq[Int] =
      (maxErrors ?? 0).all(filter).value
   allVersions.max
}
</code></pre><h5 id="Multiple+values+from+multiple+scopes">Multiple values from multiple scopes<a href="#Multiple+values+from+multiple+scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The target of <code>all</code> is any task or setting, including anonymous ones.
This means it is possible to get multiple values at once without
defining a new task or setting in each scope. A common use case is to
pair each value obtained with the project, configuration, or full scope
it came from.
</p><ul><li><code>resolvedScoped</code>: Provides the full enclosing ScopedKey (which is a Scope +
<code>AttributeKey[_]</code>)
</li><li><code>thisProject</code>: Provides the Project associated with this scope (undefined at the
global and build levels)
</li><li><code>thisProjectRef</code>: Provides the ProjectRef for the context (undefined at the global and
build levels)
</li><li><code>configuration</code>: Provides the Configuration for the context (undefined for the global
configuration)
</li></ul><p>For example, the following defines a task that prints non-Compile
configurations that define sbt plugins. This might be used to identify
an incorrectly configured build (or not, since this is a fairly
contrived example):
</p><pre><code class="prettyprint lang-scala">// Select all configurations in the current project except for Compile
lazy val filter: ScopeFilter = ScopeFilter(
   inProjects(ThisProject),
   inAnyConfiguration -- inConfigurations(Compile)
)

// Define a task that provides the name of the current configuration
//   and the set of sbt plugins defined in the configuration
lazy val pluginsWithConfig: Initialize[Task[ (String, Set[String]) ]] =
   Def.task {
      ( configuration.value.name, definedSbtPlugins.value )
   }

checkPluginsTask := {
   val oddPlugins: Seq[(String, Set[String])] =
      pluginsWithConfig.all(filter).value
   // Print each configuration that defines sbt plugins
   for( (config, plugins) &lt;- oddPlugins if plugins.nonEmpty )
      println(s&quot;$config defines sbt plugins: ${plugins.mkString(&quot;, &quot;)}&quot;)
}
</code></pre><h3 id="Advanced+Task+Operations">Advanced Task Operations<a href="#Advanced+Task+Operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The examples in this section use the task keys defined in the previous
section.
</p><h4 id="Streams%3A+Per-task+logging">Streams: Per-task logging<a href="#Streams%3A+Per-task+logging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Per-task loggers are part of a more general system for task-specific
data called Streams. This allows controlling the verbosity of stack
traces and logging individually for tasks as well as recalling the last
logging for a task. Tasks also have access to their own persisted binary
or text data.
</p><p>To use Streams, get the value of the <code>streams</code> task. This is a special
task that provides an instance of
<a href="../api/sbt/std/TaskStreams.html">TaskStreams</a> for the defining
task. This type provides access to named binary and text streams, named
loggers, and a default logger. The default
<a href="../api/sbt/util/Logger.html">Logger</a>, which is the most commonly used
aspect, is obtained by the <code>log</code> method:
</p><pre><code class="prettyprint lang-scala">myTask := {
  val s: TaskStreams = streams.value
  s.log.debug(&quot;Saying hi...&quot;)
  s.log.info(&quot;Hello!&quot;)
}
</code></pre><p>You can scope logging settings by the specific task’s scope:
</p><pre><code class="prettyprint lang-scala">logLevel in myTask := Level.Debug

traceLevel in myTask := 5
</code></pre><p>To obtain the last logging output from a task, use the <code>last</code> command:
</p><pre><code class="">$ last myTask
[debug] Saying hi...
[info] Hello!
</code></pre><p>The verbosity with which logging is persisted is controlled using the
<code>persistLogLevel</code> and <code>persistTraceLevel</code> settings. The <code>last</code> command
displays what was logged according to these levels. The levels do not
affect already logged information.
</p><h3 id="Dynamic+Computations+with">Dynamic Computations with <code>Def.taskDyn</code><a href="#Dynamic+Computations+with" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It can be useful to use the result of a task to determine the next tasks
to evaluate. This is done using <code>Def.taskDyn</code>. The result of <code>taskDyn</code>
is called a dynamic task because it introduces dependencies at runtime.
The <code>taskDyn</code> method supports the same syntax as <code>Def.task</code> and <code>:=</code>
except that you return a task instead of a plain value.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">val dynamic = Def.taskDyn {
  // decide what to evaluate based on the value of `stringTask`
  if(stringTask.value == &quot;dev&quot;)
    // create the dev-mode task: this is only evaluated if the
    //   value of stringTask is &quot;dev&quot;
    Def.task {
      3
    }
  else
    // create the production task: only evaluated if the value
    //    of the stringTask is not &quot;dev&quot;
    Def.task {
      intTask.value + 5
    }
}

myTask := {
  val num = dynamic.value
  println(s&quot;Number selected was $num&quot;)
}
</code></pre><p>The only static dependency of <code>myTask</code> is <code>stringTask</code>. The dependency
on <code>intTask</code> is only introduced in non-dev mode.
</p><blockquote><p><strong>Note</strong>: A dynamic task cannot refer to itself or a circular dependency will
result. In the example above, there would be a circular dependency if
the code passed to taskDyn referenced myTask.
</p></blockquote><h3 id="Using+Def.sequential">Using Def.sequential<a href="#Using+Def.sequential" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.13.8 added <code>Def.sequential</code> function to run tasks under semi-sequential semantics.
This is similar to the dynamic task, but easier to define.
To demonstrate the sequential task, let’s create a custom task called <code>compilecheck</code> that runs <code>Compile / compile</code> and then <code>Compile / scalastyle</code> task added by <a href="http://www.scalastyle.org/sbt.html">scalastyle-sbt-plugin</a>.
</p><pre><code class="prettyprint lang-scala">lazy val compilecheck = taskKey[Unit](&quot;compile and then scalastyle&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    Compile / compilecheck := Def.sequential(
      Compile / compile,
      (Compile / scalastyle).toTask(&quot;&quot;)
    ).value
  )
</code></pre><p>To call this task type in <code>compilecheck</code> from the shell. If the compilation fails, <code>compilecheck</code> would stop the execution.
</p><pre><code class="">root&gt; compilecheck
[info] Compiling 1 Scala source to /Users/x/proj/target/scala-2.10/classes...
[error] /Users/x/proj/src/main/scala/Foo.scala:3: Unmatched closing brace '}' ignored here
[error] }
[error] ^
[error] one error found
[error] (compile:compileIncremental) Compilation failed
</code></pre><h3 id="Handling+Failure">Handling Failure<a href="#Handling+Failure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This section discusses the <code>failure</code>, <code>result</code>, and <code>andFinally</code>
methods, which are used to handle failure of other tasks.
</p><h4 id=""><code>failure</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>failure</code> method creates a new task that returns the <code>Incomplete</code>
value when the original task fails to complete normally. If the original
task succeeds, the new task fails.
<a href="../api/sbt/Incomplete.html">Incomplete</a> is an exception with
information about any tasks that caused the failure and any underlying
exceptions thrown during task execution.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">intTask := sys.error(&quot;Failed.&quot;)

intTask := {
   println(&quot;Ignoring failure: &quot; + intTask.failure.value)
   3
}
</code></pre><p>This overrides the <code>intTask</code> so that the original exception is printed
and the constant <code>3</code> is returned.
</p><p><code>failure</code> does not prevent other tasks that depend on the target from
failing. Consider the following example:
</p><pre><code class="prettyprint lang-scala">intTask := if(shouldSucceed) 5 else sys.error(&quot;Failed.&quot;)

// Return 3 if intTask fails. If intTask succeeds, this task will fail.
aTask := intTask.failure.value - 2

// A new task that increments the result of intTask.
bTask := intTask.value + 1

cTask := aTask.value + bTask.value
</code></pre><p>The following table lists the results of each task depending on the
initially invoked task:
</p><table class="table table-striped">
  <thead>
    <tr>
      <th>invoked task</th>
      <th>intTask result</th>
      <th>aTask result</th>
      <th>bTask result</th>
      <th>cTask result</th>
      <th>overall result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>intTask</td>
      <td>failure</td>
      <td>not run</td>
      <td>not run</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>aTask</td>
      <td>failure</td>
      <td>success</td>
      <td>not run</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>bTask</td>
      <td>failure</td>
      <td>not run</td>
      <td>failure</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>cTask</td>
      <td>failure</td>
      <td>success</td>
      <td>failure</td>
      <td>failure</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>intTask</td>
      <td>success</td>
      <td>not run</td>
      <td>not run</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>aTask</td>
      <td>success</td>
      <td>failure</td>
      <td>not run</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>bTask</td>
      <td>success</td>
      <td>not run</td>
      <td>success</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>cTask</td>
      <td>success</td>
      <td>failure</td>
      <td>success</td>
      <td>failure</td>
      <td>failure</td>
    </tr>
  </tbody>
</table><p>The overall result is always the same as the root task (the directly
invoked task). A <code>failure</code> turns a success into a failure, and a failure
into an <code>Incomplete</code>. A normal task definition fails when any of its
inputs fail and computes its value otherwise.
</p><h4 id=""><code>result</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>result</code> method creates a new task that returns the full <code>Result[T]</code>
value for the original task. <a href="../api/sbt/Result.html">Result</a> has
the same structure as <code>Either[Incomplete, T]</code> for a task result of type
<code>T</code>. That is, it has two subtypes:
</p><ul><li><code>Inc</code>, which wraps <code>Incomplete</code> in case of failure
</li><li><code>Value</code>, which wraps a task’s result in case of success.
</li></ul><p>Thus, the task created by <code>result</code> executes whether or not the original
task succeeds or fails.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">intTask := sys.error(&quot;Failed.&quot;)

intTask := {
   intTask.result.value match {
      case Inc(inc: Incomplete) =&gt;
         println(&quot;Ignoring failure: &quot; + inc)
         3
      case Value(v) =&gt;
         println(&quot;Using successful result: &quot; + v)
         v
   }
}
</code></pre><p>This overrides the original <code>intTask</code> definition so that if the original
task fails, the exception is printed and the constant <code>3</code> is returned.
If it succeeds, the value is printed and returned.
</p><h5 id="andFinally">andFinally<a href="#andFinally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The <code>andFinally</code> method defines a new task that runs the original task
and evaluates a side effect regardless of whether the original task
succeeded. The result of the task is the result of the original task.
For example:
</p><pre><code class="prettyprint lang-scala">intTask := sys.error(&quot;I didn't succeed.&quot;)

lazy val intTaskImpl = intTask andFinally { println(&quot;andFinally&quot;) }

intTask := intTaskImpl.value
</code></pre><p>This modifies the original <code>intTask</code> to always print “andFinally” even
if the task fails.
</p><p>Note that <code>andFinally</code> constructs a new task. This means that the new
task has to be invoked in order for the extra block to run. This is
important when calling andFinally on another task instead of overriding
a task like in the previous example. For example, consider this code:
</p><pre><code class="prettyprint lang-scala">intTask := sys.error(&quot;I didn't succeed.&quot;)

lazy val intTaskImpl = intTask andFinally { println(&quot;andFinally&quot;) }

otherIntTask := intTaskImpl.value
</code></pre><p>If <code>intTask</code> is run directly, <code>otherIntTask</code> is never involved in
execution. This case is similar to the following plain Scala code:
</p><pre><code class="prettyprint lang-scala">def intTask(): Int =
  sys.error(&quot;I didn't succeed.&quot;)

def otherIntTask(): Int =
  try { intTask() }
  finally { println(&quot;finally&quot;) }

intTask()
</code></pre><p>It is obvious here that calling intTask() will never result in “finally”
being printed.
</p><h2 id="Caching">Caching<a href="#Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Tasks and settings are introduced in the
<a href="Basic-Def.html">getting started guide</a>, and explained in more detail in <a href="Tasks.html">Tasks</a>.
You may wish to read them first.
</p><p>When you define a custom task, you might want to cache the value to avoid unnecessary work.
</p><h3 id="Cache.cached">Cache.cached<a href="#Cache.cached" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>sbt.util.Cache</code> provides a basic caching facility:
</p><pre><code class="prettyprint lang-scala">package sbt.util

/**
 * A simple cache with keys of type `I` and values of type `O`
 */
trait Cache[I, O] {

  /**
   * Queries the cache backed with store `store` for key `key`.
   */
  def apply(store: CacheStore)(key: I): CacheResult[O]
}
</code></pre><p>We can derive the instances of <code>Cache[I, O]</code> from <code>sjsonnew.JsonFormat</code> instances for both <code>I</code> and <code>O</code> by importing <code>sbt.util.CacheImplicits._</code> (This also brings in <code>BasicJsonProtocol</code>).
</p><p>To use the cache, we can create a <em>cached</em> function by calling <code>Cache.cached</code> with a <code>CacheStore</code> (or a file) and a function that does the actual work. Normally, the cache store would be created as <code>streams.value.cacheStoreFactory / &quot;something&quot;</code>. In the following REPL example, I will create a cache store from a temp file.
</p><pre><code class="prettyprint lang-scala">scala&gt; import sbt._, sbt.util.CacheImplicits._
import sbt._
import sbt.util.CacheImplicits._

scala&gt; def doWork(i: Int): List[String] = {
         println(&quot;working...&quot;)
         Thread.sleep(1000)
         List.fill(i)(&quot;foo&quot;)
       }
doWork: (i: Int)List[String]

// use streams.value.cacheStoreFactory.make(&quot;something&quot;) for real tasks
scala&gt; val store = sbt.util.CacheStore(file(&quot;/tmp/something&quot;))
store: sbt.util.CacheStore = sbt.util.FileBasedStore@5a4a6716

scala&gt; val cachedWork: Int =&gt; List[String] = Cache.cached(store)(doWork)
cachedWork: Int =&gt; List[String] = sbt.util.Cache$$$Lambda$5577/1548870528@3bb59fba

scala&gt; cachedWork(1)
working...
res0: List[String] = List(foo)

scala&gt; cachedWork(1)
res1: List[String] = List(foo)

scala&gt; cachedWork(3)
working...
res2: List[String] = List(foo, foo, foo)

scala&gt; cachedWork(1)
working...
res3: List[String] = List(foo)
</code></pre><p>As you can see, <code>cachedWork(1)</code> is cached when it is called consecutively.
</p><h3 id="Previous+value">Previous value<a href="#Previous+value" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>TaskKey</code> has a method called <code>previous</code> that returns <code>Option[A]</code>, which can be used a lightweight tracker.
Suppose we would want to create a task where it initially returns <code>&quot;hi&quot;</code>, and append <code>&quot;!&quot;</code> for subsequent calls, you can define a <code>TaskKey[String]</code> called <code>hi</code>, and retrieve its previous value, which would be typed <code>Option[String]</code>. The previous value would be <code>None</code> the first time, and <code>Some(x)</code> for the subsequent calls.
</p><pre><code class="prettyprint lang-scala">lazy val hi = taskKey[String](&quot;say hi again&quot;)
hi := {
  import sbt.util.CacheImplicits._
  val prev = hi.previous
  prev match {
    case None    =&gt; &quot;hi&quot;
    case Some(x) =&gt; x + &quot;!&quot;
  }
}
</code></pre><p>We can test this by running <code>show hi</code> from the sbt shell:
</p><pre><code class="">sbt:hello&gt; show hi
[info] hi
[success] Total time: 0 s, completed Aug 16, 2019 12:24:32 AM
sbt:hello&gt; show hi
[info] hi!
[success] Total time: 0 s, completed Aug 16, 2019 12:24:33 AM
sbt:hello&gt; show hi
[info] hi!!
[success] Total time: 0 s, completed Aug 16, 2019 12:24:34 AM
sbt:hello&gt; show hi
[info] hi!!!
[success] Total time: 0 s, completed Aug 16, 2019 12:24:35 AM
</code></pre><p>For each call <code>hi.previous</code> contains the previous result from evaluating <code>hi</code>.
</p><h3 id="Tracked.lastOutput">Tracked.lastOutput<a href="#Tracked.lastOutput" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>sbt.util.Tracked</code> provides a facility for partial caching that can be mixed and matched with other trackers.
</p><p>Similar to the previous value associated with task keys, <code>sbt.util.Tracked.lastOutput</code> creates a tracker for the last calculated value. <code>Tracked.lastOutput</code> offers more flexibility in terms of where to store the value. (This allows the value to be shared across multiple tasks).
</p><p>Suppose we would initially take an <code>Int</code> as the input, and turn it into a <code>String</code>, but for subsequent invocation we’d append <code>&quot;!&quot;</code>:
</p><pre><code class="prettyprint lang-scala">scala&gt; import sbt._, sbt.util.CacheImplicits._
import sbt._
import sbt.util.CacheImplicits._

// use streams.value.cacheStoreFactory.make(&quot;last&quot;) for real tasks
scala&gt; val store = sbt.util.CacheStore(file(&quot;/tmp/last&quot;))
store: sbt.util.CacheStore = sbt.util.FileBasedStore@5a4a6716

scala&gt; val badCachedWork = Tracked.lastOutput[Int, String](store) {
         case (in, None)       =&gt; in.toString
         case (in, Some(read)) =&gt; read + &quot;!&quot;
       }
badCachedWork: Int =&gt; String = sbt.util.Tracked$$$Lambda$6326/638923124@68c6ff60

scala&gt; badCachedWork(1)
res1: String = 1

scala&gt; badCachedWork(1)
res2: String = 1!

scala&gt; badCachedWork(2)
res3: String = 1!!

scala&gt; badCachedWork(2)
res4: String = 1!!!
</code></pre><p><strong>Note</strong>: <code>Tracked.lastOutput</code> does not invalidate the cache when the input changes.
</p><p>See the <code>Tracked.inputChanged</code> section below to make this work.
</p><h3 id="Tracked.inputChanged">Tracked.inputChanged<a href="#Tracked.inputChanged" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To track the changes of input parameters, use <code>Tracked.inputChanged</code>.
</p><pre><code class="prettyprint lang-scala">scala&gt; import sbt._, sbt.util.CacheImplicits._
import sbt._
import sbt.util.CacheImplicits._

// use streams.value.cacheStoreFactory.make(&quot;input&quot;) for real tasks
scala&gt; val store = sbt.util.CacheStore(file(&quot;/tmp/input&quot;))
store: sbt.util.CacheStore = sbt.util.FileBasedStore@5a4a6716

scala&gt; val tracker = Tracked.inputChanged[Int, String](store) { case (changed, in) =&gt;
         if (changed) {
           println(&quot;input changed&quot;)
         }
         in.toString
       }
tracker: Int =&gt; String = sbt.util.Tracked$$$Lambda$6357/1296627950@6e6837e4

scala&gt; tracker(1)
input changed
res6: String = 1

scala&gt; tracker(1)
res7: String = 1

scala&gt; tracker(2)
input changed
res8: String = 2

scala&gt; tracker(2)
res9: String = 2

scala&gt; tracker(1)
input changed
res10: String = 1
</code></pre><p>Now, we can nest <code>Tracked.inputChanged</code> and <code>Tracked.lastOutput</code> to regain the cache invalidation.
</p><pre><code class="prettyprint lang-scala">// use streams.value.cacheStoreFactory
scala&gt; val cacheFactory = sbt.util.CacheStoreFactory(file(&quot;/tmp/cache&quot;))
cacheFactory: sbt.util.CacheStoreFactory = sbt.util.DirectoryStoreFactory@3a3d3778

scala&gt; def doWork(i: Int): String = {
         println(&quot;working...&quot;)
         Thread.sleep(1000)
         i.toString
       }
doWork: (i: Int)String

scala&gt; val cachedWork2 = Tracked.inputChanged[Int, String](cacheFactory.make(&quot;input&quot;)) { case (changed: Boolean, in: Int) =&gt;
         val tracker = Tracked.lastOutput[Int, String](cacheFactory.make(&quot;last&quot;)) {
           case (in, None)       =&gt; doWork(in)
           case (in, Some(read)) =&gt;
             if (changed) doWork(in)
             else read
         }
         tracker(in)
       }
cachedWork2: Int =&gt; String = sbt.util.Tracked$$$Lambda$6548/972308467@1c9788cc

scala&gt; cachedWork2(1)
working...
res0: String = 1

scala&gt; cachedWork2(1)
res1: String = 1
</code></pre><p>One benefit of combining trackers and/or previous value is that we can control the invalidation timing. For example, we can create a cache that works only twice.
</p><pre><code class="prettyprint lang-scala">lazy val hi = taskKey[String](&quot;say hi&quot;)
lazy val hiCount = taskKey[(String, Int)](&quot;track number of the times hi was called&quot;)

hi := hiCount.value._1
hiCount := {
  import sbt.util.CacheImplicits._
  val prev = hiCount.previous
  val s = streams.value
  def doWork(x: String): String = {
    s.log.info(&quot;working...&quot;)
    Thread.sleep(1000)
    x + &quot;!&quot;
  }
  val cachedWork = Tracked.inputChanged[String, (String, Int)](s.cacheStoreFactory.make(&quot;input&quot;)) { case (changed: Boolean, in: String) =&gt;
    prev match {
      case None            =&gt; (doWork(in), 0)
      case Some((last, n)) =&gt;
        if (changed || n &gt; 1) (doWork(in), 0)
        else (last, n + 1)
    }
  }
  cachedWork(&quot;hi&quot;)
}
</code></pre><p>This uses <code>hiCount</code> task’s previous value to track the number of times it got called, and invalidates the cache when <code>n &gt; 1</code>.
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; hi
[info] working...
[success] Total time: 1 s, completed Aug 17, 2019 10:36:34 AM
sbt:hello&gt; hi
[success] Total time: 0 s, completed Aug 17, 2019 10:36:35 AM
sbt:hello&gt; hi
[success] Total time: 0 s, completed Aug 17, 2019 10:36:38 AM
sbt:hello&gt; hi
[info] working...
[success] Total time: 1 s, completed Aug 17, 2019 10:36:40 AM
</code></pre><a name="filefunction"></a><h3 id="Tracking+file+attributes">Tracking file attributes<a href="#Tracking+file+attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Files often come up as caching targets, but <code>java.io.File</code> just carries the file name, so it’s not very useful on its own for the purpose of caching.
</p><p>For file caching, sbt provides a facility called <a href="https://www.scala-sbt.org/1.x/api/sbt/util/FileFunction$.html#cached(cacheBaseDirectory:java.io.File)(action:Set[java.io.File]=&gt;Set[java.io.File]):Set[java.io.File]=&gt;Set[java.io.File]">sbt.util.FileFunction.cached(...)</a>
to cache file inputs and outputs. The following example implements a cached task
that counts the number of lines in <code>*.md</code> and outputs <code>*.md</code> under cross target
directory with the number of lines as their contents.
</p><pre><code class="prettyprint lang-scala">lazy val countInput = taskKey[Seq[File]](&quot;&quot;)
lazy val countFiles = taskKey[Seq[File]](&quot;&quot;)

def doCount(in: Set[File], outDir: File): Set[File] =
  in map { source =&gt;
    val out = outDir / source.getName
    val c = IO.readLines(source).size
    IO.write(out, c + &quot;\n&quot;)
    out
  }

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    countInput :=
      sbt.nio.file.FileTreeView.default
        .list(Glob(baseDirectory.value + &quot;/*.md&quot;))
        .map(_._1.toFile),
    countFiles := {
      val s = streams.value
      val in = countInput.value
      val t = crossTarget.value

      // wraps a function doCount in an up-to-date check
      val cachedFun = FileFunction.cached(s.cacheDirectory / &quot;count&quot;) { (in: Set[File]) =&gt;
        doCount(in, t): Set[File]
      }
      // Applies the cached function to the inputs files
      cachedFun(in.toSet).toSeq.sorted
    },
  )
</code></pre><p>There are two additional arguments for the first parameter list that
allow the file tracking style to be explicitly specified. By default,
the input tracking style is <code>FilesInfo.lastModified</code>, based on a file’s
last modified time, and the output tracking style is <code>FilesInfo.exists</code>,
based only on whether the file exists.
</p><h3 id="FileInfo">FileInfo<a href="#FileInfo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>FileInfo.exists</code> tracks if the file exists
</li><li><code>FileInfo.lastModified</code> track the last modified timestamp
</li><li><code>FileInfo.hash</code> tracks the SHA-1 content hash
</li><li><code>FileInfo.full</code> tracks both the last modified and the content hash
</li></ul><pre><code class="prettyprint lang-scala">scala&gt; FileInfo.exists(file(&quot;/tmp/cache/last&quot;))
res23: sbt.util.PlainFileInfo = PlainFile(/tmp/cache/last,true)

scala&gt; FileInfo.lastModified(file(&quot;/tmp/cache/last&quot;))
res24: sbt.util.ModifiedFileInfo = FileModified(/tmp/cache/last,1565855326328)

scala&gt; FileInfo.hash(file(&quot;/tmp/cache/last&quot;))
res25: sbt.util.HashFileInfo = FileHash(/tmp/cache/last,List(-89, -11, 75, 97, 65, -109, -74, -126, -124, 43, 37, -16, 9, -92, -70, -100, -82, 95, 93, -112))

scala&gt; FileInfo.full(file(&quot;/tmp/cache/last&quot;))
res26: sbt.util.HashModifiedFileInfo = FileHashModified(/tmp/cache/last,List(-89, -11, 75, 97, 65, -109, -74, -126, -124, 43, 37, -16, 9, -92, -70, -100, -82, 95, 93, -112),1565855326328)
</code></pre><p>There is also <code>sbt.util.FilesInfo</code> that accepts a <code>Set</code> of <code>File</code>s (though this doesn’t always work due to complicated abstract type that it uses).
</p><pre><code class="prettyprint lang-scala">scala&gt; FilesInfo.exists(Set(file(&quot;/tmp/cache/last&quot;), file(&quot;/tmp/cache/nonexistent&quot;)))
res31: sbt.util.FilesInfo[_1.F] forSome { val _1: sbt.util.FileInfo.Style } = FilesInfo(Set(PlainFile(/tmp/cache/last,true), PlainFile(/tmp/cache/nonexistent,false)))
</code></pre><h3 id="Tracked.inputChanged">Tracked.inputChanged<a href="#Tracked.inputChanged" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The following example implements a cached task that counts the number of lines in <code>README.md</code>.
</p><pre><code class="prettyprint lang-scala">lazy val count = taskKey[Int](&quot;&quot;)

count := {
  import sbt.util.CacheImplicits._
  val prev = count.previous
  val s = streams.value
  val toCount = baseDirectory.value / &quot;README.md&quot;
  def doCount(source: File): Int = {
    s.log.info(&quot;working...&quot;)
    IO.readLines(source).size
  }
  val cachedCount = Tracked.inputChanged[ModifiedFileInfo, Int](s.cacheStoreFactory.make(&quot;input&quot;)) {
    (changed: Boolean, in: ModifiedFileInfo) =&gt;
      prev match {
        case None       =&gt; doCount(in.file)
        case Some(last) =&gt;
          if (changed) doCount(in.file)
          else last
      }
  }
  cachedCount(FileInfo.lastModified(toCount))
}
</code></pre><p>We can try this by running <code>show count</code> from the sbt shell:
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; show count
[info] working...
[info] 2
[success] Total time: 0 s, completed Aug 16, 2019 9:58:38 PM
sbt:hello&gt; show count
[info] 2
[success] Total time: 0 s, completed Aug 16, 2019 9:58:39 PM

// change something in README.md
sbt:hello&gt; show count
[info] working...
[info] 3
[success] Total time: 0 s, completed Aug 16, 2019 9:58:44 PM
</code></pre><p>This works out-of-box thanks to <code>sbt.util.FileInfo</code> implementing <code>JsonFormat</code> to persist itself.
</p><h3 id="Tracked.outputChanged">Tracked.outputChanged<a href="#Tracked.outputChanged" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The tracking works by stamping the files (collecting file attributes), storing the stamps in a cache, and comparing them later. Sometimes, it’s important to pay attention to the timing of when stamping happens. Suppose that we want to format TypeScript files, and use SHA-1 hash to detect changes. Stamping the files <em>before</em> running the formatter would cause the cache to be invalidated in subsequent calls to the task. This is because the formatter itself may modify the TypeScript files.
</p><p>Use <code>Tracked.outputChanged</code> stamps <em>after</em> your work is done to prevent this.
</p><pre><code class="prettyprint lang-scala">lazy val compileTypeScript = taskKey[Unit](&quot;compiles *.ts files&quot;)
lazy val formatTypeScript = taskKey[Seq[File]](&quot;format *.ts files&quot;)

compileTypeScript / sources := (baseDirectory.value / &quot;src&quot;).globRecursive(&quot;*.ts&quot;).get
formatTypeScript := {
  import sbt.util.CacheImplicits._
  val s = streams.value
  val files = (compileTypeScript / sources).value

  def doFormat(source: File): File = {
    s.log.info(s&quot;formatting $source&quot;)
    val lines = IO.readLines(source)
    IO.writeLines(source, lines ++ List(&quot;// something&quot;))
    source
  }
  val tracker = Tracked.outputChanged(s.cacheStoreFactory.make(&quot;output&quot;)) {
     (outChanged: Boolean, outputs: Seq[HashFileInfo]) =&gt;
       if (outChanged) outputs map { info =&gt; doFormat(info.file) }
       else outputs map { _.file }
  }
  tracker(() =&gt; files.map(FileInfo.hash(_)))
}
</code></pre><p>Type <code>formatTypeScript</code> from the sbt shell to see how it works:
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; formatTypeScript
[info] formatting /Users/eed3si9n/work/hellotest/src/util.ts
[info] formatting /Users/eed3si9n/work/hellotest/src/hello.ts
[success] Total time: 0 s, completed Aug 17, 2019 10:07:30 AM
sbt:hello&gt; formatTypeScript
[success] Total time: 0 s, completed Aug 17, 2019 10:07:32 AM
</code></pre><p>One potential drawback of this implementation is that we only have <code>true/false</code> information about the fact that any of the files have changed.
This could result in a reformatting of <em>all</em> of the files anytime one file gets changed.
</p><pre><code class="prettyprint lang-scala">// make change to one file
sbt:hello&gt; formatTypeScript
[info] formatting /Users/eed3si9n/work/hellotest/src/util.ts
[info] formatting /Users/eed3si9n/work/hellotest/src/hello.ts
[success] Total time: 0 s, completed Aug 17, 2019 10:13:47 AM
</code></pre><p>See the <code>Tracked.diffOuputs</code> in the below to prevent this all-or-nothing behavior.
</p><p>Another potential use for <code>Tracked.outputChanged</code> is using it with <code>FileInfo.exists(_)</code> to track if the output file still exists.
This is usually not necessary if you output something under <code>target</code> directory where caches are also stored.
</p><h3 id="Tracked.diffInputs">Tracked.diffInputs<a href="#Tracked.diffInputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Tracked.inputChanged</code> tracker only gives <code>Boolean</code> value, so when the cache is invalidated we need to redo all the work. Use <code>Tracked.diffInputs</code> to track the differences.
</p><p><code>Tracked.diffInputs</code> reports a datatype called <code>sbt.util.ChangeReport</code>:
</p><pre><code class="prettyprint lang-scala">/** The result of comparing some current set of objects against a previous set of objects.*/
trait ChangeReport[T] {

  /** The set of all of the objects in the current set.*/
  def checked: Set[T]

  /** All of the objects that are in the same state in the current and reference sets.*/
  def unmodified: Set[T]

  /**
   * All checked objects that are not in the same state as the reference.  This includes objects that are in both
   * sets but have changed and files that are only in one set.
   */
  def modified: Set[T] // all changes, including added

  /** All objects that are only in the current set.*/
  def added: Set[T]

  /** All objects only in the previous set*/
  def removed: Set[T]
  def +++(other: ChangeReport[T]): ChangeReport[T] = new CompoundChangeReport(this, other)

  ....
}
</code></pre><p>Let’s see how the report works by printing it out.
</p><pre><code class="prettyprint lang-scala">lazy val compileTypeScript = taskKey[Unit](&quot;compiles *.ts files&quot;)

compileTypeScript / sources := (baseDirectory.value / &quot;src&quot;).globRecursive(&quot;*.ts&quot;).get
compileTypeScript := {
  val s = streams.value
  val files = (compileTypeScript / sources).value
  Tracked.diffInputs(s.cacheStoreFactory.make(&quot;input_diff&quot;), FileInfo.lastModified)(files.toSet) {
    (inDiff: ChangeReport[File]) =&gt;
    s.log.info(inDiff.toString)
  }
}
</code></pre><p>Here’s how it looks when you rename a file for example:
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; compileTypeScript
[info] Change report:
[info]  Checked: /Users/eed3si9n/work/hellotest/src/util.ts, /Users/eed3si9n/work/hellotest/src/hello.ts
[info]  Modified: /Users/eed3si9n/work/hellotest/src/util.ts, /Users/eed3si9n/work/hellotest/src/hello.ts
[info]  Unmodified:
[info]  Added: /Users/eed3si9n/work/hellotest/src/util.ts, /Users/eed3si9n/work/hellotest/src/hello.ts
[info]  Removed:
[success] Total time: 0 s, completed Aug 17, 2019 10:42:50 AM
sbt:hello&gt; compileTypeScript
[info] Change report:
[info]  Checked: /Users/eed3si9n/work/hellotest/src/util.ts, /Users/eed3si9n/work/hellotest/src/bye.ts
[info]  Modified: /Users/eed3si9n/work/hellotest/src/hello.ts, /Users/eed3si9n/work/hellotest/src/bye.ts
[info]  Unmodified: /Users/eed3si9n/work/hellotest/src/util.ts
[info]  Added: /Users/eed3si9n/work/hellotest/src/bye.ts
[info]  Removed: /Users/eed3si9n/work/hellotest/src/hello.ts
[success] Total time: 0 s, completed Aug 17, 2019 10:43:37 AM
</code></pre><p>If we had a mapping between <code>*.ts</code> files and <code>*.js</code> files, then we should be able to make the compilation more incremental. For incremental compilation of Scala, Zinc tracks both the relationship between the <code>*.scala</code> and <code>*.class</code> files as well as the relationship among <code>*.scala</code>. We could make something like that for TypeScript. Save the following as <code>project/TypeScript.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._
import sjsonnew.{ :*:, LList, LNil}
import sbt.util.CacheImplicits._

/**
 * products - products keep the mapping between source *.ts files and *.js files that are generated.
 * references - references keep the mapping between *.ts files referencing other *.ts files.
 */
case class TypeScriptAnalysis(products: List[(File, File)], references: List[(File, File)]) {
  def ++(that: TypeScriptAnalysis): TypeScriptAnalysis =
    TypeScriptAnalysis(products ++ that.products, references ++ that.references)
}
object TypeScriptAnalysis {
  implicit val analysisIso = LList.iso(
    { a: TypeScriptAnalysis =&gt; (&quot;products&quot;, a.products) :*: (&quot;references&quot;, a.references) :*: LNil },
    { in: List[(File, File)] :*: List[(File, File)] :*: LNil =&gt; TypeScriptAnalysis(in._1, in._2) })
}
</code></pre><p>In the <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val compileTypeScript = taskKey[TypeScriptAnalysis](&quot;compiles *.ts files&quot;)

compileTypeScript / sources := (baseDirectory.value / &quot;src&quot;).globRecursive(&quot;*.ts&quot;).get
compileTypeScript / target := target.value / &quot;js&quot;
compileTypeScript := {
  import sbt.util.CacheImplicits._
  val prev0 = compileTypeScript.previous
  val prev = prev0.getOrElse(TypeScriptAnalysis(Nil, Nil))
  val s = streams.value
  val files = (compileTypeScript / sources).value

  def doCompile(source: File): TypeScriptAnalysis = {
    println(&quot;working...&quot;)
    val out = (compileTypeScript / target).value / source.getName.replaceAll(&quot;&quot;&quot;\.ts$&quot;&quot;&quot;, &quot;.js&quot;)
    IO.touch(out)
    // add a fake reference from any file to util.ts
    val references: List[(File, File)] =
      if (source.getName != &quot;util.ts&quot;) List(source -&gt; (baseDirectory.value / &quot;src&quot; / &quot;util.ts&quot;))
      else Nil
    TypeScriptAnalysis(List(source -&gt; out), references)
  }
  Tracked.diffInputs(s.cacheStoreFactory.make(&quot;input_diff&quot;), FileInfo.lastModified)(files.toSet) {
    (inDiff: ChangeReport[File]) =&gt;
    val products = scala.collection.mutable.ListBuffer(prev.products: _*)
    val references = scala.collection.mutable.ListBuffer(prev.references: _*)
    val initial = inDiff.modified &amp; inDiff.checked
    val reverseRefs = initial.flatMap(x =&gt; Set(x) ++ references.collect({ case (k, `x`) =&gt; k }).toSet )
    products --= products.filter({ case (k, v) =&gt; reverseRefs(k) || inDiff.removed(k) })
    references --= references.filter({ case (k, v) =&gt; reverseRefs(k) || inDiff.removed(k) })
    reverseRefs foreach { x =&gt;
      val temp = doCompile(x)
      products ++= temp.products
      references ++= temp.references
    }
    TypeScriptAnalysis(products.toList, references.toList)
  }
}
</code></pre><p>The above is a fake compilation that just creates <code>.js</code> files under <code>target/js</code>.
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; compileTypeScript
working...
working...
[success] Total time: 0 s, completed Aug 16, 2019 10:22:58 PM
sbt:hello&gt; compileTypeScript
[success] Total time: 0 s, completed Aug 16, 2019 10:23:03 PM
</code></pre><p>Since we added a reference from <code>hello.ts</code> to <code>util.ts</code>, if we modified <code>src/util.ts</code>, it should trigger the compilation of <code>src/util.ts</code> as well as <code>src/hello.ts</code>.
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; show compileTypeScript
working...
working...
[info] TypeScriptAnalysis(List((/Users/eed3si9n/work/hellotest/src/util.ts,/Users/eed3si9n/work/hellotest/target/js/util.ts), (/Users/eed3si9n/work/hellotest/src/hello.ts,/Users/eed3si9n/work/hellotest/target/js/hello.ts)),List((/Users/eed3si9n/work/hellotest/src/hello.ts,/Users/eed3si9n/work/hellotest/src/util.ts)))
</code></pre><p>It works.
</p><h3 id="Tracked.diffOutputs">Tracked.diffOutputs<a href="#Tracked.diffOutputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>Tracked.diffOutputs</code> is a finer version of <code>Tracked.outputChanged</code> that stamps after the work is done, and also able to report the set of modified files.
</p><p>This can be used to format only the changed TypeScript files.
</p><pre><code class="prettyprint lang-scala">lazy val formatTypeScript = taskKey[Seq[File]](&quot;format *.ts files&quot;)

compileTypeScript / sources := (baseDirectory.value / &quot;src&quot;).globRecursive(&quot;*.ts&quot;).get
formatTypeScript := {
  val s = streams.value
  val files = (compileTypeScript / sources).value
  def doFormat(source: File): File = {
    s.log.info(s&quot;formatting $source&quot;)
    val lines = IO.readLines(source)
    IO.writeLines(source, lines ++ List(&quot;// something&quot;))
    source
  }
  Tracked.diffOutputs(s.cacheStoreFactory.make(&quot;output_diff&quot;), FileInfo.hash)(files.toSet) {
    (outDiff: ChangeReport[File]) =&gt;
    val initial = outDiff.modified &amp; outDiff.checked
    initial.toList map doFormat
  }
}
</code></pre><p>Here’s how <code>formatTypeScript</code> looks like in the shell:
</p><pre><code class="prettyprint lang-scala">sbt:hello&gt; formatTypeScript
[info] formatting /Users/eed3si9n/work/hellotest/src/util.ts
[info] formatting /Users/eed3si9n/work/hellotest/src/hello.ts
[success] Total time: 0 s, completed Aug 17, 2019 9:28:56 AM
sbt:hello&gt; formatTypeScript
[success] Total time: 0 s, completed Aug 17, 2019 9:28:58 AM
</code></pre><h3 id="Case+study%3A+sbt-scalafmt">Case study: sbt-scalafmt<a href="#Case+study%3A+sbt-scalafmt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt-scalafmt implements <code>scalafmt</code> and <code>scalafmtCheck</code> tasks that cooperate with each other.
For example, if <code>scalafmt</code> ran successfully, and no changes have been made to the sources, it will skip <code>scalafmtCheck</code>’s checking.
</p><p>Here’s a snippet of how that may be implemented:
</p><pre><code class="prettyprint lang-scala">private def cachedCheckSources(
  cacheStoreFactory: CacheStoreFactory,
  sources: Seq[File],
  config: Path,
  log: Logger,
  writer: PrintWriter
): ScalafmtAnalysis = {
  trackSourcesAndConfig(cacheStoreFactory, sources, config) {
    (outDiff, configChanged, prev) =&gt;
      log.debug(outDiff.toString)
      val updatedOrAdded = outDiff.modified &amp; outDiff.checked
      val filesToCheck =
        if (configChanged) sources
        else updatedOrAdded.toList
      val failed = prev.failed filter { _.exists }
      val files = (filesToCheck ++ failed.toSet).toSeq
      val result = checkSources(files, config, log, writer)
      // cachedCheckSources moved the outDiff cursor forward,
      // save filesToCheck so scalafmt can later run formatting
      prev.copy(
        failed = result.failed,
        pending = (prev.pending ++ filesToCheck).distinct
      )
  }
}

private def trackSourcesAndConfig(
  cacheStoreFactory: CacheStoreFactory,
  sources: Seq[File],
  config: Path
)(
    f: (ChangeReport[File], Boolean, ScalafmtAnalysis) =&gt; ScalafmtAnalysis
): ScalafmtAnalysis = {
  val prevTracker = Tracked.lastOutput[Unit, ScalafmtAnalysis](cacheStoreFactory.make(&quot;last&quot;)) {
    (_, prev0) =&gt;
    val prev = prev0.getOrElse(ScalafmtAnalysis(Nil, Nil))
    val tracker = Tracked.inputChanged[HashFileInfo, ScalafmtAnalysis](cacheStoreFactory.make(&quot;config&quot;)) {
      case (configChanged, configHash) =&gt;
        Tracked.diffOutputs(cacheStoreFactory.make(&quot;output-diff&quot;), FileInfo.lastModified)(sources.toSet) {
          (outDiff: ChangeReport[File]) =&gt;
          f(outDiff, configChanged, prev)
        }
    }
    tracker(FileInfo.hash(config.toFile))
  }
  prevTracker(())
}
</code></pre><p>In the above, <code>trackSourcesAndConfig</code> is a triple-nested tracker that tracks configuration file, source last modified stamps, and the previous value shared between two tasks. To share the previous value across two different tasks, we are using <code>Tracked.lastOutput</code> instead of the <code>.previous</code> method associated with the keys.
</p><h3 id="Summary">Summary<a href="#Summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Depending on the level of control you need, sbt offers a flexible set of utilities to cache and track values and files.
</p><ul><li><code>.previous</code>, <code>FileFunction.cached</code>, and <code>Cache.cached</code> are the basic cache to get started.
</li><li>To invalidate some result based on a change to its input parameters, use <code>Tracked.inputChanged</code>.
</li><li>File attributes can be tracked as values by using <code>FileInfo.exists</code>, <code>FileInfo.lastModified</code>, and <code>FileInfo.hash</code>.
</li><li><code>Tracked</code> offers trackers that are often nested to track input invalidation, output invalidation, and diffing.
</li></ul><h2 id="Input+Tasks">Input Tasks<a href="#Input+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Input Tasks parse user input and produce a task to run.
<a href="Parsing-Input.html">Parsing Input</a> describes how to use the parser
combinators that define the input syntax and tab completion. This page
describes how to hook those parser combinators into the input task
system.
</p><h3 id="Input+Keys">Input Keys<a href="#Input+Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A key for an input task is of type <code>InputKey</code> and represents the input
task like a <code>SettingKey</code> represents a setting or a <code>TaskKey</code> represents
a task. Define a new input task key using the <code>inputKey.apply</code> factory
method:
</p><pre><code class="prettyprint lang-scala">// goes in project/Build.scala or in build.sbt
val demo = inputKey[Unit](&quot;A demo input task.&quot;)
</code></pre><p>The definition of an input task is similar to that of a normal task, but
it can also use the result of a
</p><p><a href="Parsing-Input.html">Parser</a> applied to user input. Just as
the special <code>value</code> method gets the value of a setting or task, the
special <code>parsed</code> method gets the result of a <code>Parser</code>.
</p><h3 id="Basic+Input+Task+Definition">Basic Input Task Definition<a href="#Basic+Input+Task+Definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The simplest input task accepts a space-delimited sequence of arguments.
It does not provide useful tab completion and parsing is basic. The
built-in parser for space-delimited arguments is constructed via the
<code>spaceDelimited</code> method, which accepts as its only argument the label to
present to the user during tab completion.
</p><p>For example, the following task prints the current Scala version and
then echoes the arguments passed to it on their own line.
</p><pre><code class="prettyprint lang-scala">import complete.DefaultParsers._

demo := {
  // get the result of parsing
  val args: Seq[String] = spaceDelimited(&quot;&lt;arg&gt;&quot;).parsed
  // Here, we also use the value of the `scalaVersion` setting
  println(&quot;The current Scala version is &quot; + scalaVersion.value)
  println(&quot;The arguments to demo were:&quot;)
  args foreach println
}
</code></pre><h3 id="Input+Task+using+Parsers">Input Task using Parsers<a href="#Input+Task+using+Parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Parser provided by the <code>spaceDelimited</code> method does not provide any
flexibility in defining the input syntax. Using a custom parser is just
a matter of defining your own <code>Parser</code> as described on the
<a href="Parsing-Input.html">Parsing Input</a> page.
</p><h4 id="Constructing+the+Parser">Constructing the Parser<a href="#Constructing+the+Parser" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first step is to construct the actual <code>Parser</code> by defining a value
of one of the following types:
</p><ul><li><code>Parser[I]</code>: a basic parser that does not use any settings
</li><li><code>Initialize[Parser[I]]</code>: a parser whose definition depends on one or
more settings
</li><li><code>Initialize[State =&gt; Parser[I]]</code>: a parser that is defined using
both settings and the current <a href="Build-State.html">state</a>
</li></ul><p>We already saw an example of the first case with <code>spaceDelimited</code>, which
doesn’t use any settings in its definition. As an example of the third
case, the following defines a contrived <code>Parser</code> that uses the project’s
Scala and sbt version settings as well as the state. To use these
settings, we need to wrap the Parser construction in <code>Def.setting</code> and
get the setting values with the special <code>value</code> method:
</p><pre><code class="prettyprint lang-scala">import complete.DefaultParsers._
import complete.Parser

val parser: Def.Initialize[State =&gt; Parser[(String,String)]] =
Def.setting {
  (state: State) =&gt;
    ( token(&quot;scala&quot; &lt;~ Space) ~ token(scalaVersion.value) ) |
    ( token(&quot;sbt&quot; &lt;~ Space) ~ token(sbtVersion.value) ) |
    ( token(&quot;commands&quot; &lt;~ Space) ~
        token(state.remainingCommands.size.toString) )
}
</code></pre><p>This Parser definition will produce a value of type <code>(String,String)</code>.
The input syntax defined isn’t very flexible; it is just a
demonstration. It will produce one of the following values for a
successful parse (assuming the current Scala version is 2.12.13,
the current sbt version is 1.4.7, and there are 3 commands left to
run):
</p><ul><li>(scala,2.12.13)
</li><li>(sbt,1.4.7)
</li><li>(commands,3)
</li></ul><p>Again, we were able to access the current Scala and sbt version for the
project because they are settings. Tasks cannot be used to define the
parser.
</p><h4 id="Constructing+the+Task">Constructing the Task<a href="#Constructing+the+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Next, we construct the actual task to execute from the result of the
<code>Parser</code>. For this, we define a task as usual, but we can access the
result of parsing via the special <code>parsed</code> method on <code>Parser</code>.
</p><p>The following contrived example uses the previous example’s output (of
type <code>(String,String)</code>) and the result of the <code>package</code> task to print
some information to the screen.
</p><pre><code class="prettyprint lang-scala">demo := {
    val (tpe, value) = parser.parsed
    println(&quot;Type: &quot; + tpe)
    println(&quot;Value: &quot; + value)
    println(&quot;Packaged: &quot; + packageBin.value.getAbsolutePath)
}
</code></pre><h3 id="The+InputTask+type">The InputTask type<a href="#The+InputTask+type" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It helps to look at the <code>InputTask</code> type to understand more advanced
usage of input tasks. The core input task type is:
</p><pre><code class="prettyprint lang-scala">class InputTask[T](val parser: State =&gt; Parser[Task[T]])
</code></pre><p>Normally, an input task is assigned to a setting and you work with
<code>Initialize[InputTask[T]]</code>.
</p><p>Breaking this down,
</p><ol><li>You can use other settings (via Initialize) to construct an input
task.
</li><li>You can use the current State to construct the parser.
</li><li>The parser accepts user input and provides tab completion.
</li><li>The parser produces the task to run.
</li></ol><p>So, you can use settings or <code>State</code> to construct the parser that defines
an input task’s command line syntax. This was described in the previous
section. You can then use settings, <code>State</code>, or user input to construct
the task to run. This is implicit in the input task syntax.
</p><h3 id="Using+other+input+tasks">Using other input tasks<a href="#Using+other+input+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The types involved in an input task are composable, so it is possible to
reuse input tasks. The <code>.parsed</code> and <code>.evaluated</code> methods are defined on
InputTasks to make this more convenient in common situations:
</p><ul><li>Call <code>.parsed</code> on an <code>InputTask[T]</code> or <code>Initialize[InputTask[T]]</code>
to get the <code>Task[T]</code> created after parsing the command line
</li><li>Call <code>.evaluated</code> on an <code>InputTask[T]</code> or
<code>Initialize[InputTask[T]]</code> to get the value of type <code>T</code> from
evaluating that task
</li></ul><p>In both situations, the underlying <code>Parser</code> is sequenced with other
parsers in the input task definition. In the case of <code>.evaluated</code>, the
generated task is evaluated.
</p><p>The following example applies the <code>run</code> input task, a literal separator
parser <code>--</code>, and <code>run</code> again. The parsers are sequenced in order of
syntactic appearance, so that the arguments before <code>--</code> are passed to
the first <code>run</code> and the ones after are passed to the second.
</p><pre><code class="prettyprint lang-scala">val run2 = inputKey[Unit](
    &quot;Runs the main class twice with different argument lists separated by --&quot;)

val separator: Parser[String] = &quot;--&quot;

run2 := {
   val one = (Compile / run).evaluated
   val sep = separator.parsed
   val two = (Compile / run).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 a b -- c d
[info] Running Demo c d
[info] Running Demo a b
c
d
a
b
</code></pre><h3 id="Preapplying+input">Preapplying input<a href="#Preapplying+input" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Because <code>InputTasks</code> are built from <code>Parsers</code>, it is possible to
generate a new <code>InputTask</code> by applying some input programmatically. (It
is also possible to generate a <code>Task</code>, which is covered in the next
section.) Two convenience methods are provided on <code>InputTask[T]</code> and
<code>Initialize[InputTask[T]]</code> that accept the String to apply.
</p><ul><li><code>partialInput</code> applies the input and allows further input, such as
from the command line
</li><li><code>fullInput</code> applies the input and terminates parsing, so that
further input is not accepted
</li></ul><p>In each case, the input is applied to the input task’s parser. Because
input tasks handle all input after the task name, they usually require
initial whitespace to be provided in the input.
</p><p>Consider the example in the previous section. We can modify it so that
we:
</p><ul><li>Explicitly specify all of the arguments to the first <code>run</code>. We use
<code>name</code> and <code>version</code> to show that settings can be used to define
and modify parsers.
</li><li>Define the initial arguments passed to the second <code>run</code>, but allow
further input on the command line.
</li></ul><blockquote><p><strong>Note</strong>: if the input derives from settings you need to use, for
example, <code>Def.taskDyn { ... }.value</code>
</p></blockquote><pre><code class="prettyprint lang-scala">lazy val run2 = inputKey[Unit](&quot;Runs the main class twice: &quot; +
   &quot;once with the project name and version as arguments&quot;
   &quot;and once with command line arguments preceded by hard coded values.&quot;)

// The argument string for the first run task is ' &lt;name&gt; &lt;version&gt;'
lazy val firstInput: Initialize[String] =
   Def.setting(s&quot; ${name.value} ${version.value}&quot;)

// Make the first arguments to the second run task ' red blue'
lazy val secondInput: String = &quot; red blue&quot;

run2 := {
   val one = (Compile / run).fullInput(firstInput.value).evaluated
   val two = (Compile / run).partialInput(secondInput).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 green
[info] Running Demo demo 1.0
[info] Running Demo red blue green
demo
1.0
red
blue
green
</code></pre><h3 id="Get+a+Task+from+an+InputTask">Get a Task from an InputTask<a href="#Get+a+Task+from+an+InputTask" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The previous section showed how to derive a new <code>InputTask</code> by applying
input. In this section, applying input produces a <code>Task</code>. The <code>toTask</code>
method on <code>Initialize[InputTask[T]]</code> accepts the <code>String</code> input to apply
and produces a task that can be used normally. For example, the
following defines a plain task <code>runFixed</code> that can be used by other
tasks or run directly without providing any input:
</p><pre><code class="prettyprint lang-scala">lazy val runFixed = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

runFixed := {
   val _ = (Compile / run).toTask(&quot; blue green&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>For a main class Demo that echoes its arguments, running <code>runFixed</code>
looks like:
</p><pre><code class="">$ sbt
&gt; runFixed
[info] Running Demo blue green
blue
green
Done!
</code></pre><p>Each call to <code>toTask</code> generates a new task, but each task is configured
the same as the original <code>InputTask</code> (in this case, <code>run</code>) but with
different input applied. For example:
</p><pre><code class="prettyprint lang-scala">lazy val runFixed2 = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

fork in run := true

runFixed2 := {
   val x = (Compile / run).toTask(&quot; blue green&quot;).value
   val y = (Compile / run).toTask(&quot; red orange&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>The different <code>toTask</code> calls define different tasks that each run the
project’s main class in a new jvm. That is, the <code>fork</code> setting
configures both, each has the same classpath, and each run the same main
class. However, each task passes different arguments to the main class.
For a main class Demo that echoes its arguments, the output of running
<code>runFixed2</code> might look like:
</p><pre><code class="">$ sbt
&gt; runFixed2
[info] Running Demo blue green
[info] Running Demo red orange
blue
green
red
orange
Done!
</code></pre><h2 id="Commands">Commands<a href="#Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="What+is+a+%E2%80%9Ccommand%E2%80%9D%3F">What is a “command”?<a href="#What+is+a+%E2%80%9Ccommand%E2%80%9D%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A “command” looks similar to a task: it’s a named operation that can be
executed from the sbt console.
</p><p>However, a command’s implementation takes as its parameter the entire
state of the build (represented by <a href="Build-State.html">State</a>) and
computes a new <a href="Build-State.html">State</a>. This means that a command can
look at or modify other sbt settings, for example. Typically, you would
resort to a command when you need to do something that’s impossible in a
regular task.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are three main aspects to commands:
</p><ol><li><p>The syntax used by the user to invoke the command, including:
</p><ul><li>Tab completion for the syntax
</li><li>The parser to turn input into an appropriate data structure
</li></ul></li><li>The action to perform using the parsed data structure. This action
transforms the build <a href="../api/sbt/State.html">State</a>.
</li><li>Help provided to the user
</li></ol><p>In sbt, the syntax part, including tab completion, is specified with
parser combinators. If you are familiar with the parser combinators in
Scala’s standard library, these are very similar. The action part is a
function <code>(State, T) =&gt; State</code>, where <code>T</code> is the data structure produced
by the parser. See the
<a href="Parsing-Input.html">Parsing Input</a> page for how to
use the parser combinators.
</p><p><a href="../api/sbt/State.html">State</a> provides access to the build state,
such as all registered <code>Command</code>s, the remaining commands to execute,
and all project-related information. See <a href="Build-State.html">States and Actions</a> for details on
State.
</p><p>Finally, basic help information may be provided that is used by the
<code>help</code> command to display command help.
</p><h3 id="Defining+a+Command">Defining a Command<a href="#Defining+a+Command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A command combines a function <code>State =&gt; Parser[T]</code> with an action
<code>(State, T) =&gt; State</code>. The reason for <code>State =&gt; Parser[T]</code> and not
simply <code>Parser[T]</code> is that often the current <code>State</code> is used to build
the parser. For example, the currently loaded projects (provided by
<code>State</code>) determine valid completions for the <code>project</code> command. Examples
for the general and specific cases are shown in the following sections.
</p><p>See <a href="https://github.com/sbt/sbt/blob/develop/main-command/src/main/scala/sbt/Command.scala">Command.scala</a> for the source
API details for constructing commands.
</p><h4 id="General+commands">General commands<a href="#General+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>General command construction looks like:
</p><pre><code class="prettyprint lang-scala">val action: (State, T) =&gt; State = ...
val parser: State =&gt; Parser[T] = ...
val command: Command = Command(&quot;name&quot;)(parser)(action)
</code></pre><h4 id="No-argument+commands">No-argument commands<a href="#No-argument+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that do not
accept any arguments.
</p><pre><code class="prettyprint lang-scala">val action: State =&gt; State = ...
val command: Command = Command.command(&quot;name&quot;)(action)
</code></pre><h4 id="Single-argument+command">Single-argument command<a href="#Single-argument+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that accept a
single argument with arbitrary content.
</p><pre><code class="prettyprint lang-scala">// accepts the state and the single argument
val action: (State, String) =&gt; State = ...
val command: Command = Command.single(&quot;name&quot;)(action)
</code></pre><h4 id="Multi-argument+command">Multi-argument command<a href="#Multi-argument+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that accept
multiple arguments separated by spaces.
</p><pre><code class="prettyprint lang-scala">val action: (State, Seq[String]) =&gt; State = ...

// &lt;arg&gt; is the suggestion printed for tab completion on an argument
val command: Command = Command.args(&quot;name&quot;, &quot;&lt;arg&gt;&quot;)(action)
</code></pre><h3 id="Full+Example">Full Example<a href="#Full+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The following example is a sample build that adds
commands to a project. To try it out:
</p><ol><li>Create <code>build.sbt</code> and <code>project/CommandExample.scala</code>.
</li><li>Run sbt on the project.
</li><li>Try out the <code>hello</code>, <code>helloAll</code>, <code>failIfTrue</code>, <code>color</code>, and
printState commands.
</li><li>Use tab-completion and the code below as guidance.
</li></ol><p>Here’s <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">import CommandExample._

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    commands ++= Seq(hello, helloAll, failIfTrue, changeColor, printState)
  )
</code></pre><p>Here’s <code>project/CommandExample.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

// imports standard command parsing functionality
import complete.DefaultParsers._

object CommandExample {
  // A simple, no-argument command that prints &quot;Hi&quot;,
  //  leaving the current state unchanged.
  def hello = Command.command(&quot;hello&quot;) { state =&gt;
    println(&quot;Hi!&quot;)
    state
  }

  // A simple, multiple-argument command that prints &quot;Hi&quot; followed by the arguments.
  //   Again, it leaves the current state unchanged.
  def helloAll = Command.args(&quot;helloAll&quot;, &quot;&lt;name&gt;&quot;) { (state, args) =&gt;
    println(&quot;Hi &quot; + args.mkString(&quot; &quot;))
    state
  }

  // A command that demonstrates failing or succeeding based on the input
  def failIfTrue = Command.single(&quot;failIfTrue&quot;) {
    case (state, &quot;true&quot;) =&gt; state.fail
    case (state, _) =&gt; state
  }

  // Demonstration of a custom parser.
  // The command changes the foreground or background terminal color
  //  according to the input.
  lazy val change = Space ~&gt; (reset | setColor)
  lazy val reset = token(&quot;reset&quot; ^^^ &quot;\033[0m&quot;)
  lazy val color = token( Space ~&gt; (&quot;blue&quot; ^^^ &quot;4&quot; | &quot;green&quot; ^^^ &quot;2&quot;) )
  lazy val select = token( &quot;fg&quot; ^^^ &quot;3&quot; | &quot;bg&quot; ^^^ &quot;4&quot; )
  lazy val setColor = (select ~ color) map { case (g, c) =&gt; &quot;\033[&quot; + g + c + &quot;m&quot; }

  def changeColor = Command(&quot;color&quot;)(_ =&gt; change) { (state, ansicode) =&gt;
    print(ansicode)
    state
  }

  // A command that demonstrates getting information out of State.
  def printState = Command.command(&quot;printState&quot;) { state =&gt;
    import state._
    println(definedCommands.size + &quot; registered commands&quot;)
    println(&quot;commands to run: &quot; + show(remainingCommands))
    println()

    println(&quot;original arguments: &quot; + show(configuration.arguments))
    println(&quot;base directory: &quot; + configuration.baseDirectory)
    println()

    println(&quot;sbt version: &quot; + configuration.provider.id.version)
    println(&quot;Scala version (for sbt): &quot; + configuration.provider.scalaProvider.version)
    println()

    val extracted = Project.extract(state)
    import extracted._
    println(&quot;Current build: &quot; + currentRef.build)
    println(&quot;Current project: &quot; + currentRef.project)
    println(&quot;Original setting count: &quot; + session.original.size)
    println(&quot;Session setting count: &quot; + session.append.size)

    state
  }

  def show[T](s: Seq[T]) =
    s.map(&quot;'&quot; + _ + &quot;'&quot;).mkString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;)
}
</code></pre><h2 id="Parsing+and+tab+completion">Parsing and tab completion<a href="#Parsing+and+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes the parser combinators in sbt. These parser
combinators are typically used to parse user input and provide tab
completion for <a href="Input-Tasks.html">Input Tasks</a> and <a href="Commands.html">Commands</a>. If
you are already familiar with Scala’s parser combinators, the methods
are mostly the same except that their arguments are strict. There are
two additional methods for controlling tab completion that are discussed
at the end of the section.
</p><p>Parser combinators build up a parser from smaller parsers. A <code>Parser[T]</code>
in its most basic usage is a function <code>String =&gt; Option[T]</code>. It accepts
a <code>String</code> to parse and produces a value wrapped in <code>Some</code> if parsing
succeeds or <code>None</code> if it fails. Error handling and tab completion make
this picture more complicated, but we’ll stick with <code>Option</code> for this
discussion.
</p><p>The following examples assume the imports: :
</p><pre><code class="prettyprint lang-scala">import sbt._
import complete.DefaultParsers._
</code></pre><h3 id="Basic+parsers">Basic parsers<a href="#Basic+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The simplest parser combinators match exact inputs:
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the input is 'x', returning the Char 'x'
//  and failing otherwise
val singleChar: Parser[Char] = 'x'

// A parser that succeeds if the input is &quot;blue&quot;, returning the String &quot;blue&quot;
//   and failing otherwise
val litString: Parser[String] = &quot;blue&quot;
</code></pre><p>In these examples, implicit conversions produce a literal <code>Parser</code> from
a <code>Char</code> or <code>String</code>. Other basic parser constructors are the
<code>charClass</code>, <code>success</code> and <code>failure</code> methods:
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the character is a digit, returning the matched Char 
//   The second argument, &quot;digit&quot;, describes the parser and is used in error messages
val digit: Parser[Char] = charClass( (c: Char) =&gt; c.isDigit, &quot;digit&quot;)

// A parser that produces the value 3 for an empty input string, fails otherwise
val alwaysSucceed: Parser[Int] = success( 3 )

// Represents failure (always returns None for an input String).
//  The argument is the error message.
val alwaysFail: Parser[Nothing] = failure(&quot;Invalid input.&quot;)
</code></pre><h3 id="Built-in+parsers">Built-in parsers<a href="#Built-in+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt comes with several built-in parsers defined in
<a href="../api/sbt/internal/util/complete/DefaultParsers$.html">sbt.complete.DefaultParsers</a>.
Some commonly used built-in parsers are:
</p><blockquote><ul><li><code>Space</code>, <code>NotSpace</code>, <code>OptSpace</code>, and <code>OptNotSpace</code> for parsing
spaces or non-spaces, required or not.
</li><li><code>StringBasic</code> for parsing text that may be quoted.
</li><li><code>IntBasic</code> for parsing a signed Int value.
</li><li><code>Digit</code> and <code>HexDigit</code> for parsing a single decimal or hexadecimal
digit.
</li><li><code>Bool</code> for parsing a <code>Boolean</code> value
</li></ul></blockquote><p>See the
<a href="../api/sbt/internal/util/complete/DefaultParsers$.html">DefaultParsers API</a> for
details.
</p><h3 id="Combining+parsers">Combining parsers<a href="#Combining+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We build on these basic parsers to construct more interesting parsers.
We can combine parsers in a sequence, choose between parsers, or repeat
a parser.
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the input is &quot;blue&quot; or &quot;green&quot;,
//  returning the matched input
val color: Parser[String] = &quot;blue&quot; | &quot;green&quot;

// A parser that matches either &quot;fg&quot; or &quot;bg&quot;
val select: Parser[String] = &quot;fg&quot; | &quot;bg&quot;

// A parser that matches &quot;fg&quot; or &quot;bg&quot;, a space, and then the color, returning the matched values.
//   ~ is an alias for Tuple2.
val setColor: Parser[String ~ Char ~ String] =
  select ~ ' ' ~ color

// Often, we don't care about the value matched by a parser, such as the space above
//  For this, we can use ~&gt; or &lt;~, which keep the result of
//  the parser on the right or left, respectively
val setColor2: Parser[String ~ String]  =  select ~ (' ' ~&gt; color)

// Match one or more digits, returning a list of the matched characters
val digits: Parser[Seq[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).+

// Match zero or more digits, returning a list of the matched characters
val digits0: Parser[Seq[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).*

// Optionally match a digit
val optDigit: Parser[Option[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).?
</code></pre><h3 id="Transforming+results">Transforming results<a href="#Transforming+results" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A key aspect of parser combinators is transforming results along the way
into more useful data structures. The fundamental methods for this are
<code>map</code> and <code>flatMap</code>. Here are examples of <code>map</code> and some convenience
methods implemented on top of <code>map</code>.
</p><pre><code class="prettyprint lang-scala">// Apply the `digits` parser and apply the provided function to the matched
//   character sequence
val num: Parser[Int] = digits map { (chars: Seq[Char]) =&gt; chars.mkString.toInt }

// Match a digit character, returning the matched character or return '0' if the input is not a digit
val digitWithDefault: Parser[Char]  =  charClass(_.isDigit, &quot;digit&quot;) ?? '0'

// The previous example is equivalent to:
val digitDefault: Parser[Char] =
  charClass(_.isDigit, &quot;digit&quot;).? map { (d: Option[Char]) =&gt; d getOrElse '0' }

// Succeed if the input is &quot;blue&quot; and return the value 4
val blue = &quot;blue&quot; ^^^ 4

// The above is equivalent to:
val blueM = &quot;blue&quot; map { (s: String) =&gt; 4 }
</code></pre><h3 id="Controlling+tab+completion">Controlling tab completion<a href="#Controlling+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Most parsers have reasonable default tab completion behavior. For
example, the string and character literal parsers will suggest the
underlying literal for an empty input string. However, it is impractical
to determine the valid completions for <code>charClass</code>, since it accepts an
arbitrary predicate. The <code>examples</code> method defines explicit completions
for such a parser:
</p><pre><code class="prettyprint lang-scala">val digit = charClass(_.isDigit, &quot;digit&quot;).examples(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;)
</code></pre><p>Tab completion will use the examples as suggestions. The other method
controlling tab completion is <code>token</code>. The main purpose of <code>token</code> is to
determine the boundaries for suggestions. For example, if your parser
is:
</p><pre><code class="prettyprint lang-scala">(&quot;fg&quot; | &quot;bg&quot;) ~ ' ' ~ (&quot;green&quot; | &quot;blue&quot;)
</code></pre><p>then the potential completions on empty input are:
<code>console fg green fg blue bg green bg blue</code>
</p><p>Typically, you want to suggest smaller segments or the number of
suggestions becomes unmanageable. A better parser is:
</p><pre><code class="prettyprint lang-scala">token( (&quot;fg&quot; | &quot;bg&quot;) ~ ' ') ~ token(&quot;green&quot; | &quot;blue&quot;)
</code></pre><p>Now, the initial suggestions would be (with <code>_</code> representing a space):
<code>console fg_ bg_</code>
</p><p>Be careful not to overlap or nest tokens, as in
<code>token(&quot;green&quot; ~ token(&quot;blue&quot;))</code>. The behavior is unspecified (and
should generate an error in the future), but typically the outer most
token definition will be used.
</p><h3 id="Dependent+parsers">Dependent parsers<a href="#Dependent+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes a parser must analyze some data and then more data needs to be parsed, 
and it is dependent on the previous one.  
<br/>
The key for obtaining this behaviour is to use the <code>flatMap</code> function.
</p><p>As an example, it will shown how to select several items from a list of valid ones 
with completion, but no duplicates are possible.  A space is used to separate the 
different items.
</p><pre><code class="prettyprint lang-scala">def select1(items: Iterable[String]) =
  token(Space ~&gt; StringBasic.examples(FixedSetExamples(items)))

def selectSome(items: Seq[String]): Parser[Seq[String]] = {
   select1(items).flatMap { v ⇒
   val remaining = items filter { _ != v }
   if (remaining.size == 0)
     success(v :: Nil)
   else
     selectSome(remaining).?.map(v +: _.getOrElse(Seq()))
 } 
</code></pre><p> As you can see, the <code>flatMap</code> function provides the previous value.  With this info, a new
 parser is constructed for the remaining items.  The <code>map</code> combinator is also used in order
 to transform the output of the parser.
</p><p> The parser is called recursively, until it is found the trivial case of no possible choices.
</p><h2 id="State+and+actions">State and actions<a href="#State+and+actions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><a href="../api/sbt/State$.html">State</a> is the entry point to all
available information in sbt. The key methods are:
</p><ul><li><code>definedCommands: Seq[Command]</code> returns all registered Command
definitions
</li><li><code>remainingCommands: List[Exec]</code> returns the remaining commands to
be run
</li><li><code>attributes: AttributeMap</code> contains generic data.
</li></ul><p>The action part of a command performs work and transforms <code>State</code>. The
following sections discuss <code>State =&gt; State</code> transformations. As
mentioned previously, a command will typically handle a parsed value as
well: <code>(State, T) =&gt; State</code>.
</p><h3 id="Command-related+data">Command-related data<a href="#Command-related+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A Command can modify the currently registered commands or the commands
to be executed. This is done in the action part by transforming the
(immutable) State provided to the command. A function that registers
additional power commands might look like:
</p><pre><code class="prettyprint lang-scala">val powerCommands: Seq[Command] = ...

val addPower: State =&gt; State =
  (state: State) =&gt;
    state.copy(definedCommands =
      (state.definedCommands ++ powerCommands).distinct
    )
</code></pre><p>This takes the current commands, appends new commands, and drops
duplicates. Alternatively, State has a convenience method for doing the
above:
</p><pre><code class="prettyprint lang-scala">val addPower2 = (state: State) =&gt; state ++ powerCommands
</code></pre><p>Some examples of functions that modify the remaining commands to
execute:
</p><pre><code class="prettyprint lang-scala">val appendCommand: State =&gt; State =
  (state: State) =&gt;
    state.copy(remainingCommands = state.remainingCommands :+ &quot;cleanup&quot;)

val insertCommand: State =&gt; State =
  (state: State) =&gt;
    state.copy(remainingCommands = &quot;next-command&quot; +: state.remainingCommands)
</code></pre><p>The first adds a command that will run after all currently specified
commands run. The second inserts a command that will run next. The
remaining commands will run after the inserted command completes.
</p><p>To indicate that a command has failed and execution should not continue,
return <code>state.fail</code>.
</p><pre><code class="prettyprint lang-scala">(state: State) =&gt; {
  val success: Boolean = ...
  if(success) state else state.fail
}
</code></pre><h3 id="Project-related+data">Project-related data<a href="#Project-related+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Project-related information is stored in <code>attributes</code>. Typically,
commands won’t access this directly but will instead use a convenience
method to extract the most useful information:
</p><pre><code class="prettyprint lang-scala">val state: State
val extracted: Extracted = Project.extract(state)
import extracted._
</code></pre><p><a href="../api/sbt/Extracted.html">Extracted</a> provides:
</p><ul><li>Access to the current build and project (<code>currentRef</code>)
</li><li>Access to initialized project setting data (<code>structure.data</code>)
</li><li>Access to session <code>Setting</code>s and the original, permanent settings
from .sbt and .scala files (session.append and session.original,
respectively)
</li><li>Access to the current <a href="../api/sbt/compiler/Eval.html">Eval</a>
instance for evaluating Scala expressions in the build context.
</li></ul><h3 id="Project+data">Project data<a href="#Project+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>All project data is stored in <code>structure.data</code>, which is of type
<code>sbt.Settings[Scope]</code>. Typically, one gets information of type <code>T</code> in
the following way:
</p><pre><code class="prettyprint lang-scala">val key: SettingKey[T]
val scope: Scope
val value: Option[T] = key in scope get structure.data
</code></pre><p>Here, a <code>SettingKey[T]</code> is typically obtained from
<a href="../api/sbt/Keys$.html">Keys</a> and is the same type that is used to
define settings in <code>.sbt</code> files, for example.
<a href="../api/sbt/Scope.html">Scope</a> selects the scope the key is
obtained for. There are convenience overloads of <code>in</code> that can be used
to specify only the required scope axes. See
<a href="https://github.com/sbt/sbt/blob/develop/main-settings/src/main/scala/sbt/Structure.scala">Structure.scala</a> for where <code>in</code>
and other parts of the settings interface are defined. Some examples:
</p><pre><code class="prettyprint lang-scala">import Keys._
val extracted: Extracted
import extracted._

// get name of current project
val nameOpt: Option[String] = (currentRef / name).get(structure.data)

// get the package options for the `test:packageSrc` task or Nil if none are defined
val pkgOpts: Seq[PackageOption] = (currentRef / Test / packageSrc / packageOptions).get(structure.data).getOrElse(Nil)
</code></pre><p><a href="../api/sbt/internal/BuildStructure.html">BuildStructure</a> contains
information about build and project relationships. Key members are:
</p><pre><code class="prettyprint lang-scala">units: Map[URI, LoadedBuildUnit]
root: URI
</code></pre><p>A <code>URI</code> identifies a build and <code>root</code> identifies the initial build
loaded. <a href="../api/sbt/internal/LoadedBuildUnit.html">LoadedBuildUnit</a>
provides information about a single build. The key members of
<code>LoadedBuildUnit</code> are:
</p><pre><code class="prettyprint lang-scala">// Defines the base directory for the build
localBase: File

// maps the project ID to the Project definition
defined: Map[String, ResolvedProject]
</code></pre><p><a href="../api/sbt/ResolvedProject.html">ResolvedProject</a> has the same
information as the <code>Project</code> used in a <code>project/Build.scala</code> except that
<a href="../api/sbt/ProjectReference.html">ProjectReferences</a> are resolved
to <code>ProjectRef</code>s.
</p><h3 id="Classpaths">Classpaths<a href="#Classpaths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Classpaths in sbt are of type <code>Seq[Attributed[File]]</code>. This allows
tagging arbitrary information to classpath entries. sbt currently uses
this to associate an <code>Analysis</code> with an entry. This is how it manages
the information needed for multi-project incremental recompilation. It
also associates the ModuleID and Artifact with managed entries (those
obtained by dependency management). When you only want the underlying
<code>Seq[File]</code>, use <code>files</code>:
</p><pre><code class="prettyprint lang-scala">val attributedClasspath: Seq[Attribute[File]] = ...
val classpath: Seq[File] = attributedClasspath.files
</code></pre><h3 id="Running+tasks">Running tasks<a href="#Running+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It can be useful to run a specific project task from a
<a href="Commands.html">command</a> (<em>not from another task</em>) and get its result. For
example, an IDE-related command might want to get the classpath from a
project or a task might analyze the results of a compilation. The
relevant method is <code>Project.runTask</code>, which has the following
signature:
</p><pre><code class="prettyprint lang-scala">def runTask[T](taskKey: ScopedKey[Task[T]], state: State,
  checkCycles: Boolean = false): Option[(State, Result[T])]
</code></pre><p>For example,
</p><pre><code class="prettyprint lang-scala">val eval: State =&gt; State = (state: State) =&gt; {

    // This selects the main 'compile' task for the current project.
    //   The value produced by 'compile' is of type inc.Analysis,
    //   which contains information about the compiled code.
    val taskKey = Compile / Keys.compile

    // Evaluate the task
    // None if the key is not defined
    // Some(Inc) if the task does not complete successfully (Inc for incomplete)
    // Some(Value(v)) with the resulting value
    val result: Option[(State, Result[inc.Analysis])] = Project.runTask(taskKey, state)
    // handle the result
    result match
    {
        case None =&gt; // Key wasn't defined.
        case Some((newState, Inc(inc))) =&gt; // error detail, inc is of type Incomplete, use Incomplete.show(inc.tpe) to get an error message
        case Some((newState, Value(v))) =&gt; // do something with v: inc.Analysis
    }
}
</code></pre><p>For getting the test classpath of a specific project, use this key:
</p><pre><code class="prettyprint lang-scala">val projectRef: ProjectRef = ...
val taskKey: Task[Seq[Attributed[File]]] =
  (projectRef / Test / Keys.fullClasspath)
</code></pre><h3 id="Using+State+in+a+task">Using State in a task<a href="#Using+State+in+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To access the current State from a task, use the <code>state</code> task as an
input. For example,
</p><pre><code class="prettyprint lang-scala">myTask := ... state.value ...
</code></pre><h3 id="Updating+State+in+a+task">Updating State in a task<a href="#Updating+State+in+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It is also possible to update the sbt state in a task. To do this, the
task must return type <code>StateTransform</code>. The state will be transformed upon
completion of task evaluation. The <code>StateTransform</code> is constructed with
a function from <code>State =&gt; State</code> that accepts the previous value of the <code>State</code>
and generates a new state. For example:
</p><pre><code class="prettyprint lang-scala">import complete.DefaultParsers._
val counter = AttributeKey[Int](&quot;counter&quot;)
val setCounter = inputKey[StateTransform](&quot;Set the value of the counter attribute&quot;)
setCounter := {
  val count = (Space ~&gt; IntBasic).parsed
  StateTransform(_.put(counter, count))
}
</code></pre><p>creates the input task <code>setCounter</code> that sets the counter attribute to some
value.
</p><h2 id="Tasks%2FSettings%3A+Motivation">Tasks/Settings: Motivation<a href="#Tasks%2FSettings%3A+Motivation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page motivates the task and settings system. You should already
know how to use tasks and settings, which are described in the
<a href="Task-Graph.html">getting started guide</a> and on
the <a href="Tasks.html">Tasks</a> page.
</p><p>An important aspect of the task system is to combine two common, related
steps in a build:
</p><ol><li>Ensure some other task is performed.
</li><li>Use some result from that task.
</li></ol><p>Earlier versions of sbt configured these steps separately using
</p><ol><li>Dependency declarations
</li><li>Some form of shared state
</li></ol><p>To see why it is advantageous to combine them, compare the situation to
that of deferring initialization of a variable in Scala. This Scala code
is a bad way to expose a value whose initialization is deferred:
</p><pre><code class="prettyprint lang-scala">// Define a variable that will be initialized at some point
// We don't want to do it right away, because it might be expensive
var foo: Foo = _

// Define a function to initialize the variable
def makeFoo(): Unit = ... initialize foo ...
</code></pre><p>Typical usage would be:
</p><pre><code class="prettyprint lang-scala">makeFoo()
doSomething(foo)
</code></pre><p>This example is rather exaggerated in its badness, but I claim it is
nearly the same situation as our two step task definitions. Particular
reasons this is bad include:
</p><ol><li>A client needs to know to call <code>makeFoo()</code> first.
</li><li><code>foo</code> could be changed by other code. There could be a
def makeFoo2(), for example.
</li><li>Access to foo is not thread safe.
</li></ol><p>The first point is like declaring a task dependency, the second is like
two tasks modifying the same state (either project variables or files),
and the third is a consequence of unsynchronized, shared state.
</p><p>In Scala, we have the built-in functionality to easily fix this:
<code>lazy val</code>.
</p><pre><code class="prettyprint lang-scala">lazy val foo: Foo = ... initialize foo ...
</code></pre><p>with the example usage:
</p><pre><code class="prettyprint lang-scala">doSomething(foo)
</code></pre><p>Here, <code>lazy val</code> gives us thread safety, guaranteed initialization
before access, and immutability all in one, DRY construct. The task
system in sbt does the same thing for tasks (and more, but we won’t go
into that here) that <code>lazy val</code> did for our bad example.
</p><p>A task definition must declare its inputs and the type of its output.
sbt will ensure that the input tasks have run and will then provide
their results to the function that implements the task, which will
generate its own result. Other tasks can use this result and be assured
that the task has run (once) and be thread-safe and typesafe in the
process.
</p><p>The general form of a task definition looks like:
</p><pre><code class="prettyprint lang-scala">myTask := {
  val a: A = aTask.value
  val b: B = bTask.value
  ... do something with a, b and generate a result ...
}
</code></pre><p>(This is only intended to be a discussion of the ideas behind tasks, so
see the <a href="Tasks.html">sbt Tasks</a> page for details on usage.)
Here, <code>aTask</code> is assumed to produce a result of type <code>A</code> and <code>bTask</code> is
assumed to produce a result of type <code>B</code>.
</p><h3 id="Application">Application<a href="#Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As an example, consider generating a zip file containing the binary jar,
source jar, and documentation jar for your project. First, determine
what tasks produce the jars. In this case, the input tasks are
<code>packageBin</code>, <code>packageSrc</code>, and <code>packageDoc</code> in the main <code>Compile</code>
scope. The result of each of these tasks is the File for the jar that
they generated. Our zip file task is defined by mapping these package
tasks and including their outputs in a zip file. As good practice, we
then return the File for this zip so that other tasks can map on the zip
task.
</p><pre><code class="prettyprint lang-scala">zip := {
    val bin: File = (Compile / packageBin).value
    val src: File = (Compile / packageSrc).value
    val doc: File = (Compile / packageDoc).value
    val out: File = zipPath.value
    val inputs: Seq[(File,String)] = Seq(bin, src, doc) x Path.flat
    IO.zip(inputs, out)
    out
}
</code></pre><p>The <code>val inputs</code> line defines how the input files are mapped to paths in
the zip. See <a href="Mapping-Files.html">Mapping Files</a> for details. The explicit
types are not required, but are included for clarity.
</p><p>The <code>zipPath</code> input would be a custom task to define the location of the
zip file. For example:
</p><pre><code class="prettyprint lang-scala">zipPath := target.value / &quot;out.zip&quot;
</code></pre><h2 id="Plugins+and+Best+Practices">Plugins and Best Practices<a href="#Plugins+and+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the 
<a href="Getting-Started.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="General+Best+Practices">General Best Practices<a href="#General+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes best practices for working with sbt.
</p><h3 id="vs."><code>project/</code> vs. <code>~/.sbt/</code><a href="#vs." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Anything that is necessary for building the project should go in
<code>project/</code>. This includes things like the web plugin. <code>~/.sbt/</code> should
contain local customizations and commands for working with a build, but
are not necessary. An example is an IDE plugin.
</p><h3 id="Local+settings">Local settings<a href="#Local+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two options for settings that are specific to a user. An
example of such a setting is inserting the local Maven repository at the
beginning of the resolvers list:
</p><pre><code class="prettyprint lang-scala">resolvers := {
  val localMaven = &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
  localMaven +: resolvers.value
}
</code></pre><ol><li>Put settings specific to a user in a global <code>.sbt</code> file, such as
<code>$HOME/.sbt/1.0/global.sbt</code>. These settings will be applied to all projects.
</li><li>Put settings in a <code>.sbt</code> file in a project that isn’t checked into
version control, such as <code>&lt;project&gt;/local.sbt</code>. sbt combines the
settings from multiple .sbt files, so you can still have the
standard <code>&lt;project&gt;/build.sbt</code> and check that into version control.
</li></ol><h3 id=".sbtrc">.sbtrc<a href="#.sbtrc" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Put commands to be executed when sbt starts up in a <code>.sbtrc</code> file, one
per line. These commands run before a project is loaded and are useful
for defining aliases, for example. sbt executes commands in
<code>$HOME/.sbtrc</code> (if it exists) and then <code>&lt;project&gt;/.sbtrc</code> (if it
exists).
</p><h3 id="Generated+files">Generated files<a href="#Generated+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Write any generated files to a subdirectory of the output directory,
which is specified by the <code>target</code> setting. This makes it easy to clean
up after a build and provides a single location to organize generated
files. Any generated files that are specific to a Scala version should
go in <code>crossTarget</code> for efficient cross-building.
</p><p>For generating sources and resources, see <a href="Howto-Generating-Files.html">Generating Files</a>.
</p><h3 id="Don%E2%80%99t+hard+code">Don’t hard code<a href="#Don%E2%80%99t+hard+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Don’t hard code constants, like the output directory <code>target/</code>. This is
especially important for plugins. A user might change the <code>target</code>
setting to point to <code>build/</code>, for example, and the plugin needs to
respect that. Instead, use the setting, like:
</p><pre><code class="prettyprint lang-scala">myDirectory := target.value / &quot;sub-directory&quot;
</code></pre><h3 id="Don%E2%80%99t+%E2%80%9Cmutate%E2%80%9D+files">Don’t “mutate” files<a href="#Don%E2%80%99t+%E2%80%9Cmutate%E2%80%9D+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A build naturally consists of a lot of file manipulation. How can we
reconcile this with the task system, which otherwise helps us avoid
mutable state? One approach, which is the recommended approach and the
approach used by sbt’s default tasks, is to only write to any given file
once and only from a single task.
</p><p>A build product (or by-product) should be written exactly once by only
one task. The task should then, at a minimum, provide the Files created
as its result. Another task that wants to use Files should map the task,
simultaneously obtaining the File reference and ensuring that the task
has run (and thus the file is constructed). Obviously you cannot do much
about the user or other processes modifying the files, but you can make
the I/O that is under the build’s control more predictable by treating
file contents as immutable at the level of Tasks.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">lazy val makeFile = taskKey[File](&quot;Creates a file with some content.&quot;)

// define a task that creates a file,
//  writes some content, and returns the File
makeFile := {
    val f: File = file(&quot;/tmp/data.txt&quot;)
    IO.write(f, &quot;Some content&quot;)
    f
}

// The result of makeFile is the constructed File,
//   so useFile can map makeFile and simultaneously
//   get the File and declare the dependency on makeFile
useFile :=
    doSomething( makeFile.value )
</code></pre><p>This arrangement is not always possible, but it should be the rule and
not the exception.
</p><h3 id="Use+absolute+paths">Use absolute paths<a href="#Use+absolute+paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Construct only absolute Files. Either specify an absolute path
</p><pre><code class="prettyprint lang-scala">file(&quot;/home/user/A.scala&quot;)
</code></pre><p>or construct the file from an absolute base:
</p><pre><code class="prettyprint lang-scala">base / &quot;A.scala&quot;
</code></pre><p>This is related to the no hard coding best practice because the proper
way involves referencing the <code>baseDirectory</code> setting. For example, the
following defines the myPath setting to be the <code>&lt;base&gt;/licenses/</code>
directory.
</p><pre><code class="prettyprint lang-scala">myPath := baseDirectory.value / &quot;licenses&quot;
</code></pre><p>In Java (and thus in Scala), a relative File is relative to the current
working directory. The working directory is not always the same as the
build root directory for a number of reasons.
</p><p>The only exception to this rule is when specifying the base directory
for a Project. Here, sbt will resolve a relative File against the build
root directory for you for convenience.
</p><h3 id="Parser+combinators">Parser combinators<a href="#Parser+combinators" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Use <code>token</code> everywhere to clearly delimit tab completion boundaries.
</li><li>Don’t overlap or nest tokens. The behavior here is unspecified and
will likely generate an error in the future.
</li><li>Use <code>flatMap</code> for general recursion. sbt’s combinators are strict to
limit the number of classes generated, so use flatMap like:
</li></ol><pre><code class="prettyprint lang-scala">lazy val parser: Parser[Int] =
  token(IntBasic) flatMap { i =&gt;
    if(i &lt;= 0)
      success(i)
    else
      token(Space ~&gt; parser)
  }
</code></pre><blockquote><p>This example defines a parser a whitespace-delimited list of integers,
ending with a negative number, and returning that final, negative
number.
</p></blockquote><h2 id="Plugins">Plugins<a href="#Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There’s a <a href="Using-Plugins.html">getting started page</a> focused on using existing plugins,
which you may want to read first.
</p><p>A plugin is a way to use external code in a build definition.
A plugin can be a library used to implement a task (you might use
<a href="https://github.com/tristanjuricek/knockoff/">Knockoff</a> to write a
markdown processing task). A plugin can define a sequence of sbt settings
that are automatically added to all projects or that are explicitly
declared for selected projects. For example, a plugin might add a
<code>proguard</code> task and associated (overridable) settings. Finally, a plugin
can define new commands (via the <code>commands</code> setting).
</p><p>sbt 0.13.5 introduces auto plugins, with improved dependency management
among the plugins and explicitly scoped auto importing.
Going forward, our recommendation is to migrate to the auto plugins.
The <a href="Plugins-Best-Practices.html">Plugins Best Practices</a> page describes
the currently evolving guidelines to writing sbt plugins. See also the general
<a href="Best-Practices.html">best practices</a>.
</p><h3 id="Using+an+auto+plugin">Using an auto plugin<a href="#Using+an+auto+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common situation is when using a binary plugin published to a repository.
You can create <code>project/plugins.sbt</code> with all of the desired sbt plugins, any general dependencies, and any necessary repositories:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.example&quot; % &quot;plugin&quot; % &quot;1.0&quot;)
addSbtPlugin(&quot;org.example&quot; % &quot;another-plugin&quot; % &quot;2.0&quot;)

// plain library (not an sbt plugin) for use in the build definition
libraryDependencies += &quot;org.example&quot; % &quot;utilities&quot; % &quot;1.3&quot;

resolvers += &quot;Example Plugin Repository&quot; at &quot;https://example.org/repo/&quot;
</code></pre><p>Many of the auto plugins automatically add settings into projects,
however, some may require explicit enablement. Here’s an example:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))
  .enablePlugins(FooPlugin, BarPlugin)
  .disablePlugins(plugins.IvyPlugin)
  .settings(
    name := &quot;hello-util&quot;
  )
</code></pre><p>See <a href="Using-Plugins.html">using plugins</a> in the Getting Started guide for more details on using plugins.
</p><h3 id="By+Description">By Description<a href="#By+Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin definition is a project under <code>project/</code> folder. This
project’s classpath is the classpath used for build definitions in
<code>project/</code> and any <code>.sbt</code> files in the project’s base
directory. It is also used for the <code>eval</code> and <code>set</code> commands.
</p><p>Specifically,
</p><ol><li>Managed dependencies declared by the <code>project/</code> project are
retrieved and are available on the build definition classpath, just
like for a normal project.
</li><li>Unmanaged dependencies in <code>project/lib/</code> are available to the build
definition, just like for a normal project.
</li><li>Sources in the <code>project/</code> project are the build definition files and
are compiled using the classpath built from the managed and
unmanaged dependencies.
</li><li>Project dependencies can be declared in <code>project/plugins.sbt</code>
(similarly to <code>build.sbt</code> file in a normal project) and will be available to the build
definitions.
</li></ol><p>The build definition classpath is searched for <code>sbt/sbt.autoplugins</code>
descriptor files containing the names of
<code>sbt.AutoPlugin</code> implementations.
</p><p>The <code>reload plugins</code> command changes the current build to
the (root) project’s <code>project/</code> build definition. This allows manipulating
the build definition project like a normal project. <code>reload return</code> changes back
to the original build. Any session settings for the plugin definition
project that have not been saved are dropped.
</p><p>An auto plugin is a module that defines settings to automatically inject into
projects. In addition an auto plugin provides the following feature:
</p><ul><li>Automatically import selective names to <code>.sbt</code> files and the <code>eval</code> and <code>set</code> commands.
</li><li>Specify plugin dependencies to other auto plugins.
</li><li>Automatically activate itself when all dependencies are present.
</li><li>Specify <code>projectSettings</code>, <code>buildSettings</code>, and <code>globalSettings</code> as appropriate.
</li></ul><h3 id="Plugin+dependencies">Plugin dependencies<a href="#Plugin+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When a traditional plugin wanted to reuse some functionality from an existing plugin, it would pull in the plugin as a library dependency, and then it would either:
</p><ol><li>add the setting sequence from the dependency as part of its own setting sequence, or
</li><li>tell the build users to include them in the right order.
</li></ol><p>This becomes complicated as the number of plugins increase within an application, and becomes more error prone. The main goal of auto plugin is to alleviate this setting dependency problem. An auto plugin can depend on other auto plugins and ensure these dependency settings are loaded first.
</p><p>Suppose we have the <code>SbtLessPlugin</code> and the <code>SbtCoffeeScriptPlugin</code>, which in turn depends on the <code>SbtJsTaskPlugin</code>, <code>SbtWebPlugin</code>, and <code>JvmPlugin</code>. Instead of manually activating all of these plugins, a project can just activate the <code>SbtLessPlugin</code> and <code>SbtCoffeeScriptPlugin</code> like this:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtLessPlugin, SbtCoffeeScriptPlugin)
</code></pre><p>This will pull in the right setting sequence from the plugins in the right order.  The key notion here is you declare the plugins you want, and sbt can fill in the gap.
</p><p>A plugin implementation is not required to produce an auto plugin, however.
It is a convenience for plugin consumers and because of the automatic nature, it is not always appropriate.
</p><h4 id="Global+plugins">Global plugins<a href="#Global+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>$HOME/.sbt/1.0/plugins/</code> directory is treated as a global plugin
definition project. It is a normal sbt project whose classpath is
available to all sbt project definitions for that user as described
above for per-project plugins.
</p><h3 id="Creating+an+auto+plugin">Creating an auto plugin<a href="#Creating+an+auto+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A minimal sbt plugin is a Scala library that is built against the version of
Scala that sbt runs (currently, 2.12.13) or a Java library.
Nothing special needs to be done for this type of library.
A more typical plugin will provide sbt tasks, commands, or settings.
This kind of plugin may provide these settings
automatically or make them available for the user to explicitly
integrate.
</p><p>To make an auto plugin, create a project and enable <code>SbtPlugin</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / organization := &quot;com.example&quot;
ThisBuild / homepage := Some(url(&quot;https://github.com/sbt/sbt-hello&quot;))

lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
  .settings(
    name := &quot;sbt-hello&quot;,
    pluginCrossBuild / sbtVersion := {
      scalaBinaryVersion.value match {
        case &quot;2.12&quot; =&gt; &quot;1.2.8&quot; // set minimum sbt version
      }
    }
  )
</code></pre><p>Some details to note:
- sbt plugins must be compiled with Scala 2.12.x that sbt itself is compiled in. By NOT specifying <code>scalaVersion</code>, sbt will default to the Scala version suited for a plugin.
- By default sbt plugin is compiled with whichever the sbt version you are using. Because sbt does NOT keep forward compatibility, that would typically require all of your plugin users to upgrade to the latest too. <code>pluginCrossBuild / sbtVersion</code> is an optional setting to compile your plugin against an <em>older</em> version of sbt, which allows the plugin users to choose from a range of sbt versions.
</p><p>Then, write the plugin code and publish your project to a repository.
The plugin can be used as described in the previous section.
</p><p>First, in an appropriate namespace, define your auto plugin object
by extending <code>sbt.AutoPlugin</code>.
</p><h4 id="projectSettings+and+buildSettings">projectSettings and buildSettings<a href="#projectSettings+and+buildSettings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>With auto plugins, all provided settings (e.g. <code>assemblySettings</code>) are provided by the plugin directly via the <code>projectSettings</code> method. Here’s an example plugin that adds a task named hello to sbt projects:
</p><pre><code class="prettyprint lang-scala">package sbthello

import sbt._
import Keys._

object HelloPlugin extends AutoPlugin {
  override def trigger = allRequirements

  object autoImport {
    val helloGreeting = settingKey[String](&quot;greeting&quot;)
    val hello = taskKey[Unit](&quot;say hello&quot;)
  }

  import autoImport._
  override lazy val globalSettings: Seq[Setting[_]] = Seq(
    helloGreeting := &quot;hi&quot;,
  )

  override lazy val projectSettings: Seq[Setting[_]] = Seq(
    hello := {
      val s = streams.value
      val g = helloGreeting.value
      s.log.info(g)
    }
  )
}
</code></pre><p>If the plugin needs to append settings at the build-level (that is, in <code>ThisBuild</code>) there’s a <code>buildSettings</code> method. The settings returned here are guaranteed to be added to a given build scope only once
regardless of how many projects for that build activate this AutoPlugin.
</p><pre><code class="prettyprint lang-scala">override def buildSettings: Seq[Setting[_]] = Nil
</code></pre><p>The <code>globalSettings</code> is appended once to the global settings (<code>in Global</code>).
These allow a plugin to automatically provide new functionality or new defaults. 
One main use of this feature is to globally add commands, such as for IDE plugins.
</p><pre><code class="prettyprint lang-scala">override def globalSettings: Seq[Setting[_]] = Nil
</code></pre><p>Use <code>globalSettings</code> to define the default value of a setting.
</p><h4 id="Implementing+plugin+dependencies">Implementing plugin dependencies<a href="#Implementing+plugin+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Next step is to define the plugin dependencies.
</p><pre><code class="prettyprint lang-scala">package sbtless

import sbt._
import Keys._
object SbtLessPlugin extends AutoPlugin {
  override def requires = SbtJsTaskPlugin
  override lazy val projectSettings = ...
}
</code></pre><p>The <code>requires</code> method returns a value of type <code>Plugins</code>, which is a DSL for constructing the dependency list. The requires method typically contains one of the following values:
</p><ul><li><code>empty</code> (No plugins)
</li><li>other auto plugins
</li><li><code>&amp;&amp;</code> operator (for defining multiple dependencies)
</li></ul><h4 id="Root+plugins+and+triggered+plugins">Root plugins and triggered plugins<a href="#Root+plugins+and+triggered+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some plugins should always be explicitly enabled on projects. we call
these root plugins, i.e. plugins that are “root” nodes in the plugin
dependency graph. An auto plugin is by default a root plugin.
</p><p>Auto plugins also provide a way for plugins to automatically attach themselves to
projects if their dependencies are met. We call these triggered plugins,
and they are created by overriding the <code>trigger</code> method.
</p><p>For example, we might want to create a triggered plugin that can append commands automatically to the build. To do this, set the <code>requires</code> method to return <code>empty</code>, and override the <code>trigger</code> method with <code>allRequirements</code>.
</p><pre><code class="prettyprint lang-scala">package sbthello

import sbt._
import Keys._

object HelloPlugin2 extends AutoPlugin {
  override def trigger = allRequirements
  override lazy val buildSettings = Seq(commands += helloCommand)
  lazy val helloCommand =
    Command.command(&quot;hello&quot;) { (state: State) =&gt;
      println(&quot;Hi!&quot;)
      state
    }
}
</code></pre><p>The build user still needs to include this plugin in <code>project/plugins.sbt</code>, but it is no longer needed to be included in <code>build.sbt</code>. This becomes more interesting when you do specify a plugin with requirements. Let’s modify the <code>SbtLessPlugin</code> so that it depends on another plugin:
</p><pre><code class="prettyprint lang-scala">package sbtless
import sbt._
import Keys._
object SbtLessPlugin extends AutoPlugin {
  override def trigger = allRequirements
  override def requires = SbtJsTaskPlugin
  override lazy val projectSettings = ...
}
</code></pre><p>As it turns out, <code>PlayScala</code> plugin (in case you didn’t know, the Play framework is an sbt plugin) lists <code>SbtJsTaskPlugin</code> as one of its required plugins. So, if we define a <code>build.sbt</code> with:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(PlayScala)
</code></pre><p>then the setting sequence from <code>SbtLessPlugin</code> will be automatically appended somewhere after the settings from <code>PlayScala</code>.
</p><p>This allows plugins to silently, and correctly, extend existing plugins with more features.  It also can help remove the burden of ordering from the user, allowing the plugin authors greater freedom and power when providing feature for their users.
</p><h4 id="Controlling+the+import+with+autoImport">Controlling the import with autoImport<a href="#Controlling+the+import+with+autoImport" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When an auto plugin provides a stable field such as <code>val</code> or <code>object</code>
named <code>autoImport</code>, the contents of the field are wildcard imported
in <code>set</code>, <code>eval</code>, and <code>.sbt</code> files. In the next example, we’ll replace
our hello command with a task to get the value of <code>greeting</code> easily.
In practice, it’s recommended <a href="Plugins-Best-Practices.html#Use+settings+and+tasks.+Avoid+commands.">to prefer settings or tasks to commands</a>.
</p><pre><code class="prettyprint lang-scala">package sbthello

import sbt._
import Keys._

object HelloPlugin3 extends AutoPlugin {
  object autoImport {
    val greeting = settingKey[String](&quot;greeting&quot;)
    val hello = taskKey[Unit](&quot;say hello&quot;)
  }
  import autoImport._
  override def trigger = allRequirements
  override lazy val buildSettings = Seq(
    greeting := &quot;Hi!&quot;,
    hello := helloTask.value)
  lazy val helloTask =
    Def.task {
      println(greeting.value)
    }
}
</code></pre><p>Typically, <code>autoImport</code> is used to provide new keys - <code>SettingKey</code>s, <code>TaskKey</code>s,
or <code>InputKey</code>s - or core methods without requiring an import or qualification.
</p><h4 id="Example+Plugin">Example Plugin<a href="#Example+Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An example of a typical plugin:
</p><p><code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / organization := &quot;com.example&quot;
ThisBuild / homepage := Some(url(&quot;https://github.com/sbt/sbt-obfuscate&quot;))

lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
  .settings(
    name := &quot;sbt-obfuscate&quot;,
    pluginCrossBuild / sbtVersion := {
      scalaBinaryVersion.value match {
        case &quot;2.12&quot; =&gt; &quot;1.2.8&quot; // set minimum sbt version
      }
    }
  )
</code></pre><p><code>ObfuscatePlugin.scala</code>:
</p><pre><code class="prettyprint lang-scala">package sbtobfuscate

import sbt._
import sbt.Keys._

object ObfuscatePlugin extends AutoPlugin {
  // by defining autoImport, the settings are automatically imported into user's `*.sbt`
  object autoImport {
    // configuration points, like the built-in `version`, `libraryDependencies`, or `compile`
    val obfuscate = taskKey[Seq[File]](&quot;Obfuscates files.&quot;)
    val obfuscateLiterals = settingKey[Boolean](&quot;Obfuscate literals.&quot;)

    // default values for the tasks and settings
    lazy val baseObfuscateSettings: Seq[Def.Setting[_]] = Seq(
      obfuscate := {
        Obfuscate(sources.value, (obfuscateLiterals in obfuscate).value)
      },
      obfuscateLiterals in obfuscate := false
    )
  }

  import autoImport._
  override def requires = sbt.plugins.JvmPlugin

  // This plugin is automatically enabled for projects which are JvmPlugin.
  override def trigger = allRequirements

  // a group of settings that are automatically added to projects.
  override val projectSettings =
    inConfig(Compile)(baseObfuscateSettings) ++
    inConfig(Test)(baseObfuscateSettings)
}

object Obfuscate {
  def apply(sources: Seq[File], obfuscateLiterals: Boolean): Seq[File] = {
    // TODO obfuscate stuff!
    sources
  }
}
</code></pre><h4 id="Usage+example">Usage example<a href="#Usage+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A build definition that uses the plugin might look like. <code>obfuscate.sbt</code>:
</p><pre><code class="prettyprint lang-scala">obfuscateLiterals in obfuscate := true
</code></pre><h4 id="Global+plugins+example">Global plugins example<a href="#Global+plugins+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The simplest global plugin definition is declaring a library or plugin
in <code>$HOME/.sbt/1.0/plugins/build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.example&quot; %% &quot;example-plugin&quot; % &quot;0.1&quot;
</code></pre><p>This plugin will be available for every sbt project for the current
user.
</p><p>In addition:
</p><ul><li>Jars may be placed directly in <code>$HOME/.sbt/1.0/plugins/lib/</code>
and will be available to every build definition for the current user.
</li><li>Dependencies on plugins built from source may be declared in
<code>$HOME/.sbt/1.0/plugins/project/Build.scala</code> as described at
<a href="Full-Def.html">.scala build definition</a>.
</li><li>A Plugin may be directly defined in Scala
source files in <code>$HOME/.sbt/1.0/plugins/</code>, such as
<code>$HOME/.sbt/1.0/plugins/MyPlugin.scala</code>.
<code>$HOME/.sbt/1.0/plugins//build.sbt</code>
should contain <code>sbtPlugin := true</code>. This can be used for quicker
turnaround when developing a plugin initially:
</li></ul><ol><li>Edit the global plugin code
</li><li><code>reload</code> the project you want to use the modified plugin in
</li><li><p>sbt will rebuild the plugin and use it for the project.
</p><p>   Additionally, the plugin will be available in other projects on
   the machine without recompiling again. This approach skips the
   overhead of <code>publishLocal</code> and <code>clean</code>ing the plugins directory of the
   project using the plugin.
</p></li></ol><p>These are all consequences of <code>$HOME/.sbt/1.0/plugins/</code> being a standard
project whose classpath is added to every sbt project’s build
definition.
</p><h3 id="Using+a+library+in+a+build+definition+example">Using a library in a build definition example<a href="#Using+a+library+in+a+build+definition+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As an example, we’ll add the Grizzled Scala library as a plugin.
Although this does not provide sbt-specific functionality, it
demonstrates how to declare plugins.
</p><h4 id="1a%29+Manually+managed">1a) Manually managed<a href="#1a%29+Manually+managed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ol><li>Download the jar manually from
<a href="https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala_2.8.1/1.0.4/grizzled-scala_2.8.1-1.0.4.jar">https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala<em>2.8.1/1.0.4/grizzled-scala</em>2.8.1-1.0.4.jar</a>
</li><li>Put it in <code>project/lib/</code>
</li></ol><h4 id="1b%29+Automatically+managed%3A+direct+editing+approach">1b) Automatically managed: direct editing approach<a href="#1b%29+Automatically+managed%3A+direct+editing+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Edit <code>project/plugins.sbt</code> to contain:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
</code></pre><p>If sbt is running, do <code>reload</code>.
</p><h4 id="1c%29+Automatically+managed%3A+command-line+approach">1c) Automatically managed: command-line approach<a href="#1c%29+Automatically+managed%3A+command-line+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>We can change to the plugins project in <code>project/</code> using
<code>reload plugins</code>.
</p><pre><code class="">$ sbt
&gt; reload plugins
[info] Set current project to default (in build file:/Users/sbt/demo2/project/)
&gt;
</code></pre><p>Then, we can add dependencies like usual and save them to
<code>project/plugins.sbt</code>. It is useful, but not required, to run <code>update</code>
to verify that the dependencies are correct.
</p><pre><code class="">&gt; set libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
...
&gt; update
...
&gt; session save
...
</code></pre><p>To switch back to the main project use <code>reload return</code>:
</p><pre><code class="">&gt; reload return
[info] Set current project to root (in build file:/Users/sbt/demo2/)
</code></pre><h4 id="1d%29+Project+dependency">1d) Project dependency<a href="#1d%29+Project+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This variant shows how to use sbt’s external project support to declare
a source dependency on a plugin. This means that the plugin will be
built from source and used on the classpath.
</p><p>Edit <code>project/plugins.sbt</code>
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;)).dependsOn(assemblyPlugin)

lazy val assemblyPlugin = RootProject(uri(&quot;git://github.com/sbt/sbt-assembly&quot;))
</code></pre><p>If sbt is running, run <code>reload</code>.
</p><p>Note that this approach can be useful when developing a plugin. A
project that uses the plugin will rebuild the plugin on <code>reload</code>. This
saves the intermediate steps of <code>publishLocal</code> and <code>update</code>. It can also
be used to work with the development version of a plugin from its
repository.
</p><p>It is however recommended to explicitly specify the commit or tag by appending
it to the repository as a fragment:
</p><pre><code class="prettyprint lang-scala">lazy val assemblyPlugin = uri(&quot;git://github.com/sbt/sbt-assembly#0.9.1&quot;)
</code></pre><p>One caveat to using this method is that the local sbt will try to run
the remote plugin’s build. It is quite possible that the plugin’s own
build uses a different sbt version, as many plugins cross-publish for
several sbt versions. As such, it is recommended to stick with binary
artifacts when possible.
</p><h4 id="2%29+Use+the+library">2) Use the library<a href="#2%29+Use+the+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Grizzled Scala is ready to be used in build definitions. This includes
the <code>eval</code> and <code>set</code> commands and <code>.sbt</code> and <code>project/*.scala</code> files.
</p><pre><code class="">&gt; eval grizzled.sys.os
</code></pre><p>In a <code>build.sbt</code> file:
</p><pre><code class="prettyprint lang-scala">import grizzled.sys._
import OperatingSystem._

libraryDependencies ++=
    if(os == Windows)
        Seq(&quot;org.example&quot; % &quot;windows-only&quot; % &quot;1.0&quot;)
    else
        Seq.empty
</code></pre><h3 id="Best+Practices">Best Practices<a href="#Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re a plugin writer, please consult the <a href="Plugins-Best-Practices.html">Plugins Best Practices</a>
page; it contains a set of guidelines to help you ensure that your
plugin is consistent and plays well with other plugins.
</p><p>For cross building sbt plugins see also <a href="Cross-Build-Plugins.html">Cross building plugins</a>.
</p><h2 id="Plugins+Best+Practices">Plugins Best Practices<a href="#Plugins+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><em>This page is intended primarily for sbt plugin authors.</em>
This page assumes you’ve read <a href="Using-Plugins.html">using plugins</a> and <a href="Plugins.html">Plugins</a>.
</p><p>A plugin developer should strive for consistency and ease of use.
Specifically:
</p><ul><li>Plugins should play well with other plugins. Avoiding namespace
clashes (in both sbt and Scala) is paramount.
</li><li>Plugins should follow consistent conventions. The experiences of an
sbt <em>user</em> should be consistent, no matter what plugins are pulled
in.
</li></ul><p>Here are some current plugin best practices.
</p><blockquote><p><strong>Note:</strong> Best practices are evolving, so check back frequently.
</p></blockquote><h3 id="Key+naming+convention%3A+Use+prefix">Key naming convention: Use prefix<a href="#Key+naming+convention%3A+Use+prefix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes, you need a new key, because there is no existing sbt key. In
this case, use a plugin-specific prefix.
</p><pre><code class="prettyprint lang-scala">package sbtassembly

import sbt._, Keys._

object AssemblyPlugin extends AutoPlugin {
  object autoImport {
    val assembly                  = taskKey[File](&quot;Builds a deployable fat jar.&quot;)
    val assembleArtifact          = settingKey[Boolean](&quot;Enables (true) or disables (false) assembling an artifact.&quot;)
    val assemblyOption            = taskKey[AssemblyOption](&quot;Configuration for making a deployable fat jar.&quot;)
    val assembledMappings         = taskKey[Seq[MappingSet]](&quot;Keeps track of jar origins for each source.&quot;)

    val assemblyPackageScala      = taskKey[File](&quot;Produces the scala artifact.&quot;)
    val assemblyJarName           = taskKey[String](&quot;name of the fat jar&quot;)
    val assemblyMergeStrategy     = settingKey[String =&gt; MergeStrategy](&quot;mapping from archive member path to merge strategy&quot;)
  }

  import autoImport._

  ....
}
</code></pre><p>In this approach, every <code>val</code> starts with <code>assembly</code>. A user of the
plugin would refer to the settings like this in <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">assembly / assemblyJarName := &quot;something.jar&quot;
</code></pre><p>Inside sbt shell, the user can refer to the setting in the same way:
</p><pre><code class="">sbt:helloworld&gt; show assembly/assemblyJarName
[info] helloworld-assembly-0.1.0-SNAPSHOT.jar
</code></pre><p>Avoid sbt 0.12 style key names where the key’s Scala identifier and shell uses kebab-casing:
</p><ul><li>BAD: <code>val jarName = SettingKey[String](&quot;assembly-jar-name&quot;)</code>
</li><li>BAD: <code>val jarName = SettingKey[String](&quot;jar-name&quot;)</code>
</li><li>GOOD: <code>val assemblyJarName = taskKey[String](&quot;name of the fat jar&quot;)</code>
</li></ul><p>Because there’s a single namespace for keys both in <code>build.sbt</code> and in sbt shell,
if different plugins use generic sounding key names like <code>jarName</code> and <code>excludedFiles</code> they will cause name conflict.
</p><h3 id="Artifact+naming+convention">Artifact naming convention<a href="#Artifact+naming+convention" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Use the <code>sbt-$projectname</code> scheme to name your library and artifact.
A plugin ecosystem with a consistent naming convention makes it easier for users to tell whether a
project or dependency is an SBT plugin.
</p><p>If the project’s name is <code>foobar</code> the following holds:
</p><ul><li>BAD: <code>foobar</code>
</li><li>BAD: <code>foobar-sbt</code>
</li><li>BAD: <code>sbt-foobar-plugin</code>
</li><li>GOOD: <code>sbt-foobar</code>
</li></ul><p>If your plugin provides an obvious “main” task, consider naming it <code>foobar</code> or <code>foobar...</code> to make
it more intuitive to explore the capabilities of your plugin within the sbt shell and tab-completion.
</p><h3 id="%28optional%29+Plugin+naming+convention">(optional) Plugin naming convention<a href="#%28optional%29+Plugin+naming+convention" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Name your plugin as <code>FooBarPlugin</code>.
</p><h3 id="Don%E2%80%99t+use+default+package">Don’t use default package<a href="#Don%E2%80%99t+use+default+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Users who have their build files in some package will not be able to use
your plugin if it’s defined in default (no-name) package.
</p><h3 id="Get+your+plugins+known">Get your plugins known<a href="#Get+your+plugins+known" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Make sure people can find your plugin. Here are some of the recommended steps:
</p><ol><li>Mention <a href="https://twitter.com/scala_sbt">@scala_sbt</a> in your announcement, and we will RT it.
</li><li>Send a pull request to <a href="https://github.com/sbt/website">sbt/website</a> and add your plugin on <a href="Community-Plugins.html">the plugins list</a>.
</li></ol><h3 id="Reuse+existing+keys">Reuse existing keys<a href="#Reuse+existing+keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt has a number of <a href="../api/sbt/Keys$.html">predefined keys</a>.
Where possible, reuse them in your plugin. For instance, don’t define:
</p><pre><code class="prettyprint lang-scala">val sourceFiles = settingKey[Seq[File]](&quot;Some source files&quot;)
</code></pre><p>Instead, reuse sbt’s existing <code>sources</code> key.
</p><h3 id="Use+settings+and+tasks.+Avoid+commands.">Use settings and tasks. Avoid commands.<a href="#Use+settings+and+tasks.+Avoid+commands." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Your plugin should fit in naturally with the rest of the sbt ecosystem.
The first thing you can do is to avoid defining <a href="Commands.html">commands</a>,
and use settings and <a href="Tasks.html">tasks</a> and task-scoping instead (see below for more on task-scoping).
Most of the interesting things in sbt like
<code>compile</code>, <code>test</code> and <code>publish</code> are provided using tasks.
Tasks can take advantage of duplication reduction and parallel execution by the task engine.
With features like <a href="Tasks.html#ScopeFilter">ScopeFilter</a>, many of the features that previously required
commands are now possible using tasks.
</p><p>Settings can be composed from other settings and tasks.
Tasks can be composed from other tasks and input tasks.
Commands, on the other hand, cannot be composed from any of the above.
In general, use the minimal thing that you need.
One legitimate use of commands may be using plugin to access the build definition itself not the code.
sbt-inspectr was implemented using <a href="https://github.com/eed3si9n/sbt-inspectr/blob/aa88bfac609e4668d0ad8ac220e4ef5fb1c3b9f5/src/main/scala/sbtinspectr/InspectrCommand.scala">a command</a> before it became <code>inspect tree</code>.
</p><h3 id="Provide+core+feature+in+a+plain+old+Scala+object">Provide core feature in a plain old Scala object<a href="#Provide+core+feature+in+a+plain+old+Scala+object" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The core feature of sbt’s <code>package</code> task, for example, is implemented in <a href="../api/sbt/Package$.html">sbt.Package</a>,
which can be called via its <code>apply</code> method.
This allows greater reuse of the feature from other plugins such as sbt-assembly,
which in return implements <code>sbtassembly.Assembly</code> object to implement its core feature.
</p><p>Follow their lead, and provide core feature in a plain old Scala object.
</p><h3 id="Configuration+advice">Configuration advice<a href="#Configuration+advice" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If your plugin introduces either a new set of source code or
its own library dependencies, only then you want your own configuration.
</p><h4 id="You+probably+won%E2%80%99t+need+your+own+configuration">You probably won’t need your own configuration<a href="#You+probably+won%E2%80%99t+need+your+own+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Configurations should <em>not</em> be used to namespace keys for a plugin. 
If you’re merely adding tasks and settings, don’t define your own
configuration. Instead, reuse an existing one <em>or</em> scope by the main
task (see below).
</p><pre><code class="prettyprint lang-scala">package sbtwhatever

import sbt._, Keys._

object WhateverPlugin extends sbt.AutoPlugin {
  override def requires = plugins.JvmPlugin
  override def trigger = allRequirements

  object autoImport {
    // BAD sample
    lazy val Whatever = config(&quot;whatever&quot;) extend(Compile)
    lazy val specificKey = settingKey[String](&quot;A plugin specific key&quot;)
  }
  import autoImport._
  override lazy val projectSettings = Seq(
    specificKey in Whatever := &quot;another opinion&quot; // DON'T DO THIS
  )
}
</code></pre><h4 id="When+to+define+your+own+configuration">When to define your own configuration<a href="#When+to+define+your+own+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If your plugin introduces either a new set of source code or
its own library dependencies, only then you want your own configuration.
For instance, suppose you’ve built a plugin that performs fuzz testing
that requires its own fuzzing library and fuzzing source code.
<code>scalaSource</code> key can be reused similar to <code>Compile</code> and <code>Test</code> configuration,
but <code>scalaSource</code> scoped to <code>Fuzz</code> configuration (denoted as <code>scalaSource in Fuzz</code>)
can point to <code>src/fuzz/scala</code> so it is distinct from other Scala source directories.
Thus, these three definitions use
the same <em>key</em>, but they represent distinct <em>values</em>. So, in a user’s
<code>build.sbt</code>, we might see:
</p><pre><code class="prettyprint lang-scala">Fuzz / scalaSource := baseDirectory.value / &quot;source&quot; / &quot;fuzz&quot; / &quot;scala&quot;

Compile / scalaSource := baseDirectory.value / &quot;source&quot; / &quot;main&quot; / &quot;scala&quot;
</code></pre><p>In the fuzzing plugin, this is achieved with an <code>inConfig</code> definition:
</p><pre><code class="prettyprint lang-scala">package sbtfuzz

import sbt._, Keys._

object FuzzPlugin extends sbt.AutoPlugin {
  override def requires = plugins.JvmPlugin
  override def trigger = allRequirements

  object autoImport {
    lazy val Fuzz = config(&quot;fuzz&quot;) extend(Compile)
  }
  import autoImport._

  lazy val baseFuzzSettings: Seq[Def.Setting[_]] = Seq(
    test := {
      println(&quot;fuzz test&quot;)
    }
  )
  override lazy val projectSettings = inConfig(Fuzz)(baseFuzzSettings)
}
</code></pre><p>When defining a new type of configuration, e.g.
</p><pre><code class="prettyprint lang-scala">lazy val Fuzz = config(&quot;fuzz&quot;) extend(Compile)
</code></pre><p>should be used to create a configuration.
Configurations actually tie into dependency resolution (with Ivy) and
can alter generated pom files.
</p><h4 id="Playing+nice+with+configurations">Playing nice with configurations<a href="#Playing+nice+with+configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Whether you ship with a configuration or not, a plugin should strive to
support multiple configurations, including those created by the build
user. Some tasks that are tied to a particular configuration can be
re-used in other configurations. While you may not see the need
immediately in your plugin, some project may and will ask you for the
flexibility.
</p><h4 id="Provide+raw+settings+and+configured+settings">Provide raw settings and configured settings<a href="#Provide+raw+settings+and+configured+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Split your settings by the configuration axis like so:
</p><pre><code class="prettyprint lang-scala">package sbtobfuscate

import sbt._, Keys._

object ObfuscatePlugin extends sbt.AutoPlugin {
  override def requires = plugins.JvmPlugin
  override def trigger = allRequirements

  object autoImport {
    lazy val obfuscate = taskKey[Seq[File]](&quot;obfuscate the source&quot;)
    lazy val obfuscateStylesheet = settingKey[File](&quot;obfuscate stylesheet&quot;)
  }
  import autoImport._
  lazy val baseObfuscateSettings: Seq[Def.Setting[_]] = Seq(
    obfuscate := Obfuscate((sources in obfuscate).value),
    sources in obfuscate := sources.value
  )
  override lazy val projectSettings = inConfig(Compile)(baseObfuscateSettings)
}

// core feature implemented here
object Obfuscate {
  def apply(sources: Seq[File]): Seq[File] = {
    sources
  }
}
</code></pre><p>The <code>baseObfuscateSettings</code> value provides base configuration for the
plugin’s tasks. This can be re-used in other configurations if projects
require it. The <code>obfuscateSettings</code> value provides the default <code>Compile</code>
scoped settings for projects to use directly. This gives the greatest
flexibility in using features provided by a plugin. Here’s how the raw
settings may be reused:
</p><pre><code class="prettyprint lang-scala">import sbtobfuscate.ObfuscatePlugin

lazy val app = (project in file(&quot;app&quot;))
  .settings(inConfig(Test)(ObfuscatePlugin.baseObfuscateSettings))
</code></pre><h3 id="Scoping+advice">Scoping advice<a href="#Scoping+advice" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In general, if a plugin provides keys (settings and tasks) with the widest scoping,
and refer to them with the narrowest scoping, it will give the maximum flexibility to the build users.
</p><h4 id="Provide+default+values+in">Provide default values in <code>globalSettings</code><a href="#Provide+default+values+in" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If the default value of your settings or task does not transitively depend on a project-level settings
(such as <code>baseDirectory</code>, <code>compile</code>, etc), define it in <code>globalSettings</code>.
</p><p>For example, in <code>sbt.Defaults</code> keys related to publishing such as <code>licenses</code>, <code>developers</code>,
and <code>scmInfo</code> are all defined at the <code>Global</code> scope, typically to empty values like <code>Nil</code> and <code>None</code>.
</p><pre><code class="prettyprint lang-scala">package sbtobfuscate

import sbt._, Keys._

object ObfuscatePlugin extends sbt.AutoPlugin {
  override def requires = plugins.JvmPlugin
  override def trigger = allRequirements

  object autoImport {
    lazy val obfuscate = taskKey[Seq[File]](&quot;obfuscate the source&quot;)
    lazy val obfuscateOption = settingKey[ObfuscateOption](&quot;options to configure obfuscate&quot;)
  }
  import autoImport._
  override lazy val globalSettings = Seq(
    obfuscateOption := ObfuscateOption()
  )

  override lazy val projectSettings = inConfig(Compile)(
    obfuscate := {
      Obfuscate(
        (obfuscate / sources).value,
        (obfuscate / obfuscateOption).value
      )
    },
    obfuscate / sources := sources.value
  )
}

// core feature implemented here
object Obfuscate {
  def apply(sources: Seq[File], opt: ObfuscateOption): Seq[File] = {
    sources
  }
}
</code></pre><p>In the above, <code>obfuscateOption</code> is set a default made-up value in the <code>globalSettings</code>;
but is used as <code>(obfuscate / obfuscateOption)</code> in the <code>projectSettings</code>.
This lets the user either set <code>obfuscate / obfuscateOption</code> at a particular subproject level,
or scoped to <code>ThisBuild</code> affecting all subprojects:
</p><pre><code class="prettyprint lang-scala">ThisBuild / obfuscate / obfuscateOption := ObfuscateOption().withX(true)
</code></pre><p>Giving keys default values in global scope requires knowing that every key (if any)
used to define that key must <em>also</em> be defined in global scope, otherwise it will
fail at load time.
</p><h4 id="Using+a+%E2%80%9Cmain%E2%80%9D+task+scope+for+settings">Using a “main” task scope for settings<a href="#Using+a+%E2%80%9Cmain%E2%80%9D+task+scope+for+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Sometimes you want to define some settings for a particular “main” task
in your plugin. In this instance, you can scope your settings using the
task itself. See the <code>baseObfuscateSettings</code>:
</p><pre><code class="prettyprint lang-scala">  lazy val baseObfuscateSettings: Seq[Def.Setting[_]] = Seq(
    obfuscate := Obfuscate((sources in obfuscate).value),
    sources in obfuscate := sources.value
  )
</code></pre><p>In the above example, <code>sources in obfuscate</code> is scoped under the main
task, <code>obfuscate</code>.
</p><h4 id="Rewiring+existing+keys+in">Rewiring existing keys in <code>globalSettings</code><a href="#Rewiring+existing+keys+in" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There may be times when you need to rewire an existing key in <code>globalSettings</code>.
The general rule is <em>be careful what you touch</em>.
</p><p>Care should be taken to ensure previous settings from other plugins are not ignored. e.g. when creating a new
<code>onLoad</code> handler, ensure that the previous <code>onLoad</code> handler is not
removed.
</p><pre><code class="prettyprint lang-scala">package sbtsomething

import sbt._, Keys._

object MyPlugin extends AutoPlugin {
  override def requires = plugins.JvmPlugin
  override def trigger = allRequirements

  override val globalSettings: Seq[Def.Setting[_]] = Seq(
    onLoad in Global := (onLoad in Global).value andThen { state =&gt;
      ... return new state ...
    }
  )
}
</code></pre><h2 id="Setting+up+GitHub+Actions+with+sbt">Setting up GitHub Actions with sbt<a href="#Setting+up+GitHub+Actions+with+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><a href="https://docs.github.com/en/free-pro-team@latest/actions">GitHub Actions</a> is a workflow system by GitHub that supports continuous integration (CI) and continuous deployment (CD). As CI/CD feature was introduced in <a href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">2019</a>, it’s a newcomer in the CI/CD field, but it quickly rised to the de-facto standard CI solution for open source Scala projects.
</p><h3 id="Set">Set <code>project/build.properties</code><a href="#Set" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Continuous integration is a great way of checking that your code works outside of your machine.
If you haven’t created one already, make sure to create <code>project/build.properties</code> and explicitly set the
<code>sbt.version</code> number:
</p><pre><code class="prettyprint lang-yml">sbt.version=1.4.7
</code></pre><p>Your build will now use 1.4.7.
</p><h3 id="Read+the+GitHub+Actions+manual">Read the GitHub Actions manual<a href="#Read+the+GitHub+Actions+manual" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A treasure trove of Github Actions tricks can be found in the Github Actions <a href="https://docs.github.com/en/free-pro-team@latest/actions">official documentation</a>, including the <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference">Reference</a>.
Use this guide as an inspiration, but consult the official source for more details.
</p><h3 id="Basic+setup">Basic setup<a href="#Basic+setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Setting up your build for GitHub Actions is mostly about setting up <code>.github/workflows/ci.yml</code>. Here’s what a minimal CI workflow could look like using Olaf’s <a href="https://github.com/olafurpg/setup-scala">setup-scala</a>:
</p><pre><code class="prettyprint lang-yml">name: CI
on:
  pull_request:
  push:
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Setup Scala
      uses: olafurpg/setup-scala@v10
      with:
        java-version: &quot;adopt@1.8&quot;
    - name: Build and Test
      run: sbt -v -Dfile.encoding=UTF-8 +test
</code></pre><h3 id="Custom+JVM+options">Custom JVM options<a href="#Custom+JVM+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The default JVM options are provided by the unofficial sbt-extras script adopted by <a href="https://github.com/olafurpg/setup-scala">setup-scala</a>, and it should work for most cases. If you do decide to customize it, use <code>-v</code> option to let the script output the current options first:
</p><pre><code class="">Detected Java version: 8
# Executing command line:
java
-Xms512m
-Xss2m
-XX:MaxInlineLevel=18
-Dfile.encoding=UTF8
-jar
/home/runner/.sbt/launchers/1.4.0-RC2/sbt-launch.jar
</code></pre><p>We can define <code>JAVA_OPTS</code> and <code>JVM_OPTS</code> environment variables to override this.
</p><pre><code class="prettyprint lang-yml">name: CI
on:
  pull_request:
  push:
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      # define Java options for both official sbt and sbt-extras
      JAVA_OPTS: -Xms2048M -Xmx2048M -Xss6M -XX:ReservedCodeCacheSize=256M -Dfile.encoding=UTF-8
      JVM_OPTS:  -Xms2048M -Xmx2048M -Xss6M -XX:ReservedCodeCacheSize=256M -Dfile.encoding=UTF-8
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Setup Scala
      uses: olafurpg/setup-scala@v10
      with:
        java-version: &quot;adopt@1.8&quot;
    - name: Build and Test
      run: sbt -v +test
</code></pre><p>Again, let’s check the log to see if the flags are taking effect:
</p><pre><code class="">Using jvm options defined in $JVM_OPTS variable
# Executing command line:
java
-Xms2048M
-Xmx2048M
-Xss6M
-XX:ReservedCodeCacheSize=256M
-Dfile.encoding=UTF8
-jar
/home/runner/.sbt/launchers/1.4.0-RC2/sbt-launch.jar
+test
</code></pre><h3 id="Caching">Caching<a href="#Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can speed up your <code>sbt</code> builds on GitHub Actions by caching various artifacts in-between the jobs.
</p><p>Here are sample caching steps that you can use:
</p><pre><code class="prettyprint lang-yml">    - name: Coursier cache
      uses: coursier/cache-action@v5
    - name: Build and test
      run: |
        sbt -v +test
        rm -rf &quot;$HOME/.ivy2/local&quot; || true
        find $HOME/Library/Caches/Coursier/v1        -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.ivy2/cache                       -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.cache/coursier/v1                -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.sbt                              -name &quot;*.lock&quot;               -delete || true
</code></pre><p>With the above changes combined GitHub Actions will tar up the cached directories and uploads them to a cloud storage provider.
Overall, the use of caching should shave off a few minutes of build time per job.
</p><h3 id="Build+matrix">Build matrix<a href="#Build+matrix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When creating a continous integration job, it’s fairly common to split up the task into multiple jobs that runs in parallel. For example, we could:
</p><ul><li>Run identical tests on JDK 8, JDK 11, Linux, macOS, and Windows
</li><li>Run different subset of tests on the same JDK, OS, and other setups
</li></ul><p>Both use cases are possible using <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategy">the build matrix</a>. The point here is that we would like to mostly reuse the steps except for a few variance. For tasks that do not overlap in steps (like testing vs deployment), it might be better to just create a different job or a new workflow.
</p><p>Here’s an example of forming a build matrix using JDK version and operating system.
</p><pre><code class="prettyprint lang-yml">name: CI
on:
  pull_request:
  push:
jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            java: 8
          - os: ubuntu-latest
            java: 11
          - os: windows-latest
            java: 11
    runs-on: ${{ matrix.os }}
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Setup
      uses: olafurpg/setup-scala@v10
      with:
        java-version: &quot;adopt@1.${{ matrix.java }}&quot;
    - name: Build and test
      run: sbt -v -Dfile.encoding=UTF8 +test
      shell: bash
</code></pre><p>Note that there’s nothing magical about the <code>os</code> or <code>java</code> keys in the build matrix.
</p><blockquote><p>The keys you define become properties in the <code>matrix</code> context and you can reference the property in other areas of your workflow file.
</p></blockquote><p>You can create an arbitrary key to iterate over! We can use this and create a key named <code>jobtype</code> to split the work too.
</p><pre><code class="prettyprint lang-yml">name: CI
on:
  pull_request:
  push:
jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            java: 11
            jobtype: 1
          - os: ubuntu-latest
            java: 11
            jobtype: 2
          - os: ubuntu-latest
            java: 11
            jobtype: 3
    runs-on: ${{ matrix.os }}
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Setup
      uses: olafurpg/setup-scala@v10
      with:
        java-version: &quot;adopt@1.${{ matrix.java }}&quot;
    - name: Build and test
      run: |
        case ${{ matrix.jobtype }} in
          1)
            sbt -v &quot;mimaReportBinaryIssues; scalafmtCheckAll; +test;&quot;
            ;;
          2)
            sbt -v &quot;scripted actions/*&quot;
            ;;
          3)
            sbt -v &quot;dependency-management/*&quot;
            ;;
          *)
            echo unknown jobtype
            exit 1
        esac
      shell: bash
</code></pre><h3 id="Sample+.github%2Fworkflows%2Fci.yml+setting">Sample .github/workflows/ci.yml setting<a href="#Sample+.github%2Fworkflows%2Fci.yml+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here’s a sample that puts them all together. Remember, most of the sections are optional.
</p><pre><code class="prettyprint lang-yml">name: CI
on:
  pull_request:
  push:
jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            java: 11
            jobtype: 1
          - os: ubuntu-latest
            java: 11
            jobtype: 2
          - os: windows-latest
            java: 11
            jobtype: 2
          - os: ubuntu-latest
            java: 11
            jobtype: 3
    runs-on: ${{ matrix.os }}
    env:
      # define Java options for both official sbt and sbt-extras
      JAVA_OPTS: -Xms2048M -Xmx2048M -Xss6M -XX:ReservedCodeCacheSize=256M -Dfile.encoding=UTF-8
      JVM_OPTS:  -Xms2048M -Xmx2048M -Xss6M -XX:ReservedCodeCacheSize=256M -Dfile.encoding=UTF-8
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Setup
      uses: olafurpg/setup-scala@v10
      with:
        java-version: &quot;adopt@1.${{ matrix.java }}&quot;
    - name: Coursier cache
      uses: coursier/cache-action@v5
    - name: Build and test
      run: |
        case ${{ matrix.jobtype }} in
          1)
            sbt -v &quot;mimaReportBinaryIssues; scalafmtCheckAll; +test;&quot;
            ;;
          2)
            sbt -v &quot;scripted actions/*&quot;
            ;;
          3)
            sbt -v &quot;dependency-management/*&quot;
            ;;
          *)
            echo unknown jobtype
            exit 1
        esac
        rm -rf &quot;$HOME/.ivy2/local&quot; || true
        find $HOME/Library/Caches/Coursier/v1        -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.ivy2/cache                       -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.cache/coursier/v1                -name &quot;ivydata-*.properties&quot; -delete || true
        find $HOME/.sbt                              -name &quot;*.lock&quot;               -delete || true
      shell: bash
</code></pre><h3 id="sbt-github-actions">sbt-github-actions<a href="#sbt-github-actions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There’s also <a href="https://github.com/djspiewak/sbt-github-actions">sbt-github-actions</a>, an sbt plugin by Daniel Spiewak that can generate the workflow files, and keep the settings in <code>build.sbt</code> file.
</p><h2 id="Setting+up+Travis+CI+with+sbt">Setting up Travis CI with sbt<a href="#Setting+up+Travis+CI+with+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><a href="https://travis-ci.com/">Travis CI</a> is a hosted continuous integration service for open source and private projects. Many of the OSS projects hosted on GitHub uses <a href="https://travis-ci.org/">open source edition of Travis CI</a> to validate pushes and pull requests. We’ll discuss some of the best practices setting up Travis CI.
</p><h3 id="Set">Set <code>project/build.properties</code><a href="#Set" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Continuous integration is a great way of checking that your code works outside of your machine.
If you haven’t created one already, make sure to create <code>project/build.properties</code> and explicitly set the
<code>sbt.version</code> number:
</p><pre><code class="prettyprint lang-yml">sbt.version=1.4.7
</code></pre><p>Your build will now use 1.4.7.
</p><h3 id="Read+the+Travis+manual">Read the Travis manual<a href="#Read+the+Travis+manual" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A treasure trove of Travis tricks can be found in the Travis’s <a href="http://docs.travis-ci.com/">official documentation</a>.
Use this guide as an inspiration, but consult the official source for more details.
</p><h3 id="Basic+setup">Basic setup<a href="#Basic+setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Setting up your build for Travis CI is mostly about setting up <code>.travis.yml</code>.
<a href="http://docs.travis-ci.com/user/languages/scala/">Scala</a> page says the basic file can look like:
</p><pre><code class="prettyprint lang-yml">language: scala

jdk: openjdk8

scala:
   - 2.10.4
   - 2.12.13
</code></pre><p>By default Travis CI executes <code>sbt ++$TRAVIS_SCALA_VERSION test</code>.
Let’s specify that explicitly:
</p><pre><code class="prettyprint lang-yml">language: scala

jdk: openjdk8

scala:
   - 2.10.4
   - 2.12.13

script:
   - sbt ++$TRAVIS_SCALA_VERSION test
</code></pre><p>More info on <code>script</code> section can be found in <a href="http://docs.travis-ci.com/user/build-configuration/">Configuring your build</a>.
</p><p>As noted on the <a href="http://docs.travis-ci.com/user/languages/scala/">Scala</a> page, Travis CI uses <a href="https://github.com/paulp/sbt-extras">paulp/sbt-extras</a> as the <code>sbt</code> command.
This becomes relevant when you want to override JVM options, which we’ll see later.
</p><h3 id="Plugin+build+setup">Plugin build setup<a href="#Plugin+build+setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For sbt plugins, there is no need for cross building on Scala, so the following is all you need:
</p><pre><code class="prettyprint lang-yml">language: scala

jdk: openjdk8

script:
   - sbt scripted
</code></pre><p>Another source of good information is to read the output by Travis CI itself to learn about how the virtual environment is set up.
For example, from the following output we learn that it is using <code>JVM_OPTS</code> environment variable to pass in the JVM options.
</p><pre><code class="">$ export JVM_OPTS=@/etc/sbt/jvmopts
$ export SBT_OPTS=@/etc/sbt/sbtopts
</code></pre><h3 id="Custom+JVM+options">Custom JVM options<a href="#Custom+JVM+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The default <a href="https://github.com/travis-ci/travis-cookbooks/blob/master/cookbooks/travis_sbt_extras/templates/default/sbtopts.erb">sbt</a> and <a href="https://github.com/travis-ci/travis-cookbooks/blob/master/cookbooks/travis_sbt_extras/templates/default/jvmopts.erb">JVM</a> options are set by Travis CI people,
and it should work for most cases.
If you do decide to customize it, read what they currently use as the defaults first.
Because Travis is already using the environment variable <code>JVM_OPTS</code>, we can instead create a file <code>travis/jvmopts</code>:
</p><pre><code class="">-Dfile.encoding=UTF8
-Xms2048M
-Xmx2048M
-Xss6M
-XX:ReservedCodeCacheSize=256M
</code></pre><p>and then write out the <code>script</code> section with <code>-jvm-opts</code> option:
</p><pre><code class="">script:
   - sbt ++$TRAVIS_SCALA_VERSION -jvm-opts travis/jvmopts test
</code></pre><p>After making the change, confirm on the Travis log to see if the flags are taking effect:
</p><pre><code class=""># Executing command line:
java
-Dfile.encoding=UTF8
-Xms2048M
-Xmx2048M
-Xss6M
-XX:ReservedCodeCacheSize=256M
-jar
/home/travis/.sbt/launchers/1.4.7/sbt-launch.jar
</code></pre><p>It seems to be working. One downside of setting all of the parameters is that we might be left behind when the environment updates and the default values gives us more memory in the future.
</p><p>Here’s how we can add just a few JVM options:
</p><pre><code class="">script:
   - sbt ++$TRAVIS_SCALA_VERSION -Dfile.encoding=UTF8 -J-XX:ReservedCodeCacheSize=256M -J-Xms1024M test
</code></pre><p>sbt-extra script passes any arguments starting with either <code>-D</code> or <code>-J</code> directly to JVM.
</p><p>Again, let’s check the Travis log to see if the flags are taking effect:
</p><pre><code class=""># Executing command line:
java
-Xms2048M
-Xmx2048M
-Xss6M
-Dfile.encoding=UTF8
-XX:ReservedCodeCacheSize=256M
-Xms1024M
-jar
/home/travis/.sbt/launchers/1.4.7/sbt-launch.jar
</code></pre><p><strong>Note</strong>: This duplicates the <code>-Xms</code> flag as intended, which might not the best thing to do.
</p><h3 id="Caching">Caching<a href="#Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can speed up your <code>sbt</code> builds on Travis CI by using their <a href="http://docs.travis-ci.com/user/caching/">caching</a> feature.
</p><p>Here’s a sample <code>cache:</code> configuration that you can use:
</p><pre><code class="prettyprint lang-yml">cache:
  directories:
    - $HOME/.cache/coursier
    - $HOME/.ivy2/cache
    - $HOME/.sbt
</code></pre><p><strong>Note</strong>: Coursier uses different <a href="https://get-coursier.io/docs/cache">cache location</a> depending on the OS, so the above needs to be changed accordingly for macOS or Windows images.
</p><p>You’ll also need the following snippet to avoid unnecessary cache updates:
</p><pre><code class="prettyprint lang-yml">before_cache:
  - rm -fv $HOME/.ivy2/.sbt.ivy.lock
  - find $HOME/.ivy2/cache -name &quot;ivydata-*.properties&quot; -print -delete
  - find $HOME/.sbt        -name &quot;*.lock&quot;               -print -delete
</code></pre><p>With the above changes combined Travis CI will tar up the cached directories and uploads them to a cloud storage provider.
Overall, the use of caching should shave off a few minutes of build time per job.
</p><h3 id="Build+matrix">Build matrix<a href="#Build+matrix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We’ve already seen the example of Scala cross building.
</p><pre><code class="prettyprint lang-yml">language: scala

jdk: openjdk8

scala:
   - 2.10.4
   - 2.12.13

script:
   - sbt ++$TRAVIS_SCALA_VERSION test
</code></pre><p>We can also form a build matrix using environment variables:
</p><pre><code class="prettyprint lang-yml">env:
  global:
    - SOME_VAR=&quot;1&quot;

  # This splits the build into two parts 
  matrix:
    - TEST_COMMAND=&quot;scripted sbt-assembly/*&quot;
    - TEST_COMMAND=&quot;scripted merging/* caching/*&quot;

script:
   - sbt &quot;$TEST_COMMAND&quot;
</code></pre><p>Now two jobs will be created to build this sbt plugin, simultaneously running different integration tests.
This technique is described in <a href="http://docs.travis-ci.com/user/speeding-up-the-build/">Parallelizing your builds across virtual machines</a>.
</p><h3 id="Notification">Notification<a href="#Notification" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can configure Travis CI to <a href="http://docs.travis-ci.com/user/notifications/">notify you</a>.
</p><blockquote><p>By default, email notifications will be sent to the committer and the commit author, if they are members of the repository[…].
</p><p>And it will by default send emails when, on the given branch:
</p><ul><li>a build was just broken or still is broken
</li><li>a previously broken build was just fixed
</li></ul></blockquote><p>The default behavior looks reasonable, but if you want, we can override the <code>notifications</code> section to email you on successful builds too, or to use some other channel of communication like IRC.
</p><pre><code class="prettyprint lang-yml"># Email specific recipient all the time
notifications:
  email:
    recipients:
      - one@example.com
  on_success: always # default: change
</code></pre><p>This might also be a good time to read up on <a href="http://docs.travis-ci.com/user/encryption-keys/">encryption</a> using the command line <code>travis</code> tool.
</p><pre><code class="">$ travis encrypt one@example.com
</code></pre><h3 id="Dealing+with+flaky+network+or+tests">Dealing with flaky network or tests<a href="#Dealing+with+flaky+network+or+tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For builds that are more prone to flaky network or tests, Travis CI has created some tricks
described in the page <a href="http://docs.travis-ci.com/user/build-timeouts/">My builds is timing out</a>.
</p><p>Starting your command with <code>travis_retry</code> retries the command three times if the return code is non-zero.
With caching, hopefully the effect of flaky network is reduced, but it’s an interesting one nonetheless.
Here are some cautionary words from the documentation:
</p><blockquote><p>We recommend careful use of <code>travis_retry</code>, as overusing it can extend your build time when there could be a deeper underlying issue.
</p></blockquote><p>Another tidbit about Travis is the output timeout:
</p><blockquote><p>Our builds have a global timeout and a timeout that’s based on the output. If no output is received from a build for 10 minutes, it’s assumed to have stalled for unknown reasons and is subsequently killed.
</p></blockquote><p>There’s a function called <code>travis_wait</code> that can extend this to 20 minutes.
</p><h3 id="More+things">More things<a href="#More+things" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are more thing you can do, such as <a href="http://docs.travis-ci.com/user/database-setup/">set up databases</a>, <a href="http://docs.travis-ci.com/user/installing-dependencies/">installing Ubuntu packages</a>, and <a href="http://docs.travis-ci.com/user/deployment/">deploy continuously</a>.
</p><p>Travis offers the ability to run tests in parallel, and also imposes
time limits on builds.  If you have an especially long-running suite
of scripted tests for your plugin, you can run a subset of scripted
tests in a directory, for example:
</p><pre><code class="">    - TEST_COMMAND=&quot;scripted tests/*1of3&quot;
    - TEST_COMMAND=&quot;scripted tests/*2of3&quot;
    - TEST_COMMAND=&quot;scripted tests/*3of3&quot;
</code></pre><p>Will create three chunks and run each of the chunks separately for the
directory <code>tests</code>.
</p><h3 id="Sample+setting">Sample setting<a href="#Sample+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here’s a sample that puts them all together. Remember, most of the sections are optional.
</p><pre><code class="prettyprint lang-yml">language: scala

jdk: openjdk8

env:
  # This splits the build into two parts
  matrix:
    - TEST_COMMAND=&quot;scripted sbt-assembly/*&quot;
    - TEST_COMMAND=&quot;scripted merging/* caching/*&quot;

script:
  - sbt -Dfile.encoding=UTF8 -J-XX:ReservedCodeCacheSize=256M &quot;$TEST_COMMAND&quot;

before_cache:
  - rm -fv $HOME/.ivy2/.sbt.ivy.lock
  - find $HOME/.ivy2/cache -name &quot;ivydata-*.properties&quot; -print -delete
  - find $HOME/.sbt        -name &quot;*.lock&quot;               -print -delete

cache:
  directories:
    - $HOME/.cache/coursier
    - $HOME/.ivy2/cache
    - $HOME/.sbt
</code></pre><h2 id="Testing+sbt+plugins">Testing sbt plugins<a href="#Testing+sbt+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Let’s talk about testing. Once you write a plugin, it turns into a long-term thing. To keep adding new features (or to keep fixing bugs), writing tests makes sense.
</p><h3 id="scripted+test+framework">scripted test framework<a href="#scripted+test+framework" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt comes with scripted test framework, which lets you script a build scenario. It was written to test sbt itself on complex scenarios — such as change detection and partial compilation:
</p><blockquote><p>Now, consider what happens if you were to delete B.scala but do not update A.scala. When you recompile, you should get an error because B no longer exists for A to reference.
[… (really complicated stuff)]
</p><p>The scripted test framework is used to verify that sbt handles cases such as that described above.
</p></blockquote><p>The framework is made available via scripted-plugin. The rest of this page explains how to include the scripted-plugin into your plugin.
</p><h3 id="step+1%3A+snapshot">step 1: snapshot<a href="#step+1%3A+snapshot" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Before you start, set your version to a <strong>-SNAPSHOT</strong> one because scripted-plugin will publish your plugin locally. If you don’t use SNAPSHOT, you could get into a horrible inconsistent state of you and the rest of the world seeing different artifacts.
</p><h3 id="step+2%3A+SbtPlugin">step 2: SbtPlugin<a href="#step+2%3A+SbtPlugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Enable <code>SbtPlugin</code> in <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
  .settings(
    name := &quot;sbt-something&quot;
  )
</code></pre><p>Then add the following settings to <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(SbtPlugin)
  .settings(
    name := &quot;sbt-something&quot;,
    scriptedLaunchOpts := { scriptedLaunchOpts.value ++
      Seq(&quot;-Xmx1024M&quot;, &quot;-Dplugin.version=&quot; + version.value)
    },
    scriptedBufferLog := false
  )
</code></pre><p><strong>Note</strong>: You must use sbt 1.2.1 and above to use <code>SbtPlugin</code>.
</p><h3 id="step+3%3A+src%2Fsbt-test">step 3: src/sbt-test<a href="#step+3%3A+src%2Fsbt-test" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Make dir structure <code>src/sbt-test/&lt;test-group&gt;/&lt;test-name&gt;</code>. For starters, try something like <code>src/sbt-test/&lt;your-plugin-name&gt;/simple</code>.
</p><p>Now ready? Create an initial build in <code>simple</code>. Like a real build using your plugin. I’m sure you already have several of them to test manually. Here’s an example <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    version := &quot;0.1&quot;,
    scalaVersion := &quot;2.10.6&quot;,
    assemblyJarName in assembly := &quot;foo.jar&quot;
  )
</code></pre><p>In <code>project/plugins.sbt</code>:
</p><pre><code class="prettyprint lang-scala">sys.props.get(&quot;plugin.version&quot;) match {
  case Some(x) =&gt; addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % x)
  case _ =&gt; sys.error(&quot;&quot;&quot;|The system property 'plugin.version' is not defined.
                         |Specify this property using the scriptedLaunchOpts -D.&quot;&quot;&quot;.stripMargin)
}
</code></pre><p>This a trick I picked up from <a href="https://github.com/earldouglas/xsbt-web-plugin/commit/feabb2eb554940d9b28049bd0618b6a790d9e141">earldouglas/xsbt-web-plugin@feabb2</a>, which allows us to pass version number into the test.
</p><p>I also have <code>src/main/scala/hello.scala</code>:
</p><pre><code class="prettyprint lang-scala">object Main extends App {
  println(&quot;hello&quot;)
}
</code></pre><h3 id="step+4%3A+write+a+script">step 4: write a script<a href="#step+4%3A+write+a+script" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now, write a script to describe your scenario in a file called <code>test</code> located at the root dir of your test project.
</p><pre><code class=""># check if the file gets created
&gt; assembly
$ exists target/scala-2.10/foo.jar
</code></pre><p>Here is the syntax for the script:
</p><ol><li><strong><code>#</code></strong> starts a one-line comment
</li><li><strong><code>&gt;</code></strong> <code>name</code> sends a task to sbt (and tests if it succeeds)
</li><li><strong><code>$</code></strong> <code>name arg*</code> performs a file command (and tests if it succeeds)
</li><li><strong><code>-&gt;</code></strong> <code>name</code> sends a task to sbt, but expects it to fail
</li><li><strong><code>-$</code></strong> <code>name arg*</code> performs a file command, but expects it to fail
</li></ol><p>File commands are:
</p><ul><li><strong><code>touch</code></strong> <code>path+</code> creates or updates the timestamp on the files
</li><li><strong><code>delete</code></strong> <code>path+</code> deletes the files
</li><li><strong><code>exists</code></strong> <code>path+</code> checks if the files exist
</li><li><strong><code>mkdir</code></strong> <code>path+</code> creates dirs
</li><li><strong><code>absent</code></strong> <code>path+</code> checks if the files don’t exist
</li><li><strong><code>newer</code></strong> <code>source target</code> checks if <code>source</code> is newer
</li><li><strong><code>must-mirror</code></strong> <code>source target</code> checks if <code>source</code> is identical
</li><li><strong><code>pause</code></strong> pauses until enter is pressed
</li><li><strong><code>sleep</code></strong> <code>time</code> sleeps (in milliseconds)
</li><li><strong><code>exec</code></strong> <code>command args*</code> runs the command in another process
</li><li><strong><code>copy-file</code></strong> <code>fromPath toPath</code> copies the file
</li><li><strong><code>copy</code></strong> <code>fromPath+ toDir</code> copies the paths to <code>toDir</code> preserving relative structure
</li><li><strong><code>copy-flat</code></strong> <code>fromPath+ toDir</code> copies the paths to <code>toDir</code> flat
</li></ul><p>So my script will run <code>assembly</code> task, and checks if <code>foo.jar</code> gets created. We’ll cover more complex tests later.
</p><h3 id="step+5%3A+run+the+script">step 5: run the script<a href="#step+5%3A+run+the+script" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To run the scripts, go back to your plugin project, and run:
</p><pre><code class="">&gt; scripted
</code></pre><p>This will copy your test build into a temporary dir, and executes the <code>test</code> script. If everything works out, you’d see <code>publishLocal</code> running, then:
</p><pre><code class="">Running sbt-assembly / simple
[success] Total time: 18 s, completed Sep 17, 2011 3:00:58 AM
</code></pre><h3 id="step+6%3A+custom+assertion">step 6: custom assertion<a href="#step+6%3A+custom+assertion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The file commands are great, but not nearly enough because none of them test the actual contents. An easy way to test the contents is to implement a custom task in your test build.
</p><p>For my hello project, I’d like to check if the resulting jar prints out “hello”. I can take advantage of <code>scala.sys.process.Process</code> to run the jar. To express a failure, just throw an error. Here’s <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">import scala.sys.process.Process

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    version := &quot;0.1&quot;,
    scalaVersion := &quot;2.10.6&quot;,
    assemblyJarName in assembly := &quot;foo.jar&quot;,
    TaskKey[Unit](&quot;check&quot;) := {
      val process = Process(&quot;java&quot;, Seq(&quot;-jar&quot;, (crossTarget.value / &quot;foo.jar&quot;).toString))
      val out = (process!!)
      if (out.trim != &quot;bye&quot;) sys.error(&quot;unexpected output: &quot; + out)
      ()
    }
  )
</code></pre><p>I am intentionally testing if it matches “bye”, to see how the test fails.
</p><p>Here’s <code>test</code>:
</p><pre><code class=""># check if the file gets created
&gt; assembly
$ exists target/foo.jar

# check if it says hello
&gt; check
</code></pre><p>Running <code>scripted</code> fails the test as expected:
</p><pre><code class="">[info] [error] {file:/private/var/folders/Ab/AbC1EFghIj4LMNOPqrStUV+++XX/-Tmp-/sbt_cdd1b3c4/simple/}default-0314bd/*:check: unexpected output: hello
[info] [error] Total time: 0 s, completed Sep 21, 2011 8:43:03 PM
[error] x sbt-assembly / simple
[error]    {line 6}  Command failed: check failed
[error] {file:/Users/foo/work/sbt-assembly/}default-373f46/*:scripted: sbt-assembly / simple failed
[error] Total time: 14 s, completed Sep 21, 2011 8:00:00 PM
</code></pre><h3 id="step+7%3A+testing+the+test">step 7: testing the test<a href="#step+7%3A+testing+the+test" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Until you get the hang of it, it might take a while for the test itself to behave correctly. There are several techniques that may come in handy.
</p><p>First place to start is turning off the log buffering.
</p><pre><code class="">&gt; set scriptedBufferLog := false
</code></pre><p>This for example should print out the location of the temporary dir:
</p><pre><code class="">[info] [info] Set current project to default-c6500b (in build file:/private/var/folders/Ab/AbC1EFghIj4LMNOPqrStUV+++XX/-Tmp-/sbt_8d950687/simple/project/plugins/)
...
</code></pre><p>Add the following line to your <code>test</code> script to suspend the test until you hit the enter key:
</p><pre><code class="">$ pause
</code></pre><p>If you’re thinking about going down to the <code>sbt/sbt-test/sbt-foo/simple</code> and running <code>sbt</code>, don’t do it. The right way, is to copy the dir somewhere else and run it.
</p><h3 id="step+8%3A+get+inspired">step 8: get inspired<a href="#step+8%3A+get+inspired" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are literally <a href="https://github.com/sbt/sbt/tree/develop/sbt/src/sbt-test">100+ scripted tests</a> under sbt project itself. Browse around to get inspirations.
</p><p>For example, here’s the one called by-name.
</p><pre><code class="">&gt; compile

# change =&gt; Int to Function0
$ copy-file changes/A.scala A.scala

# Both A.scala and B.scala need to be recompiled because the type has changed
-&gt; compile
</code></pre><p><a href="https://github.com/earldouglas/xsbt-web-plugin/tree/master/src/sbt-test">xsbt-web-plugin</a> and <a href="https://github.com/sbt/sbt-assembly/tree/master/src/sbt-test/sbt-assembly">sbt-assembly</a> have some scripted tests too.
</p><p>That’s it! Let me know about your experience in testing plugins!
</p><h2 id="sbt+new+and+Templates">sbt new and Templates<a href="#sbt+new+and+Templates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 0.13.13 adds a new command called new, to create new build definitions from a template.
The <code>new</code> command is extensible via a mechanism called the <a href="#Template+Resolver">template resolver</a>.
</p><h3 id="Trying+new+command">Trying new command<a href="#Trying+new+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>First, you need sbt’s launcher version 0.13.13 or above.
Normally the exact version for the <code>sbt</code> launcher does not matter
because it will use the version specified by <code>sbt.version</code> in <code>project/build.properties</code>;
however for new sbt’s launcher 0.13.13 or above is required as the command functions without a <code>project/build.properties</code> present.
</p><p>Next, run:
</p><pre><code class="">$ sbt new scala/scala-seed.g8
....
name [hello]:

Template applied in ./hello
</code></pre><p>This ran the template <a href="https://github.com/scala/scala-seed.g8">scala/scala-seed.g8</a> using <a href="http://www.foundweekends.org/giter8/">Giter8</a>, prompted for values for “name” (which has a default value of “hello”, which we accepted hitting <code>[Enter]</code>), and created a build under <code>./hello</code>.
</p><p><code>scala-seed</code> is the official template for a “minimal” Scala project, but it’s definitely not the only one out there.
</p><h3 id="Giter8+support">Giter8 support<a href="#Giter8+support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="http://www.foundweekends.org/giter8/">Giter8</a> is a templating project originally started by Nathan Hamblen in 2010, and now maintained by the <a href="http://www.foundweekends.org/">foundweekends</a> project.
The unique aspect of Giter8 is that it uses GitHub (or any other git repository) to host the templates, so it allows anyone to participate in template creation. Here are some of the templates provided by official sources:
</p><ul><li><a href="https://github.com/foundweekends/giter8.g8">foundweekends/giter8.g8</a>                 (A template for Giter8 templates)
</li><li><a href="https://github.com/scala/scala-seed.g8">scala/scala-seed.g8</a>                         (Seed template for Scala)
</li><li><a href="https://github.com/scala/hello-world.g8">scala/hello-world.g8</a>                       (A template to demonstrate a minimal Scala application)
</li><li><a href="https://github.com/scala/scalatest-example.g8">scala/scalatest-example.g8</a>           (A template for trying out ScalaTest)
</li><li><a href="https://github.com/akka/akka-scala-seed.g8">akka/akka-scala-seed.g8</a>                 (A minimal seed template for an Akka with Scala build
)
</li><li><a href="https://github.com/akka/akka-java-seed.g8">akka/akka-java-seed.g8</a>                   (A minimal seed template for an Akka in Java
)
</li><li><a href="https://github.com/playframework/play-scala-seed.g8">playframework/play-scala-seed.g8</a> (Play Scala Seed Template)
</li><li><a href="https://github.com/playframework/play-java-seed.g8">playframework/play-java-seed.g8</a>   (Play Java Seed template)
</li><li><a href="https://github.com/lagom/lagom-scala.g8/">lagom/lagom-scala.g8</a>                      (A <a href="https://www.lagomframework.com/">Lagom</a> Scala seed template for sbt)
</li><li><a href="https://github.com/lagom/lagom-java.g8/">lagom/lagom-java.g8</a>                        (A <a href="https://www.lagomframework.com/">Lagom</a> Java seed template for sbt)
</li><li><a href="https://github.com/scala-native/scala-native.g8">scala-native/scala-native.g8</a>       (Scala Native)
</li><li><a href="https://github.com/scala-native/sbt-crossproject.g8">scala-native/sbt-crossproject.g8</a> (sbt-crosspoject)
</li><li><a href="https://github.com/http4s/http4s.g8">http4s/http4s.g8</a>                               (http4s services)
</li><li><a href="https://github.com/unfiltered/unfiltered.g8">unfiltered/unfiltered.g8</a>               (<a href="http://unfiltered.ws/">Unfiltered</a> application)
</li><li><a href="https://github.com/scalatra/scalatra-sbt.g8">scalatra/scalatra-sbt.g8</a>               (Basic Scalatra template using SBT 0.13.x.)
</li></ul><p>For more, see <a href="https://github.com/foundweekends/giter8/wiki/giter8-templates">Giter8 templates</a> on the Giter8 wiki. sbt provides out-of-the-box support for Giter8 templates by shipping with a template resolver for Giter8.
</p><h4 id="Giter8+parameters">Giter8 parameters<a href="#Giter8+parameters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You can append Giter8 parameters to the end of the command, so for example to specify a particular branch you can use:
</p><pre><code class="">$ sbt new scala/scala-seed.g8 --branch myBranch
</code></pre><h4 id="How+to+create+a+Giter8+template">How to create a Giter8 template<a href="#How+to+create+a+Giter8+template" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="http://www.foundweekends.org/giter8/template.html">Making your own templates</a> for the details on how to create a new Giter8 template.
</p><pre><code class="">$ sbt new foundweekends/giter8.g8
</code></pre><h4 id="Use+CC0+1.0+for+template+licensing">Use CC0 1.0 for template licensing<a href="#Use+CC0+1.0+for+template+licensing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>We recommend licensing software templates under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>,
which waives all copyrights and related rights, similar to the “public domain.”
</p><p>If you reside in a country covered by the Berne Convention, such as the US,
copyright will arise automatically without registration.
Thus, people won’t have legal right to use your template if you do not
declare the terms of license.
The tricky thing is that even permissive licenses such as MIT License and Apache License will require attribution to your template in the template user’s software.
To remove all claims to the templated snippets, distribute it under CC0, which is an international equivalent to public domain.
</p><pre><code class="">License
-------
Written in &lt;YEAR&gt; by &lt;AUTHOR NAME&gt; &lt;AUTHOR E-MAIL ADDRESS&gt;
[other author/contributor lines as appropriate]
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see &lt;http://creativecommons.org/publicdomain/zero/1.0/&gt;.
</code></pre><h3 id="How+to+extend+sbt+new">How to extend sbt new<a href="#How+to+extend+sbt+new" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The rest of this page explains how to extend the <code>sbt new</code> command
to provide support for something other than Giter8 templates.
You can skip this section if you’re not interested in extending <code>new</code>.
</p><h4 id="Template+Resolver">Template Resolver<a href="#Template+Resolver" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A template resolver is a partial function that looks at the arguments
after <code>sbt new</code> and determines whether it can resolve to a particular template. This is analogous to <code>resolvers</code> resolving a <code>ModuleID</code> from the Internet.
</p><p>The <code>Giter8TemplateResolver</code> takes the first argument that does not start with a hyphen (<code>-</code>), and checks whether it looks like
a GitHub repo or a git repo that ends in ”.g8”.
If it matches one of the patterns, it will pass the arguments to Giter8 to process.
</p><p>To create your own template resolver, create a library that has <code>template-resolver</code> as a dependency:
</p><pre><code class="prettyprint lang-scala">val templateResolverApi = &quot;org.scala-sbt&quot; % &quot;template-resolver&quot; % &quot;0.1&quot;
</code></pre><p>and extend <code>TemplateResolver</code>, which is defined as:
</p><pre><code class="prettyprint lang-java">package sbt.template;

/** A way of specifying template resolver.
 */
public interface TemplateResolver {
  /** Returns true if this resolver can resolve the given argument.
   */
  public boolean isDefined(String[] arguments);
  /** Resolve the given argument and run the template.
   */
  public void run(String[] arguments);
}
</code></pre><p>Publish the library to sbt community repo or Maven Central.
</p><h4 id="templateResolverInfos">templateResolverInfos<a href="#templateResolverInfos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Next, create an sbt plugin that adds a <code>TemplateResolverInfo</code> to <code>templateResolverInfos</code>.
</p><pre><code class="prettyprint lang-scala">import Def.Setting
import Keys._

/** An experimental plugin that adds the ability for Giter8 templates to be resolved
 */
object Giter8TemplatePlugin extends AutoPlugin {
  override def requires = CorePlugin
  override def trigger = allRequirements

  override lazy val globalSettings: Seq[Setting[_]] =
    Seq(
      templateResolverInfos +=
        TemplateResolverInfo(ModuleID(&quot;org.scala-sbt.sbt-giter8-resolver&quot;, &quot;sbt-giter8-resolver&quot;, &quot;0.1.0&quot;) cross CrossVersion.binary,
          &quot;sbtgiter8resolver.Giter8TemplateResolver&quot;)
    )
}
</code></pre><p>This indirecton allows template resolvers to have a classpath independent from the rest of the build.
</p><h2 id="Cross+building+plugins">Cross building plugins<a href="#Cross+building+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Like we are able to cross build against multiple Scala versions, we can cross build sbt 0.13 plugins while staying on sbt 1.x.
</p><pre><code class="prettyprint lang-scala">crossSbtVersions := Vector(&quot;1.2.8&quot;, &quot;0.13.18&quot;)
</code></pre><p>If you need to make changes specific to a sbt version, you can now include them into <code>src/main/scala-sbt-0.13</code>
and <code>src/main/scala-sbt-1.0</code>. To switch between the sbt versions use
</p><pre><code class="">^^ 0.13.18

[info] Setting `sbtVersion in pluginCrossBuild` to 0.13.18
[info] Set current project to sbt-something (in build file:/xxx/sbt-something/)
</code></pre><p>or <code>^compile</code> to cross compile.
</p><h3 id="Mixing+libraries+and+sbt+plugins+in+a+build">Mixing libraries and sbt plugins in a build<a href="#Mixing+libraries+and+sbt+plugins+in+a+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When you want to mix both libraries and sbt plugins into a multi-project build,
it’s more convenient to drive the sbt version based on the Scala version.
</p><p>You can do that as follows:
</p><pre><code class="prettyprint lang-scala">ThisBuild / crossScalaVersions := Seq(&quot;2.10.7&quot;, &quot;2.12.10&quot;)

lazy val core = (project in file(&quot;core&quot;))

lazy val plugin = (project in file(&quot;sbt-something&quot;))
  .enablePlugins(SbtPlugin)
  .dependsOn(core)
  .settings(
    // change the sbt version based on Scala version
    pluginCrossBuild / sbtVersion := {
      scalaBinaryVersion.value match {
        case &quot;2.10&quot; =&gt; &quot;0.13.18&quot;
        case &quot;2.12&quot; =&gt; &quot;1.2.8&quot;
      }
    }
  )
</code></pre><p>This is a technique discovered by <a href="https://github.com/jroper">@jroper</a> in <a href="https://github.com/sbt/sbt-pgp/pull/115">sbt-pgp#115</a>. It works because sbt 0.13 and 1.x series use different Scala binary versions.
</p><p>Using the setting, you can now use Scala cross building commands such as <code>+compile</code> and <code>+publish</code>.
</p><h2 id="How+to%E2%80%A6">How to…<a href="#How+to%E2%80%A6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>See <a href="Contents+in+Depth.html">Detailed Table of Contents</a> for the list of all the how-tos.
</p><h2 id="Classpaths">Classpaths<a href="#Classpaths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="classpath-types"></a><h3 id="Include+a+new+type+of+managed+artifact+on+the+classpath%2C+such+as">Include a new type of managed artifact on the classpath, such as <code>mar</code><a href="#Include+a+new+type+of+managed+artifact+on+the+classpath%2C+such+as" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>classpathTypes</code> setting controls the types of managed artifacts
that are included on the classpath by default. To add a new type, such
as <code>mar</code>,
</p><pre><code class="prettyprint lang-scala">classpathTypes += &quot;mar&quot;
</code></pre><a name="get-compile-classpath"></a><h3 id="Get+the+classpath+used+for+compilation">Get the classpath used for compilation<a href="#Get+the+classpath+used+for+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See the default types included by running <code>show classpathTypes</code> at the
sbt prompt.
</p><p>The <code>dependencyClasspath</code> task scoped to <code>Compile</code> provides the
classpath to use for compilation. Its type is <code>Seq[Attributed[File]]</code>,
which means that each entry carries additional metadata. The <code>files</code>
method provides just the raw <code>Seq[File]</code> for the classpath. For example,
to use the files for the compilation classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (Compile / dependencyClasspath).value.files
  ...
}
</code></pre><blockquote><p><strong>Note</strong>: This classpath does not include the class directory, which may be
necessary for compilation in some situations.
</p></blockquote><a name="get-runtime-classpath"></a><h3 id="Get+the+runtime+classpath%2C+including+the+project%E2%80%99s+compiled+classes">Get the runtime classpath, including the project’s compiled classes<a href="#Get+the+runtime+classpath%2C+including+the+project%E2%80%99s+compiled+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fullClasspath</code> task provides a classpath including both the
dependencies and the products of project. For the runtime classpath,
this means the main resources and compiled classes for the project as
well as all runtime dependencies.
</p><p>The type of a classpath is <code>Seq[Attributed[File]]</code>, which means that
each entry carries additional metadata. The <code>files</code> method provides just
the raw <code>Seq[File]</code> for the classpath. For example, to use the files for
the runtime classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (fullClasspath in Runtime).value.files
  ...
}
</code></pre><a name="get-test-classpath"></a><h3 id="Get+the+test+classpath%2C+including+the+project%E2%80%99s+compiled+test+classes">Get the test classpath, including the project’s compiled test classes<a href="#Get+the+test+classpath%2C+including+the+project%E2%80%99s+compiled+test+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fullClasspath</code> task provides a classpath including both the
dependencies and the products of a project. For the test classpath, this
includes the main and test resources and compiled classes for the
project as well as all dependencies for testing.
</p><p>The type of a classpath is <code>Seq[Attributed[File]]</code>, which means that
each entry carries additional metadata. The <code>files</code> method provides just
the raw <code>Seq[File]</code> for the classpath. For example, to use the files for
the test classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (Test / fullClasspath).value.files
  ...
}
</code></pre><a name="export-jars"></a><h3 id="Use+packaged+jars+on+classpaths+instead+of+class+directories">Use packaged jars on classpaths instead of class directories<a href="#Use+packaged+jars+on+classpaths+instead+of+class+directories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, <code>fullClasspath</code> includes a directory containing class files
and resources for a project. This in turn means that tasks like
<code>compile</code>, <code>test</code>, and <code>run</code> have these class directories on their
classpath. To use the packaged artifact (such as a jar) instead,
configure <code>exportJars</code> :
</p><pre><code class="prettyprint lang-scala">exportJars := true
</code></pre><p>This will use the result of <code>packageBin</code> on the classpath instead of the
class directory.
</p><blockquote><p><strong>Note</strong>: Specifically, fullClasspath is the concatenation of
dependencyClasspath and exportedProducts. When exportJars is true,
exportedProducts is the output of packageBin. When exportJars is
false, exportedProducts is just products, which is by default the
directory containing class files and resources.
</p></blockquote><a name="managed-jars-in-config"></a><h3 id="Get+all+managed+jars+for+a+configuration">Get all managed jars for a configuration<a href="#Get+all+managed+jars+for+a+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The result of the <code>update</code> task has type
<a href="Update-Report.html">UpdateReport</a>, which contains the
results of dependency resolution. This can be used to extract the files
for specific types of artifacts in a specific configuration. For
example, to get the jars and zips of dependencies in the <code>Compile</code>
configuration, :
</p><pre><code class="prettyprint lang-scala">example := {
   val artifactTypes = Set(&quot;jar&quot;, &quot;zip&quot;)
   val files =
      Classpaths.managedJars(Compile, artifactTypes, update.value)
   ...
}
</code></pre><a name="classpath-files"></a><h3 id="Get+the+files+included+in+a+classpath">Get the files included in a classpath<a href="#Get+the+files+included+in+a+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A classpath has type <code>Seq[Attributed[File]]</code>, which means that each
entry carries additional metadata. The <code>files</code> method provides just the
raw <code>Seq[File]</code> for the classpath. For example, :
</p><pre><code class="prettyprint lang-scala">val cp: Seq[Attributed[File]] = ...
val files: Seq[File] = cp.files
</code></pre><a name="classpath-entry-module"></a><h3 id="Get+the+module+and+artifact+that+produced+a+classpath+entry">Get the module and artifact that produced a classpath entry<a href="#Get+the+module+and+artifact+that+produced+a+classpath+entry" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A classpath has type <code>Seq[Attributed[File]]</code>, which means that each
entry carries additional metadata. This metadata is in the form of an
<a href="../api/sbt/internal/util/AttributeMap.html">AttributeMap</a>. Useful keys for
entries in the map are <code>artifact.key</code>, <code>moduleID.key</code>, and <code>analysis</code>. For
example,
</p><pre><code class="prettyprint lang-scala">val classpath: Seq[Attributed[File]] = ???
for(entry &lt;- classpath) yield {
   val art: Option[Artifact] = entry.get(artifact.key)
   val mod: Option[ModuleID] = entry.get(moduleID.key)
   val an: Option[inc.Analysis] = entry.get(analysis)
   ...
}
</code></pre><blockquote><p><strong>Note</strong>: Entries may not have some or all metadata. Only entries from source
dependencies, such as internal projects, have an incremental
compilation <a href="../api/sbt/internal/inc/Analysis.html">Analysis</a>. Only entries
for managed dependencies have an
<a href="../api/sbt/librarymanagement/Artifact.html">Artifact</a> and
<a href="../api/sbt/librarymanagement/ModuleID.html">ModuleID</a>.
</p></blockquote><h2 id="Customizing+paths">Customizing paths<a href="#Customizing+paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes how to modify the default source, resource, and
library directories and what files get included from them.
</p><a name="scala-source-directory"></a><h3 id="Change+the+default+Scala+source+directory">Change the default Scala source directory<a href="#Change+the+default+Scala+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main Scala sources is by default
<code>src/main/scala</code>. For test Scala sources, it is <code>src/test/scala</code>. To
change this, modify <code>scalaSource</code> in the <code>Compile</code> (for main sources) or
<code>Test</code> (for test sources). For example,
</p><pre><code class="prettyprint lang-scala">Compile / scalaSource := baseDirectory.value / &quot;src&quot;

Test / scalaSource := baseDirectory.value / &quot;test-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: The Scala source directory can be the same as the Java source
directory.
</p></blockquote><a name="java-source-directory"></a><h3 id="Change+the+default+Java+source+directory">Change the default Java source directory<a href="#Change+the+default+Java+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main Java sources is by default
<code>src/main/java</code>. For test Java sources, it is <code>src/test/java</code>. To change
this, modify <code>javaSource</code> in the <code>Compile</code> (for main sources) or <code>Test</code>
(for test sources).
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">Compile / javaSource := baseDirectory.value / &quot;src&quot;

Test / javaSource := baseDirectory.value / &quot;test-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: The Scala source directory can be the same as the Java source
directory.
</p></blockquote><a name="resource-directory"></a><h3 id="Change+the+default+resource+directory">Change the default resource directory<a href="#Change+the+default+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main resources is by default
<code>src/main/resources</code>. For test resources, it is <code>src/test/resources</code>. To
change this, modify <code>resourceDirectory</code> in either the <code>Compile</code> or
<code>Test</code> configuration.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">Compile / resourceDirectory := baseDirectory.value / &quot;resources&quot;

Test / resourceDirectory := baseDirectory.value / &quot;test-resources&quot;
</code></pre><a name="unmanaged-base-directory"></a><h3 id="Change+the+default+%28unmanaged%29+library+directory">Change the default (unmanaged) library directory<a href="#Change+the+default+%28unmanaged%29+library+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the unmanaged libraries is by default
<code>lib/</code>. To change this, modify <code>unmanagedBase</code>. This setting can be
changed at the project level or in the <code>Compile</code>, <code>Runtime</code>, or <code>Test</code>
configurations.
</p><p>When defined without a configuration, the directory is the default
directory for all configurations. For example, the following declares
<code>jars/</code> as containing libraries:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;jars&quot;
</code></pre><p>When set for <code>Compile</code>, <code>Runtime</code>, or <code>Test</code>, <code>unmanagedBase</code> is the
directory containing libraries for that configuration, overriding the
default. For example, the following declares <code>lib/main/</code> to contain jars
only for <code>Compile</code> and not for running or testing:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedBase := baseDirectory.value / &quot;lib&quot; / &quot;main&quot;
</code></pre><a name="disable-base-sources"></a><h3 id="Disable+using+the+project%E2%80%99s+base+directory+as+a+source+directory">Disable using the project’s base directory as a source directory<a href="#Disable+using+the+project%E2%80%99s+base+directory+as+a+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt includes <code>.scala</code> files from the project’s base
directory as main source files. To disable this, configure
<code>sourcesInBase</code>:
</p><pre><code class="prettyprint lang-scala">sourcesInBase := false
</code></pre><a name="add-source-directory"></a><h3 id="Add+an+additional+source+directory">Add an additional source directory<a href="#Add+an+additional+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt collects <code>sources</code> from <code>unmanagedSourceDirectories</code>, which by
default consists of <code>scalaSource</code> and <code>javaSource</code>. Add a directory to
<code>unmanagedSourceDirectories</code> in the appropriate configuration to add a
source directory. For example, to add <code>extra-src</code> to be an additional
directory containing main sources,
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedSourceDirectories += baseDirectory.value / &quot;extra-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: This directory should only contain unmanaged sources, which are
sources that are manually created and managed. See
[Generating Files][Howto-Generating-Files] for working with automatically generated sources.
</p></blockquote><a name="add-resource-directory"></a><h3 id="Add+an+additional+resource+directory">Add an additional resource directory<a href="#Add+an+additional+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt collects <code>resources</code> from <code>unmanagedResourceDirectories</code>, which by
default consists of <code>resourceDirectory</code>. Add a directory to
<code>unmanagedResourceDirectories</code> in the appropriate configuration to add
another resource directory. For example, to add <code>extra-resources</code> to be
an additional directory containing main resources,
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedResourceDirectories += baseDirectory.value / &quot;extra-resources&quot;
</code></pre><blockquote><p><strong>Note</strong>: This directory should only contain unmanaged resources, which are
resources that are manually created and managed. See
[Generating Files][Howto-Generating-Files] for working with automatically generated
resources.
</p></blockquote><a name="source-include-filter"></a><h3 id="Include%2Fexclude+files+in+the+source+directory">Include/exclude files in the source directory<a href="#Include%2Fexclude+files+in+the+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedSourceDirectories</code> for sources, it only
includes directories and files that match <code>includeFilter</code> and do not
match <code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores files containing <code>impl</code> in their
name,
</p><pre><code class="prettyprint lang-scala">unmanagedSources / excludeFilter := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedSources / includeFilter := &quot;*.scala&quot; || &quot;*.java&quot;
Test / unmanagedSources / includeFilter := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes <code>.scala</code> and <code>.java</code> sources, excluding hidden
files.
</p></blockquote><a name="resource-include-filter"></a><h3 id="Include%2Fexclude+files+in+the+resource+directory">Include/exclude files in the resource directory<a href="#Include%2Fexclude+files+in+the+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedResourceDirectories</code> for resources, it only
includes directories and files that match <code>includeFilter</code> and do not
match <code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores files containing <code>impl</code> in their
name,
</p><pre><code class="prettyprint lang-scala">unmanagedResources / excludeFilter := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedResources / includeFilter := &quot;*.txt&quot;
Test / unmanagedResources / includeFilter := &quot;*.html&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes all files that are not hidden.
</p></blockquote><a name="lib-include-filter"></a><h3 id="Include+only+certain+%28unmanaged%29+libraries">Include only certain (unmanaged) libraries<a href="#Include+only+certain+%28unmanaged%29+libraries" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedBase</code> for resources, it only includes
directories and files that match <code>includeFilter</code> and do not match
<code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores zips,
</p><pre><code class="prettyprint lang-scala">unmanagedJars / excludeFilter := HiddenFileFilter || &quot;*.zip&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedJars / includeFilter := &quot;*.jar&quot;
Test / unmanagedJars / includeFilter := &quot;*.jar&quot; || &quot;*.zip&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes jars, zips, and native dynamic libraries,
excluding hidden files.
</p></blockquote><h2 id="Generating+files">Generating files<a href="#Generating+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt provides standard hooks for adding source and resource generation
tasks.
</p><a name="sources"></a><h3 id="Generate+sources">Generate sources<a href="#Generate+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A source generation task should generate sources in a subdirectory of
<code>sourceManaged</code> and return a sequence of files generated. The signature
of a source generation function (that becomes a basis for a task) is
usually as follows:
</p><pre><code class="prettyprint lang-scala">def makeSomeSources(base: File): Seq[File]
</code></pre><p>The key to add the task to is called <code>sourceGenerators</code>. Because we want
to add the task, and not the value after its execution, we use
<code>taskValue</code> instead of the usual <code>value</code>. <code>sourceGenerators</code> should be
scoped according to whether the generated files are main (<code>Compile</code>) or
test (<code>Test</code>) sources. This basic structure looks like:
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += &lt;task of type Seq[File]&gt;.taskValue
</code></pre><p>For example, assuming a method
<code>def makeSomeSources(base: File): Seq[File]</code>,
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += Def.task {
  makeSomeSources((Compile / sourceManaged).value / &quot;demo&quot;)
}.taskValue
</code></pre><p>As a specific example, the following source generator generates
<code>Test.scala</code> application object that once executed, prints <code>&quot;Hi&quot;</code> to the
console:
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += Def.task {
  val file = (Compile / sourceManaged).value / &quot;demo&quot; / &quot;Test.scala&quot;
  IO.write(file, &quot;&quot;&quot;object Test extends App { println(&quot;Hi&quot;) }&quot;&quot;&quot;)
  Seq(file)
}.taskValue
</code></pre><p>Executing <code>run</code> will print <code>&quot;Hi&quot;</code>.
</p><pre><code class="">&gt; run
[info] Running Test
Hi
</code></pre><p>Change <code>Compile</code> to <code>Test</code> to make it a test source.
</p><p><strong>NOTE:</strong> For the efficiency of the build, <code>sourceGenerators</code> should avoid
regenerating source files upon each call. Instead, the outputs should be cached
based on the input values either using the <a href="Howto-Track-File-Inputs-and-Outputs.html">File tracking
system</a> or by manually
tracking the input values using <code>sbt.Tracked.{ inputChanged, outputChanged }</code>
etc.
</p><p>By default, generated sources are not included in the packaged source
artifact. To do so, add them as you would other mappings. See
<a href="Howto-Package.html#modify-package-contents">Adding files to a package</a>. A source
generator can return both Java and Scala sources mixed together in the
same sequence. They will be distinguished by their extension later.
</p><a name="resources"></a><h3 id="Generate+resources">Generate resources<a href="#Generate+resources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A resource generation task should generate resources in a subdirectory
of <code>resourceManaged</code> and return a sequence of files generated. Like a
source generation function, the signature of a resource generation
function (that becomes a basis for a task) is usually as follows:
</p><pre><code class="prettyprint lang-scala">def makeSomeResources(base: File): Seq[File]
</code></pre><p>The key to add the task to is called <code>resourceGenerators</code>. Because we
want to add the task, and not the value after its execution, we use
<code>taskValue</code> instead of the usual <code>value</code>. It should be scoped according
to whether the generated files are main (<code>Compile</code>) or test (<code>Test</code>)
resources. This basic structure looks like:
</p><pre><code class="prettyprint lang-scala">Compile / resourceGenerators += &lt;task of type Seq[File]&gt;.taskValue
</code></pre><p>For example, assuming a method
<code>def makeSomeResources(base: File): Seq[File]</code>,
</p><pre><code class="prettyprint lang-scala">Compile / resourceGenerators += Def.task {
  makeSomeResources((Compile / resourceManaged).value / &quot;demo&quot;)
}.taskValue
</code></pre><p>Executing <code>run</code> (or <code>package</code>, not <code>compile</code>) will add a file <code>demo</code> to
<code>resourceManaged</code>, which is <code>target/scala-*/resource_managed&quot;</code>. By default,
generated resources are not included in the packaged source artifact. To do so,
add them as you would other mappings.
See <a href="Howto-Package.html#modify-package-contents">Adding files to a package</a>.
</p><p>As a specific example, the following generates a properties file
<code>myapp.properties</code> containing the application name and version:
</p><pre><code class="prettyprint lang-scala">Compile / resourceGenerators += Def.task {
  val file = (Compile / resourceManaged).value / &quot;demo&quot; / &quot;myapp.properties&quot;
  val contents = &quot;name=%s\nversion=%s&quot;.format(name.value,version.value)
  IO.write(file, contents)
  Seq(file)
}.taskValue
</code></pre><p>Change <code>Compile</code> to <code>Test</code> to make it a test resource.
</p><p><strong>NOTE:</strong> For the efficiency of the build, <code>resourceGenerators</code> should avoid regenerating resource files upon each call,
and cache based on the input values using <code>sbt.Tracked.{ inputChanged, outputChanged }</code> etc instead.
</p><h2 id="Inspect+the+build">Inspect the build<a href="#Inspect+the+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="taskhelp"></a><h3 id="Show+or+search+help+for+a+command%2C+task%2C+or+setting">Show or search help for a command, task, or setting<a href="#Show+or+search+help+for+a+command%2C+task%2C+or+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>help</code> command is used to show available commands and search the
help for commands, tasks, or settings. If run without arguments, <code>help</code>
lists the available commands.
</p><pre><code class="">&gt; help

  help                         Displays this help message or prints detailed help on 
                                  requested commands (run 'help &lt;command&gt;').
  about                        Displays basic information about sbt and the build.
  reload                       (Re)loads the project in the current directory
  ...

&gt; help compile
</code></pre><p>If the argument passed to <code>help</code> is the name of an existing command,
setting or task, the help for that entity is displayed. Otherwise, the
argument is interpreted as a regular expression that is used to search
the help of all commands, settings and tasks.
</p><p>The <code>tasks</code> command is like <code>help</code>, but operates only on tasks.
Similarly, the <code>settings</code> command only operates on settings.
</p><p>See also <code>help help</code>, <code>help tasks</code>, and <code>help settings</code>.
</p><a name="listtasks"></a><h3 id="List+available+tasks">List available tasks<a href="#List+available+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>tasks</code> command, without arguments, lists the most commonly used
tasks. It can take a regular expression to search task names and
descriptions. The verbosity can be increased to show or search less
commonly used tasks. See <code>help tasks</code> for details.
</p><p>The <code>settings</code> command, without arguments, lists the most commonly used
settings. It can take a regular expression to search setting names and
descriptions. The verbosity can be increased to show or search less
commonly used settings. See <code>help settings</code> for details.
</p><a name="listsettings"></a><h3 id="List+available+settings">List available settings<a href="#List+available+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command displays several pieces of information about a
given setting or task, including the dependencies of a task/setting as
well as the tasks/settings that depend on the it. For example,
</p><pre><code class="">&gt; inspect test:compile
...
[info] Dependencies:
[info]  Test / manipulateBytecode
[info]  Test / enableBinaryCompileAnalysis
[info]  Test / compileIncSetup
[info] Reverse dependencies:
[info]  Test / products
[info]  Test / discoveredMainClasses
[info]  Test / printWarnings
[info]  Test / definedTestNames
[info]  Test / definedTests
...
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="taskdependencytree"></a><h3 id="Display+tree+of+setting%2Ftask+dependencies">Display tree of setting/task dependencies<a href="#Display+tree+of+setting%2Ftask+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to displaying immediate forward and reverse dependencies as
described in the previous section, the <code>inspect</code> command can display the
full dependency tree for a task or setting. For example,
</p><pre><code class="">&gt; inspect tree clean
[info] clean = Task[Unit]
[info]   +-clean / streams = Task[sbt.std.TaskStreams[sbt.internal.util.Init$ScopedKey[_ &lt;: Any]]]
[info]   | +-Global / streamsManager = Task[sbt.std.Streams[sbt.internal.util.Init$ScopedKey[_ &lt;: Any]]]
[info]   | 
[info]   +-cleanFiles = Task[scala.collection.Seq[java.io.File]]
[info]   | +-cleanKeepFiles = Vector(&lt;project&gt;/target/.history)
[info]   | | +-history = Some(&lt;project&gt;/target/.history)
[info]   | |   +-target = target
[info]   | |     +-baseDirectory = 
...
</code></pre><p>For each task, <code>inspect tree</code> show the type of the value generated by
the task. For a setting, the <code>toString</code> of the setting is displayed. See
the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details on the
<code>inspect</code> command.
</p><a name="description"></a><h3 id="Display+the+description+and+type+of+a+setting+or+task">Display the description and type of a setting or task<a href="#Display+the+description+and+type+of+a+setting+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>While the <code>help</code>, <code>settings</code>, and <code>tasks</code> commands display a description
of a task, the <code>inspect</code> command also shows the type of a setting or
task and the value of a setting. For example:
</p><pre><code class="">&gt; inspect update
[info] Task: sbt.librarymanagement.UpdateReport
[info] Description:
[info]  Resolves and optionally retrieves dependencies, producing a report.
...
</code></pre><pre><code class="">&gt; inspect scalaVersion
[info] Setting: java.lang.String = 2.12.6
[info] Description:
[info]  The version of Scala used for building.
...
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="delegates"></a><h3 id="Display+the+delegation+chain+of+a+setting+or+task">Display the delegation chain of a setting or task<a href="#Display+the+delegation+chain+of+a+setting+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="related"></a><h3 id="Display+related+settings+or+tasks">Display related settings or tasks<a href="#Display+related+settings+or+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command can help find scopes where a setting or task is
defined. The following example shows that different options may be
specified to the Scala for testing and API documentation generation.
</p><pre><code class="">&gt; inspect scalacOptions
...
[info] Related:
[info]  Compile / scalacOptions
[info]  Global / scalacOptions
[info]  Test / scalacOptions
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="projects"></a><h3 id="Show+the+list+of+projects+and+builds">Show the list of projects and builds<a href="#Show+the+list+of+projects+and+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>projects</code> command displays the currently loaded projects. The
projects are grouped by their enclosing build and the current project is
indicated by an asterisk. For example,
</p><pre><code class="">&gt; projects
[info] In file:/home/user/demo/
[info]   * parent
[info]     sub
[info] In file:/home/user/dep/
[info]     sample
</code></pre><a name="session"></a><h3 id="Show+the+current+session+%28temporary%29+settings">Show the current session (temporary) settings<a href="#Show+the+current+session+%28temporary%29+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>session list</code> displays the settings that have been added at the command
line for the current project. For example,
</p><pre><code class="">&gt; session list
  1. maxErrors := 5
  2. scalacOptions += &quot;-explaintypes&quot;
</code></pre><p><code>session list-all</code> displays the settings added for all projects. For
details, see <code>help session</code>.
</p><a name="about"></a><h3 id="Show+basic+information+about+sbt+and+the+current+build">Show basic information about sbt and the current build<a href="#Show+basic+information+about+sbt+and+the+current+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; about
[info] This is sbt 1.1.5
[info] The current project is {file:~/code/sbt.github.com/}default
[info] The current project is built against Scala 2.12.6
[info] Available Plugins: sbt.plugins.IvyPlugin, sbt.plugins.JvmPlugin, sbt.plugins.CorePlugin, sbt.plugins.JUnitXmlReportPlugin, sbt.plugins.Giter8TemplatePlugin
[info] sbt, sbt plugins, and build definitions are using Scala 2.12.6
</code></pre><a name="value"></a><h3 id="Show+the+value+of+a+setting">Show the value of a setting<a href="#Show+the+value+of+a+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command shows the value of a setting as part of its
output, but the <code>show</code> command is dedicated to this job. It shows the
output of the setting provided as an argument. For example,
</p><pre><code class="">&gt; show organization
[info] com.github.sbt 
</code></pre><p>The <code>show</code> command also works for tasks, described next.
</p><a name="result"></a><h3 id="Show+the+result+of+executing+a+task">Show the result of executing a task<a href="#Show+the+result+of+executing+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; show update
... &lt;output of update&gt; ...
[info] Update report:
[info]  Resolve time: 122 ms, Download time: 5 ms, Download size: 0 bytes
[info]  compile:
[info]      org.scala-lang:scala-library:
[info]              - 2.12.6
[info] ...
</code></pre><p>The <code>show</code> command will execute the task provided as an argument and
then print the result. Note that this is different from the behavior of
the <code>inspect</code> command (described in other sections), which does not
execute a task and thus can only display its type and not its generated
value.
</p><pre><code class="">&gt; show compile:dependencyClasspath
...
[info] ArrayBuffer(Attributed(/Users/foo/.sbt/boot/scala-2.12.6/lib/scala-library.jar))
</code></pre><a name="classpath"></a><h3 id="Show+the+classpath+used+for+compilation+or+testing">Show the classpath used for compilation or testing<a href="#Show+the+classpath+used+for+compilation+or+testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For the test classpath,
</p><pre><code class="">&gt; show test:dependencyClasspath
...
[info] List(Attributed(/Users/foo/code/sbt.github.com/target/scala-2.12/classes), Attributed(~/.sbt/boot/scala-2.12.6/lib/scala-library.jar), Attributed(/Users/foo/.ivy2/cache/junit/junit/jars/junit-4.8.2.jar))
...
</code></pre><a name="applications"></a><h3 id="Show+the+main+classes+detected+in+a+project">Show the main classes detected in a project<a href="#Show+the+main+classes+detected+in+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt detects the classes with public, static main methods for use by the
<code>run</code> method and to tab-complete the <code>runMain</code> method. The
<code>discoveredMainClasses</code> task does this discovery and provides as its
result the list of class names. For example, the following shows the
main classes discovered in the main sources:
</p><pre><code class="">&gt; show compile:discoveredMainClasses
... &lt;runs compile if out of date&gt; ...
[info] List(org.example.Main)
</code></pre><a name="tests"></a><h3 id="Show+the+test+classes+detected+in+a+project">Show the test classes detected in a project<a href="#Show+the+test+classes+detected+in+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt detects tests according to fingerprints provided by test frameworks.
The <code>definedTestNames</code> task provides as its result the list of test
names detected in this way. For example,
</p><pre><code class="">&gt; show test:definedTestNames
... &lt; runs test:compile if out of date &gt; ...
[info] List(org.example.TestA, org.example.TestB)
</code></pre><h2 id="Interactive+mode">Interactive mode<a href="#Interactive+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="basic_completion"></a><h3 id="Use+tab+completion">Use tab completion<a href="#Use+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt’s interactive mode is started when no commands are
provided on the command line or when the <code>shell</code> command is invoked.
</p><p>As the name suggests, tab completion is invoked by hitting the tab key.
Suggestions are provided that can complete the text entered to the left
of the current cursor position. Any part of the suggestion that is
unambiguous is automatically appended to the current text. Commands
typically support tab completion for most of their syntax.
</p><p>As an example, entering <code>tes</code> and hitting tab:
</p><pre><code class="">&gt; tes&lt;TAB&gt;
</code></pre><p>results in sbt appending a <code>t</code>:
</p><pre><code class="">&gt; test
</code></pre><p>To get further completions, hit tab again:
</p><pre><code class="">&gt; test&lt;TAB&gt;
testFrameworks   testListeners    testLoader       testOnly         testOptions      test:
</code></pre><p>Now, there is more than one possibility for the next character, so sbt
prints the available options. We will select <code>testOnly</code> and get more
suggestions by entering the rest of the command and hitting tab twice:
</p><pre><code class="">&gt; testOnly&lt;TAB&gt;&lt;TAB&gt;
--                      sbt.DagSpecification    sbt.EmptyRelationTest   sbt.KeyTest             sbt.RelationTest        sbt.SettingsTest
</code></pre><p>The first tab inserts an unambiguous space and the second suggests names
of tests to run. The suggestion of <code>--</code> is for the separator between
test names and options provided to the test framework. The other
suggestions are names of test classes for one of sbt’s modules. Test
name suggestions require tests to be compiled first. If tests have been
added, renamed, or removed since the last test compilation, the
completions will be out of date until another successful compile.
</p><a name="verbose_completion"></a><h3 id="Show+more+tab+completion+suggestions">Show more tab completion suggestions<a href="#Show+more+tab+completion+suggestions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Some commands have different levels of completion. Hitting tab multiple
times increases the verbosity of completions. (Presently, this feature
is only used by the <code>set</code> command.)
</p><a name="change_keybindings"></a><h3 id="Modify+the+default+JLine+keybindings">Modify the default JLine keybindings<a href="#Modify+the+default+JLine+keybindings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>JLine, used by both Scala and sbt, uses a configuration file for many of
its keybindings. The location of this file can be changed with the
system property <code>jline.keybindings</code>. The default keybindings file is
included in the sbt launcher and may be used as a starting point for
customization.
</p><a name="prompt"></a><h3 id="Configure+the+prompt+string">Configure the prompt string<a href="#Configure+the+prompt+string" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt only displays <code>&gt;</code> to prompt for a command. This can be
changed through the <code>shellPrompt</code> setting, which has type
<code>State =&gt; String</code>. <a href="Build-State.html">State</a> contains all state
for sbt and thus provides access to all build information for use in the
prompt string.
</p><p>Examples:
</p><pre><code class="prettyprint lang-scala">// set the prompt (for this build) to include the project id.
shellPrompt in ThisBuild := { state =&gt; Project.extract(state).currentRef.project + &quot;&gt; &quot; }

// set the prompt (for the current project) to include the username
shellPrompt := { state =&gt; System.getProperty(&quot;user.name&quot;) + &quot;&gt; &quot; }
</code></pre><a name="history"></a><h3 id="Use+history">Use history<a href="#Use+history" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="Running.html#history">sbt shell history</a>.
</p><a name="history_file"></a><h3 id="Change+the+location+of+the+interactive+history+file">Change the location of the interactive history file<a href="#Change+the+location+of+the+interactive+history+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, interactive history is stored in the <code>target/</code> directory for
the current project (but is not removed by a <code>clean</code>). History is thus
separate for each subproject. The location can be changed with the
<code>historyPath</code> setting, which has type <code>Option[File]</code>. For example,
history can be stored in the root directory for the project instead of
the output directory:
</p><pre><code class="prettyprint lang-scala">historyPath := Some(baseDirectory.value / &quot;.history&quot;)
</code></pre><p>The history path needs to be set for each project, since sbt will use
the value of <code>historyPath</code> for the current project (as selected by the
<code>project</code> command).
</p><a name="share_history"></a><h3 id="Use+the+same+history+for+all+projects">Use the same history for all projects<a href="#Use+the+same+history+for+all+projects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The previous section describes how to configure the location of the
history file. This setting can be used to share the interactive history
among all projects in a build instead of using a different history for
each project. The way this is done is to set <code>historyPath</code> to be the
same file, such as a file in the root project’s <code>target/</code> directory:
</p><pre><code class="prettyprint lang-scala">historyPath :=
  Some( (target in LocalRootProject).value / &quot;.history&quot;)
</code></pre><p>The <code>in LocalRootProject</code> part means to get the output directory for the
root project for the build.
</p><a name="disable_history"></a><h3 id="Disable+interactive+history">Disable interactive history<a href="#Disable+interactive+history" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If, for whatever reason, you want to disable history, set <code>historyPath</code>
to <code>None</code> in each project it should be disabled in:
</p><pre><code class="">&gt; historyPath := None
</code></pre><a name="pre_commands"></a><h3 id="Run+commands+before+entering+interactive+mode">Run commands before entering interactive mode<a href="#Run+commands+before+entering+interactive+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Interactive mode is implemented by the <code>shell</code> command. By default, the
<code>shell</code> command is run if no commands are provided to sbt on the command
line. To run commands before entering interactive mode, specify them on
the command line followed by <code>shell</code>. For example,
</p><pre><code class="">$ sbt clean compile shell
</code></pre><p>This runs <code>clean</code> and then <code>compile</code> before entering the interactive
prompt. If either <code>clean</code> or <code>compile</code> fails, sbt will exit without
going to the prompt. To enter the prompt whether or not these initial
commands succeed, prepend <code>&quot;onFailure shell&quot;</code>, which means to run <code>shell</code> if any
command fails. For example,
</p><pre><code class="">$ sbt &quot;onFailure shell&quot; clean compile shell
</code></pre><h2 id="Configure+and+use+logging">Configure and use logging<a href="#Configure+and+use+logging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="last"></a><h3 id="View+the+logging+output+of+the+previously+executed+command">View the logging output of the previously executed command<a href="#View+the+logging+output+of+the+previously+executed+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When a command is run, more detailed logging output is sent to a file
than to the screen (by default). This output can be recalled for the
command just executed by running <code>last</code>.
</p><p>For example, the output of <code>run</code> when the sources are up to date is:
</p><pre><code class="">&gt; run
[info] Running A
Hi!
[success] Total time: 0 s, completed Feb 25, 2012 1:00:00 PM
</code></pre><p>The details of this execution can be recalled by running <code>last</code>:
</p><pre><code class="">&gt; last
[debug] Running task... Cancelable: false, max worker threads: 4, check cycles: false
[debug]
[debug] Initial source changes:
[debug]     removed:Set()
[debug]     added: Set()
[debug]     modified: Set()
[debug] Removed products: Set()
[debug] Modified external sources: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated sources: Set()
[debug]
[debug] Sources indirectly invalidated by:
[debug]     product: Set()
[debug]     binary dep: Set()
[debug]     external source: Set()
[debug] Initially invalidated: Set()
[debug] Copy resource mappings:
[debug]
[info] Running A
[debug] Starting sandboxed run...
[debug] Waiting for threads to exit or System.exit to be called.
[debug]   Classpath:
[debug]     /tmp/e/target/scala-2.9.2/classes
[debug]     /tmp/e/.sbt/0.12.0/boot/scala-2.9.2/lib/scala-library.jar
[debug] Waiting for thread runMain to exit
[debug]     Thread runMain exited.
[debug] Interrupting remaining threads (should be all daemons).
[debug] Sandboxed run complete..
[debug] Exited with code 0
[success] Total time: 0 s, completed Jan 1, 2012 1:00:00 PM
</code></pre><p>Configuration of the logging level for the console and for the backing
file are described in following sections.
</p><a name="tasklast"></a><h3 id="View+the+previous+logging+output+of+a+specific+task">View the previous logging output of a specific task<a href="#View+the+previous+logging+output+of+a+specific+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When a task is run, more detailed logging output is sent to a file than
to the screen (by default). This output can be recalled for a specific
task by running <code>last &lt;task&gt;</code>. For example, the first time <code>compile</code> is
run, output might look like:
</p><pre><code class="">&gt; compile
[info] Updating {file:/.../demo/}example...
[info] Resolving org.scala-lang#scala-library;2.9.2 ...
[info] Done updating.
[info] Compiling 1 Scala source to .../demo/target/scala-2.9.2/classes...
[success] Total time: 0 s, completed Jun 1, 2012 1:11:11 PM
</code></pre><p>The output indicates that both dependency resolution and compilation
were performed. The detailed output of each of these may be recalled
individually. For example,
</p><pre><code class="">&gt; last compile
[debug]
[debug] Initial source changes:
[debug]     removed:Set()
[debug]     added: Set(/home/mark/tmp/a/b/A.scala)
[debug]     modified: Set()
...
</code></pre><p>and:
</p><pre><code class="">&gt; last update
[info] Updating {file:/.../demo/}example...
[debug] post 1.3 ivy file: using exact as default matcher
[debug] :: resolving dependencies :: example#example_2.9.2;0.1-SNAPSHOT
[debug]     confs: [compile, runtime, test, provided, optional, compile-internal, runtime-internal, test-internal, plugin, sources, docs, pom]
[debug]     validate = true
[debug]     refresh = false
[debug] resolving dependencies for configuration 'compile'
...
</code></pre><a name="printwarnings"></a><h3 id="Show+warnings+from+the+previous+compilation">Show warnings from the previous compilation<a href="#Show+warnings+from+the+previous+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Scala compiler does not print the full details of warnings by
default. Compiling code that uses the deprecated <code>error</code> method from
Predef might generate the following output:
</p><pre><code class="">&gt; compile
[info] Compiling 1 Scala source to &lt;...&gt;/classes...
[warn] there were 1 deprecation warnings; re-run with -deprecation for details
[warn] one warning found
</code></pre><p>The details aren’t provided, so it is necessary to add <code>-deprecation</code> to
the options passed to the compiler (<code>scalacOptions</code>) and recompile. An
alternative when using Scala 2.10 and later is to run <code>printWarnings</code>.
This task will display all warnings from the previous compilation. For
example,
</p><pre><code class="">&gt; printWarnings
[warn] A.scala:2: method error in object Predef is deprecated: Use sys.error(message) instead
[warn]  def x = error(&quot;Failed.&quot;)
[warn]          ^
</code></pre><a name="level"></a><h3 id="Change+the+logging+level+globally">Change the logging level globally<a href="#Change+the+logging+level+globally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The quickest way to change logging levels is by using the <code>error</code>,
<code>warn</code>, <code>info</code>, or <code>debug</code> commands. These set the default logging level
for commands and tasks. For example,
</p><pre><code class="">&gt; warn
</code></pre><p>will by default show only warnings and errors. To set the logging level
before any commands are executed on startup, use <code>--</code> before the logging
level. For example,
</p><pre><code class="">$ sbt --warn
&gt; compile
[warn] there were 2 feature warning(s); re-run with -feature for details
[warn] one warning found
[success] Total time: 4 s, completed ...
&gt;
</code></pre><p>The logging level can be overridden at a finer granularity, which is
described next.
</p><a name="tasklevel"></a><h3 id="Change+the+logging+level+for+a+specific+task%2C+configuration%2C+or+project">Change the logging level for a specific task, configuration, or project<a href="#Change+the+logging+level+for+a+specific+task%2C+configuration%2C+or+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The amount of logging is controlled by the <code>logLevel</code> setting, which
takes values from the <code>Level</code> enumeration. Valid values are <code>Error</code>,
<code>Warn</code>, <code>Info</code>, and <code>Debug</code> in order of increasing verbosity. The
logging level may be configured globally, as described in the previous
section, or it may be applied to a specific project, configuration, or
task. For example, to change the logging level for compilation to only
show warnings and errors:
</p><pre><code class="prettyprint lang-scala">&gt; set Compile / compile / logLevel := Level.Warn
</code></pre><p>To enable debug logging for all tasks in the current project,
</p><pre><code class="prettyprint lang-scala">&gt; set logLevel := Level.Warn
</code></pre><p>A common scenario is that after running a task, you notice that you need
more information than was shown by default. A <code>logLevel</code> based solution
typically requires changing the logging level and running a task again.
However, there are two cases where this is unnecessary. First, warnings
from a previous compilation may be displayed using <code>printWarnings</code> for
the main sources or <code>test:printWarnings</code> for test sources. Second,
output from the previous execution is available either for a single task
or for in its entirety. See the section on
<a href="#printwarnings">printWarnings</a> and the sections on
<a href="#last">previous output</a>.
</p><a name="trace"></a><h3 id="Configure+printing+of+stack+traces">Configure printing of stack traces<a href="#Configure+printing+of+stack+traces" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt hides the stack trace of most exceptions thrown during
execution. It prints a message that indicates how to display the
exception. However, you may want to show more of stack traces by
default.
</p><p>The setting to configure is <code>traceLevel</code>, which is a setting with an Int
value. When <code>traceLevel</code> is set to a negative value, no stack traces are
shown. When it is zero, the stack trace is displayed up to the first sbt
stack frame. When positive, the stack trace is shown up to that many
stack frames.
</p><p>For example, the following configures sbt to show stack traces up to the
first sbt frame:
</p><pre><code class="prettyprint lang-scala">&gt; set every traceLevel := 0
</code></pre><p>The <code>every</code> part means to override the setting in all scopes. To change
the trace printing behavior for a single project, configuration, or
task, scope <code>traceLevel</code> appropriately:
</p><pre><code class="prettyprint lang-scala">&gt; set Test / traceLevel := 5
&gt; set update / traceLevel := 0
&gt; set ThisProject / traceLevel := -1
</code></pre><a name="nobuffer"></a><h3 id="Print+the+output+of+tests+immediately+instead+of+buffering">Print the output of tests immediately instead of buffering<a href="#Print+the+output+of+tests+immediately+instead+of+buffering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt buffers the logging output of a test until the whole
class finishes. This is so that output does not get mixed up when
executing in parallel. To disable buffering, set the <code>logBuffered</code>
setting to false:
</p><pre><code class="prettyprint lang-scala">logBuffered := false
</code></pre><a name="custom"></a><h3 id="Add+a+custom+logger">Add a custom logger<a href="#Add+a+custom+logger" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The setting <code>extraLoggers</code> can be used to add custom loggers. Internally, sbt
makes use of the <a href="https://logging.apache.org/log4j/2.x/">log4j2 library</a>, so a custom
logger should implement <a href="https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/Appender.html"><code>org.apache.logging.log4j.core.Appender</code></a>,
usually by extending <a href="https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/AbstractAppender.html"><code>AbstractAppender</code></a>.
</p><p><code>extraLoggers</code> is a function
<code>ScopedKey[_] =&gt; Seq[Appender]</code>. This means that it can provide
different logging based on the task that requests the logger.
</p><pre><code class="prettyprint lang-scala">extraLoggers := {
  val currentFunction = extraLoggers.value
    (key: ScopedKey[_]) =&gt; {
        myCustomLogger(key) +: currentFunction(key)
    }
}
</code></pre><p>Here, we take the current function <code>currentFunction</code> for the setting and
provide a new function. The new function prepends our custom logger to
the ones provided by the old function.
</p><p>An <code>Appender</code> in log4j2 appends a <a href="https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/LogEvent.html"><code>LogEvent</code></a>,
whose core internally is a <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/Message.html"><code>Message</code></a>. There can
be many types of Message, but sbt generates events containing instances of <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/ObjectMessage.html"><code>ObjectMessage</code></a>,
containing a payload that can be retrieved by calling <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/ObjectMessage.html#getParameter--"><code>getParameter()</code></a>.
</p><p>The payload emitted by sbt logging is an instance of <a href="https://github.com/sbt/util/blob/develop/internal/util-logging/src/main/contraband-scala/sbt/internal/util/StringEvent.scala"><code>StringEvent</code></a>,
which contains <code>String</code> fields including <code>message</code> and <code>level</code>.
</p><p>Putting all that together, here’s a (completely useless!) example of an extra logger that logs messages from tasks in reverse to the console:
</p><pre><code class="prettyprint lang-scala">extraLoggers := {
  import org.apache.logging.log4j.core.LogEvent;
  import org.apache.logging.log4j.core.appender.AbstractAppender
  import org.apache.logging.log4j.message.{Message,ObjectMessage}

  import sbt.internal.util.StringEvent

  def loggerNameForKey( key : sbt.Def.ScopedKey[_] ) = s&quot;&quot;&quot;reverse.${key.scope.task.toOption.getOrElse(&quot;&lt;unknown&gt;&quot;)}&quot;&quot;&quot;

  class ReverseConsoleAppender( key : ScopedKey[_] ) extends AbstractAppender (
    loggerNameForKey( key ), // name : String
    null,                    // filter : org.apache.logging.log4j.core.Filter
    null,                    // layout : org.apache.logging.log4j.core.Layout[ _ &lt;: Serializable]
    false                    // ignoreExceptions : Boolean
  ) {

    this.start() // the log4j2 Appender must be started, or it will fail with an Exception

    override def append( event : LogEvent ) : Unit = {
      val output = {
        def forUnexpected( message : Message ) = s&quot;[${this.getName()}] Unexpected: ${message.getFormattedMessage()}&quot;
        event.getMessage() match {
	   case om : ObjectMessage =&gt; { // what we expect
	     om.getParameter() match {
	       case se : StringEvent =&gt; s&quot;[${this.getName()} - ${se.level}] ${se.message.reverse}&quot;
	       case other            =&gt; forUnexpected( om )
	     }
	   }
	   case unexpected : Message =&gt; forUnexpected( unexpected )
	}
      }
      System.out.synchronized { // sbt adopts a convention of acquiring System.out's monitor printing to the console
         println( output )
      }
    }
  }

  val currentFunction = extraLoggers.value
  (key: ScopedKey[_]) =&gt; {
     new ReverseConsoleAppender(key) +: currentFunction(key)
  }
}
</code></pre><p>Now, if we execute a task that logs messages, we should see our logger invoked:
</p><pre><code class="">sbt:sbt-logging-example&gt; update
[info] Updating ...
[reverse.update - info] ... gnitadpU
[info] Done updating.
[reverse.update - info] .gnitadpu enoD
[success] Total time: 0 s, completed Oct 16, 2019 5:22:22 AM
</code></pre><a name="log"></a><h3 id="Log+messages+in+a+task">Log messages in a task<a href="#Log+messages+in+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The special task <code>streams</code> provides per-task logging and I/O via a
<a href="../api/sbt/std/Streams.html">Streams</a> instance. To log, a task uses
the <code>log</code> member from the <code>streams</code> task. Calling <code>log</code> provides
a <a href="../api/sbt/util/Logger.html">Logger</a>:
</p><pre><code class="prettyprint lang-scala">import sbt.Keys.streams

myTask := {
  val log = streams.value.log
  log.warn(&quot;A warning.&quot;)
}
</code></pre><h3 id="Log+messages+in+a+setting">Log messages in a setting<a href="#Log+messages+in+a+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Since settings cannot reference tasks, the special task <code>streams</code>
cannot be used to provide logging during setting initialization.
The recommended way is to use <code>sLog</code>. Calling <code>sLog.value</code> provides
a <a href="../api/sbt/util/Logger.html">Logger</a>.
</p><pre><code class="prettyprint lang-scala">mySetting := {
  val log = sLog.value
  log.warn(&quot;A warning.&quot;)
}
</code></pre><h2 id="Project+metadata">Project metadata<a href="#Project+metadata" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="name"></a><h3 id="Set+the+project+name">Set the project name<a href="#Set+the+project+name" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A project should define <code>name</code> and <code>version</code>. These will be used in
various parts of the build, such as the names of generated artifacts.
Projects that are published to a repository should also override
<code>organization</code>.
</p><pre><code class="prettyprint lang-scala">name := &quot;Your project name&quot;
</code></pre><p>For published projects, this name is normalized to be suitable for use
as an artifact name and dependency ID. This normalized name is stored in
<code>normalizedName</code>.
</p><a name="version"></a><h3 id="Set+the+project+version">Set the project version<a href="#Set+the+project+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">version := &quot;1.0&quot;
</code></pre><a name="organization"></a><h3 id="Set+the+project+organization">Set the project organization<a href="#Set+the+project+organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">organization := &quot;org.example&quot;
</code></pre><p>By convention, this is a reverse domain name that you own, typically one
specific to your project. It is used as a namespace for projects.
</p><p>A full/formal name can be defined in the <code>organizationName</code> setting.
This is used in the generated pom.xml. If the organization has a web
site, it may be set in the <code>organizationHomepage</code> setting. For example:
</p><pre><code class="prettyprint lang-scala">organizationName := &quot;Example, Inc.&quot;

organizationHomepage := Some(url(&quot;http://example.org&quot;))
</code></pre><a name="other"></a><h3 id="Set+the+project%E2%80%99s+homepage+and+other+metadata">Set the project’s homepage and other metadata<a href="#Set+the+project%E2%80%99s+homepage+and+other+metadata" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">homepage := Some(url(&quot;https://www.scala-sbt.org&quot;))

startYear := Some(2008)

description := &quot;A build tool for Scala.&quot;

licenses += &quot;GPLv2&quot; -&gt; url(&quot;https://www.gnu.org/licenses/gpl-2.0.html&quot;)
</code></pre><h2 id="Configure+packaging">Configure packaging<a href="#Configure+packaging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="export"></a><h3 id="Use+the+packaged+jar+on+classpaths+instead+of+class+directory">Use the packaged jar on classpaths instead of class directory<a href="#Use+the+packaged+jar+on+classpaths+instead+of+class+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, a project exports a directory containing its resources and
compiled class files. Set <code>exportJars</code> to true to export the packaged
jar instead. For example,
</p><pre><code class="prettyprint lang-scala">exportJars := true
</code></pre><p>The jar will be used by <code>run</code>, <code>test</code>, <code>console</code>, and other tasks that
use the full classpath.
</p><a name="manifest"></a><h3 id="Add+manifest+attributes">Add manifest attributes<a href="#Add+manifest+attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt constructs a manifest for the binary package from
settings such as <code>organization</code> and <code>mainClass</code>. Additional attributes
may be added to the <code>packageOptions</code> setting scoped by the configuration
and package task.
</p><p>Main attributes may be added with <code>Package.ManifestAttributes</code>. There
are two variants of this method, once that accepts repeated arguments
that map an attribute of type <code>java.util.jar.Attributes.Name</code> to a
String value and other that maps attribute names (type String) to the
String value.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / packageOptions +=
  Package.ManifestAttributes(java.util.jar.Attributes.Name.SEALED -&gt; &quot;true&quot;)
</code></pre><p>Other attributes may be added with <code>Package.JarManifest</code>.
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / packageOptions +=  {
  import java.util.jar.{Attributes, Manifest}
  val manifest = new Manifest
  manifest.getAttributes(&quot;foo/bar/&quot;).put(Attributes.Name.SEALED, &quot;false&quot;)
  Package.JarManifest( manifest )
}
</code></pre><p>Or, to read the manifest from a file:
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / packageOptions +=  {
  val file = new java.io.File(&quot;META-INF/MANIFEST.MF&quot;)
  val manifest = Using.fileInputStream(file)( in =&gt; new java.util.jar.Manifest(in) )
  Package.JarManifest( manifest )
}
</code></pre><a name="name"></a><h3 id="Change+the+file+name+of+a+package">Change the file name of a package<a href="#Change+the+file+name+of+a+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>artifactName</code> setting controls the name of generated packages. See
the <a href="Artifacts.html">Artifacts</a> page for details.
</p><a name="contents"></a><h3 id="Modify+the+contents+of+the+package">Modify the contents of the package<a href="#Modify+the+contents+of+the+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The contents of a package are defined by the <code>mappings</code> task, of type
<code>Seq[(File,String)]</code>. The <code>mappings</code> task is a sequence of mappings from
a file to include in the package to the path in the package. See
<a href="Mapping-Files.html">Mapping Files</a> for convenience functions for
generating these mappings. For example, to add the file <code>in/example.txt</code>
to the main binary jar with the path “out/example.txt”,
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / mappings += {
  (baseDirectory.value / &quot;in&quot; / &quot;example.txt&quot;) -&gt; &quot;out/example.txt&quot;
}
</code></pre><p>Note that <code>mappings</code> is scoped by the configuration and the specific
package task. For example, the mappings for the test source package are
defined by the <code>Test / packageSrc / mappings</code> task.
</p><h2 id="Running+commands">Running commands<a href="#Running+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="batch"></a><h3 id="Pass+arguments+to+a+command+or+task+in+batch+mode">Pass arguments to a command or task in batch mode<a href="#Pass+arguments+to+a+command+or+task+in+batch+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt interprets each command line argument provided to it as a command
together with the command’s arguments. Therefore, to run a command that
takes arguments in batch mode, quote the command using double quotes,
and its arguments. For example,
</p><pre><code class="">$ sbt &quot;project X&quot; clean &quot;~ compile&quot;
</code></pre><a name="multi"></a><h3 id="Provide+multiple+commands+to+run+consecutively">Provide multiple commands to run consecutively<a href="#Provide+multiple+commands+to+run+consecutively" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Multiple commands can be scheduled at once by prefixing each command
with a semicolon. This is useful for specifying multiple commands where
a single command string is accepted. For example, the syntax for
triggered execution is <code>~ &lt;command&gt;</code>. To have more than one command run
for each triggering, use semicolons. For example, the following runs
<code>clean</code> and then <code>compile</code> each time a source file changes:
</p><pre><code class="">&gt; ~ ;clean;compile
</code></pre><a name="read"></a><h3 id="Read+commands+from+a+file">Read commands from a file<a href="#Read+commands+from+a+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>&lt;</code> command reads commands from the files provided to it as
arguments. Run <code>help &lt;</code> at the sbt prompt for details.
</p><a name="alias"></a><h3 id="Define+an+alias+for+a+command+or+task">Define an alias for a command or task<a href="#Define+an+alias+for+a+command+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>alias</code> command defines, removes, and displays aliases for commands.
Run <code>help alias</code> at the sbt prompt for details.
</p><p>Example usage:
</p><pre><code class="">&gt; alias a=about
&gt; alias
    a = about    
&gt; a
[info] This is sbt ...
&gt; alias a=
&gt; alias
&gt; a
[error] Not a valid command: a ...
</code></pre><a name="eval"></a><h3 id="Quickly+evaluate+a+Scala+expression">Quickly evaluate a Scala expression<a href="#Quickly+evaluate+a+Scala+expression" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>eval</code> command compiles and runs the Scala expression passed to it
as an argument. The result is printed along with its type. For example,
</p><pre><code class="">&gt; eval 2+2
4: Int
</code></pre><p>Variables defined by an <code>eval</code> are not visible to subsequent <code>eval</code>s,
although changes to system properties persist and affect the JVM that is
running sbt. Use the Scala REPL (<code>console</code> and related commands) for
full support for evaluating Scala code interactively.
</p><h2 id="Configure+and+use+Scala">Configure and use Scala<a href="#Configure+and+use+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="version"></a><h3 id="Set+the+Scala+version+used+for+building+the+project">Set the Scala version used for building the project<a href="#Set+the+Scala+version+used+for+building+the+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>scalaVersion</code> configures the version of Scala used for compilation.
By default, sbt also adds a dependency on the Scala library with this
version. See the next section for how to disable this automatic
dependency. If the Scala version is not specified, the version sbt was
built against is used. It is recommended to explicitly specify the
version of Scala.
</p><p>For example, to set the Scala version to “2.11.1”,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.11.1&quot;
</code></pre><a name="noauto"></a><h3 id="Disable+the+automatic+dependency+on+the+Scala+library">Disable the automatic dependency on the Scala library<a href="#Disable+the+automatic+dependency+on+the+Scala+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt adds a dependency on the Scala standard library by default. To
disable this behavior, set the <code>autoScalaLibrary</code> setting to false.
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false
</code></pre><a name="temporary"></a><h3 id="Temporarily+switch+to+a+different+Scala+version">Temporarily switch to a different Scala version<a href="#Temporarily+switch+to+a+different+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To set the Scala version in all scopes to a specific value, use the <code>++</code>
command. For example, to temporarily use Scala 2.10.4, run:
</p><pre><code class="">&gt; ++ 2.10.4
</code></pre><a name="local"></a><h3 id="Use+a+local+Scala+installation+for+building+a+project">Use a local Scala installation for building a project<a href="#Use+a+local+Scala+installation+for+building+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Defining the <code>scalaHome</code> setting with the path to the Scala home
directory will use that Scala installation. sbt still requires
<code>scalaVersion</code> to be set when a local Scala version is used. For
example,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.10.0-local&quot;

scalaHome := Some(file(&quot;/path/to/scala/home/&quot;))
</code></pre><a name="cross"></a><h3 id="Build+a+project+against+multiple+Scala+versions">Build a project against multiple Scala versions<a href="#Build+a+project+against+multiple+Scala+versions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="Cross-Build.html">cross building</a>.
</p><a name="consoleQuick"></a><h3 id="Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+on+the+classpath%2C+but+not+the+compiled+project+classes">Enter the Scala REPL with a project’s dependencies on the classpath, but not the compiled project classes<a href="#Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+on+the+classpath%2C+but+not+the+compiled+project+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>consoleQuick</code> action retrieves dependencies and puts them on the
classpath of the Scala REPL. The project’s sources are not compiled, but
sources of any source dependencies are compiled. To enter the REPL with
test dependencies on the classpath but without compiling test sources,
run <code>test:consoleQuick</code>. This will force compilation of main sources.
</p><a name="console"></a><h3 id="Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+and+compiled+code+on+the+classpath">Enter the Scala REPL with a project’s dependencies and compiled code on the classpath<a href="#Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+and+compiled+code+on+the+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>console</code> action retrieves dependencies and compiles sources and
puts them on the classpath of the Scala REPL. To enter the REPL with
test dependencies and compiled test sources on the classpath, run
<code>test:console</code>.
</p><a name="consoleProject"></a><h3 id="Enter+the+Scala+REPL+with+plugins+and+the+build+definition+on+the+classpath">Enter the Scala REPL with plugins and the build definition on the classpath<a href="#Enter+the+Scala+REPL+with+plugins+and+the+build+definition+on+the+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; consoleProject
</code></pre><p>For details, see the <a href="Console-Project.html">consoleProject</a>
page.
</p><a name="initial"></a><h3 id="Define+the+initial+commands+evaluated+when+entering+the+Scala+REPL">Define the initial commands evaluated when entering the Scala REPL<a href="#Define+the+initial+commands+evaluated+when+entering+the+Scala+REPL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>initialCommands in console</code> to set the initial statements to
evaluate when <code>console</code> and <code>consoleQuick</code> are run. To configure
<code>consoleQuick</code> separately, use <code>initialCommands in consoleQuick</code>. For
example,
</p><pre><code class="prettyprint lang-scala">initialCommands in console := &quot;&quot;&quot;println(&quot;Hello from console&quot;)&quot;&quot;&quot;

initialCommands in consoleQuick := &quot;&quot;&quot;println(&quot;Hello from consoleQuick&quot;)&quot;&quot;&quot;
</code></pre><p>The <code>consoleProject</code> command is configured separately by
<code>initialCommands in consoleProject</code>. It does not use the value from
<code>initialCommands in console</code> by default. For example,
</p><pre><code class="prettyprint lang-scala">initialCommands in consoleProject := &quot;&quot;&quot;println(&quot;Hello from consoleProject&quot;)&quot;&quot;&quot;
</code></pre><a name="cleanup"></a><h3 id="Define+the+commands+evaluated+when+exiting+the+Scala+REPL">Define the commands evaluated when exiting the Scala REPL<a href="#Define+the+commands+evaluated+when+exiting+the+Scala+REPL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>cleanupCommands in console</code> to set the statements to evaluate after
exiting the Scala REPL started by <code>console</code> and <code>consoleQuick</code>. To
configure <code>consoleQuick</code> separately, use
<code>cleanupCommands in consoleQuick</code>. For example,
</p><pre><code class="prettyprint lang-scala">cleanupCommands in console := &quot;&quot;&quot;println(&quot;Bye from console&quot;)&quot;&quot;&quot;

cleanupCommands in consoleQuick := &quot;&quot;&quot;println(&quot;Bye from consoleQuick&quot;)&quot;&quot;&quot;
</code></pre><p>The <code>consoleProject</code> command is configured separately by
<code>cleanupCommands in consoleProject</code>. It does not use the value from
<code>cleanupCommands in console</code> by default. For example,
</p><pre><code class="prettyprint lang-scala">cleanupCommands in consoleProject := &quot;&quot;&quot;println(&quot;Bye from consoleProject&quot;)&quot;&quot;&quot;
</code></pre><a name="embed"></a><h3 id="Use+the+Scala+REPL+from+project+code">Use the Scala REPL from project code<a href="#Use+the+Scala+REPL+from+project+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt runs tests in the same JVM as sbt itself and Scala classes are not
in the same class loader as the application classes. This is also the
case in <code>console</code> and when <code>run</code> is not forked. Therefore, when using
the Scala interpreter, it is important to set it up properly to avoid an
error message like:
</p><pre><code class="">Failed to initialize compiler: class scala.runtime.VolatileBooleanRef not found.
** Note that as of 2.8 scala does not assume use of the java classpath.
** For the old behavior pass -usejavacp to scala, or if using a Settings
** object programmatically, settings.usejavacp.value = true.
</code></pre><p>The key is to initialize the Settings for the interpreter using
<em>embeddedDefaults</em>. For example:
</p><pre><code class="prettyprint lang-scala">val settings = new Settings
settings.embeddedDefaults[MyType]
val interpreter = new Interpreter(settings, ...)
</code></pre><p>Here, <code>MyType</code> is a representative class that should be included on the
interpreter’s classpath and in its application class loader. For more
background, see the
<a href="https://gist.github.com/404272">original proposal</a> that resulted in
<em>embeddedDefaults</em> being added.
</p><p>Similarly, use a representative class as the type argument when using
the <em>break</em> and <em>breakIf</em> methods of <em>ILoop</em>, as in the following
example:
</p><pre><code class="prettyprint lang-scala">def x(a: Int, b: Int) = {
  import scala.tools.nsc.interpreter.ILoop
  ILoop.breakIf[MyType](a != b, &quot;a&quot; -&gt; a, &quot;b&quot; -&gt; b )
}
</code></pre><h2 id="Generate+API+documentation">Generate API documentation<a href="#Generate+API+documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="generate-javadoc-or-scaladoc"></a><h3 id="Select+javadoc+or+scaladoc">Select javadoc or scaladoc<a href="#Select+javadoc+or+scaladoc" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt will run <code>javadoc</code> if there are only Java sources in the project. If
there are any Scala sources, sbt will run <code>scaladoc</code>. (This situation
results from <code>scaladoc</code> not processing Javadoc comments in Java sources
nor linking to Javadoc.)
</p><a name="definitive-doc-options"></a><h3 id="Set+the+options+used+for+generating+scaladoc+independently+of+compilation">Set the options used for generating scaladoc independently of compilation<a href="#Set+the+options+used+for+generating+scaladoc+independently+of+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>scalacOptions</code> to the <code>doc</code> task to configure <code>scaladoc</code>. Use
<code>:=</code> to definitively set the options without appending to the options
for <code>compile</code>. Scope to <code>Compile</code> for main sources or to <code>Test</code> for test
sources. For example,
</p><pre><code class="prettyprint lang-scala">Compile / doc / scalacOptions := Seq(&quot;-groups&quot;, &quot;-implicits&quot;)
</code></pre><a name="additional-doc-options"></a><h3 id="Add+options+for+scaladoc+to+the+compilation+options">Add options for scaladoc to the compilation options<a href="#Add+options+for+scaladoc+to+the+compilation+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>scalacOptions</code> to the <code>doc</code> task to configure <code>scaladoc</code>. Use
<code>+=</code> or <code>++=</code> to append options to the base options. To append a single
option, use <code>+=</code>. To append a <code>Seq[String]</code>, use <code>++=</code>. Scope to
<code>Compile</code> for main sources or to <code>Test</code> for test sources. For example,
</p><pre><code class="prettyprint lang-scala">Compile / doc / scalacOptions ++= Seq(&quot;-groups&quot;, &quot;-implicits&quot;)
</code></pre><a name="definitive-javadoc-options"></a><h3 id="Set+the+options+used+for+generating+javadoc+independently+of+compilation">Set the options used for generating javadoc independently of compilation<a href="#Set+the+options+used+for+generating+javadoc+independently+of+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>javacOptions</code> to the <code>doc</code> task to configure <code>javadoc</code>. Use <code>:=</code>
to definitively set the options without appending to the options for
<code>compile</code>. Scope to <code>Compile</code> for main sources or to <code>Test</code> for test
sources.
</p><a name="additional-doc-options"></a><h3 id="Add+options+for+javadoc+to+the+compilation+options">Add options for javadoc to the compilation options<a href="#Add+options+for+javadoc+to+the+compilation+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>javacOptions</code> to the <code>doc</code> task to configure <code>javadoc</code>. Use <code>+=</code>
or <code>++=</code> to append options to the base options. To append a single
option, use <code>+=</code>. To append a <code>Seq[String]</code>, use <code>++=</code>. Scope to
<code>Compile</code> for main sources or to <code>Test</code> for test sources. For example,
</p><pre><code class="prettyprint lang-scala">Compile / doc / javacOptions ++= Seq(&quot;-notimestamp&quot;, &quot;-linksource&quot;)
</code></pre><a name="auto-link"></a><h3 id="Enable+automatic+linking+to+the+external+Scaladoc+of+managed+dependencies">Enable automatic linking to the external Scaladoc of managed dependencies<a href="#Enable+automatic+linking+to+the+external+Scaladoc+of+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>autoAPIMappings := true</code> for sbt to tell <code>scaladoc</code> where it can
find the API documentation for managed dependencies. This requires that
dependencies have this information in its metadata and you are using
<code>scaladoc</code> for Scala 2.10.2 or later.
</p><a name="manual-api-links"></a><h3 id="Enable+manual+linking+to+the+external+Scaladoc+of+managed+dependencies">Enable manual linking to the external Scaladoc of managed dependencies<a href="#Enable+manual+linking+to+the+external+Scaladoc+of+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Add mappings of type <code>(File, URL)</code> to <code>apiMappings</code> to manually tell
<code>scaladoc</code> where it can find the API documentation for dependencies.
(This requires <code>scaladoc</code> for Scala 2.10.2 or later.) These mappings are
used in addition to <code>autoAPIMappings</code>, so this manual configuration is
typically done for unmanaged dependencies. The <code>File</code> key is the
location of the dependency as passed to the classpath. The <code>URL</code> value
is the base URL of the API documentation for the dependency. For
example,
</p><pre><code class="prettyprint lang-scala">apiMappings += (
  (unmanagedBase.value / &quot;a-library.jar&quot;) -&gt; 
    url(&quot;https://example.org/api/&quot;)
)
</code></pre><a name="define-api-url"></a><h3 id="Define+the+location+of+API+documentation+for+a+library">Define the location of API documentation for a library<a href="#Define+the+location+of+API+documentation+for+a+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>apiURL</code> to define the base <code>URL</code> for the Scaladocs for your
library. This will enable clients of your library to automatically link
against the API documentation using <code>autoAPIMappings</code>. (This only works
for Scala 2.10.2 and later.) For example,
</p><pre><code class="prettyprint lang-scala">apiURL := Some(url(&quot;https://example.org/api/&quot;))
</code></pre><p>This information will get included in a property of the published
<code>pom.xml</code>, where it can be automatically consumed by sbt.
</p><h2 id="Define+Custom+Tasks">Define Custom Tasks<a href="#Define+Custom+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Define+a+Task+that+runs+tests+in+specific+sub-projects">Define a Task that runs tests in specific sub-projects<a href="#Define+a+Task+that+runs+tests+in+specific+sub-projects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Consider a hypothetical multi-build project with 3 subprojects. The following defines a task <code>myTestTask</code> that will
run the <code>test</code> Task in specific subprojects  <code>core</code> and <code>tools</code> but not <code>client</code>:
</p><pre><code class="prettyprint lang-scala">lazy val core = project.in(file(&quot;./core&quot;))
lazy val tools = project.in(file(&quot;./tools&quot;))
lazy val client = project.in(file(&quot;./client&quot;))

lazy val myTestTask = taskKey[Unit](&quot;my test task&quot;)

myTestTask := {
  (core / Test / test).value
  (tools / Test / test).value
}
</code></pre><h2 id="How+to+take+an+action+on+startup">How to take an action on startup<a href="#How+to+take+an+action+on+startup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>A global setting <code>onLoad</code> is of type <code>State =&gt; State</code> and is executed once, after all projects are built and loaded. There is a similar hook <code>onUnload</code> for when a project is unloaded.
</p><p>Project unloading typically occurs as a result of a <code>reload</code> command or a <code>set</code> command. Because the <code>onLoad</code> and <code>onUnload</code> hooks are global, modifying this setting typically involves composing a new function with the previous value. The following example shows the basic structure of defining <code>onLoad</code>.
</p><p>Suppose you want to run a task named <code>dependencyUpdates</code> on start up. Here’s what you can do:
</p><pre><code class="prettyprint lang-scala">lazy val dependencyUpdates = taskKey[Unit](&quot;foo&quot;)

// This prepends the String you would type into the shell
lazy val startupTransition: State =&gt; State = { s: State =&gt;
  &quot;dependencyUpdates&quot; :: s
}

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    scalaVersion in ThisBuild := &quot;2.12.6&quot;,
    organization in ThisBuild := &quot;com.example&quot;,
    name := &quot;helloworld&quot;,
    dependencyUpdates := { println(&quot;hi&quot;) },

    // onLoad is scoped to Global because there's only one.
    onLoad in Global := {
      val old = (onLoad in Global).value
      // compose the new transition on top of the existing one
      // in case your plugins are using this hook.
      startupTransition compose old
    }
  )
</code></pre><p>You can use this technique to switch the startup subproject too.
</p><h2 id="Track+file+inputs+and+outputs">Track file inputs and outputs<a href="#Track+file+inputs+and+outputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Many sbt tasks depend on a collection of files. For example, the
<code>package</code> task generates a jar file containing the resources and class files,
which are generated by the <code>compile</code> task, for a project. Staring with version
1.3.0, sbt provides a file management system that tracks the inputs and outputs
of any task. The task can query which of its file dependencies have changed
since the task last completed allowing it to incrementally re-build only the
modified files. This system integrates with <a href="Triggered-Execution.html">Triggered
execution</a> so that the file dependencies of a task are
automatically monitored in a continuous build.
</p><p>To best illustrate the file tracking system, we construct a build.sbt that
illustrates all of the essential features. The example will be a project that is
able to build a shared library in c using gcc. This will be done with two tasks:
<code>buildObjects</code>, which compiles c source files to object files, and
<code>linkLibrary</code>, which links the object files into a shared library. These can be
defined with:
</p><pre><code class="prettyprint lang-scala">import java.nio.file.Path
val buildObjects = taskKey[Seq[Path]](&quot;Compiles c files into object files.&quot;)
val linkLibrary = taskKey[Path](&quot;Links objects into a shared library.&quot;)
</code></pre><p>The <code>buildObjects</code> task will depend on <code>*.c</code> source file inputs. The <code>linkLibrary</code>
task depends on the output <code>*.o</code> object files generated by <code>buildObjects</code>. This
creates a build pipeline: if none of the input sources to <code>buildObjects</code> are
modified between calls to <code>linkLibrary</code> then neither compilation nor linking
should occur. Conversely, when input source changes are detected, sbt should
both generate new object files corresponding to the modified source files and
link the shared library.
</p><h3 id="File+inputs">File inputs<a href="#File+inputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It is natural for a task to specify the inputs on which it depends. These are
set with the <code>fileInputs</code> key, which has type: <code>Seq[Glob]</code> (see <a href="Globs.html">Globs</a>).
The <code>fileInputs</code> are specified as <code>Seq[Glob]</code> so that more than one search query
may be provided, which may be necessary if sources are located in multiple
directories or different file types are needed within the same task.
</p><p>When the <code>fileInputs</code> key is set in a given scope, sbt automatically generates
a task named <code>allInputFiles</code> for that scope that returns a <code>Seq[Path]</code>
containing all of the files matching the <code>fileInputs</code> queries. For convenience,
there is an extension method defined for <code>Task[_]</code> that translates
<code>foo.inputFiles</code> to <code>(foo / allInputFiles).value</code>. We can use these to write a
simple implementation of <code>buildObjects</code>:
</p><pre><code class="prettyprint lang-scala">import scala.sys.process._
import java.nio.file.{ Files, Path }
import sbt.nio._
import sbt.nio.Keys._

val buildObjects = taskKey[Seq[Path]](&quot;Compiles c files into object files.&quot;)
buildObjects / fileInputs += baseDirectory.value.toGlob / &quot;src&quot; / &quot;*.c&quot;
buildObjects := {
  val outputDir = Files.createDirectories(streams.value.cacheDirectory.toPath)
  def outputPath(path: Path): Path =
    outputDir / path.getFileName.toString.replaceAll(&quot;.c$&quot;, &quot;.o&quot;)
  val logger = streams.value.log
  buildObjects.inputFiles.map { path =&gt;
    val output = outputPath(path)
    logger.info(s&quot;Compiling $path to $output&quot;)
    Seq(&quot;gcc&quot;, &quot;-c&quot;, path.toString, &quot;-o&quot;, output.toString).!!
    output
  }
}
</code></pre><p>This implementation will gather all of the files ending with the <code>*.c</code> extension
and shell out to gcc to compile them to the output directory.
</p><p>sbt will automatically monitor any file matched by the globs specified by
<code>fileInputs</code>. In this
case, modifying any file with <code>*.c</code> extension in the <code>src</code> directory will trigger
a build in a continuous build.
</p><h4 id="Incremental+builds">Incremental builds<a href="#Incremental+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Every time that <code>buildObjects</code> is invoked from the sbt shell, it will re-compile
all of the source files. This becomes expensive as the number of source files
increases. In addition to <code>fileInputs</code>, sbt also provides another api,
<code>inputFileChanges</code>, that provides information about what source files have changed
since the last time the task successfully completed. Using the
<code>inputFileChanges</code>, we can make the build above incremental:
</p><pre><code class="prettyprint lang-scala">import scala.sys.process._
import java.nio.file.{ Files, Path }
import sbt.nio._
import sbt.nio.Keys._

val buildObjects = taskKey[Seq[Path]](&quot;Generate object files from c sources&quot;)
buildObjects / fileInputs += baseDirectory.value.toGlob / &quot;src&quot; / &quot;*.c&quot;
buildObjects := {
  val outputDir = Files.createDirectories(streams.value.cacheDirectory.toPath)
  val logger = streams.value.log
  def outputPath(path: Path): Path =
    outputDir / path.getFileName.toString.replaceAll(&quot;.c$&quot;, &quot;.o&quot;)
  def compile(path: Path): Path = {
    val output = outputPath(path)
    logger.info(s&quot;Compiling $path to $output&quot;)
    Seq(&quot;gcc&quot;, &quot;-fPIC&quot;, &quot;-std=gnu99&quot;, &quot;-c&quot;, s&quot;$path&quot;, &quot;-o&quot;, s&quot;$output&quot;).!!
    output
  }
  val sourceMap = buildObjects.inputFiles.view.map(p =&gt; outputPath(p) -&gt; p).toMap
  val existingTargets = fileTreeView.value.list(outputDir.toGlob / **).flatMap { case (p, _) =&gt;
    if (!sourceMap.contains(p)) {
      Files.deleteIfExists(p)
      None
    } else {
      Some(p)
    }
  }.toSet
  val changes = buildObjects.inputFileChanges
  val updatedPaths = (changes.created ++ changes.modified).toSet
  val needCompile = updatedPaths ++ sourceMap.filterKeys(!existingTargets(_)).values
  needCompile.foreach(compile)
  sourceMap.keys.toVector
}
</code></pre><p>The <code>FileChangeReport</code> makes it possible to write an incremental task without
manually tracking the input files. It is a sealed trait implemented by three case classes:
</p><ol><li><code>Changes</code> — indicates that one or more source files have been modified.
</li><li><code>Unmodified</code> — none of the source file have been modified since the last
run.
</li><li><code>Fresh</code> — there is no cache entry for the previous source file hashes.
</li></ol><p>It is sometimes convenient to pattern match on the result of the
<code>inputFileChanges</code>:
</p><pre><code class="prettyprint lang-scala">foo.inputFileChanges match {
  case FileChanges(created, deleted, modified, unmodified)
    if created.nonEmpty || modified.nonEmpty =&gt;
      build(created ++ modified)
      delete(deleted)
  case _ =&gt; // no changes
}
</code></pre><p>The input file report says nothing about the outputs. This is why the
<code>buildObjects</code> implementation needs to check the target directory to see which
outputs exist. In that example, there is a 1:1 mapping between inputs and
outputs, but this need not be the case in general. An implementation of <code>buildObjects</code> may include header files in the <code>fileInputs</code>. These are not compiled themselves, but they may
trigger re-compilation of one or more <code>*.c</code> source files.
</p><p>Note that calling <code>buildObjects.inputFileChanges</code> also causes <code>buildObjects /
fileInputs</code> to automatically be watched in a continuous build.
</p><h3 id="File+outputs">File outputs<a href="#File+outputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The outputs of a file are often best specified as the result of a task. In the
example above, <code>buildObjects</code> is a <code>Task</code> returning a <code>Seq[Path]</code> containing the
object files generated by compilation. sbt will automatically track the outputs
of any task that returns one of the following result types: <code>Path</code>, <code>Seq[Path]</code>,
<code>File</code> or <code>Seq[File]</code>. We can use this to build on the <code>buildObjects</code> example to
write a task that links the object into a shared library:
</p><pre><code class="prettyprint lang-scala">val linkLibrary = taskKey[Path](&quot;Links objects into a shared library.&quot;)
linkLibrary := {
  val outputDir = Files.createDirectories(streams.value.cacheDirectory.toPath)
  val logger = streams.value.log
  val isMac = scala.util.Properties.isMac
  val library = outputDir / s&quot;mylib.${if (isMac) &quot;dylib&quot; else &quot;so&quot;}&quot;
  val linkOpts = if (isMac) Seq(&quot;-dynamiclib&quot;) else Seq(&quot;-shared&quot;, &quot;-fPIC&quot;)
  if (buildObjects.outputFileChanges.hasChanges || !Files.exists(library)) {
    logger.info(s&quot;Linking $library&quot;)
    (Seq(&quot;gcc&quot;) ++ linkOpts ++ Seq(&quot;-o&quot;, s&quot;$library&quot;) ++
      buildObjects.outputFiles.map(_.toString)).!!
  } else {
    logger.debug(s&quot;Skipping linking of $library&quot;)
  }
  library
}
</code></pre><p>Here the tracking was simpler because linking a shared library is not
incremental. Thus we have to rebuild if any of the outputs of <code>buildObjects</code> has
changed or if the library doesn’t exist.
</p><p>Similar to <code>fileInputs</code>, there is a <code>fileOutputs</code> key. This can be used as an
alternative to returning the output files in the task when the outputs have a
known pattern. For example, <code>buildObjects</code> could have been defined as:
</p><pre><code class="prettyprint lang-scala">val buildObjects = taskKey[Unit](&quot;Compiles c files into object files.&quot;)
buildObjects / fileOutputs := target.value / &quot;objects&quot; / ** / &quot;*.o&quot;
</code></pre><p>This can be useful when using an opaque external tool where the mapping of
inputs to outputs is not known.
</p><p>Like <code>allInputFiles</code>, there is an <code>allOutputFiles</code> task of return type
<code>Seq[Path]</code> that is automatically
generated for a task, <code>foo</code>, if the return type of <code>foo</code> is one of <code>Seq[Path]</code>,
<code>Path</code>, <code>Seq[File]</code> or <code>File</code>. It is also generated if <code>foo / outputFiles</code> is
specified. When both <code>fileOutputs</code> is specified and the return type represents a
file or collection of files, the result of <code>allOutputFiles</code> is the distinct
union of the files returned by the task and the files described by <code>ouputFiles</code>.
Calling <code>foo.outputFiles</code> is syntactic sugar for <code>(foo / allOutputFiles).value</code>.
</p><h3 id="Filters">Filters<a href="#Filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fileInputs</code> and <code>fileOutputs</code> can be filtered beyond what is specified by
their <code>Glob</code> patterns. sbt provides four settings of type
<a href="Globs.html#path-filters">sbt.nio.file.PathFilter</a>:
1. <code>fileInputIncludeFilter</code> — only include file inputs that also match this
filter
2. <code>fileInputExcludeFilter</code>— exclude any file inputs that also match this filter
3. <code>fileOutputIncludeFilter</code> — only include file inputs that also match this
filter
4. <code>fileOutputExcludeFilter</code> — exclude any file output that also match this filter
</p><p>By default, sbt sets
<code>`scala
fileInputExcludeFilter := HiddenFileFilter.toNio || DirectoryFilter
</code><code>
Both </code>fileInputIncludeFilter<code> and </code>fileInputOutputFilter<code> are set to
</code>AllPassFilter.toNio<code>. The </code>fileOutputExcludeFilter<code> is set to
</code>NothingFilter.toNio`.
</p><p>To exclude files matching with test in the name from <code>buildObjects</code>, write:
</p><pre><code class="prettyprint lang-scala">buildObjects / fileInputExcludeFilter := &quot;*test*&quot;
</code></pre><p>To preserve the previous excludes of hidden files and directories, write:
</p><pre><code class="prettyprint lang-scala">buildObjects / fileInputExcludeFilter :=
  (buildObjects / fileInputExcludeFilter).value || &quot;*test*&quot;
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">buildObjects / fileInputExcludeFilter ~= { ef =&gt; ef || &quot;*test*&quot; }
</code></pre><p>In most cases, it shouldn’t be necessary to set the <code>fileInputIncludeFilter</code>
since the path name filtering it should be handled by <code>fileInputs</code> itself. It
also shouldn’t commonly be necessary to filter the outputs.
</p><h4 id="Cleaning+outputs">Cleaning outputs<a href="#Cleaning+outputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt automatically generates an implementation of <code>clean</code> scoped to the task
<code>foo</code> whenever it also generates the <code>allOutputFiles</code> task. Calling <code>foo /
clean</code> will remove all of the files <em>previously</em> generated by <code>foo</code>. It will not
re-evaluate <code>foo</code>. For example, calling <code>buildObjects / clean</code> will remove all
of the object files generated by the previous call to <code>buildObjects</code>. The
generated clean tasks are not transitive. Calling <code>linkLibrary / clean</code> will
delete the shared library but will not delete the object files generated by
<code>buildObjects</code>.
</p><h3 id="File+change+tracking">File change tracking<a href="#File+change+tracking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For each input or output file tracked by sbt, there is an associated
<code>FileStamp</code>. This can either be the last modified time of the file or a hash. By
default, inputs are tracked using the hash and outputs are tracked using the
last modified time. To change this, set the <code>inputFileStamper</code> or
<code>outputFileStamper</code>:
</p><pre><code class="prettyprint lang-scala">val generateSources = taskKey[Seq[Path]](&quot;Generates source files from json schema.&quot;)
generateSources / fileInputs := baseDirectory.value.toGlob / &quot;schema&quot; / ** / &quot;*.json&quot;
generateSources / outputFileStamper := FileStamper.Hash
</code></pre><h4 id="Continuous+build+file+monitoring">Continuous build file monitoring<a href="#Continuous+build+file+monitoring" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In a continuous build, <code>~bar</code>, for an arbitrary task, <code>bar</code>, given some task,
<code>foo</code>, any calls to <code>foo.inputFiles</code> and <code>foo.inputFileChanges</code> within <code>bar</code>
will cause all of the globs specified by <code>foo / fileInputs</code> to be monitored in a
continuous build.  Transitive file input dependencies are automatically
monitored. For example, the <code>~linkLibrary</code> continuous build command will monitor
the <code>*.c</code> source files defined for <code>buildObjects</code>.
</p><p>Input files will only trigger a re-build if their hash has changed.  This
behavior can be overridden with:
</p><pre><code class="prettyprint lang-scala">Global / watchForceTriggerOnAnyChange := true
</code></pre><p>Changes to file outputs, which are gathered with either <code>foo.outputFiles</code> or
<code>foo.outputFileChanges</code>, do not trigger a re-build.
</p><h4 id="Partial+pipeline+evaluation+%2F+error+handling">Partial pipeline evaluation / error handling<a href="#Partial+pipeline+evaluation+%2F+error+handling" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The stamps for each file are tracked on a per-task basis. They are only updated
if the incremental task itself succeeds. In the example above, this means that
the current file last modified times for <code>buildObjects</code> are stored by the <code>linkLibrary</code>
task only when it succeeds. This means that <code>buildObjects</code> can be run many times
between calls to <code>linkLibrary</code> and <code>linkLibrary</code> will see the cumulative changes
to the outputs of <code>buildObjects</code>.
</p><p>If <code>linkLibrary</code> fails to complete, sbt will also skip updating the last
modified times for the outputs of <code>buildObjects</code> corresponding to <code>linkLibrary</code>
because it is impossible to know in general which files were successfully
processed.
</p><h2 id="Troubleshoot+memory+issues">Troubleshoot memory issues<a href="#Troubleshoot+memory+issues" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt may sometimes run out of memory, leading to a crash or badly degraded
performance. The amount of memory needed by sbt is dependent on the number of
subprojects in the build and the plugins that are enabled. For projects with a
large memory footprint, it may be necessary to start sbt with an increased java
heap size. The default java heap size is 1GB.  To increase it to 2GB, you can
run the following command:
</p><pre><code class="">sbt -J-Xmx2G
</code></pre><p>Any command argument with a leading <code>-J</code> is interpreted as a java vm argument.
To automatically increase the heap to 2GB in a project, create or edit the file
<code>.sbtopts</code> and add a line with <code>-J-Xmx2G</code>.
</p><p>When sbt is run in interactive mode or as a server (i.e. it was started
with <code>sbt --client</code> or <code>sbtn</code>), it is important that each task in the build
clean up all of its resources or the memory footprint of sbt may grow over time.
For example, the run task starts an Akka
<a href="https://doc.akka.io/docs/akka/current/general/actor-systems.html#terminating-actorsystem">ActorSystem</a>,
it is necessary to shutdown the ActorSystem before run exits or else the
memory utilization of the sbt process will increase each time run is invoked.
</p><p>In order to fix memory leaks, it is necessary to figure out what classes are
persisting in memory longer than expected. The easiest way to do this is with
the
<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">jmap</a>
command, which is provided by the jdk, and a jvm memory analyzer tool like
<a href="https://visualvm.github.io">VisualVM</a>. Find the process id of the sbt process
that you with to debug using the <code>ps</code> command. Then run
<code>jmap -dump:format=b,file=leak.hprof $SBT_PID</code>. Open the <code>leak.hprof</code> file in
VisualVM. It may be obvious what classes are taking up the most memory, but
sometimes it is necessary to click the “Compute Retained Sizes” button. This may
take a while if there is a large heap, but it can identify what classes are
taking up the most memory. Often this will help you identify where there is a
thread that has leaked or a cache that has not been cleared.
</p><h2 id="Sequencing">Sequencing<a href="#Sequencing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>One of the most frequently asked questions is in the form of “how do I do X <em>and then</em> do Y in sbt”?
</p><p>Generally speaking, that’s not how sbt tasks are set up. build.sbt is a DSL to define dependency graph of tasks. This is covered in <a href="Custom-Settings.html#Execution+semantics+of+tasks">Execution semantics of tasks</a>. So ideally, what you should do is define task Y yourself, and depend on the task X.
</p><pre><code class="prettyprint lang-scala">taskY := {
  val x = taskX.value
  x + 1
}
</code></pre><p>This is more constrained compared to the imperative style plain Scala code with side effects such as the follows:
</p><pre><code class="prettyprint lang-scala">def foo(): Unit = {
  doX()
  doY()
}
</code></pre><p>The benefit of the dependency-oriented programming model is that sbt’s task engine is able to reorder the task execution. When possible we run dependent tasks in parallel. Another benefit is that we can deduplicate the graph, and make sure that the task evaluation, such as <code>Compile / compile</code>, is called once per command execution, as opposed to compiling the same source many times.
</p><p>Because task system is generally set up this way, running something sequentially is possible, but you will be fighting the system a bit, and it’s not always going to be easy.
</p><ul><li><a href="Howto-Sequential-Task.html">Defining a sequential task with Def.sequential</a>
</li><li><a href="Howto-Dynamic-Task.html">Defining a dynamic task with Def.taskDyn</a>
</li><li><a href="Howto-After-Input-Task.html">Doing something after an input task</a>
</li><li><a href="Howto-Dynamic-Input-Task.html">Defining a dynamic input task with Def.inputTaskDyn</a>
</li><li><a href="Howto-Sequence-using-Commands.html">How to sequence using commands</a>
</li></ul><h3 id="Defining+a+sequential+task+with+Def.sequential">Defining a sequential task with Def.sequential<a href="#Defining+a+sequential+task+with+Def.sequential" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.13.8 added <code>Def.sequential</code> function to run tasks under semi-sequential semantics.
To demonstrate the sequential task, let’s create a custom task called <code>compilecheck</code> that runs <code>Compile / compile</code> and then <code>Compile / scalastyle</code> task added by <a href="http://www.scalastyle.org/sbt.html">scalastyle-sbt-plugin</a>.
</p><p>Here’s how to set it up
</p><h4 id="project%2Fbuild.properties">project/build.properties<a href="#project%2Fbuild.properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">sbt.version=1.4.7
</code></pre><h4 id="project%2Fstyle.sbt">project/style.sbt<a href="#project%2Fstyle.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">addSbtPlugin(&quot;org.scalastyle&quot; %% &quot;scalastyle-sbt-plugin&quot; % &quot;1.0.0&quot;)
</code></pre><h4 id="build.sbt">build.sbt<a href="#build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">lazy val compilecheck = taskKey[Unit](&quot;compile and then scalastyle&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    Compile / compilecheck := Def.sequential(
      Compile / compile,
      (Compile / scalastyle).toTask(&quot;&quot;)
    ).value
  )
</code></pre><p>To call this task type in <code>compilecheck</code> from the shell. If the compilation fails, <code>compilecheck</code> would stop the execution.
</p><pre><code class="">root&gt; compilecheck
[info] Compiling 1 Scala source to /Users/x/proj/target/scala-2.10/classes...
[error] /Users/x/proj/src/main/scala/Foo.scala:3: Unmatched closing brace '}' ignored here
[error] }
[error] ^
[error] one error found
[error] (compile:compileIncremental) Compilation failed
</code></pre><p>Looks like we were able to sequence these tasks.
</p><h3 id="Defining+a+dynamic+task+with+Def.taskDyn">Defining a dynamic task with Def.taskDyn<a href="#Defining+a+dynamic+task+with+Def.taskDyn" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If <a href="Howto-Sequential-Task.html">sequential task</a> is not enough, another step up is <a href="Tasks.html">the dynamic task</a>. Unlike <code>Def.task</code> which expects you to return pure value <code>A</code>, with a <code>Def.taskDyn</code> you return a task <code>sbt.Def.Initialize[sbt.Task[A]]</code> which the task engine can continue the rest of the computation with.
</p><p>Let’s try implementing a custom task called <code>compilecheck</code> that runs <code>Compile / compile</code> and then <code>Compile / scalastyle</code> task added by <a href="http://www.scalastyle.org/sbt.html">scalastyle-sbt-plugin</a>.
</p><h4 id="project%2Fbuild.properties">project/build.properties<a href="#project%2Fbuild.properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">sbt.version=1.4.7
</code></pre><h4 id="project%2Fstyle.sbt">project/style.sbt<a href="#project%2Fstyle.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">addSbtPlugin(&quot;org.scalastyle&quot; %% &quot;scalastyle-sbt-plugin&quot; % &quot;1.0.0&quot;)
</code></pre><h4 id="build.sbt+v1">build.sbt v1<a href="#build.sbt+v1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">lazy val compilecheck = taskKey[sbt.inc.Analysis](&quot;compile and then scalastyle&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    compilecheck := (Def.taskDyn {
      val c = (Compile / compile).value
      Def.task {
        val x = (Compile / scalastyle).toTask(&quot;&quot;).value
        c
      }
    }).value
  )
</code></pre><p>Now we have the same thing as the sequential task, except we can now return the result <code>c</code> from the first task.
</p><h4 id="build.sbt+v2">build.sbt v2<a href="#build.sbt+v2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If we can return the same return type as <code>Compile / compile</code>, might actually rewire the key to our dynamic task.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    Compile / compile := (Def.taskDyn {
      val c = (Compile / compile).value
      Def.task {
        val x = (Compile / scalastyle).toTask(&quot;&quot;).value
        c
      }
    }).value
  )
</code></pre><p>Now we can actually call <code>Compile / compile</code> from the shell and make it do what we want it to do.
</p><h3 id="Doing+something+after+an+input+task">Doing something after an input task<a href="#Doing+something+after+an+input+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Thus far we’ve mostly looked at tasks. There’s another kind of tasks called input tasks that accepts user input from the shell.
A typical example for this is the <code>Compile / run</code> task. The <code>scalastyle</code> task is actually an input task too. See <a href="Input-Tasks.html">input task</a> for the details of the input tasks.
</p><p>Now suppose we want to call <code>Compile / run</code> task and then open the browser for testing purposes.
</p><h4 id="src%2Fmain%2Fscala%2FGreeting.scala">src/main/scala/Greeting.scala<a href="#src%2Fmain%2Fscala%2FGreeting.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">object Greeting extends App {
  println(&quot;hello &quot; + args.toList)
}
</code></pre><h4 id="build.sbt+v1">build.sbt v1<a href="#build.sbt+v1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">lazy val runopen = inputKey[Unit](&quot;run and then open the browser&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    runopen := {
      (Compile / run).evaluated
      println(&quot;open browser!&quot;)
    }
  )
</code></pre><p>Here, I’m faking the browser opening using <code>println</code> as the side effect. We can now call this task from the shell:
</p><pre><code class="">&gt; runopen foo
[info] Compiling 1 Scala source to /x/proj/...
[info] Running Greeting foo
hello List(foo)
open browser!
</code></pre><h4 id="build.sbt+v2">build.sbt v2<a href="#build.sbt+v2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>We can actually remove <code>runopen</code> key, by rewriting the new input task to <code>Compile / run</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    Compile / run := {
      (Compile / run).evaluated
      println(&quot;open browser!&quot;)
    }
  )
</code></pre><h3 id="Defining+a+dynamic+input+task+with+Def.inputTaskDyn">Defining a dynamic input task with Def.inputTaskDyn<a href="#Defining+a+dynamic+input+task+with+Def.inputTaskDyn" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Let’s suppose that there’s a task already that does the browser opening called <code>openbrowser</code> because of a plugin. Here’s how we can sequence a task after an input tasks.
</p><h4 id="build.sbt+v1">build.sbt v1<a href="#build.sbt+v1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">lazy val runopen = inputKey[Unit](&quot;run and then open the browser&quot;)
lazy val openbrowser = taskKey[Unit](&quot;open the browser&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    runopen := (Def.inputTaskDyn {
      import sbt.complete.Parsers.spaceDelimited
      val args = spaceDelimited(&quot;&lt;args&gt;&quot;).parsed
      Def.taskDyn {
        (Compile / run).toTask(&quot; &quot; + args.mkString(&quot; &quot;)).value
        openbrowser
      }
    }).evaluated,
    openbrowser := {
      println(&quot;open browser!&quot;)
    }
  )
</code></pre><h4 id="build.sbt+v2">build.sbt v2<a href="#build.sbt+v2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Trying to rewire <code>Compile / run</code> is going to be complicated. Since the reference to the inner <code>Compile / run</code> is already inside the continuation task, simply rewiring <code>runopen</code> to <code>Compile / run</code> will create a cyclic reference.
To break the cycle, we will introduce a clone of <code>Compile / run</code> called <code>Compile / actualRun</code>:
</p><pre><code class="prettyprint lang-scala">lazy val actualRun = inputKey[Unit](&quot;The actual run task&quot;)
lazy val openbrowser = taskKey[Unit](&quot;open the browser&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    Compile / run := (Def.inputTaskDyn {
      import sbt.complete.Parsers.spaceDelimited
      val args = spaceDelimited(&quot;&lt;args&gt;&quot;).parsed
      Def.taskDyn {
        (Compile / actualRun).toTask(&quot; &quot; + args.mkString(&quot; &quot;)).value
        openbrowser
      }
    }).evaluated,
    Comile / actualRun := Defaults.runTask(
      Runtime / fullClasspath,
      Compile / run / mainClass,
      Compile / run / runner
    ).evaluated,
    openbrowser := {
      println(&quot;open browser!&quot;)
    }
  )
</code></pre><p>* Note that some tasks (ie. <code>testOnly</code>) will fail with trailing spaces, so a right trim (<code>.replaceAll(&quot;\s+$&quot;, &quot;&quot;)</code>) of the string built for <code>toTask</code> might be needed to handle empty <code>args</code>.\
</p><p>The <code>Compile / actualRun</code>’s implementation was copy-pasted from <code>run</code> task’s implementation in Defaults.scala.
</p><p>Now we can call <code>run foo</code> from the shell and it will evaluate <code>Compile / actualRun</code> with the passed in argument, and then evaluate the <code>openbrowser</code> task.
</p><h3 id="How+to+sequence+using+commands">How to sequence using commands<a href="#How+to+sequence+using+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If all you care about is the side effects, and you really just want to emulate humans typing in one command after another, a custom command might be just want you need. This comes in handy for release procedures.
</p><p>Here’s from the build script of sbt itself:
</p><pre><code class="prettyprint lang-scala">  commands += Command.command(&quot;releaseNightly&quot;) { state =&gt;
    &quot;stampVersion&quot; ::
      &quot;clean&quot; ::
      &quot;compile&quot; ::
      &quot;publish&quot; ::
      &quot;bintrayRelease&quot; ::
      state
  }
</code></pre><h2 id="How+to+define+a+custom+dependency+configuration">How to define a custom dependency configuration<a href="#How+to+define+a+custom+dependency+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>A <em>dependency configuration</em> (or <em>configuration</em> for short) defines
a graph of library dependencies, potentially with its own
classpath, sources, generated packages, etc. The dependency configuration concept
comes from Ivy, which sbt used to use for
managed dependencies [Library Dependencies][Library-Dependencies], and from
[MavenScopes](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope).
</p><p>Some configurations you’ll see in sbt:
</p><ul><li><code>Compile</code> which defines the main build (<code>src/main/scala</code>).
</li><li><code>Test</code> which defines how to build tests (<code>src/test/scala</code>).
</li><li><code>Runtime</code> which defines the classpath for the <code>run</code> task.
</li></ul><h3 id="Cautions+on+custom+dependency+configurations">Cautions on custom dependency configurations<a href="#Cautions+on+custom+dependency+configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A custom configuration should be considered only when you are
introducing either a new set of source code or its own
library dependencies (like <code>Test</code>).
</p><p>In general, it would be a bad idea to introduce configuration
merely as a way to namespace keys.
</p><p>One drawback of the custom configuration is that the users will be confused
about the complexity around scoping. They might be familar with
subprojects and tasks, but it becomes complicated when configuration scoping
is involved.
</p><p>Another drawback is that there is limited support from sbt.
For instance, you can express that a configuration is meant to <code>extend</code>
another configuration, but there is no inheritance of settings.
You have to provide all expected settings and tasks.
This means that when a new features are added to sbt, there’s a good
chance the custom configurations will not be covered.
The same goes for third-party plugins.
</p><h3 id="Example+basic+custom+configuration">Example basic custom configuration<a href="#Example+basic+custom+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here’s an example of a minimum custom configuration.
</p><h4 id="project%2FFuzzPlugin.scala">project/FuzzPlugin.scala<a href="#project%2FFuzzPlugin.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">package com.example.sbtfuzz

import sbt._

object FuzzPlugin extends AutoPlugin {
  object autoImport {
    lazy val Fuzz = config(&quot;fuzz&quot;)
  }
  import autoImport._
  override lazy val projectSettings =
    inConfig(Fuzz)(Defaults.configSettings)
}
</code></pre><h4 id="build.sbt">build.sbt<a href="#build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion     := &quot;2.13.4&quot;
ThisBuild / version          := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .configs(Fuzz)
  .enablePlugins(FuzzPlugin, ScalafmtCliPlugin)
  .settings(
    name := &quot;use&quot;,
  )
</code></pre><h3 id="Example+sandbox+configuration">Example sandbox configuration<a href="#Example+sandbox+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>One sometimes useful technique with a configuration is adding a side graph
to the user’s project so Coursier would download some JARs,
which your task can invoke. This is called a sandbox configuration.
This can be used for instance to invoke Scala 2.13 CLI version of scalafmt.
As of sbt 1.4.x there’s a limitation so the sandbox configuration
must use the same Scala version as the user’s subproject.
</p><h4 id="project%2FScalafmtPlugin.scala">project/ScalafmtPlugin.scala<a href="#project%2FScalafmtPlugin.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">package com.example

import sbt._
import Keys._

object ScalafmtCliPlugin extends AutoPlugin {
  object autoImport {
    lazy val ScalafmtSandbox = config(&quot;scalafmt&quot;).hide
    lazy val scalafmt = inputKey[Unit](&quot;&quot;)
  }
  import autoImport._
  override lazy val projectSettings = Seq(
    ivyConfigurations += ScalafmtSandbox,
    libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalafmt-cli&quot; % &quot;2.7.5&quot; % ScalafmtSandbox,
    scalafmt := (ScalafmtSandbox / run).evaluated
  ) ++ inConfig(ScalafmtSandbox)(
    Seq(
      run := Defaults.runTask(managedClasspath, run / mainClass, run / runner)
        .evaluated,
      managedClasspath := Classpaths.managedJars(
        ScalafmtSandbox,
        classpathTypes.value,
        update.value,
      )
    ) ++
      inTask(run)(
        Seq(
          mainClass := Some(&quot;org.scalafmt.cli.Cli&quot;),
          fork := true, // to avoid exit
        ) ++ Defaults.runnerSettings
      )
  )
}
</code></pre><p>Enabling <code>ScalafmtPlugin</code> would add <code>scalafmt</code> task, which runs the CLI.
</p><pre><code class="">sbt:custom-configs&gt; scalafmt --version
[info] running (fork) org.scalafmt.cli.Cli --version
[info] scalafmt 2.7.5
[success] Total time: 3 s, completed Feb 8, 2021 12:01:34 AM
sbt:custom-configs&gt; scalafmt
[info] running (fork) org.scalafmt.cli.Cli
[info] Reformatting...
       Reformatting...
[success] Total time: 6 s, completed Feb 8, 2021 12:01:40 AM
</code></pre><h3 id="How+do+I+add+a+test+configuration%3F">How do I add a test configuration?<a href="#How+do+I+add+a+test+configuration%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See the <a href="Testing.html#additional-test-configurations">Additional test configurations</a> section of
<a href="Testing.html">Testing</a>.
</p><h2 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This section of the documentation has example sbt build definitions and
code. Contributions are welcome!
</p><p>You may want to read the
<a href="Getting-Started.html">Getting Started Guide</a> as a foundation for
understanding the examples.
</p><h2 id=".sbt+build+examples">.sbt build examples<a href="#.sbt+build+examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><strong>Note</strong>: As of sbt 0.13.7 blank lines are no longer used to delimit <code>build.sbt</code> files. The following example requires sbt 0.13.7+.
</p><p>Listed here are some examples of settings (each setting is independent).
See <a href="Basic-Def.html">.sbt build definition</a> for details.
</p><pre><code class="prettyprint lang-scala">import scala.concurrent.duration._

// factor out common settings
ThisBuild / organization := &quot;org.myproject&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
// set the Scala version used for the project
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

// set the prompt (for this build) to include the project id.
ThisBuild / shellPrompt := { state =&gt; Project.extract(state).currentRef.project + &quot;&gt; &quot; }

// define ModuleID for library dependencies
lazy val scalacheck = &quot;org.scalacheck&quot; %% &quot;scalacheck&quot; % &quot;1.13.4&quot;

// define ModuleID using string interpolator
lazy val osmlibVersion = &quot;2.5.2-RC1&quot;
lazy val osmlib = (&quot;net.sf.travelingsales&quot; % &quot;osmlib&quot; % osmlibVersion from
  s&quot;&quot;&quot;http://downloads.sourceforge.net/project/travelingsales/libosm/$osmlibVersion/libosm-$osmlibVersion.jar&quot;&quot;&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    // set the name of the project
    name := &quot;My Project&quot;,

    // set the main Scala source directory to be &lt;base&gt;/src
    Compile / scalaSource := baseDirectory.value / &quot;src&quot;,

    // set the Scala test source directory to be &lt;base&gt;/test
    Test / scalaSource := baseDirectory.value / &quot;test&quot;,

    // add a test dependency on ScalaCheck
    libraryDependencies += scalacheck % Test,

    // add compile dependency on osmlib
    libraryDependencies += osmlib,

    // reduce the maximum number of errors shown by the Scala compiler
    maxErrors := 20,

    // increase the time between polling for file changes when using continuous execution
    pollInterval := 1.second,

    // append several options to the list of options passed to the Java compiler
    javacOptions ++= Seq(&quot;-source&quot;, &quot;1.5&quot;, &quot;-target&quot;, &quot;1.5&quot;),

    // append -deprecation to the options passed to the Scala compiler
    scalacOptions += &quot;-deprecation&quot;,

    // define the statements initially evaluated when entering 'console', 'consoleQuick', or 'consoleProject'
    initialCommands := &quot;&quot;&quot;
      |import System.{currentTimeMillis =&gt; now}
      |def time[T](f: =&gt; T): T = {
      |  val start = now
      |  try { f } finally { println(&quot;Elapsed: &quot; + (now - start)/1000.0 + &quot; s&quot;) }
      |}&quot;&quot;&quot;.stripMargin,

    // set the initial commands when entering 'console' or 'consoleQuick', but not 'consoleProject'
    console / initialCommands := &quot;import myproject._&quot;,

    // set the main class for packaging the main jar
    // 'run' will still auto-detect and prompt
    // change Compile to Test to set it for the test jar
    Comile / packageBin / mainClass := Some(&quot;myproject.MyMain&quot;),

    // set the main class for the main 'run' task
    // change Compile to Test to set it for 'test:run'
    Compile / run / mainClass := Some(&quot;myproject.MyMain&quot;),

    // add &lt;base&gt;/input to the files that '~' triggers on
    watchSources += baseDirectory.value / &quot;input&quot;,

    // add a maven-style repository
    resolvers += &quot;name&quot; at &quot;url&quot;,

    // add a sequence of maven-style repositories
    resolvers ++= Seq(&quot;name&quot; at &quot;url&quot;),

    // define the repository to publish to
    publishTo := Some(&quot;name&quot; at &quot;url&quot;),

    // set Ivy logging to be at the highest level
    ivyLoggingLevel := UpdateLogging.Full,

    // disable updating dynamic revisions (including -SNAPSHOT versions)
    offline := true,

    // set the prompt (for the current project) to include the username
    shellPrompt := { state =&gt; System.getProperty(&quot;user.name&quot;) + &quot;&gt; &quot; },

    // disable printing timing information, but still print [success]
    showTiming := false,

    // disable printing a message indicating the success or failure of running a task
    showSuccess := false,

    // change the format used for printing task completion time
    timingFormat := {
        import java.text.DateFormat
        DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT)
    },

    // disable using the Scala version in output paths and artifacts
    crossPaths := false,

    // fork a new JVM for 'run' and 'Test/run'
    fork := true,

    // fork a new JVM for 'Test/run', but not 'run'
    Test / fork := true,

    // add a JVM option to use when forking a JVM for 'run'
    javaOptions += &quot;-Xmx2G&quot;,

    // only use a single thread for building
    parallelExecution := false,

    // Execute tests in the current project serially
    //   Tests from other projects may still run concurrently.
    Test / parallelExecution := false,

    // set the location of the JDK to use for compiling Java code.
    // if 'fork' is true, this is used for 'run' as well
    javaHome := Some(file(&quot;/usr/lib/jvm/sun-jdk-1.6&quot;)),

    // Use Scala from a directory on the filesystem instead of retrieving from a repository
    scalaHome := Some(file(&quot;/home/user/scala/trunk/&quot;)),

    // don't aggregate clean (See FullConfiguration for aggregation details)
    clean / aggregate := false,

    // only show warnings and errors on the screen for compilations.
    //  this applies to both test:compile and compile and is Info by default
    compile / logLevel := Level.Warn,

    // only show warnings and errors on the screen for all tasks (the default is Info)
    //  individual tasks can then be more verbose using the previous setting
    logLevel := Level.Warn,

    // only store messages at info and above (the default is Debug)
    //   this is the logging level for replaying logging with 'last'
    persistLogLevel := Level.Debug,

    // only show 10 lines of stack traces
    traceLevel := 10,

    // only show stack traces up to the first sbt stack frame
    traceLevel := 0,

    // add SWT to the unmanaged classpath
    Compile / unmanagedJars += Attributed.blank(file(&quot;/usr/share/java/swt.jar&quot;)),

    // publish test jar, sources, and docs
    Test / publishArtifact := true,

    // disable publishing of main docs
    Compile / packageDoc / publishArtifact := false,

    // change the classifier for the docs artifact
    packageDoc / artifactClassifier := Some(&quot;doc&quot;),

    // Copy all managed dependencies to &lt;build-root&gt;/lib_managed/
    //   This is essentially a project-local cache.  There is only one
    //   lib_managed/ in the build root (not per-project).
    retrieveManaged := true,

    /* Specify a file containing credentials for publishing. The format is:
    realm=Sonatype Nexus Repository Manager
    host=nexus.scala-tools.org
    user=admin
    password=admin123
    */
    credentials += Credentials(Path.userHome / &quot;.ivy2&quot; / &quot;.credentials&quot;),

    // Directly specify credentials for publishing.
    credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;, &quot;nexus.scala-tools.org&quot;, &quot;admin&quot;, &quot;admin123&quot;),

    // Exclude transitive dependencies, e.g., include log4j without including logging via jdmk, jmx, or jms.
    libraryDependencies +=
      &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; excludeAll(
        ExclusionRule(organization = &quot;com.sun.jdmk&quot;),
        ExclusionRule(organization = &quot;com.sun.jmx&quot;),
        ExclusionRule(organization = &quot;javax.jms&quot;)
      )
  )
</code></pre><h2 id=".sbt+build+with+.scala+files+example">.sbt build with .scala files example<a href="#.sbt+build+with+.scala+files+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><code>.sbt</code> builds can be supplemented with <code>project/*.scala</code> files.
When the build file gets large enough, the first thing to factor out are resolvers and dependencies.
</p><h3 id="project%2FResolvers.scala">project/Resolvers.scala<a href="#project%2FResolvers.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object Resolvers {
  val sunrepo    = &quot;Sun Maven2 Repo&quot; at &quot;http://download.java.net/maven/2&quot;
  val sunrepoGF  = &quot;Sun GF Maven2 Repo&quot; at &quot;http://download.java.net/maven/glassfish&quot; 
  val oraclerepo = &quot;Oracle Maven2 Repo&quot; at &quot;http://download.oracle.com/maven&quot;

  val oracleResolvers = Seq(sunrepo, sunrepoGF, oraclerepo)
}
</code></pre><h3 id="project%2FDependencies.scala">project/Dependencies.scala<a href="#project%2FDependencies.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object Dependencies {
  val logbackVersion = &quot;0.9.16&quot;
  val grizzlyVersion = &quot;1.9.19&quot;

  val logbackcore    = &quot;ch.qos.logback&quot; % &quot;logback-core&quot;     % logbackVersion
  val logbackclassic = &quot;ch.qos.logback&quot; % &quot;logback-classic&quot;  % logbackVersion

  val jacksonjson = &quot;org.codehaus.jackson&quot; % &quot;jackson-core-lgpl&quot; % &quot;1.7.2&quot;

  val grizzlyframwork = &quot;com.sun.grizzly&quot; % &quot;grizzly-framework&quot; % grizzlyVersion
  val grizzlyhttp     = &quot;com.sun.grizzly&quot; % &quot;grizzly-http&quot;      % grizzlyVersion
  val grizzlyrcm      = &quot;com.sun.grizzly&quot; % &quot;grizzly-rcm&quot;       % grizzlyVersion
  val grizzlyutils    = &quot;com.sun.grizzly&quot; % &quot;grizzly-utils&quot;     % grizzlyVersion
  val grizzlyportunif = &quot;com.sun.grizzly&quot; % &quot;grizzly-portunif&quot;  % grizzlyVersion

  val sleepycat = &quot;com.sleepycat&quot; % &quot;je&quot; % &quot;4.0.92&quot;

  val apachenet   = &quot;commons-net&quot;   % &quot;commons-net&quot;   % &quot;2.0&quot;
  val apachecodec = &quot;commons-codec&quot; % &quot;commons-codec&quot; % &quot;1.4&quot;

  val scalatest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
}
</code></pre><p>These files can be used mange library dependencies in one place.
</p><h3 id="project%2FShellPromptPlugin.scala">project/ShellPromptPlugin.scala<a href="#project%2FShellPromptPlugin.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When you want to implement custom commands or tasks, you can organize your build by defining an one-off auto plugin.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._
import scala.sys.process._

// Shell prompt which show the current project and git branch
object ShellPromptPlugin extends AutoPlugin {
  override def trigger = allRequirements
  override lazy val projectSettings = Seq(
    shellPrompt := buildShellPrompt
  )
  val devnull: ProcessLogger = new ProcessLogger {
    def out(s: =&gt; String): Unit = {}
    def err(s: =&gt; String): Unit = {}
    def buffer[T] (f: =&gt; T): T = f
  }
  def currBranch =
    (&quot;git status -sb&quot; lineStream_! devnull headOption)
      .getOrElse(&quot;-&quot;).stripPrefix(&quot;## &quot;)
  val buildShellPrompt: State =&gt; String = {
    case (state: State) =&gt;
      val currProject = Project.extract (state).currentProject.id
      s&quot;&quot;&quot;$currProject:$currBranch&gt; &quot;&quot;&quot;
  }
}
</code></pre><p>This auto plugin will display the current project name and the git branch.
</p><h3 id="build.sbt">build.sbt<a href="#build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now that we factored out custom settings and dependencies out to <code>project/*.scala</code>, we can make use of them in <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">import Resolvers._
import Dependencies._

// factor out common settings into a sequence
lazy val buildSettings = Seq(
  organization := &quot;com.example&quot;,
  version := &quot;0.1.0&quot;,
  scalaVersion := &quot;2.12.13&quot;
)

// Sub-project specific dependencies
lazy val commonDeps = Seq(
  logbackcore,
  logbackclassic,
  jacksonjson,
  scalatest % Test
)

lazy val serverDeps = Seq(
  grizzlyframwork,
  grizzlyhttp,
  grizzlyrcm,
  grizzlyutils,
  grizzlyportunif,
  sleepycat,
  scalatest % Test
)

lazy val pricingDeps = Seq(
  apachenet,
  apachecodec,
  scalatest % Test
)

lazy val cdap2 = (project in file(&quot;.&quot;))
  .aggregate(common, server, compact, pricing, pricing_service)
  .settings(buildSettings)

lazy val common = (project in file(&quot;cdap2-common&quot;))
  .settings(
    buildSettings,
    libraryDependencies ++= commonDeps
  )

lazy val server = (project in file(&quot;cdap2-server&quot;))
  .dependsOn(common)
  .settings(
    buildSettings,
    resolvers := oracleResolvers,
    libraryDependencies ++= serverDeps
  )

lazy val pricing = (project in file(&quot;cdap2-pricing&quot;))
  .dependsOn(common, compact, server)
  .settings(
    buildSettings,
    libraryDependencies ++= pricingDeps
  )  

lazy val pricing_service = (project in file(&quot;cdap2-pricing-service&quot;))
  .dependsOn(pricing, server)
  .settings(buildSettings)

lazy val compatct = (project in file(&quot;compact-hashmap&quot;))
  .settings(buildSettings)
</code></pre><h2 id="Advanced+configurations+example">Advanced configurations example<a href="#Advanced+configurations+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an example <a href="Basic-Def.html">.sbt build definition</a>
that demonstrates using configurations to group dependencies.
</p><p>The <code>utils</code> module provides utilities for other modules. It uses
configurations to group dependencies so that a dependent project doesn’t
have to pull in all dependencies if it only uses a subset of
functionality. This can be an alternative to having multiple utilities
modules (and consequently, multiple utilities jars).
</p><p>In this example, consider a <code>utils</code> project that provides utilities
related to both Scalate and Saxon. It therefore needs both Scalate and
Saxon on the compilation classpath and a project that uses all of the
functionality of ‘utils’ will need these dependencies as well. However,
project <code>a</code> only needs the utilities related to Scalate, so it doesn’t
need Saxon. By depending only on the <code>scalate</code> configuration of <code>utils</code>,
it only gets the Scalate-related dependencies.
</p><pre><code class="prettyprint lang-scala">// Custom configurations
lazy val Common = config(&quot;common&quot;).describedAs(&quot;Dependencies required in all configurations.&quot;)
lazy val Scalate = config(&quot;scalate&quot;).extend(Common).describedAs(&quot;Dependencies for using Scalate utilities.&quot;)
lazy val Saxon = config(&quot;saxon&quot;).extend(Common).describedAs(&quot;Dependencies for using Saxon utilities.&quot;)

// Define a customized compile configuration that includes
// dependencies defined in our other custom configurations
lazy val CustomCompile = config(&quot;compile&quot;).extend(Saxon, Common, Scalate)

// factor out common settings
ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

// An example project that only uses the Scalate utilities.
lazy val a = (project in file(&quot;a&quot;))
  .dependsOn(utils % &quot;compile-&gt;scalate&quot;)

// An example project that uses the Scalate and Saxon utilities.
// For the configurations defined here, this is equivalent to doing dependsOn(utils),
//  but if there were more configurations, it would select only the Scalate and Saxon
//  dependencies.
lazy val b = (project in file(&quot;b&quot;))
  .dependsOn(utils % &quot;compile-&gt;scalate,saxon&quot;)

// Defines the utilities project
lazy val utils = (project in file(&quot;utils&quot;))
  .settings(
    inConfig(Common)(Defaults.configSettings),  // Add the src/common/scala/ compilation configuration.
    addArtifact(Common / packageBin / artifact, Common / packageBin), // Publish the common artifact

    // We want our Common sources to have access to all of the dependencies on the classpaths
    //   for compile and test, but when depended on, it should only require dependencies in 'common'
    Common / classpathConfiguration := CustomCompile,

    // Modify the default Ivy configurations.
    // 'overrideConfigs' ensures that Compile is replaced by CustomCompile
    ivyConfigurations := overrideConfigs(Scalate, Saxon, Common, CustomCompile)(ivyConfigurations.value),

    // Put all dependencies without an explicit configuration into Common (optional)
    defaultConfiguration := Some(Common),

    // Declare dependencies in the appropriate configurations
    libraryDependencies ++= Seq(
       &quot;org.fusesource.scalate&quot; % &quot;scalate-core&quot; % &quot;1.5.0&quot; % Scalate,
       &quot;org.squeryl&quot; %% &quot;squeryl&quot; % &quot;0.9.5-6&quot; % Scalate,
       &quot;net.sf.saxon&quot; % &quot;saxon&quot; % &quot;8.7&quot; % Saxon
    )
  )
</code></pre><h2 id="Advanced+command+example">Advanced command example<a href="#Advanced+command+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an advanced example showing some of the power of the new
settings system. It shows how to temporarily modify all declared
dependencies in the build, regardless of where they are defined. It
directly operates on the final <code>Seq[Setting[_]]</code> produced from every
setting involved in the build.
</p><p>The modifications are applied by running <em>canonicalize</em>. A <em>reload</em> or
using <em>set</em> reverts the modifications, requiring <em>canonicalize</em> to be
run again.
</p><p>This particular example shows how to transform all declared dependencies
on ScalaCheck to use version 1.8. As an exercise, you might try
transforming other dependencies, the repositories used, or the scalac
options used. It is possible to add or remove settings as well.
</p><p>This kind of transformation is possible directly on the settings of
Project, but it would not include settings automatically added from
plugins or build.sbt files. What this example shows is doing it
unconditionally on all settings in all projects in all builds, including
external builds.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object Canon extends Plugin {
  // Registers the canonicalize command in every project
  override def settings = Seq(commands += canonicalize)

  // Define the command.  This takes the existing settings (including any session settings)
  // and applies 'f' to each Setting[_]
  def canonicalize = Command.command(&quot;canonicalize&quot;) { (state: State) =&gt;
    val extracted = Project.extract(state)
    import extracted._
    val transformed = session.mergeSettings map ( s =&gt; f(s) )
    appendWithSession(transformed, state)
  }

  // Transforms a Setting[_].
  def f(s: Setting[_]): Setting[_] = s.key.key match {
    // transform all settings that modify libraryDependencies
    case Keys.libraryDependencies.key =&gt;
      // hey scalac.  T == Seq[ModuleID]
      s.asInstanceOf[Setting[Seq[ModuleID]]].mapInit(mapLibraryDependencies)
      // preserve other settings
    case _ =&gt; s
  }
  // This must be idempotent because it gets applied after every transformation.
  // That is, if the user does:
  //  libraryDependencies += a
  //  libraryDependencies += b
  // then this method will be called for Seq(a) and Seq(a,b)
  def mapLibraryDependencies(key: ScopedKey[Seq[ModuleID]], value: Seq[ModuleID]): Seq[ModuleID] =
    value map mapSingle

  // This is the fundamental transformation.
  // Here we map all declared ScalaCheck dependencies to be version 1.8
  def mapSingle(module: ModuleID): ModuleID =
    if(module.name == &quot;scalacheck&quot;) module.withRevision(revision = &quot;1.8&quot;) 
    else module
}
</code></pre><h2 id="Index">Index<a href="#Index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an index of common methods, types, and values you might find in
an sbt build definition. For command names, see
<a href="Running.html">Running</a>. For available plugins, see
<a href="Communitiy-Plugins.html">the plugins list</a>.
</p><h3 id="Values+and+Types">Values and Types<a href="#Values+and+Types" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="../api/sbt/librarymanagement/ModuleID.html">ModuleID</a> is the type of a dependency
definition. See
<a href="Library-Management.html">Library Management</a>.
</li><li><a href="../api/sbt/librarymanagement/Artifact.html">Artifact</a> represents a single artifact
(such as a jar or a pom) to be built and published. See
<a href="Library-Management.html">Library Management</a> and <a href="Artifacts.html">Artifacts</a>.
</li><li>A <a href="../api/sbt/librarymanagement/Resolver.html">Resolver</a> can resolve and retrieve
dependencies. Many types of Resolvers can publish dependencies as
well. A repository is a closely linked idea that typically refers to
the actual location of the dependencies. However, sbt is not very
consistent with this terminology and repository and resolver are
occasionally used interchangeably.
</li><li>A <a href="../api/sbt/librarymanagement/ModuleConfiguration.html">ModuleConfiguration</a> defines
a specific resolver to use for a group of dependencies.
</li><li>A <a href="../api/sbt/librarymanagement/Configuration.html">Configuration</a> is a useful Ivy
construct for grouping dependencies. See ivy-configurations. It is
also used for <a href="Scopes.html">scoping settings</a>.
</li><li><code>Compile</code>, <code>Test</code>, <code>Runtime</code>, <code>Provided</code>, and <code>Optional</code> are
predefined <a href="Library-Management.html#ivy-configurations">configurations</a>.
</li></ul><h4 id="Settings+and+Tasks">Settings and Tasks<a href="#Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>A <a href="../api/sbt/internal/util/Init$Setting.html">Setting</a> describes how to
initialize a specific setting in the build. It can use the values of
other settings or the previous value of the setting being
initialized.
</li><li>A <a href="../api/sbt/internal/util/Init$SettingsDefinition.html">SettingsDefinition</a>
is the actual type of an expression in a build.sbt. This allows
either a single <a href="../api/sbt/internal/util/Init$Setting.html">Setting</a> or a
sequence of settings
(<a href="../api/sbt/internal/util/Init$SettingList.html">SettingList</a>) to be defined at
once. The types in a <a href="Full-Def.html">.scala build definition</a> always use just a
plain <a href="../api/sbt/internal/util/Init$Setting.html">Setting</a>.
</li><li><a href="../api/sbt/internal/util/Init$Initialize.html">Initialize</a> describes how to
initialize a setting using other settings, but isn’t bound to a
particular setting yet. Combined with an initialization method and a
setting to initialize, it produces a full
<a href="../api/sbt/internal/util/Init$Setting.html">Setting</a>.
</li><li><a href="../api/sbt/TaskKey.html">TaskKey</a>,
<a href="../api/sbt/SettingKey.html">SettingKey</a>, and
<a href="../api/sbt/InputKey.html">InputKey</a> are keys that represent a task
or setting. These are not the actual tasks, but keys that are used
to refer to them. They can be scoped to produce
<a href="../api/sbt/ScopedTask.html">ScopedTask</a>,
<a href="../api/sbt/ScopedSetting.html">ScopedSetting</a>, and
<a href="../api/sbt/ScopedInput.html">ScopedInput</a>. These form the base
types that provide the Settings methods.
</li><li><a href="../api/sbt/InputTask.html">InputTask</a> parses and tab completes
user input, producing a task to run.
</li><li><a href="../api/sbt/Task.html">Task</a> is the type of a task. A task is an
action that runs on demand. This is in contrast to a setting, which
is run once at project initialization.
</li></ul><h4 id="Build+Structure">Build Structure<a href="#Build+Structure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="../api/sbt/AutoPlugin.html">AutoPlugin</a> is the trait implemented for sbt
<a href="Using-Plugins.html">plugins</a>.
</li><li><a href="../api/sbt/Project.html">Project</a> is both a trait and a
companion object that declares a single module in a build. See
<a href="Full-Def.html">.scala build definition</a>.
</li><li><a href="../api/sbt/Keys$.html">Keys</a> is an object that provides all of
the built-in keys for settings and tasks.
</li><li><a href="../api/sbt/State.html">State</a> contains the full state for a
build. It is mainly used by <a href="Commands.html">Commands</a> and sometimes
<a href="Input-Tasks.html">Input Tasks</a>. See also <a href="Build-State.html">State and Actions</a>.
</li></ul><h3 id="Methods">Methods<a href="#Methods" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Settings+and+Tasks">Settings and Tasks<a href="#Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See the <a href="Basic-Def.html">Getting Started Guide</a> for
details.
</p><ul><li><code>:=</code>, <code>+=</code>, <code>++=</code> These construct a
<a href="../api/sbt/internal/util/Init$Setting.html">Setting</a>, which is the fundamental
type in the <a href="Basic-Def.html">settings</a> system.
</li><li><code>value</code> This uses the value of another setting or task in the
definition of a new setting or task. This method is special (it is a
macro) and cannot be used except in the argument of one of the
setting definition methods above (:=, …) or in the standalone
construction methods Def.setting and Def.task. See
<a href="Task-Graph.html">Task-Graph</a> for
details.
</li><li><code>in</code> specifies the <a href="../api/sbt/Scope.html">Scope</a> or part of the
<a href="../api/sbt/Scope.html">Scope</a> of a setting being referenced. See
<a href="Scopes.html">scopes</a>.
</li></ul><h4 id="File+and+IO">File and IO<a href="#File+and+IO" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="../api/sbt/io/RichFile.html">RichFile</a>,
<a href="../api/sbt/io/PathFinder.html">PathFinder</a>, and
<a href="Paths.html">Paths</a> for the full documentation.
</p><ul><li><code>/</code> When called on a single File, this is <code>new File(x,y)</code>. For
Seq[File], this is applied for each member of the sequence..
</li><li><code>*</code> and <code>**</code> are methods for selecting children (<code>*</code>) or descendants
(<code>**</code>) of a File or Seq[File] that match a filter.
</li><li><code>|</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>&amp;</code>, <code>-</code>, and <code>--</code> are methods for combining
filters, which are often used for selecting Files. See
<a href="../api/sbt/io/NameFilter.html">NameFilter</a> and
<a href="../api/sbt/io/FileFilter.html">FileFilter</a>. Note that methods with
these names also exist for other types, such as collections (like
Seq) and <a href="../api/sbt/internal/util/complete/Parser.html">Parser</a> (see
<a href="Parsing-Input.html">Parsing Input</a>).
</li><li><code>pair</code> Used to construct mappings from a <code>File</code> to another <code>File</code> or
to a String. See <a href="Mapping-Files.html">Mapping Files</a>.
</li><li><code>get</code> forces a <a href="../api/sbt/io/PathFinder.html">PathFinder</a> (a
call-by-name data structure) to a strict <code>Seq[File]</code> representation.
This is a common name in Scala, used by types like Option.
</li></ul><h4 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Library-Management.html">Library Management</a> for full documentation.
</p><ul><li><code>%</code> This is used to build up a <a href="../api/sbt/librarymanagement/ModuleID.html">ModuleID</a>.
</li><li><code>%%</code> This is similar to <code>%</code> except that it identifies a dependency
that has been <a href="Cross-Build.html">cross built</a>.
</li><li><code>from</code> Used to specify the fallback URL for a dependency
</li><li><code>classifier</code> Used to specify the classifier for a dependency.
</li><li><code>at</code> Used to define a Maven-style resolver.
</li><li><code>intransitive</code> Marks a <a href="../api/sbt/librarymanagement/ModuleID.html">dependency</a> or
<a href="../api/sbt/librarymanagement/Configuration.html">Configuration</a> as being
intransitive.
</li><li><code>hide</code> Marks a <a href="../api/sbt/librarymanagement/Configuration.html">Configuration</a> as
internal and not to be included in the published metadata.
</li></ul><h4 id="Parsing">Parsing<a href="#Parsing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These methods are used to build up
<a href="../api/sbt/internal/util/complete/Parser.html">Parser</a>s from smaller
<a href="../api/sbt/internal/util/complete/Parser.html">Parser</a>s. They closely follow the
names of the standard library’s parser combinators. See
<a href="Parsing-Input.html">Parsing Input</a> for the full documentation. These are
used for
<a href="Input-Tasks.html">Input Tasks</a> and
<a href="Commands.html">Commands</a>.
</p><ul><li><code>~</code>, <code>~&gt;</code>, <code>&lt;~</code> Sequencing methods.
</li><li><code>??</code>, <code>?</code> Methods for making a Parser optional. <code>?</code> is postfix.
</li><li><code>id</code> Used for turning a Char or String literal into a Parser. It is
generally used to trigger an implicit conversion to a Parser.
</li><li><code>|</code>, <code>||</code> Choice methods. These are common method names in Scala.
</li><li><code>^^^</code> Produces a constant value when a Parser matches.
</li><li><code>+</code>, <code>*</code> Postfix repetition methods. These are common method names
in Scala.
</li><li><code>map</code>, <code>flatMap</code> Transforms the result of a Parser. These are common
method names in Scala.
</li><li><code>filter</code> Restricts the inputs that a Parser matches on. This is a
common method name in Scala.
</li><li><code>-</code> Prefix negation. Only matches the input when the original parser
doesn’t match the input.
</li><li><code>examples</code>, <code>token</code> Tab completion
</li><li><code>!!!</code> Provides an error message to use when the original parser
doesn’t match the input.
</li></ul><h2 id="Developer%E2%80%99s+Guide+%28Work+in+progress%29">Developer’s Guide (Work in progress)<a href="#Developer%E2%80%99s+Guide+%28Work+in+progress%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is the set of documentation about the future architecture of sbt.
The target audience of this document is the sbt plugin authors
and sbt developers. See also <a href="https://www.scala-sbt.org/community.html#how-can-I-help">How can I help?</a>
</p><h3 id="Towards+sbt+1.0">Towards sbt 1.0<a href="#Towards+sbt+1.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On 2008-12-18, Mark Harrah announced sbt 0.3.2 as the initial release of sbt.
Mark remained the primary author of sbt until sbt 0.13.1 (2013-12-11).
In 2014, sbt project was handed over to the authors of this document Josh Suereth
and Eugene Yokota.
</p><p>As we move towards sbt 1.0, we wish to stabilize what’s already stable
and innovate where it matters. There are several levels of stability:
</p><ul><li>conceptual stability
</li><li>source compatibility of the build definition
</li><li>binary compatibility of the plugins
</li></ul><h4 id="Concepts">Concepts<a href="#Concepts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Conceptually, sbt has been stable on what it does:
</p><ol><li>incremental compilation that supports Scala
</li><li>dependency management that’s aware of Scala’s binary compatibility
</li><li>task and plugins system that’s extensible using Scala
</li><li>a text-based interactive shell
</li></ol><p>The only thing that we plan to change is the last point.
In sbt 1.0, we will replace the interactive shell with sbt server
that’s accessible via JSON API and a text-based client.
</p><h4 id="Source+compatibility+of+the+build+definition">Source compatibility of the build definition<a href="#Source+compatibility+of+the+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Source compatibility means that a build source that worked for sbt version A
works for another version B without modification.
Our goal for sbt 1.0 is to adopt Semantic Versioning, and maintain
source compatibility of the build during 1.x.y.
</p><h4 id="Binary+compatibility+of+the+plugins">Binary compatibility of the plugins<a href="#Binary+compatibility+of+the+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Binary compatibility (“bincompat”) of the plugins means that a plugin
that was published for sbt version A works for another version B without recompilation.
sbt 0.13 has kept binary compatibility for 18 months as of March 2015.
The stability here helps maintain the sbt plugin ecosystem.
Our goal for sbt 1.0 is to adopt Semantic Versioning, and maintain
binary compatibility of the build during 1.x.y.
</p><p>From the development perspective, maintaining binary compatibility becomes
an additional constraint that we need to worry about whenever we make changes.
The root of the problem is that sbt 0.13 does not distinguish between public API
and internal implementation. Most things are open to plugins.
</p><h3 id="Modularization">Modularization<a href="#Modularization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The process we aim to take for sbt 1.0 is to disassemble sbt into smaller modules and layers.
To be clear, sbt 0.13’s codebase already does consist of numerous subprojects.
</p><p>Layers are more coarse-grained sets of subproject(s) that can be used independently.
Another purpose of the modularization is to distinguish between public API and internal implementation.
Reducing the surface area of the sbt code base has several benefits:
</p><ul><li>It makes it easier for the build users and the plugin authors to learn the APIs.
</li><li>It makes it easier for us to maintain binary and semantic compatibilities.
</li><li>It encourages the reuse of the modules.
</li></ul><p>The following is a conceptual diagram of the layers:
</p><p><img src="files/module-diagram.png" alt="Module diagram"/>
</p><p>We’ll discuss the details in the next page.
</p><h3 id="Module+summary">Module summary<a href="#Module+summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The following is a conceptual diagram of the modular layers:
</p><p><img src="files/module-diagram.png" alt="Module diagram"/>
</p><p>This diagram is arranged such that each layer depends only on the layers underneath it.
</p><h4 id="IO+API+%28%29">IO API (<a href="https://github.com/sbt/io">sbt/io</a>)<a href="#IO+API+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>IO API is a low level API to deal with files and directories.
</p><h4 id="Serialization+API+%28%29">Serialization API (<a href="https://github.com/sbt/serialization">sbt/serialization</a>)<a href="#Serialization+API+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Serialization API is an opinionated wrapper around <a href="https://github.com/scala/pickling">Scala Pickling</a>.
The responsibility of the serialization API is to turn values into JSON.
</p><h4 id="Util+APIs+%28%29">Util APIs (<a href="https://github.com/sbt/util">sbt/util</a>)<a href="#Util+APIs+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Util APIs provide commonly used features like logging and internal datatypes used by sbt.
</p><h4 id="LibraryManagement+API+%28%29">LibraryManagement API (<a href="https://github.com/sbt/librarymanagement">sbt/librarymanagement</a>)<a href="#LibraryManagement+API+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt’s library management system is based on Apache Ivy, and as such
the concepts and terminology around the library management system are also influenced by Ivy.
The responsibility of the library management API is to calculate the transitive dependency graph,
and download artifacts from the given repositories.
</p><h4 id="IncrementalCompiler+API+%28%29">IncrementalCompiler API (<a href="https://github.com/sbt/zinc">sbt/zinc</a>)<a href="#IncrementalCompiler+API+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Incremental compilation of Scala is so fundamental
that we now seldom think of it as a feature of sbt.
There are number of subprojects/classes involved that are actually internal details,
and we should use this opportunity to hide them.
</p><h4 id="Build+API+%28tbd%29">Build API (tbd)<a href="#Build+API+%28tbd%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This is the part that’s exposed to <code>build.sbt</code>.
The responsibility of the module is to load the build files and plugins,
and provide a way for commands to be executed on the state.
</p><p>This might remain at <a href="https://github.com/sbt/sbt">sbt/sbt</a>.
</p><h4 id="sbt+Launcher+%28%29">sbt Launcher (<a href="https://github.com/sbt/launcher">sbt/launcher</a>)<a href="#sbt+Launcher+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The sbt launcher provides a generic container that can load and run
programs resolved using the Ivy dependency manager.
sbt uses this as the deployment mechanism, but it can be used for other purposes.
</p><p>See <a href="https://github.com/foundweekends/conscript">foundweekends/conscript</a> and <a href="Sbt-Launcher.html">Launcher</a> for more details.
</p><h4 id="Client%2FServer+%28tbd%29">Client/Server (tbd)<a href="#Client%2FServer+%28tbd%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Currently developed in <a href="https://github.com/sbt/sbt-remote-control">sbt/sbt-remote-control</a>.
sbt Server provides a JSON-based API wrapping functionality of the command line experience.
</p><p>One of the clients will be the “terminal client”,
which subsumes the command line sbt shell.
Other clients that are planned are IDE integrations.
</p><h4 id="Website+%28%29">Website (<a href="https://github.com/sbt/website">sbt/website</a>)<a href="#Website+%28%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This website’s source.
</p><h2 id="sbt+Coding+Guideline">sbt Coding Guideline<a href="#sbt+Coding+Guideline" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page discusses the coding style and other guidelines for sbt 1.0.
</p><h3 id="General+goal">General goal<a href="#General+goal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 1.0 will primarily target Scala 2.12.
We will cross-build against Scala 2.10.
</p><h4 id="Clean+up+old+deprecation">Clean up old deprecation<a href="#Clean+up+old+deprecation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Before 1.0 is release, we should clean up deprecations.
</p><h4 id="Aim+for+zero+warnings+%28except+deprecation%29">Aim for zero warnings (except deprecation)<a href="#Aim+for+zero+warnings+%28except+deprecation%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>On Scala 2.12 we should aim for zero warnings.
One exception may be deprecation if it’s required for cross-building.
</p><h3 id="Documentation">Documentation<a href="#Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><p>It is often useful to start with the Scaladoc before fleshing out a trait/class implementation by forcing you to consider the need for its existence.
</p></blockquote><p>All newly introduced <strong>public</strong> traits and classes and, to a lesser extent, functions and methods, should have Scaladoc. A significant amount of existing sbt code lacks documentation and we need to repair this situation over time. If you see an opportunity to add some documentation, or improve existing documentation then this will also help.
</p><p>Package level documentation is a great place to describe how various components interact, so please consider adding/enhancing that where possible.
</p><p>For more information on good Scaladoc style, please refer to the <a href="https://docs.scala-lang.org/style/scaladoc.html">Scaladoc Style Guide</a>
</p><h3 id="Modular+design">Modular design<a href="#Modular+design" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Aim+small">Aim small<a href="#Aim+small" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The fewer methods we can expose to the build user, the easier sbt becomes to maintain.
</p><h4 id="Public+APIs+should+be+coded+against+%E2%80%9Cinterfaces%E2%80%9C">Public APIs should be coded against “interfaces“<a href="#Public+APIs+should+be+coded+against+%E2%80%9Cinterfaces%E2%80%9C" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Code against interfaces.
</p><h4 id="Hide+implementation+details">Hide implementation details<a href="#Hide+implementation+details" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The implementation details should be hidden behind <code>sbt.internal.x</code> packages,
where <code>x</code> could be the name of the main package (like <code>io</code>).
</p><h4 id="Less+interdependence">Less interdependence<a href="#Less+interdependence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Independent modules with fewer dependent libraries are easier to reuse.
</p><h4 id="Hide+external+classes">Hide external classes<a href="#Hide+external+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Avoid exposing external classes in the API, except for standard Scala and Java classes.
</p><h4 id="Hide+internal+modules">Hide internal modules<a href="#Hide+internal+modules" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A module may be declared internal if it has no use to the public.
</p><h4 id="Compiler+flags">Compiler flags<a href="#Compiler+flags" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">-encoding utf8
-deprecation
-feature
-unchecked
-Xlint
-language:higherKinds
-language:implicitConversions
-Xfuture
-Yinline-warnings
-Yno-adapted-args
-Ywarn-dead-code
-Ywarn-numeric-widen
-Ywarn-value-discard
-Xfatal-warnings
</code></pre><p>The <code>-Xfatal-warnings</code> may be removed if there are unavoidable warnings.
</p><h4 id="Package+name+and+organization+name">Package name and organization name<a href="#Package+name+and+organization+name" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Use the package name appended with the layer name, such as <code>sbt.io</code> for IO layer.
The organization name for published artifacts should remain <code>org.scala-sbt</code>.
</p><h3 id="Binary+resiliency">Binary resiliency<a href="#Binary+resiliency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A good overview on the topic of binary resiliency is <a href="http://jsuereth.com/scala/2012/04/22/scaladays.html">Josh's 2012 talk</a> on
Binary resiliency.
The guideline here applies mostly to publicly exposed APIs.
</p><h4 id="MiMa">MiMa<a href="#MiMa" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Use <a href="https://github.com/lightbend/migration-manager">MiMa</a>.
</p><h4 id="Public+traits+should+contain++declarations+only">Public traits should contain <code>def</code> declarations only<a href="#Public+traits+should+contain++declarations+only" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><code>val</code> or <code>var</code> in a <code>trait</code> results in code generated at subclass and in the artificial <code>Foo$class.$init$</code>
</li><li><code>lazy val</code> results in code generated at subclass
</li></ul><h4 id="Abstract+classes+are+also+useful">Abstract classes are also useful<a href="#Abstract+classes+are+also+useful" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><a href="http://www.artima.com/pins1ed/traits.html#12.7">To trait, or not to trait?</a>.
Abstract classes are less flexible than traits, but traits pose more problems for binary compatibility. Abstract classes also have better Java interoperability.
</p><h4 id="Seal+traits+and+abstract+classes">Seal traits and abstract classes<a href="#Seal+traits+and+abstract+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If there’s no need to keep a class open, seal it.
</p><h4 id="Finalize+the+leaf+classes">Finalize the leaf classes<a href="#Finalize+the+leaf+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If there’s no need to keep a class open, finalize it.
</p><h4 id="Typeclass+and+subclass+inheritance">Typeclass and subclass inheritance<a href="#Typeclass+and+subclass+inheritance" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The typeclass pattern with pure traits might ease maintaining binary compatibility more so than subclassing.
</p><h4 id="Avoid+case+classes%2C+use+sbt-datatype">Avoid case classes, use sbt-datatype<a href="#Avoid+case+classes%2C+use+sbt-datatype" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Case classes involve code generation that makes it harder to maintain binary compatibility over time.
</p><h4 id="Prefer+method+overloading+over+default+parameter+values">Prefer method overloading over default parameter values<a href="#Prefer+method+overloading+over+default+parameter+values" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Default parameter values are effectively code generation,
which makes them difficult to maintain.
</p><h3 id="Other+public+API+matters">Other public API matters<a href="#Other+public+API+matters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Here are other guidelines about the sbt public API.
</p><h4 id="Avoid+Stringly-typed+programming">Avoid Stringly-typed programming<a href="#Avoid+Stringly-typed+programming" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Define datatypes.
</p><h4 id="Avoid+overuse+of">Avoid overuse of <code>def apply</code><a href="#Avoid+overuse+of" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>def apply</code> should be reserved for factory methods
in a companion object that returns type <code>T</code>.
</p><h4 id="Use+specific+datatypes+%28%2C+%2C+or+%29%2C+rather+than">Use specific datatypes (<code>Vector</code>, <code>List</code>, or <code>Array</code>), rather than <code>Seq</code><a href="#Use+specific+datatypes+%28%2C+%2C+or+%29%2C+rather+than" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>scala.Seq</code> is <code>scala.collection.Seq</code>, which is not immutable.
Default to <code>Vector</code>. Use <code>List</code> if constant prepending is needed.
Use <code>Array</code> if Java interoperability is needed.
Note that using mutable collections is perfectly fine within the implementation.
</p><h4 id="Avoid+calling++or+anything+with+side-effects+on">Avoid calling <code>toSeq</code> or anything with side-effects on <code>Set</code><a href="#Avoid+calling++or+anything+with+side-effects+on" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>Set</code> is fine if you stick to set operations, like <code>contains</code> and <code>subsetOf</code>.
More often than not, <code>toSeq</code> is called explicitly or implicitly,
or some side-effecting method is called from <code>map</code>.
This introduces non-determinism to the code.
</p><h4 id="Avoid+calling++on">Avoid calling <code>toSeq</code> on <code>Map</code><a href="#Avoid+calling++on" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Same as above. This will introduce non-determinism.
</p><h4 id="Avoid+functions+and+tuples+in+the+signature%2C+if+Java+interoperability+is+needed">Avoid functions and tuples in the signature, if Java interoperability is needed<a href="#Avoid+functions+and+tuples+in+the+signature%2C+if+Java+interoperability+is+needed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Instead of functions and tuples, turn them into a trait.
This applies where interoperability is a concern, like implementing
incremental compilation.
</p><h3 id="Style+matters">Style matters<a href="#Style+matters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Use+scalafmt">Use scalafmt<a href="#Use+scalafmt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt-houserules comes with scalafmt for formatting source code consistently.
</p><h4 id="Avoid+procedure+syntax">Avoid procedure syntax<a href="#Avoid+procedure+syntax" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Declare an explicit <code>Unit</code> return.
</p><h4 id="Define+instances+of+typeclasses+in+their+companion+objects%2C+when+possible">Define instances of typeclasses in their companion objects, when possible<a href="#Define+instances+of+typeclasses+in+their+companion+objects%2C+when+possible" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This style is encouraged:
</p><pre><code class="prettyprint lang-scala">final class FooID {}
object FooID {
  implicit val fooIdPicklerUnpicker: PicklerUnpickler[FooID] = ???
}
</code></pre><h4 id="Implicit+conversions+for+syntax+%28enrich-my-library+pattern%29+should+be+imported">Implicit conversions for syntax (enrich-my-library pattern) should be imported<a href="#Implicit+conversions+for+syntax+%28enrich-my-library+pattern%29+should+be+imported" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Avoid defining implicit converters in companion objects and package objects.
</p><p>Suppose the IO module introduces a <code>URL</code> enrichment called <code>RichURI</code>,
and LibraryManagement introduces a <code>String</code> enrichment called <code>GroupID</code> (for <code>ModuleID</code> syntax).
These implicit conversions should be defined in an object named <code>syntax</code> in the respective package:
</p><pre><code class="prettyprint lang-scala">package sbt.io

object syntax {
  implicit def uriToRichURI(uri: URI): RichURI = new RichURI(uri)
}
</code></pre><p>When all the layers are available, the <code>sbt</code> package should also define an object called <code>syntax</code>
which forwards implicit conversions from all the layers:
</p><pre><code class="prettyprint lang-scala">package sbt

object syntax {
  implicit def uriToRichURI(uri: URI): io.RichURI = io.syntax.uriToRichURI(uri)
  ....
}
</code></pre><h2 id="sbt-datatype">sbt-datatype<a href="#sbt-datatype" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt-datatype is a code generation library and an sbt autoplugin that generates
growable datatypes and helps developers avoid breakage of binary compatibility.
</p><p>Unlike standard Scala case classes, the datatypes (or pseudo case classes) generated
by this library allow the developer to add new fields to the defined datatypes without breaking
binary compatibility, while offering (almost) the same functionality as plain
case classes. The only difference is that datatype doesn’t generate <code>unapply</code> or <code>copy</code>
methods, because they would break binary compatibility.
</p><p>In addition, sbt-datatype is also able to generate JSON codec for sjson-new,
which can work against various JSON backends.
</p><p>Our plugin takes as input a datatype schema in the form of a <code>JSON</code> object,
whose format is based on the format defined by
<a href="http://avro.apache.org">Apache Avro</a>, and generates the corresponding code in
Java or Scala along with the boilerplate code that will allow the generated
classes to remain binary-compatible with previous versions of the datatype.
</p><p>The source code of the library and autoplugin
<a href="https://github.com/sbt/sbt-datatype">can be found on GitHub</a>.
</p><h3 id="Using+the+plugin">Using the plugin<a href="#Using+the+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To enable the plugin for your build, put the following line in
<code>project/datatype.sbt</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.scala-sbt&quot; % &quot;sbt-datatype&quot; % &quot;0.2.2&quot;)
</code></pre><p>Your datatype definitions should be placed by default in <code>src/main/datatype</code>
and <code>src/test/datatype</code>. Here’s how your build should be configured:
</p><pre><code class="prettyprint lang-scala">lazy val library = (project in file(&quot;library&quot;))
  .enablePlugins(DatatypePlugin)
  .settings(
    name := &quot;foo library&quot;,
  )
</code></pre><h3 id="Datatype+schema">Datatype schema<a href="#Datatype+schema" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Datatype is able to generate three kinds of types:
</p><ol><li>Records
</li><li>Interfaces
</li><li>Enums
</li></ol><h4 id="Records">Records<a href="#Records" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Records are mapped to Java or Scala <code>class</code>es, corresponding to
the standard case classes in Scala.
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Person&quot;,
      &quot;type&quot;: &quot;record&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;name&quot;,
          &quot;type&quot;: &quot;String&quot;
        },
        {
          &quot;name&quot;: &quot;age&quot;,
          &quot;type&quot;: &quot;int&quot;
        }
      ]
    }
  ]
}
</code></pre><p>This schema will produce the following Scala class:
</p><pre><code class="prettyprint lang-scala">final class Person(
  val name: String,
  val age: Int) extends Serializable {
  override def equals(o: Any): Boolean = o match {
    case x: Person =&gt; (this.name == x.name) &amp;&amp; (this.age == x.age)
    case _ =&gt; false
  }
  override def hashCode: Int = {
    37 * (37 * (17 + name.##) + age.##)
  }
  override def toString: String = {
    &quot;Person(&quot; + name + &quot;, &quot; + age + &quot;)&quot;
  }
  private[this] def copy(name: String = name, age: Int = age): Person = {
    new Person(name, age)
  }
  def withName(name: String): Person = {
    copy(name = name)
  }
  def withAge(age: Int): Person = {
    copy(age = age)
  }
}
object Person {
  def apply(name: String, age: Int): Person = new Person(name, age)
}
</code></pre><p>Or the following Java code (after changing the <code>target</code> property to <code>&quot;Java&quot;</code>):
</p><pre><code class="prettyprint lang-java">public final class Person implements java.io.Serializable {
    private String name;
    private int age;
    public Person(String _name, int _age) {
        super();
        name = _name;
        age = _age;
    }
    public String name() {
        return this.name;
    }
    public int age() {
        return this.age;
    }
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (!(obj instanceof Person)) {
            return false;
        } else {
            Person o = (Person)obj;
            return name().equals(o.name()) &amp;&amp; (age() == o.age());
        }
    }
    public int hashCode() {
        return 37 * (37 * (17 + name().hashCode()) + (new Integer(age())).hashCode());
    }
    public String toString() {
        return &quot;Person(&quot;  + &quot;name: &quot; + name() + &quot;, &quot; + &quot;age: &quot; + age() + &quot;)&quot;;
    }
}
</code></pre><h4 id="Interfaces">Interfaces<a href="#Interfaces" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Interfaces are mapped to Java <code>abstract class</code>es or Scala
<code>abstract classes</code>. They can be extended by other interfaces or records.
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Greeting&quot;,
      &quot;namespace&quot;: &quot;com.example&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;type&quot;: &quot;interface&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;message&quot;,
          &quot;type&quot;: &quot;String&quot;
        }
      ],
      &quot;types&quot;: [
        {
          &quot;name&quot;: &quot;SimpleGreeting&quot;,
          &quot;namespace&quot;: &quot;com.example&quot;,
          &quot;target&quot;: &quot;Scala&quot;,
          &quot;type&quot;: &quot;record&quot;
        }
      ]
    }
  ]
}
</code></pre><p>This generates abstract class named <code>Greeting</code> and a class named <code>SimpleGreeting</code>
that extends <code>Greeting</code>.
</p><p>In addition, interfaces can define <code>messages</code>, which generates abstract method declarations.
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;FooService&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;type&quot;: &quot;interface&quot;,
      &quot;messages&quot;: [
        {
          &quot;name&quot;: &quot;doSomething&quot;,
          &quot;response&quot;: &quot;int*&quot;,
          &quot;request&quot;: [
            {
              &quot;name&quot;: &quot;arg0&quot;,
              &quot;type&quot;: &quot;int*&quot;,
              &quot;doc&quot;: [
                &quot;The first argument of the message.&quot;,
              ]
            }
          ]
        }
      ]
    }
  ]
}
</code></pre><h4 id="Enums">Enums<a href="#Enums" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Enums are mapped to Java enumerations or Scala case objects.
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Weekdays&quot;,
      &quot;type&quot;: &quot;enum&quot;,
      &quot;target&quot;: &quot;Java&quot;,
      &quot;symbols&quot;: [
        &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;,
        &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;
      ]
    }
  ]
}
</code></pre><p>This schema will generate the following Java code:
</p><pre><code class="prettyprint lang-java">public enum Weekdays {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}
</code></pre><p>Or the following Scala code (after changing the <code>target</code> property to):
</p><pre><code class="prettyprint lang-scala">sealed abstract class Weekdays extends Serializable
object Weekdays {
  case object Monday extends Weekdays
  case object Tuesday extends Weekdays
  case object Wednesday extends Weekdays
  case object Thursday extends Weekdays
  case object Friday extends Weekdays
  case object Saturday extends Weekdays
  case object Sunday extends Weekdays
}
</code></pre><h3 id="Using+datatype+to+retain+binary+compatibility">Using datatype to retain binary compatibility<a href="#Using+datatype+to+retain+binary+compatibility" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By using the <code>since</code> and <code>default</code> parameters, it is possible to grow existing
datatypes while remaining binary compatible with classes that have been
compiled against an earlier version of your datatype definition.
</p><p>Consider the following initial version of a datatype:
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Greeting&quot;,
      &quot;type&quot;: &quot;record&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;message&quot;,
          &quot;type&quot;: &quot;String&quot;
        }
      ]
    }
  ]
}
</code></pre><p>The generated code could be used in a Scala program using the following code:
</p><pre><code class="prettyprint lang-scala">val greeting = Greeting(&quot;hello&quot;)
</code></pre><p>Imagine now that you would like to extend your datatype to include a date to
the <code>Greeting</code>s. The datatype can be modified accordingly:
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Greeting&quot;,
      &quot;type&quot;: &quot;record&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;message&quot;,
          &quot;type&quot;: &quot;String&quot;
        },
        {
          &quot;name&quot;: &quot;date&quot;,
          &quot;type&quot;: &quot;java.util.Date&quot;
        }
      ]
    }
  ]
}
</code></pre><p>Unfortunately, the code that used <code>Greeting</code> would no longer compile, and
classes that have been compiled against the previous version of the datatype
would crash with a <code>NoSuchMethodError</code>.
</p><p>To circumvent this problem and allow you to grow your datatypes, it is possible
to indicate the version <code>since</code> the field exists and a <code>default</code> value in the
datatype definition:
</p><pre><code class="prettyprint lang-json">{
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Greeting&quot;,
      &quot;type&quot;: &quot;record&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;message&quot;,
          &quot;type&quot;: &quot;String&quot;
        },
        {
          &quot;name&quot;: &quot;date&quot;,
          &quot;type&quot;: &quot;java.util.Date&quot;,
          &quot;since&quot;: &quot;0.2.0&quot;,
          &quot;default&quot;: &quot;new java.util.Date()&quot;
        }
      ]
    }
  ]
}
</code></pre><p>Now the code that was compiled against previous definitions of the datatype
will still run.
</p><h3 id="JSON+codec+generation">JSON codec generation<a href="#JSON+codec+generation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Adding <code>JsonCodecPlugin</code> to the subproject will generate sjson-new JSON codes for
the datatypes.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .enablePlugins(DatatypePlugin, JsonCodecPlugin)
  .settings(
    scalaVersion := &quot;2.11.8&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;sjson-new-scalajson&quot; % &quot;0.4.1&quot;
  )
</code></pre><p><code>codecNamespace</code> can be used to specify the package name for the codecs.
</p><pre><code class="prettyprint lang-json">{
  &quot;codecNamespace&quot;: &quot;com.example.codec&quot;,
  &quot;fullCodec&quot;: &quot;CustomJsonProtocol&quot;,
  &quot;types&quot;: [
    {
      &quot;name&quot;: &quot;Person&quot;,
      &quot;namespace&quot;: &quot;com.example&quot;,
      &quot;type&quot;: &quot;record&quot;,
      &quot;target&quot;: &quot;Scala&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;name&quot;,
          &quot;type&quot;: &quot;String&quot;
        },
        {
          &quot;name&quot;: &quot;age&quot;,
          &quot;type&quot;: &quot;int&quot;
        }
      ]
    }
  ]
}
</code></pre><p>JsonFormat traits will be generated under <code>com.example.codec</code> package,
along with a full codec named <code>CustomJsonProtocol</code> that mixes in all the traits.
</p><pre><code class="">scala&gt; import sjsonnew.support.scalajson.unsafe.{ Converter, CompactPrinter, Parser }
import sjsonnew.support.scalajson.unsafe.{Converter, CompactPrinter, Parser}

scala&gt; import com.example.codec.CustomJsonProtocol._
import com.example.codec.CustomJsonProtocol._

scala&gt; import com.example.Person
import com.example.Person

scala&gt; val p = Person(&quot;Bob&quot;, 20)
p: com.example.Person = Person(Bob, 20)

scala&gt; val j = Converter.toJsonUnsafe(p)
j: scala.json.ast.unsafe.JValue = JObject([Lscala.json.ast.unsafe.JField;@6731ad72)

scala&gt; val s = CompactPrinter(j)
s: String = {&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:20}

scala&gt; val x = Parser.parseUnsafe(s)
x: scala.json.ast.unsafe.JValue = JObject([Lscala.json.ast.unsafe.JField;@7331f7f8)

scala&gt; val q = Converter.fromJsonUnsafe[Person](x)
q: com.example.Person = Person(Bob, 20)

scala&gt; assert(p == q)
</code></pre><h3 id="Existing+parameters+for+protocols%2C+records%2C+etc.">Existing parameters for protocols, records, etc.<a href="#Existing+parameters+for+protocols%2C+records%2C+etc." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>All the elements of the schema definition accept a number of parameters that
will influence the generated code. These parameters are not available for
every node of the schema. Please refer to the syntax summary to see whether a
parameters can be defined for a node.
</p><h6><code>name</code></h6><p>This parameter defines the name of a field, record, field, etc.
</p><h6><code>target</code></h6><p>This parameter determines whether the code will be generated in Java or Scala.
</p><h6><code>namespace</code></h6><p>This parameter exists only for <code>Definition</code>s. It determines the package in
which the code will be generated.
</p><h6><code>doc</code></h6><p>The Javadoc that will accompany the generated element.
</p><h6><code>fields</code></h6><p>For a <code>protocol</code> or a <code>record</code> only, it describes all the fields that compose
the generated entity.
</p><h6><code>types</code></h6><p>For a <code>protocol</code>, it defines the child <code>protocol</code>s and <code>record</code>s that extend
it.
</p><p>For an <code>enumeration</code>, it defines the values of the enumeration.
</p><h6><code>since</code></h6><p>This parameter exists for <code>field</code>s only. It indicates the version in which the
field has been added to its parent <code>protocol</code> or <code>record</code>.
</p><p>When this parameter is defined, <code>default</code> must also be defined.
</p><h6><code>default</code></h6><p>This parameter exists for <code>field</code>s only. It indicates what the default value
should be for this field, in case it is used by a class that has been compiled
against an earlier version of this datatype.
</p><p>It must contain an expression which is valid in the <code>target</code> language of the
parent <code>protocol</code> or <code>record</code>.
</p><h6><code>type</code> for <code>field</code>s</h6><p>It indicates what is the underlying type of the field.
</p><p>Always use the type that you want to see in Scala. For instance, if your field
will contain an integer value, use <code>Int</code> rather than Java’s <code>int</code>. <code>datatype</code>
will automatically use Java’s primitive types if they are available.
</p><p>For non-primitive types, it is recommended to write the fully-qualified type.
</p><h6><code>type</code> for other definitions</h6><p>It simply indicates the kind of entity that you want to generate: <code>protocol</code>,
<code>record</code> or <code>enumeration</code>.
</p><h3 id="Settings">Settings<a href="#Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This location can be changed by setting a new location
in your build definition:
</p><pre><code class="prettyprint lang-scala">datatypeSource in generateDatatypes := file(&quot;some/location&quot;)
</code></pre><p>The plugin exposes other settings for Scala code generation:
</p><ol><li><code>Compile / generateDatatypes / datatypeScalaFileNames</code>
This setting accepts a function <code>Definition =&gt; File</code> which will determine
the filename for every generated Scala definition.
</li><li><code>Compile / generateDatatypes / datatypeScalaSealInterfaces</code>
This setting accepts a boolean value, and will determine whether interfaces
should be <code>seal</code>ed or not.
</li></ol><h3 id="Syntax+summary">Syntax summary<a href="#Syntax+summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">Schema           := {   &quot;types&quot;: [ Definition* ]
                     (, &quot;codecNamespace&quot;: string constant)?
                     (, &quot;fullCodec&quot;: string constant)? }

Definition       := Record | Interface | Enumeration

Record           := {   &quot;name&quot;: ID,
                        &quot;type&quot;: &quot;record&quot;,
                        &quot;target&quot;: (&quot;Scala&quot; | &quot;Java&quot;)
                     (, &quot;namespace&quot;: string constant)?
                     (, &quot;doc&quot;: string constant)?
                     (, &quot;fields&quot;: [ Field* ])? }

Interface        := {   &quot;name&quot;: ID,
                        &quot;type&quot;: &quot;interface&quot;,
                        &quot;target&quot;: (&quot;Scala&quot; | &quot;Java&quot;)
                     (, &quot;namespace&quot;: string constant)?
                     (, &quot;doc&quot;: string constant)?
                     (, &quot;fields&quot;: [ Field* ])?
                     (, &quot;messages&quot;: [ Message* ])?
                     (, &quot;types&quot;: [ Definition* ])? }

Enumeration      := {   &quot;name&quot;: ID,
                        &quot;type&quot;: &quot;enum&quot;,
                        &quot;target&quot;: (&quot;Scala&quot; | &quot;Java&quot;)
                     (, &quot;namespace&quot;: string constant)?
                     (, &quot;doc&quot;: string constant)?
                     (, &quot;symbols&quot;: [ Symbol* ])? }

Symbol           := ID
                  | {   &quot;name&quot;: ID
                     (, &quot;doc&quot;: string constant)? }

Field            := {   &quot;name&quot;: ID,
                        &quot;type&quot;: ID
                     (, &quot;doc&quot;: string constant)?
                     (, &quot;since&quot;: version number string)?
                     (, &quot;default&quot;: string constant)? }

Message          := {   &quot;name&quot;: ID,
                        &quot;response&quot;: ID
                     (, &quot;request&quot;: [ Request* ])?
                     (, &quot;doc&quot;: string constant)? }

Request          := {   &quot;name&quot;: ID,
                        &quot;type&quot;: ID
                     (, &quot;doc&quot;: string constant)? }
</code></pre><h2 id="Compiler+Interface">Compiler Interface<a href="#Compiler+Interface" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The compiler interface is the communication link between sbt and the
Scala compiler.
</p><p>It is used to get information from the Scala compiler, and must therefore
be compiled against the Scala version in use for the configured projects.
</p><p>The code for this project can be found in the directory <a href="https://github.com/sbt/zinc/tree/v1.1.0/internal/compiler-bridge">internal/compiler-bridge</a>.
</p><h2 id="Fetching+the+most+specific+sources">Fetching the most specific sources<a href="#Fetching+the+most+specific+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Because the compiler interface is recompiled against each Scala version
in use in your project, its source must stay compatible with all the Scala
versions that sbt supports (from Scala 2.8 to the latest version of Scala).
</p><p>This comes at great cost for both the sbt maintainers and the Scala
compiler authors:
</p><ol><li>The compiler authors cannot remove old and deprecated public APIs from
the Scala compiler.
</li><li>sbt cannot use new APIs defined in the Scala compiler.
</li><li>sbt must implement <a href="https://github.com/sbt/sbt/blob/0.13/compile/interface/src/main/scala/xsbt/Compat.scala#L6">all kinds of hackery</a>
to remain source-compatible with all versions of the Scala compiler and support
new features.
</li></ol><p>To circumvent this problem, a new mechanism that allows sbt to fetch the
version of the sources for the compiler interface that are the most specific
for the Scala version in use has been implemented in sbt.
</p><p>For instance, for a project that is compiled using Scala 2.11.8-M2, sbt
will look for the following version of the sources for the compiler interface,
in this order:
</p><ol><li>2.11.8-M2
</li><li>2.11.8
</li><li>2.11
</li><li>The default sources.
</li></ol><p>This new mechanism allows both the Scala compiler and sbt to move forward and
enjoy new APIs while being certain than users of older versions of Scala will
still be able to use sbt.
</p><p>Finally, another advantage of this technique is that it relies on Ivy to
retrieve the sources of the compiler bridge, but can be easily ported for use
with Maven, which is the distribution mechanism that the sbt maintainers would
like to use to distribute sbt’s modules.
</p><h2 id="sbt+Launcher">sbt Launcher<a href="#sbt+Launcher" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher provides a generic container that can load and run
programs resolved using the Ivy dependency manager. Sbt uses this as its
own deployment mechanism.
</p><p>The code is hosted at <a href="https://github.com/sbt/launcher">sbt/launcher</a>.
</p><h2 id="Getting+Started+with+the+sbt+launcher">Getting Started with the sbt launcher<a href="#Getting+Started+with+the+sbt+launcher" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher provides two parts:
</p><ol><li>An interface for launched applications to interact with the launcher code
</li><li>A minimal sbt-launch.jar that can launch applications by resolving them
through ivy.
</li></ol><p>The sbt launcher component is a self-contained jar that boots a Scala
application or server without Scala or the application already existing
on the system. The only prerequisites are the launcher jar itself, an
optional configuration file, and a Java runtime version 1.6 or greater.
</p><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A user downloads the launcher jar and creates a script to run it. In
this documentation, the script will be assumed to be called <code>launch</code>.
For Unix, the script would look like: <code>java -jar sbt-launcher.jar &quot;$@&quot;</code>
</p><p>The user can now launch servers and applications which provide sbt
launcher configuration.
</p><p>Alternatively, you can repackage the launcher with a launcher configuration file.
For example, <a href="https://github.com/sbt/sbt">sbt/sbt</a> pulls in the raw JAR and
<a href="launcher-inject">injects the appropriate boot.properties files for sbt</a>.
</p><h4 id="Applications">Applications<a href="#Applications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To launch an application, the user then downloads the configuration file
for the application (call it <code>my.app.configuration</code>) and creates a
script to launch it (call it <code>myapp</code>):
</p><pre><code class="">launch @my.app.configuration &quot;$@&quot;
</code></pre><p>The user can then launch the application using <code>myapp arg1 arg2 ...</code>
</p><p>More on launcher configuration can be found at
<a href="Launcher-Configuration.html">Launcher Configuration</a>
</p><h4 id="Servers">Servers<a href="#Servers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The sbt launcher can be used to launch and discover running servers on
the system. The launcher can be used to launch servers similarly to
applications. However, if desired, the launcher can also be used to
ensure that only one instance of a server is running at time. This is
done by having clients always use the launcher as a <em>service locator</em>.
</p><p>To discover where a server is running (or launch it if it is not
running), the user downloads the configuration file for the server (call
it <code>my.server.configuration</code>) and creates a script to discover the
server (call it <code>find-myserver</code>):
</p><pre><code class="">launch --locate @my.server.properties.
</code></pre><p>This command will print out one string, the URI at which to reach the
server, e.g. <code>sbt://127.0.0.1:65501</code>. Clients should use the IP/port to
connect to to the server and initiate their connection.
</p><p>When using the <code>locate</code> feature, the sbt launcher makes the following
restrictions to servers:
</p><ul><li>The Server must have a starting class that extends the
<code>xsbti.ServerMain</code> class
</li><li>The Server must have an entry point (URI) that clients can use to
detect the server
</li><li>The server must have defined a lock file which the launcher can use
to ensure that only one instance is running at a time
</li><li>The filesystem on which the lock file resides must support locking.
</li><li>The server must allow the launcher to open a socket against the port
without sending any data. This is used to check if a previous server
is still alive.
</li></ul><h4 id="Resolving+Applications%2FServers">Resolving Applications/Servers<a href="#Resolving+Applications%2FServers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Like the launcher used to distribute <code>sbt</code>, the downloaded launcher jar
will retrieve Scala and the application according to the provided
configuration file. The versions may be fixed or read from a different
configuration file (the location of which is also configurable). The
location to which the Scala and application jars are downloaded is
configurable as well. The repositories searched are configurable.
Optional initialization of a properties file on launch is configurable.
</p><p>Once the launcher has downloaded the necessary jars, it loads the
application/server and calls its entry point. The application is passed
information about how it was called: command line arguments, current
working directory, Scala version, and application ID (organization,
name, version). In addition, the application can ask the launcher to
perform operations such as obtaining the Scala jars and a <code>ClassLoader</code>
for any version of Scala retrievable from the repositories specified in
the configuration file. It can request that other applications be
downloaded and run. When the application completes, it can tell the
launcher to exit with a specific exit code or to reload the application
with a different version of Scala, a different version of the
application, or different arguments.
</p><p>There are some other options for setup, such as putting the
configuration file inside the launcher jar and distributing that as a
single download. The rest of this documentation describes the details of
configuring, writing, distributing, and running the application.
</p><h4 id="Creating+a+Launched+Application">Creating a Launched Application<a href="#Creating+a+Launched+Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This section shows how to make an application that is launched by this
launcher. First, declare a dependency on the <code>launcher-interface</code>. Do not
declare a dependency on the launcher itself. The launcher interface
consists strictly of Java interfaces in order to avoid binary
incompatibility between the version of Scala used to compile the
launcher and the version used to compile your application. The launcher
interface class will be provided by the launcher, so it is only a
compile-time dependency. If you are building with sbt, your dependency
definition would be:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-sbt&quot; % &quot;launcher-interface&quot; % &quot;1.0.0&quot; % &quot;provided&quot;

resolvers += sbtResolver.value
</code></pre><p>Make the entry point to your class implement <code>xsbti.AppMain</code>. An example
that uses some of the information:
</p><pre><code class="prettyprint lang-scala">package com.acme.launcherapp

class Main extends xsbti.AppMain
{
    def run(configuration: xsbti.AppConfiguration) =
    {
        // get the version of Scala used to launch the application
        val scalaVersion = configuration.provider.scalaProvider.version

        // Print a message and the arguments to the application
        println(&quot;Hello world!  Running Scala &quot; + scalaVersion)
        configuration.arguments.foreach(println)

        // demonstrate the ability to reboot the application into different versions of Scala
        // and how to return the code to exit with
        scalaVersion match
        {
            case &quot;2.10.6&quot; =&gt;
                new xsbti.Reboot {
                    def arguments = configuration.arguments
                    def baseDirectory = configuration.baseDirectory
                    def scalaVersion = &quot;2.11.8&quot;
                    def app = configuration.provider.id
                }
            case &quot;2.11.8&quot; =&gt; new Exit(1)
            case _ =&gt; new Exit(0)
        }
    }
    class Exit(val code: Int) extends xsbti.Exit
}
</code></pre><p>Next, define a configuration file for the launcher. For the above class,
it might look like:
</p><pre><code class="">[scala]
  version: 2.11.8
[app]
  org: com.acme
  name: launcherapp
  version: 0.0.1
  class: com.acme.launcherapp.Main
  cross-versioned: true
[repositories]
  local
  maven-central
[boot]
 directory: ${user.home}/.myapp/boot
</code></pre><p>Then, <code>publishLocal</code> or <code>+publishLocal</code> the application in sbt’s shell to make it
available. For more information, see
<a href="Launcher-Configuration.html">Launcher Configuration</a>.
</p><h4 id="Running+an+Application">Running an Application<a href="#Running+an+Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As mentioned above, there are a few options to actually run the
application. The first involves providing a modified jar for download.
The second two require providing a configuration file for download.
</p><ul><li>Replace the <code>/sbt/sbt.boot.properties</code> file in the launcher jar and
distribute the modified jar. The user would need a script to run
<code>java -jar your-launcher.jar arg1 arg2 ....</code>
</li><li><p>The user downloads the launcher jar and you provide the
configuration file.
</p><ul><li>The user needs to run
<code>java -Dsbt.boot.properties=your.boot.properties -jar launcher.jar</code>.
</li><li>The user already has a script to run the launcher (call it
‘launch’). The user needs to run
<code>launch @your.boot.properties your-arg-1 your-arg-2</code>
</li></ul></li></ul><h4 id="Execution">Execution<a href="#Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Let’s review what’s happening when the launcher starts your application.
</p><p>On startup, the launcher searches for its configuration and then parses
it. Once the final configuration is resolved, the launcher proceeds to
obtain the necessary jars to launch the application. The
<code>boot.directory</code> property is used as a base directory to retrieve jars
to. Locking is done on the directory, so it can be shared system-wide.
The launcher retrieves the requested version of Scala to
</p><pre><code class="">${boot.directory}/${scala.version}/lib/
</code></pre><p>If this directory already exists, the launcher takes a shortcut for
startup performance and assumes that the jars have already been
downloaded. If the directory does not exist, the launcher uses Apache
Ivy to resolve and retrieve the jars. A similar process occurs for the
application itself. It and its dependencies are retrieved to
</p><pre><code class="">${boot.directory}/${scala.version}/${app.org}/${app.name}/.
</code></pre><p>Once all required code is downloaded, the class loaders are set up. The
launcher creates a class loader for the requested version of Scala. It
then creates a child class loader containing the jars for the requested
<code>app.components</code> and with the paths specified in <code>app.resources</code>. An
application that does not use components will have all of its jars in
this class loader.
</p><p>The main class for the application is then instantiated. It must be a
public class with a public no-argument constructor and must conform to
<code>xsbti.AppMain</code>. The <code>run</code> method is invoked and execution passes to the
application. The argument to the ‘run’ method provides configuration
information and a callback to obtain a class loader for any version of
Scala that can be obtained from a repository in [repositories]. The
return value of the run method determines what is done after the
application executes. It can specify that the launcher should restart
the application or that it should exit with the provided exit code.
</p><h2 id="Sbt+Launcher+Architecture">Sbt Launcher Architecture<a href="#Sbt+Launcher+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher is a mechanism whereby modules can be loaded from Ivy
and executed within a JVM. It abstracts the mechanism of grabbing and
caching jars, allowing users to focus on what application they want, and
control its versions.
</p><p>The launcher’s primary goal is to take configuration for applications—
mostly Ivy coordinates and a main class—and start the application.
The launcher resolves the Ivy module, caches the required runtime jars,
and starts the application.
</p><p>The sbt launcher provides the application with the means to load a
different application when it completes, exit normally, or load
additional applications from inside another.
</p><p>The sbt launcher provides these core functions:
</p><ul><li>Module Resolution
</li><li>Classloader Caching and Isolation
</li><li>File Locking
</li><li>Service Discovery and Isolation
</li></ul><h3 id="Module+Resolution">Module Resolution<a href="#Module+Resolution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The primary purpose of the sbt launcher is to resolve applications and
run them. This is done through the <code>[app]</code> configuration section. See
[launcher configuration][Launcher-Configuration] for more information on how to configure module
resolution.
</p><p>Module resolution is performed using the Ivy dependency management
library. This library supports loading artifacts from Maven repositories
as well.
</p><h3 id="Classloader+Caching+and+Isolation">Classloader Caching and Isolation<a href="#Classloader+Caching+and+Isolation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The sbt launcher’s classloading structure is different than just
starting an application in the standard Java mechanism. Every
application loaded by the launcher is given its own classloader. This
classloader is a child of the Scala classloader used by the application.
The Scala classloader can see all of the <code>xsbti.*</code> classes from the
launcher itself.
</p><p>Here’s an example classloader layout from an sbt-launched application.
</p><p><img src="files/classloaders.png" alt="image"/>
</p><p>In this diagram, three different applications were loaded. Two of these
use the same version of Scala (2.9.2). In this case, sbt can share the
same classloader for these applications. This has the benefit that any
JIT optimisations performed on Scala classes can be re-used between
applications thanks to the shared classloader.
</p><h3 id="Caching">Caching<a href="#Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The sbt launcher creates a secondary cache on top of Ivy’s own cache.
This helps isolate applications from errors resulting from unstable
revisions, like <code>-SNAPSHOT</code>. For any launched application, the launcher
creates a directory to store all its jars. Here’s an example layout.
</p><h3 id="Locking">Locking<a href="#Locking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to providing a secondary cache, the launcher also provides a
mechanism of safely doing file-based locks. This is used in two places
directly by the launcher:
</p><ol><li>Locking the boot directory.
</li><li>Ensuring located servers have at most one active process.
</li></ol><p>This feature requires a filesystem which supports locking. It is exposed
via the <code>xsbti.GlobalLock</code> interface.
</p><ul><li>Note: This is both a thread and file lock. Not only are we limiting
access to a single process, but also a single thread within that
process.*
</li></ul><h3 id="Service+Discovery+and+Isolation">Service Discovery and Isolation<a href="#Service+Discovery+and+Isolation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The launcher also provides a mechanism to ensure that only one instance
of a server is running, while dynamically starting it when a client
requests. This is done through the <code>--locate</code> flag on the launcher. When
the launcher is started with the <code>--locate</code> flag it will do the
following:
</p><ol><li>Lock on the configured server lock file.
</li><li>Read the server properties to find the URI of the previous server.
</li><li>If the port is still listening to connection requests, print this
URI on the command line.
</li><li>If the port is not listening, start a new server and write the URI
on the command line.
</li><li>Release all locks and shutdown.
</li></ol><p>The configured <code>server.lock</code> file is thus used to prevent multiple
servers from running. sbt itself uses this to prevent more than one
server running on any given project directory by configuring
<code>server.lock</code> to be <code>${user.dir}/.sbtserver</code>.
</p><h2 id="sbt+Launcher+Configuration">sbt Launcher Configuration<a href="#sbt+Launcher+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The launcher may be configured in one of the following ways in
increasing order of precedence:
</p><ul><li>Replace the <code>/sbt/sbt.boot.properties</code> file in the launcher jar
</li><li>Put a configuration file named <code>sbt.boot.properties</code> on the
classpath. Put it in the classpath root without the /sbt prefix.
</li><li>Specify the location of an alternate configuration on the command
line, either as a path or an absolute URI. This can be done by
either specifying the location as the system property
sbt.boot.properties or as the first argument to the launcher
prefixed by <code>@</code>. The system property has lower precedence.
Resolution of a relative path is first attempted against the current
working directory, then against the user’s home directory, and then
against the directory containing the launcher jar.
</li></ul><p>An error is generated if none of these attempts succeed.
</p><h3 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The default configuration file for sbt as an application looks like:
</p><pre><code class="">[scala]
  version: ${sbt.scala.version-auto}

[app]
  org: ${sbt.organization-org.scala-sbt}
  name: sbt
  version: ${sbt.version-read(sbt.version)[0.13.5]}
  class: ${sbt.main.class-sbt.xMain}
  components: xsbti,extra
  cross-versioned: ${sbt.cross.versioned-false}

[repositories]
  local
  typesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly
  maven-central
  sonatype-snapshots: https://oss.sonatype.org/content/repositories/snapshots

[boot]
  directory: ${sbt.boot.directory-${sbt.global.base-${user.home}/.sbt}/boot/}

[ivy]
  ivy-home: ${sbt.ivy.home-${user.home}/.ivy2/}
  checksums: ${sbt.checksums-sha1,md5}
  override-build-repos: ${sbt.override.build.repos-false}
  repository-config: ${sbt.repository.config-${sbt.global.base-${user.home}/.sbt}/repositories}
</code></pre><p>Let’s look at all the launcher configuration sections in detail:
</p><h4 id="1.+Scala+Configuration">1. Scala Configuration<a href="#1.+Scala+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[scala]</code> section is used to configure the version of Scala. It has
one property:
</p><ul><li><code>version</code> - The version of Scala an application uses, or <code>auto</code> if
the application is not cross-versioned.
</li><li><code>classifiers</code> - The (optional) list of additional Scala artifacts to
resolve, e.g. sources.
</li></ul><h4 id="2.+Application+Identification">2. Application Identification<a href="#2.+Application+Identification" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[app]</code> section configures how the launcher will look for your
application using the Ivy dependency manager. It consists of the
following properties:
</p><ul><li><code>org</code> - The organization associated with the Ivy module. (<code>groupId</code> in
Maven vernacular)
</li><li><code>name</code> - The name of the Ivy module. (<code>artifactId</code> in Maven
vernacular)
</li><li><code>version</code> - The revision of the Ivy module.
</li><li><p><code>class</code> - The name of the “entry point” into the application. An
entry point must be a class which meets one of the following criteria
</p><ul><li>Extends the <code>xsbti.AppMain</code> interface.
</li><li>Extends the <code>xsbti.ServerMain</code> interfaces.
</li><li>Contains a method with the signature <code>static void main(String[])</code>
</li><li>Contains a method with the signature <code>static int main(String[])</code>
</li><li>Contains a method with the signature <code>static xsbti.Exit main(String[])</code>
</li></ul></li><li><code>components</code> - An optional list of additional components that Ivy
should resolve.
</li><li><code>cross-versioned</code> - An optional string denoting how this application
is published. If <code>app.cross-versioned</code> is binary, the resolved module
ID is
<code>{app.name+'_'+CrossVersion.binaryScalaVersion(scala.version)}</code>. If
<code>app.cross-versioned</code> is <code>true</code> or <code>full</code>, the resolved module ID is
<code>{app.name+'_'+scala.version}</code>. The <code>scala.version</code> property must be
specified and cannot be <code>auto</code> when cross-versioned.
</li><li><code>resources</code> - An optional list of jar files that should be added to
the application’s classpath.
</li><li><code>classifiers</code> - An optional list of additional classifiers that
should be resolved with this application, e.g. sources.
</li></ul><h4 id="3.+Repositories+Section">3. Repositories Section<a href="#3.+Repositories+Section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[repositories]</code> section configures where and how Ivy will look for
your application. Each line denotes a repository where Ivy will look.
</p><ul><li>Note: This section configured the default location where Ivy will look,
but this can be overridden via user configuration.*
</li></ul><p>There are several built-in strings that can be used for common
repositories:
</p><ul><li><code>local</code> - the local Ivy repository <code>~/.ivy2/local</code>.
</li><li><code>maven-local</code> - The local Maven repository <code>~/.m2/repository</code>.
</li><li><code>maven-central</code> - The Maven Central repository <code>repo1.maven.org</code>.
</li></ul><p>Besides built in repositories, other repositories can be configured
using the following syntax:
</p><blockquote><p>name: url(, pattern)(,bootOnly)(,descriptorOptional)(,skipConsistencyCheck)(,allowInsecureProtocol)
</p></blockquote><p>The <code>name</code> property is an identifier which Ivy uses to cache modules
resolved from this location. The <code>name</code> should be unique across all
repositories.
</p><p>The <code>url</code> property is the base <code>url</code> where Ivy should look for modules.
</p><p>The <code>pattern</code> property is an optional specification of <em>how</em> Ivy should
look for modules. By default, the launcher assumes repositories are in
the maven style format.
</p><p>The <code>bootOnly</code> string is used to tell Ivy to only use this repository during startup. i.e. To find sbt’s own JARs and the JARs of any plugins. Repositories with the <code>bootOnly</code> string will not be used for build-time dependency resolution.
</p><p>The <code>skipConsistencyCheck</code> string is used to tell Ivy not to validate
checksums and signatures of files it resolves.
</p><p>The <code>allowInsecureProtocol</code> string tells SBT not to output a warning about this repository being <code>http://</code>. Please think carefully before using HTTP repositories as they can present a significant <a href="https://github.com/sbt/sbt/issues/4905">security risk</a>.
</p><h4 id="4.+The+Boot+section">4. The Boot section<a href="#4.+The+Boot+section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[boot]</code> section is used to configure where the sbt launcher will
store its cache and configuration information. It consists of the
following properties:
</p><ul><li><code>directory</code> - The directory defined here is used to store all cached
JARs resolved launcher.
</li><li><code>properties</code> - (optional) A properties file to use for any <code>read</code>
variables.
</li></ul><h4 id="5.+The+Ivy+section">5. The Ivy section<a href="#5.+The+Ivy+section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[ivy]</code> section is used to configure the Ivy dependency manager for
resolving applications. It consists of the following properties:
</p><ul><li><code>ivy-home</code> - The home directory for Ivy. This determines where the
ivy-local repository is located, and also where the Ivy cache is
stored. Defaults to <code>~/.ivy2</code>
</li><li><code>checksums</code> - The comma-separated list of checksums that Ivy should
use to verify artifacts have correctly resolved, e.g. md5 or sha1.
</li><li><code>override-build-repos</code> - If this is set, then the
<code>isOverrideRepositories</code> method on <code>xsbti.Launcher</code> interface will
return its value. The use of this method is application-specific,
but in the case of sbt denotes that the configuration of
repositories in the launcher should override those used by any
build. Applications should respect this convention if they can.
</li><li><code>repository-config</code> - This specifies a configuration location where
Ivy repositories can also be configured. If this file exists, then
its contents override the <code>[repositories]</code> section.
</li></ul><h4 id="6.+The+Server+Section">6. The Server Section<a href="#6.+The+Server+Section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When using the <code>--locate</code> feature of the launcher, this section
configures how a server is started. It consists of the following
properties:
</p><ul><li><code>lock</code> - The file that controls access to the running server. This
file will contain the active port used by a server and must be
located on a filesystem that supports locking.
</li><li><code>jvmargs</code> - A file that contains line-separated JVM arguments that were
used when starting the server.
</li><li><code>jvmprops</code> - The location of a properties file that will define
override properties in the server. All properties defined in this
file will be set as <code>-D</code> Java properties.
</li></ul><h3 id="Variable+Substitution">Variable Substitution<a href="#Variable+Substitution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Property values may include variable substitutions. A variable
substitution has one of these forms:
</p><ul><li><code>${variable.name}</code>
</li><li><code>${variable.name-default}</code>
</li></ul><p>where <code>variable.name</code> is the name of a system property. If a system
property by that name exists, the value is substituted. If it does not
exists and a default is specified, the default is substituted after
recursively substituting variables in it. If the system property does
not exist and no default is specified, the original string is not
substituted.
</p><p>There is also a special variable substitution:
</p><pre><code>read(property.name)[default]
</code></pre><p>This will look in the file configured by <code>boot.properties</code> for a value.
If there is no <code>boot.properties</code> file configured, or the property does
not exist, then the default value is chosen.
</p><h3 id="Syntax">Syntax<a href="#Syntax" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The configuration file is line-based, read as UTF-8 encoded, and defined
by the following grammar. <code>'nl'</code> is a newline or end of file and
<code>'text'</code> is plain text without newlines or the surrounding delimiters
(such as parentheses or square brackets):
</p><pre><code class="prettyprint lang-scala">configuration: scala app repositories boot log appProperties
scala: &quot;[&quot; &quot;scala&quot; &quot;]&quot; nl version nl classifiers nl
app: &quot;[&quot; &quot;app&quot; &quot;]&quot; nl org nl name nl version nl components nl class nl crossVersioned nl resources nl classifiers nl
repositories: &quot;[&quot; &quot;repositories&quot; &quot;]&quot; nl (repository nl)*
boot: &quot;[&quot; &quot;boot&quot; &quot;]&quot; nl directory nl bootProperties nl search nl promptCreate nl promptFill nl quickOption nl
log: &quot;[&quot; &quot;log&quot; &quot;]&quot; nl logLevel nl
appProperties: &quot;[&quot; &quot;app-properties&quot; &quot;]&quot; nl (property nl)*
ivy: &quot;[&quot; &quot;ivy&quot; &quot;]&quot; nl homeDirectory nl checksums nl overrideRepos nl repoConfig nl
directory: &quot;directory&quot; &quot;:&quot; path
bootProperties: &quot;properties&quot; &quot;:&quot; path
search: &quot;search&quot; &quot;:&quot; (&quot;none&quot; | &quot;nearest&quot; | &quot;root-first&quot; | &quot;only&quot; ) (&quot;,&quot; path)*
logLevel: &quot;level&quot; &quot;:&quot; (&quot;debug&quot; | &quot;info&quot; | &quot;warn&quot; | &quot;error&quot;)
promptCreate: &quot;prompt-create&quot;  &quot;:&quot;  label
promptFill: &quot;prompt-fill&quot; &quot;:&quot; boolean
quickOption: &quot;quick-option&quot; &quot;:&quot; boolean
version: &quot;version&quot; &quot;:&quot; versionSpecification
versionSpecification: readProperty | fixedVersion
readProperty: &quot;read&quot;  &quot;(&quot; propertyName &quot;)&quot;  &quot;[&quot; default &quot;]&quot;
fixedVersion: text
classifiers: &quot;classifiers&quot; &quot;:&quot; text (&quot;,&quot; text)*
homeDirectory: &quot;ivy-home&quot; &quot;:&quot; path
checksums: &quot;checksums&quot; &quot;:&quot; checksum (&quot;,&quot; checksum)*
overrideRepos: &quot;override-build-repos&quot; &quot;:&quot; boolean
repoConfig: &quot;repository-config&quot; &quot;:&quot; path
org: &quot;org&quot; &quot;:&quot; text
name: &quot;name&quot; &quot;:&quot; text
class: &quot;class&quot; &quot;:&quot; text
components: &quot;components&quot; &quot;:&quot; component (&quot;,&quot; component)*
crossVersioned: &quot;cross-versioned&quot; &quot;:&quot;  (&quot;true&quot; | &quot;false&quot; | &quot;none&quot; | &quot;binary&quot; | &quot;full&quot;)
resources: &quot;resources&quot; &quot;:&quot; path (&quot;,&quot; path)*
repository: ( predefinedRepository | customRepository ) nl
predefinedRepository: &quot;local&quot; | &quot;maven-local&quot; | &quot;maven-central&quot;
customRepository: label &quot;:&quot; url [ [&quot;,&quot; ivyPattern] [&quot;,&quot; artifactPattern] [&quot;, mavenCompatible&quot;] [&quot;, bootOnly&quot;]]
property: label &quot;:&quot; propertyDefinition (&quot;,&quot; propertyDefinition)*
propertyDefinition: mode &quot;=&quot; (set | prompt)
mode: &quot;quick&quot; | &quot;new&quot; | &quot;fill&quot;
set: &quot;set&quot; &quot;(&quot; value &quot;)&quot;
prompt: &quot;prompt&quot;  &quot;(&quot; label &quot;)&quot; (&quot;[&quot; default &quot;]&quot;)?
boolean: &quot;true&quot; | &quot;false&quot;
nl: &quot;\r\n&quot; | &quot;\n&quot; | &quot;\r&quot;
path: text
propertyName: text
label: text
default: text
checksum: text
ivyPattern: text
artifactPattern: text
url: text
component: text
</code></pre><h2 id="Notes">Notes<a href="#Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Here are some more docs that used to be part of Developer Guide.
</p><h2 id="Core+Principles">Core Principles<a href="#Core+Principles" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This document details the core principles overarching sbt’s design and
code style. sbt’s core principles can be stated quite simply:
</p><ol><li>Everything should have a <code>Type</code>, enforced as much as is practical.
</li><li>Dependencies should be <strong>explicit</strong>.
</li><li>Once learned, a concept should hold throughout <strong>all</strong> parts of sbt.
</li><li>Parallel is the default.
</li></ol><p>With these principles in mind, let’s walk through the core design of
sbt.
</p><h3 id="Introduction+to+build+state">Introduction to build state<a href="#Introduction+to+build+state" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is the first piece you hit when starting sbt. sbt’s command engine
is the means by which it processes user requests using the build state.
The command engine is essentially a means of applying <strong>state
transformations</strong> on the build state, to execute user requests.
</p><p>In sbt, commands are functions that take the current build state
(<code>sbt.State</code>) and produce the next state. In other words, they are
essentially functions of <code>sbt.State =&gt; sbt.State</code>. However, in reality,
Commands are actually string processors which take some string input and
act on it, returning the next build state.
</p><p>So, the entirety of sbt is driven off the <code>sbt.State</code> class. Since this
class needs to be resilient in the face of custom code and plugins, it
needs a mechanism to store the state from any potential client. In
dynamic languages, this can be done directly on objects.
</p><p>A naive approach in Scala is to use a <code>Map&lt;String,Any&gt;</code>. However, this
violates tenant #1: Everything should have a <code>Type</code>. So, sbt defines a
new type of map called an <code>AttributeMap</code>. An <code>AttributeMap</code> is a
key-value storage mechanism where keys are both strings <em>and</em> expected
<code>Type</code>s for their value.
</p><p>Here is what the type-safe <code>AttributeKey</code> key looks like :
</p><pre><code>sealed trait AttributeKey[T] {
  /** The label is the identifier for the key and is camelCase by convention. */
  def label: String
  /** The runtime evidence for ``T`` */
  def manifest: Manifest[T]
}
</code></pre><p>These keys store both a <code>label</code> (<code>string</code>) and some runtime type
information (<code>manifest</code>). To put or get something on the <code>AttributeMap</code>,
we first need to construct one of these keys. Let’s look at the basic
definition of the <code>AttributeMap</code>:
</p><pre><code class="prettyprint lang-scala">trait AttributeMap {
  /** Gets the value of type ``T`` associated with the key ``k`` or ``None`` if no value is associated. 
  * If a key with the same label but a different type is defined, this method will return ``None``. */
  def get[T](k: AttributeKey[T]): Option[T]

  /** Adds the mapping ``k -&gt; value`` to this map, replacing any existing mapping for ``k``.
  * Any mappings for keys with the same label but different types are unaffected. */
  def put[T](k: AttributeKey[T], value: T): AttributeMap
}
</code></pre><p>Now that there’s a definition of what build state is, there needs to be
a way to dynamically construct it. In sbt, this is done through the
<code>Setting[_]</code> sequence.
</p><h3 id="Settings+Architecture">Settings Architecture<a href="#Settings+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A Setting represents the means of constructing the value of one
particular <code>AttributeKey[_]</code> in the <code>AttributeMap</code> of build state. A
setting consists of two pieces:
</p><ol><li>The <code>AttributeKey[T]</code> where the value of the setting should be
assigned.
</li><li>An <code>Initialize[T]</code> object which is able to construct the value for
this setting.
</li></ol><p>sbt’s initialization time is basically just taking a sequence of these
<code>Setting[_]</code> objects and running their initialization objects and then
storing the value into the <code>AttributeMap</code>. This means overwriting an
existing value at a key is as easy as appending a <code>Setting[_]</code> to the
end of the sequence which does so.
</p><p>Where it gets interesting is that <code>Initialize[T]</code> can depend on other
<code>AttributeKey[_]</code>s in the build state. Each <code>Initialize[_]</code> can pull
values from any <code>AttributeKey[_]</code> in the build state’s <code>AttributeMap</code> to
compute its value. sbt ensures a few things when it comes to
<code>Initialize[_]</code> dependencies:
</p><ol><li>There can be no circular dependencies
</li><li><p>If one <code>Initialize[_]</code> depends on another <code>Initialize[_]</code> key, then
</p><p><em>all</em> associated <code>Initialize[_]</code> blocks for that key must have run
before we load the value.
</p></li></ol><p>Let’s look at what gets stored for the setting :
</p><pre><code>normalizedName := normalize(name.value)
</code></pre><p><img src="files/overview-setting-example.png" alt="image"/>
</p><p>Here, a <code>Setting[_]</code> is constructed that understands it depends on the
value in the <code>name</code> <code>AttributeKey</code>. Its initialize block first grabs the
value of the <code>name</code> key, then runs the function <code>normalize</code> on it to
compute its value.
</p><p>This represents the core mechanism of how to construct sbt’s build
state. Conceptually, at some point we have a graph of dependencies and
initialization functions which we can use to construct the first build
state. Once this is completed, we can then start to process user
requests.
</p><h3 id="Task+Architecture">Task Architecture<a href="#Task+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The next layer in sbt is around these user requests, or tasks. When a
user configures a build, they are defining a set of repeatable tasks
that they can run on their project. Things like <code>compile</code> or <code>test</code>.
These tasks <em>also</em> have a dependency graph, where e.g. the <code>test</code> task
requires that <code>compile</code> has run before it can successfully execute.
</p><p>sbt defines a class <code>Task[T]</code>. The <code>T</code> type parameter represents the
type of data returned by a task. Remember the tenets of sbt? “All things
have types” and “Dependencies are explicit” both hold true for tasks.
sbt promotes a style of task dependencies that is closer to functional
programming: return data for your users rather than using shared mutable
state.
</p><p>Most build tools communicate over the filesystem, and indeed by necessity
sbt does some of this. However, for stable parallelization it is
far better to keep tasks isolated on the filesystem and communicate
directly through types.
</p><p>Similarly to how a <code>Setting[_]</code> stores both dependencies and an
initialization function, a <code>Task[_]</code> stores both its
<code>Task[_]</code>dependencies and its behavior (a function).
</p><p>TODO - More on <code>Task[_]</code>
</p><p>TODO - Transition into <code>InputTask[_]</code>, rehash Command
</p><p>TODO - Transition into Scope.
</p><h2 id="Settings+Core">Settings Core<a href="#Settings+Core" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes the core settings engine a bit. This may be useful
for using it outside of sbt. It may also be useful for understanding how
sbt works internally.
</p><p>The documentation is comprised of two parts. The first part shows an
example settings system built on top of the settings engine. The second
part comments on how sbt’s settings system is built on top of the
settings engine. This may help illuminate what exactly the core settings
engine provides and what is needed to build something like the sbt
settings system.
</p><h3 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Setting+up">Setting up<a href="#Setting+up" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To run this example, first create a new project with the following
build.sbt file:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-sbt&quot; %% &quot;collections&quot; % sbtVersion.value

resolvers += sbtResolver.value
</code></pre><p>Then, put the following examples in source files <code>SettingsExample.scala</code>
and <code>SettingsUsage.scala</code>. Finally, run sbt and enter the REPL using
<code>console</code>. To see the output described below, enter <code>SettingsUsage</code>.
</p><h4 id="Example+Settings+System">Example Settings System<a href="#Example+Settings+System" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first part of the example defines the custom settings system. There
are three main parts:
</p><ol><li>Define the <code>Scope</code> type.
</li><li>Define a function that converts that <code>Scope</code> (plus an <code>AttributeKey</code>) to
a <code>String</code>.
</li><li>Define a delegation function that defines the sequence of <code>Scope</code>s in
which to look up a value.
</li></ol><p>There is also a fourth, but its usage is likely to be specific to sbt at
this time. The example uses a trivial implementation for this part.
</p><p><code>SettingsExample.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._

/** Define our settings system */

// A basic scope indexed by an integer.
final case class Scope(index: Int)

// Extend the Init trait.
//  (It is done this way because the Scope type parameter is used everywhere in Init.
//  Lots of type constructors would become binary, which as you may know requires lots of type lambdas
//  when you want a type function with only one parameter.
//  That would be a general pain.)
object SettingsExample extends Init[Scope]
{
    // Provides a way of showing a Scope+AttributeKey[_]
    val showFullKey: Show[ScopedKey[_]] = new Show[ScopedKey[_]] {
        def apply(key: ScopedKey[_]) = key.scope.index + &quot;/&quot; + key.key.label
    }

    // A sample delegation function that delegates to a Scope with a lower index.
    val delegates: Scope =&gt; Seq[Scope] = { case s @ Scope(index) =&gt;
        s +: (if(index &lt;= 0) Nil else delegates(Scope(index-1)) )
    }

    // Not using this feature in this example.
    val scopeLocal: ScopeLocal = _ =&gt; Nil

    // These three functions + a scope (here, Scope) are sufficient for defining our settings system.
}
</code></pre><h4 id="Example+Usage">Example Usage<a href="#Example+Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This part shows how to use the system we just defined. The end result is
a <code>Settings[Scope]</code> value. This type is basically a mapping
<code>Scope -&gt; AttributeKey[T] -&gt; Option[T]</code>. See the
<a href="../api/sbt/internal/util/Settings.html">Settings API documentation</a> for
details.
</p><p><code>SettingsUsage.scala</code>:
</p><pre><code class="prettyprint lang-scala">/** Usage Example **/

import sbt._
import SettingsExample._
import Types._

object SettingsUsage {

      // Define some keys
   val a = AttributeKey[Int](&quot;a&quot;)
   val b = AttributeKey[Int](&quot;b&quot;)

      // Scope these keys
   val a3 = ScopedKey(Scope(3), a)
   val a4 = ScopedKey(Scope(4), a)
   val a5 = ScopedKey(Scope(5), a)

   val b4 = ScopedKey(Scope(4), b)

      // Define some settings
   val mySettings: Seq[Setting[_]] = Seq(
      setting( a3, value( 3 ) ),
      setting( b4, map(a4)(_ * 3)),
      update(a5)(_ + 1)
   )

      // &quot;compiles&quot; and applies the settings.
      //  This can be split into multiple steps to access intermediate results if desired.
      //  The 'inspect' command operates on the output of 'compile', for example.
   val applied: Settings[Scope] = make(mySettings)(delegates, scopeLocal, showFullKey)

   // Show results.
   for(i &lt;- 0 to 5; k &lt;- Seq(a, b)) {
      println( k.label + i + &quot; = &quot; + applied.get( Scope(i), k) )
   }
}
</code></pre><p>This produces the following output when run:
</p><pre><code class="">a0 = None
b0 = None
a1 = None
b1 = None
a2 = None
b2 = None
a3 = Some(3)
b3 = None
a4 = Some(3)
b4 = Some(9)
a5 = Some(4)
b5 = Some(9)
</code></pre><ul><li>For the <code>None</code> results, we never defined the value and there was no
value to delegate to.
</li><li>For <code>a3</code>, we explicitly defined it to be 3.
</li><li><code>a4</code> wasn’t defined, so it delegates to <code>a3</code> according to our <code>delegates</code>
function.
</li><li><code>b4</code> gets the value for <code>a4</code> (which delegates to <code>a3</code>, so it is 3) and
multiplies by 3
</li><li><code>a5</code> is defined as the previous value of <code>a5</code> + 1 and since no previous
value of <code>a5</code> was defined, it delegates to <code>a4</code>, resulting in 3+1=4.
</li><li><code>b5</code> isn’t defined explicitly, so it delegates to <code>b4</code> and is therefore
equal to 9 as well
</li></ul><h3 id="sbt+Settings+Discussion">sbt Settings Discussion<a href="#sbt+Settings+Discussion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Scopes">Scopes<a href="#Scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt defines a more complicated scope than the one shown here for the
standard usage of settings in a build. This scope has four components:
the project axis, the configuration axis, the task axis, and the extra
axis. Each component may be 
<a href="../api/sbt/Zero$.html">Zero</a> (no specific value),
<a href="../api/sbt/This$.html">This</a>
(current context), or
<a href="../api/sbt/Select.html">Select</a> (containing a specific value). sbt
resolves <code>This_</code> to either
<a href="../api/sbt/Zero$.html">Zero</a> or
<a href="../api/sbt/Select.html">Select</a>
depending on the context.
</p><p>For example, in a project, a
<a href="../api/sbt/This$.html">This</a> project axis becomes a
<a href="../api/sbt/Select.html">Select</a> referring to the defining project. All other axes that are
<a href="../api/sbt/This$.html">This</a> are
translated to
<a href="../api/sbt/Zero$.html">Zero</a>. Functions like <code>inConfig</code> and <code>inTask</code> transform
<code>This</code> into a
<a href="../api/sbt/Select.html">Select</a> for a specific value. For example,
<code>inConfig(Compile)(someSettings)</code> translates the configuration axis for
all settings in <em>someSettings</em> to be <code>Select(Compile)</code> if the axis value
is
<a href="../api/sbt/This$.html">This</a>.
</p><p>So, from the example and from sbt’s scopes, you can see that the core
settings engine does not impose much on the structure of a scope. All it
requires is a <code>delegates</code> function <code>Scope =&gt; Seq[Scope]</code> and a <code>display</code>
function. You can choose a scope type that makes sense for your
situation.
</p><h4 id="Constructing+settings">Constructing settings<a href="#Constructing+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>app</code>, <code>value</code>, <code>update</code>, and related methods are the core methods
for constructing settings. This example obviously looks rather different
from sbt’s interface because these methods are not typically used
directly, but are wrapped in a higher-level abstraction.
</p><p>With the core settings engine, you work with <code>HList</code>s to access other
settings. In sbt’s higher-level system, there are wrappers around <code>HList</code>
for <code>TupleN</code> and <code>FunctionN</code> for N = 1-9 (except <code>Tuple1</code> isn’t actually
used). When working with arbitrary arity, it is useful to make these
wrappers at the highest level possible. This is because once wrappers
are defined, code must be duplicated for every N. By making the wrappers
at the top-level, this requires only one level of duplication.
</p><p>Additionally, sbt uniformly integrates its task engine into the settings
system. The underlying settings engine has no notion of tasks. This is
why sbt uses a <code>SettingKey</code> type and a <code>TaskKey</code> type. Methods on an
underlying <code>TaskKey[T]</code> are basically translated to operating on an
underlying <code>SettingKey[Task[T]]</code> (and they both wrap an underlying
<code>AttributeKey</code>).
</p><p>For example, <code>a := 3</code> for a SettingKey <em>a</em> will very roughly translate
to <code>setting(a, value(3))</code>. For a TaskKey <em>a</em>, it will roughly translate
to <code>setting(a, value( task { 3 } ) )</code>. See
<a href="https://github.com/sbt/sbt/blob/develop/main-settings/src/main/scala/sbt/Structure.scala">main/Structure.scala</a> for details.
</p><h4 id="Settings+definitions">Settings definitions<a href="#Settings+definitions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt also provides a way to define these settings in a file (<code>build.sbt</code>
and <code>Build.scala</code>). This is done for <code>build.sbt</code> using basic parsing and
then passing the resulting chunks of code to <code>compile/Eval.scala</code>. For
all definitions, sbt manages the classpaths and recompilation process to
obtain the settings. It also provides a way for users to define project,
task, and configuration delegation, which ends up being used by the
<code>delegates</code> function.
</p><h2 id="Setting+Initialization">Setting Initialization<a href="#Setting+Initialization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page outlines the mechanisms by which sbt loads settings for a
particular build, including the hooks where users can control the
ordering of everything.
</p><p>As stated elsewhere, sbt constructs its initialization graph and task
graph via <code>Setting[_]</code> objects. A setting is something which can take
the values stored at other <code>Keys</code> in the build state, and generates a new
value for a particular build key. sbt converts all registered
<code>Setting[_]</code> objects into a giant linear sequence and <em>compiles</em> them
into a task graph. This task graph is then used to execute your build.
</p><p>All of sbt’s loading semantics are contained within the
<a href="https://github.com/sbt/sbt/blob/develop/main/src/main/scala/sbt/internal/Load.scala">Load.scala</a> file. It is approximately
the following:
</p><p><img src="files/settings-initialization-load-ordering.png" alt="image"/>
</p><p>The blue circles represent actions happening when sbt loads a project.
We can see that sbt performs the following actions in load:
</p><ol><li><p>Compile the user-level project (<code>~/.sbt/&lt;version&gt;/</code>)
</p><p>a. Load any plugins defined by this project (<code>~/.sbt/&lt;version&gt;/plugins/*.sbt</code> and <code>~/.sbt/&lt;version&gt;/plugins/project/*.scala</code>)
b. Load all settings defined (<code>~/.sbt/&lt;version&gt;/*.sbt</code> and <code>~/.sbt/&lt;version&gt;/plugins/*.scala</code>)
</p></li><li><p>Compile the current project (<code>&lt;working-directory/project</code>)
</p><p>a. Load all defined plugins (<code>project/plugins.sbt</code> and <code>project/project/*.scala</code>)
b. Load/Compile the project (<code>project/*.scala</code>)
</p></li><li>Load project <code>*.sbt</code> files (<code>build.sbt</code> and friends).
</li></ol><p>Each of these loads defines several sequences of settings. The diagram
shows the two most important:
</p><ul><li><p><code>buildSettings</code> - These are settings defined to be <code>in ThisBuild</code> or
directly against the <code>Build</code> object. They are initialized <em>once</em> for
the build. You can add these, e.g. in <code>build.sbt</code> file:
</p><pre><code class="prettyprint lang-scala">ThisBuild / foo := &quot;hi&quot;
</code></pre></li><li><p><code>projectSettings</code> - These are settings specific to a project. They
are specific to a <em>particular subproject</em> in the build. A plugin
may be contributing its settings to more than one project, in which
case the values are duplicated for each project. You add project
specific settings, eg. in <code>project/build.scala</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;)).settings(...)
</code></pre></li></ul><p>After loading/compiling all the build definitions, sbt has a series of
<code>Seq[Setting[_]]</code> that it must order. As shown in the diagram, the
default inclusion order for sbt is:
</p><ol><li>All AutoPlugin settings
</li><li>All settings defined in the user directory
(<code>~/.sbt/&lt;version&gt;/*.sbt</code>)
</li><li>All local configurations (<code>build.sbt</code>)
</li></ol><h2 id="Creating+Command+Line+Applications+Using+sbt">Creating Command Line Applications Using sbt<a href="#Creating+Command+Line+Applications+Using+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There are several components of sbt that may be used to create a command
line application. The <a href="Sbt-Launcher.html">launcher</a> and the
<a href="Commands.html">command system</a> are the two main ones illustrated here.
</p><p>As described on the <a href="Sbt-Launcher.html">launcher page</a>, a
launched application implements the xsbti.AppMain interface and defines
a brief configuration file that users pass to the launcher to run the
application. To use the command system, an application sets up a
<a href="Build-State.html">State</a> instance that provides
<a href="Commands.html">command implementations</a> and the initial commands to run. A
minimal hello world example is given below.
</p><h3 id="Hello+World+Example">Hello World Example<a href="#Hello+World+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are three files in this example:
</p><ol><li>build.sbt
</li><li>Main.scala
</li><li>hello.build.properties
</li></ol><p>To try out this example:
</p><ol><li>Put the first two files in a new directory
</li><li>In sbt’s shell run <code>publishLocal</code> in that directory
</li><li>Run <code>sbt @path/to/hello.build.properties</code> to run the application.
</li></ol><p>Like for sbt itself, you can specify commands from the command line
(batch mode) or run them at an prompt (interactive mode).
</p><h4 id="Build+Definition%3A+build.sbt">Build Definition: build.sbt<a href="#Build+Definition%3A+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The build.sbt file should define the standard settings: name, version,
and organization. To use the sbt command system, a dependency on the
<code>command</code> module is needed. To use the task system, add a dependency on
the <code>task-system</code> module as well.
</p><pre><code class="prettyprint lang-scala">organization := &quot;org.example&quot;

name := &quot;hello&quot;

version := &quot;0.1-SNAPSHOT&quot;

libraryDependencies += &quot;org.scala-sbt&quot; % &quot;command&quot; % &quot;0.12.0&quot;
</code></pre><h4 id="Application%3A+Main.scala">Application: Main.scala<a href="#Application%3A+Main.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The application itself is defined by implementing
<a href="../api/xsbti/AppMain.html">xsbti.AppMain</a>. The basic steps are
</p><ol><li>Provide command definitions. These are the commands that are
available for users to run.
</li><li>Define initial commands. These are the commands that are initially
scheduled to run. For example, an application will typically add
anything specified on the command line (what sbt calls batch mode)
and if no commands are defined, enter interactive mode by running
the ‘shell’ command.
</li><li>Set up logging. The default setup in the example rotates the log
file after each user interaction and sends brief logging to the
console and verbose logging to the log file.
</li></ol><pre><code class="prettyprint lang-scala">package org.example

   import sbt._
   import java.io.{File, PrintWriter}

final class Main extends xsbti.AppMain
{
   /** Defines the entry point for the application.
   * The call to `initialState` sets up the application.
   * The call to runLogged starts command processing. */
   def run(configuration: xsbti.AppConfiguration): xsbti.MainResult =
      MainLoop.runLogged( initialState(configuration) )

   /** Sets up the application by constructing an initial State instance with the supported commands
   * and initial commands to run.  See the State API documentation for details. */
   def initialState(configuration: xsbti.AppConfiguration): State =
   {
      val commandDefinitions = hello +: BasicCommands.allBasicCommands
      val commandsToRun = Hello +: &quot;iflast shell&quot; +: configuration.arguments.map(_.trim)
      State( configuration, commandDefinitions, Set.empty, None, commandsToRun, State.newHistory,
         AttributeMap.empty, initialGlobalLogging, State.Continue )
   }

   // defines an example command.  see the Commands page for details.
   val Hello = &quot;hello&quot;
   val hello = Command.command(Hello) { s =&gt;
      s.log.info(&quot;Hello!&quot;)
      s
   }

   /** Configures logging to log to a temporary backing file as well as to the console. 
   * An application would need to do more here to customize the logging level and
   * provide access to the backing file (like sbt's last command and logLevel setting).*/
   def initialGlobalLogging: GlobalLogging =
      GlobalLogging.initial(MainLogging.globalDefault _, File.createTempFile(&quot;hello&quot;, &quot;log&quot;))
}
</code></pre><h4 id="Launcher+configuration+file%3A+hello.build.properties">Launcher configuration file: hello.build.properties<a href="#Launcher+configuration+file%3A+hello.build.properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The launcher needs a configuration file in order to retrieve and run an
application. <code>hello.build.properties</code>:
</p><pre><code class="">[scala]
  version: 2.9.1

[app]
  org: org.example
  name: hello
  version: 0.1-SNAPSHOT
  class: org.example.Main
  components: xsbti
  cross-versioned: true

[repositories]
  local
  maven-central
  typesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre><ul><li>-
out: Archive.html
</li><li>-
</li></ul><h2 id="Archived+pages">Archived pages<a href="#Archived+pages" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h2 id="Hello%2C+World">Hello, World<a href="#Hello%2C+World" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page assumes you’ve <a href="Setup.html">installed sbt</a> 0.13.13 or later.
</p><h3 id="sbt+new+command">sbt new command<a href="#sbt+new+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re using sbt 0.13.13 or later, you can use sbt <code>new</code> command to quickly setup a simple Hello world build. Type the following command to the terminal.
</p><pre><code class="">$ sbt new sbt/scala-seed.g8
....
Minimum Scala build.

name [My Something Project]: hello

Template applied in ./hello
</code></pre><p>When prompted for the project name, type <code>hello</code>.
</p><p>This will create a new project under a directory named <code>hello</code>.
</p><h3 id="Running+your+app">Running your app<a href="#Running+your+app" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now from inside the <code>hello</code> directory, start <code>sbt</code> and type <code>run</code> at the sbt shell. On Linux or OS X the commands might look like this:
</p><pre><code class="">$ cd hello
$ sbt
...
&gt; run
...
[info] Compiling 1 Scala source to /xxx/hello/target/scala-2.12/classes...
[info] Running example.Hello
hello
</code></pre><p>We will see more tasks <a href="Running.html">later</a>.
</p><h3 id="Exiting+sbt+shell">Exiting sbt shell<a href="#Exiting+sbt+shell" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To leave sbt shell, type <code>exit</code> or use Ctrl+D (Unix) or Ctrl+Z
(Windows).
</p><pre><code class="">&gt; exit
</code></pre><h3 id="Build+definition">Build definition<a href="#Build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The build definition goes in a file called <code>build.sbt</code>, located in the project’s base directory.
You can take a look at the file, but don’t worry if the details of this build file aren’t clear yet.
In <a href="Basic-Def.html">.sbt build definition</a> you’ll learn more about how to write
a <code>build.sbt</code> file.
</p>
                  </div>
                </div>
          </div> <!-- row -->
        </div>
        <div class="header">
          <link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<!-- Algolia stylesheet -->
<link href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" rel="stylesheet" type = "text/css">
<div class="container-fluid top nav">
  <div class="row w-100">
    <div class="col-md-4">
      <div class="logo">
        <a href="../../index.html"><img src="files/sbt-logo.svg" alt="sbt"></a>
        <span class="versions"><select id="versions"></select></span>
      </div>
    </div>
    <div class="col-md-8">
        <div class="docsearch">
          <input type="text" id="doc-search-bar" placeholder="Search...">
          <ul class="result-container" id="result-container" style="display: none;"></ul>
        </div>
        <div class="nav" id="topbar">
          <a href="../../learn.html">Learn</a>
          <a href="../../download.html">Download</a>
          <a href="../../support.html">Support</a>
          <a href="../../community.html">Get Involved</a>
          <a id="source-code" href="https://github.com/sbt/sbt"><img src="files/github-logo-teal.svg" alt="Source code" class="social"></a>
          <a id="twitter" href="https://twitter.com/scala_sbt"><img src="files/twitter-logo-teal.svg" alt="sbt on Twitter" class="social"></a>
          <a id="edit-on-github" href="https://github.com/sbt/website/edit/develop/src/reference/Combined Pages"><img src="files/octicon-pencil.svg" alt="Edit on GitHub"></a>
        </div>
    </div>
  </div>
</div>
<script type="text/javascript" async>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-41449189-1', 'scala-sbt.org');
ga('send', 'pageview');
</script>
<script type="text/javascript" async>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
  ga('tsTracker.require', 'linker');
  ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org']);
  ga('tsTracker.send', 'pageview');
</script>
<script type="text/javascript">
$(function() {
var scrollDown = function() {
if (window.location.hash !== "") {
  setTimeout(function() { $(window).scrollTop($(window).scrollTop() - 120); }, 100);
}
}
scrollDown();
$(window).bind('hashchange', function() {
scrollDown();
});
});
</script>

        </div>
        <div class="footer">
          <footer>
  <div class="container-fluid footer">
    <div class="row">
      <div class="col-md-8">
        <div class="support-item">
          <div class="support-icon">
            <svg class="svg-icon svg-icon-chat" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 97.5 85.2" enable-background="new 0 0 97.5 85.2"><path stroke="#fff" stroke-width="4.282" stroke-linecap="round" stroke-miterlimit="10" d="M27 29.5h-16.3c-4.7 0-8.6 3.9-8.6 8.6v25.7c0 4.7 3.9 8.6 8.6 8.6h2.7c.8 0 1.5.7 1.5 1.5v7.8c0 1.3 1.6 2 2.5 1l9.5-9.5c.5-.5 1.2-.8 2-.8h20.2c4.7 0 8.6-3.9 8.6-8.6v-7.8" fill="none"/><path fill="#fff" d="M85 0h-40c-6.9 0-12.5 5.6-12.5 12.5v33.4c0 2.2 1.8 4.1 4.1 4.1h29.9c.7 0 1.3.3 1.8.7l10 10c1.6 1.6 4.3.5 4.3-1.8v-6.5c0-1.4 1.1-2.5 2.5-2.5 6.9 0 12.5-5.6 12.5-12.5v-25c-.1-6.8-5.8-12.4-12.6-12.4z"/></svg>
          </div>
          <div class="support-detail">
            <h2>Community Support</h2>
            <a href="https://stackoverflow.com/questions/tagged/sbt">StackOverflow</a>
          </div>
        </div>
        <div class="support-item">
          <div class="support-icon">
            <svg id="lightbend-icon-reverse" class="svg-icon svg-icon-lightbend-reverse" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 302 262"><title>lightbend-icon</title><g id="icon"><path d="M1,195v56a10,10,0,0,0,10,10H291a10,10,0,0,0,10-10V195a557.85,557.85,0,0,1-150,20A557.85,557.85,0,0,1,1,195Z" style="fill:#fff"/><path d="M291,1H11A10,10,0,0,0,1,11V176a539.94,539.94,0,0,0,150,21,539.94,539.94,0,0,0,150-21V11A10,10,0,0,0,291,1Z" style="fill:#fff"/></g></svg>
          </div>
          <div class="support-detail">
            <h2>Commercial Support</h2>
            <a href="https://www.lightbend.com/services/expert-support">Lightbend Subscription</a>
            <a href="https://www.lightbend.com/services/training">Training</a>
            <a href="https://www.lightbend.com/services/consulting">Consulting</a>
          </div>
        </div>
      </div>
      <div class="col-md-4 text-right ts">
        &copy; 2016-<script>document.write(new Date().getFullYear())</script> Lightbend Inc.
        <a href="https://www.lightbend.com">
          <img src="files/lightbend-reverse.svg" alt="Lightbend, Inc.">
        </a>
      </div>
    </div>
  </div>
</footer><script src="/assets/versions.js"></script><script src="/assets/set-versions.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript"> docsearch({
  apiKey: 'e47ee877a07ea1c48722f08430d54913',
  indexName: 'scala-sbt',
  inputSelector: '#doc-search-bar',
  debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
        </div>
        
        <div class="highlight-outer">
              <div class="highlight-menu">
                <ul>
                  <li><button id="highlight-button-twitter"><img src="img/twitter-bird-dark-bgs.png"/></button></li>
                </ul>
              </div>
            </div>
      </body>
    </html>