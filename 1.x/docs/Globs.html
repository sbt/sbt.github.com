<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>sbt Reference Manual — Globs</title>
        <link rel="shortcut icon" href="favicon.ico"/>
        <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
        <script type="text/javascript" src="js/bootstrap.bundle.min.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom-202107.css" type="text/css" media="screen, projection"/>
        
        <script type="text/javascript">
              Pamflet.twitter = '#sbt #scala';
            </script>
      </head>
      <body class="color_scheme-github">
        <div class="container-fluid contentswrapper h-100">
          <div class="row minh-100">
          <div class="col-md-4 col-xl-3 toccolumn leftcolumn">
                  <div class="lefttocwrapper">
      <div class="tocwrapper">
        
        <div class="tocbody show" id="toc">
        
        <div><a href="index.html">sbt Reference Manual</a></div><ol class="toc"> <li><div><a href="Getting-Started.html">Getting Started with sbt</a></div><ol class="toc"> <li><div><a href="Setup.html">Installing sbt</a></div><ol class="toc"> <li><div><a href="Installing-sbt-on-Mac.html">Installing sbt on macOS</a></div></li><li><div><a href="Installing-sbt-on-Windows.html">Installing sbt on Windows</a></div></li><li><div><a href="Installing-sbt-on-Linux.html">Installing sbt on Linux</a></div></li> </ol></li><li><div><a href="sbt-by-example.html">sbt by example</a></div></li><li><div><a href="Directories.html">Directory structure</a></div></li><li><div><a href="Running.html">Running</a></div></li><li><div><a href="IDE.html">IDE Integration</a></div></li><li><div><a href="Basic-Def.html">Build definition</a></div></li><li><div><a href="Multi-Project.html">Multi-project builds</a></div></li><li><div><a href="Task-Graph.html">Task graph</a></div></li><li><div><a href="Scopes.html">Scopes</a></div></li><li><div><a href="Appending-Values.html">Appending values</a></div></li><li><div><a href="Scope-Delegation.html">Scope delegation (.value lookup)</a></div></li><li><div><a href="Library-Dependencies.html">Library dependencies</a></div></li><li><div><a href="Using-Plugins.html">Using plugins</a></div></li><li><div><a href="Custom-Settings.html">Custom settings and tasks</a></div></li><li><div><a href="Organizing-Build.html">Organizing the build</a></div></li><li><div><a href="Summary.html">Getting Started summary</a></div></li> </ol></li><li><div><a href="Faq.html">Frequently Asked Questions</a></div><ol class="toc">  </ol></li><li><div><a href="General-Info.html">General Information</a></div><ol class="toc"> <li><div><a href="Credits.html">Credits</a></div></li><li><div><a href="Community-Plugins.html">Community Plugins</a></div></li><li><div><a href="Repository-Roles.html">Community Repository Policy</a></div></li><li><div><a href="Bintray-For-Plugins.html">Bintray For Plugins</a></div></li><li><div><a href="Using-Sonatype.html">Using Sonatype</a></div></li><li><div><a href="Contributing-to-sbt.html">Contributing to sbt</a></div></li><li><div><a href="Changes.html">Changes</a></div><ol class="toc"> <li><div><a href="Migrating-from-sbt-013x.html">Migrating from sbt 0.13.x</a></div></li><li><div><a href="sbt-1.4-Release-Notes.html">sbt 1.4.x releases</a></div></li><li><div><a href="sbt-1.3-Release-Notes.html">sbt 1.3.x releases</a></div></li><li><div><a href="sbt-1.2-Release-Notes.html">sbt 1.2.x releases</a></div></li><li><div><a href="sbt-1.1-Release-Notes.html">sbt 1.1.x releases</a></div></li><li><div><a href="sbt-1.0-Release-Notes.html">sbt 1.0.x releases</a></div></li> </ol></li> </ol></li><li><div><a href="Detailed-Topics.html">Detailed Topics</a></div><ol class="toc"> <li><div><a href="Using-sbt.html">Using sbt</a></div><ol class="toc"> <li><div><a href="Command-Line-Reference.html">Command Line Reference</a></div></li><li><div><a href="Console-Project.html">Console Project</a></div></li><li><div><a href="Cross-Build.html">Cross-building</a></div></li><li><div><a href="Inspecting-Settings.html">Interacting with the Configuration System</a></div></li><li><div><a href="Triggered-Execution.html">Triggered Execution</a></div></li><li><div><a href="Scripts.html">Script mode</a></div></li><li><div><a href="sbt-server.html">sbt Server</a></div></li><li><div><a href="Understanding-Recompilation.html">Understanding Incremental Recompilation</a></div></li> </ol></li><li><div><a href="Configuration-Index.html">Configuration</a></div><ol class="toc"> <li><div><a href="Classpaths.html">Classpaths, sources, and resources</a></div></li><li><div><a href="Compiler-Plugins.html">Compiler Plugin Support</a></div></li><li><div><a href="Configuring-Scala.html">Configuring Scala</a></div></li><li><div><a href="Forking.html">Forking</a></div></li><li><div><a href="Global-Settings.html">Global Settings</a></div></li><li><div><a href="Java-Sources.html">Java Sources</a></div></li><li><div><a href="Mapping-Files.html">Mapping Files</a></div></li><li><div><a href="Local-Scala.html">Local Scala</a></div></li><li><div><a href="Macro-Projects.html">Macro Projects</a></div></li><li><div><a href="Paths.html">Paths</a></div></li><li><div><a href="Parallel-Execution.html">Parallel Execution</a></div></li><li><div><a href="Process.html">External Processes</a></div></li><li><div><a href="Running-Project-Code.html">Running Project Code</a></div></li><li><div><a href="Testing.html">Testing</a></div></li><li><div><a href="In-Process-Classloaders.html">In process class loading</a></div></li><li><div class="current">Globs</div></li><li><div><a href="Remote-Caching.html">Remote Caching</a></div></li> </ol></li><li><div><a href="Dependency-Management-Index.html">Dependency Management</a></div><ol class="toc"> <li><div><a href="Artifacts.html">Artifacts</a></div></li><li><div><a href="Dependency-Management-Flow.html">Dependency Management Flow</a></div></li><li><div><a href="Library-Management.html">Library Management</a></div></li><li><div><a href="Proxy-Repositories.html">Proxy Repositories</a></div></li><li><div><a href="Publishing.html">Publishing</a></div></li><li><div><a href="Resolvers.html">Resolvers</a></div></li><li><div><a href="Update-Report.html">Update Report</a></div></li><li><div><a href="Cached-Resolution.html">Cached Resolution</a></div></li> </ol></li><li><div><a href="Tasks-and-Commands.html">Tasks and Commands</a></div><ol class="toc"> <li><div><a href="Tasks.html">Tasks</a></div></li><li><div><a href="Caching.html">Caching</a></div></li><li><div><a href="Input-Tasks.html">Input Tasks</a></div></li><li><div><a href="Commands.html">Commands</a></div></li><li><div><a href="Parsing-Input.html">Parsing and tab completion</a></div></li><li><div><a href="Build-State.html">State and actions</a></div></li><li><div><a href="Task-Inputs.html">Tasks/Settings: Motivation</a></div></li> </ol></li><li><div><a href="Plugins-and-Best-Practices.html">Plugins and Best Practices</a></div><ol class="toc"> <li><div><a href="Best-Practices.html">General Best Practices</a></div></li><li><div><a href="Plugins.html">Plugins</a></div></li><li><div><a href="Plugins-Best-Practices.html">Plugins Best Practices</a></div></li><li><div><a href="GitHub-Actions-with-sbt.html">Setting up GitHub Actions with sbt</a></div></li><li><div><a href="Travis-CI-with-sbt.html">Setting up Travis CI with sbt</a></div></li><li><div><a href="Testing-sbt-plugins.html">Testing sbt plugins</a></div></li><li><div><a href="sbt-new-and-Templates.html">sbt new and Templates</a></div></li><li><div><a href="Cross-Build-Plugins.html">Cross building plugins</a></div></li> </ol></li> </ol></li><li><div><a href="Howto.html">How to…</a></div><ol class="toc"> <li><div><a href="Howto-Classpaths.html">Classpaths</a></div></li><li><div><a href="Howto-Customizing-Paths.html">Customizing paths</a></div></li><li><div><a href="Howto-Generating-Files.html">Generating files</a></div></li><li><div><a href="Howto-Inspect-the-Build.html">Inspect the build</a></div></li><li><div><a href="Howto-Interactive-Mode.html">Interactive mode</a></div></li><li><div><a href="Howto-Logging.html">Configure and use logging</a></div></li><li><div><a href="Howto-Project-Metadata.html">Project metadata</a></div></li><li><div><a href="Howto-Package.html">Configure packaging</a></div></li><li><div><a href="Howto-Running-Commands.html">Running commands</a></div></li><li><div><a href="Howto-Scala.html">Configure and use Scala</a></div></li><li><div><a href="Howto-Scaladoc.html">Generate API documentation</a></div></li><li><div><a href="Define+Custom+Tasks.html">Define Custom Tasks</a></div></li><li><div><a href="Howto-Startup.html">How to take an action on startup</a></div></li><li><div><a href="Howto-Track-File-Inputs-and-Outputs.html">Track file inputs and outputs</a></div></li><li><div><a href="Troubleshoot-Memory-Issues.html">Troubleshoot memory issues</a></div></li><li><div><a href="Howto-Sequencing.html">Sequencing</a></div><ol class="toc"> <li><div><a href="Howto-Sequential-Task.html">Defining a sequential task with Def.sequential</a></div></li><li><div><a href="Howto-Dynamic-Task.html">Defining a dynamic task with Def.taskDyn</a></div></li><li><div><a href="Howto-After-Input-Task.html">Doing something after an input task</a></div></li><li><div><a href="Howto-Dynamic-Input-Task.html">Defining a dynamic input task with Def.inputTaskDyn</a></div></li><li><div><a href="Howto-Sequence-using-Commands.html">How to sequence using commands</a></div></li> </ol></li><li><div><a href="Custom-Dependency-Configuration.html">How to define a custom dependency configuration</a></div></li><li><div><a href="Examples.html">Examples</a></div><ol class="toc"> <li><div><a href="Basic-Def-Examples.html">.sbt build examples</a></div></li><li><div><a href="Scala-Files-Example.html">.sbt build with .scala files example</a></div></li><li><div><a href="Advanced-Configurations-Example.html">Advanced configurations example</a></div></li><li><div><a href="Advanced-Command-Example.html">Advanced command example</a></div></li> </ol></li> </ol></li><li><div><a href="Name-Index.html">Index</a></div></li><li><div><a href="Developers-Guide.html">Developer’s Guide (Work in progress)</a></div><ol class="toc"> <li><div><a href="Modularization.html">Modularization</a></div><ol class="toc"> <li><div><a href="Module-Summary.html">Module summary</a></div></li> </ol></li><li><div><a href="Coding-Guideline.html">sbt Coding Guideline</a></div><ol class="toc">  </ol></li><li><div><a href="Datatype.html">sbt-datatype</a></div><ol class="toc">  </ol></li><li><div><a href="Compiler-Interface.html">Compiler Interface</a></div><ol class="toc"> <li><div><a href="Version-Specific-Sources.html">Fetching the most specific sources</a></div></li> </ol></li><li><div><a href="Sbt-Launcher.html">sbt Launcher</a></div><ol class="toc"> <li><div><a href="Launcher-Getting-Started.html">Getting Started with the sbt launcher</a></div></li><li><div><a href="Launcher-Architecture.html">Sbt Launcher Architecture</a></div></li><li><div><a href="Launcher-Configuration.html">sbt Launcher Configuration</a></div></li> </ol></li><li><div><a href="DevGuide-Notes.html">Notes</a></div><ol class="toc"> <li><div><a href="Core-Principles.html">Core Principles</a></div></li><li><div><a href="Settings-Core.html">Settings Core</a></div></li><li><div><a href="Setting-Initialization.html">Setting Initialization</a></div></li><li><div><a href="Command-Line-Applications.html">Creating Command Line Applications Using sbt</a></div></li> </ol></li> </ol></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div>
      </div>
      </div>
                </div><div class="col-md-8 col-xs-9">
                  <div class="rightcolumn contents">
                  <h2 id="Globs">Globs<a href="#Globs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 1.3.0 introduces the <code>Glob</code> type which can be used to specify a file system
query. The design is inspired by shell
<a href="https://en.wikipedia.org/wiki/Glob_%28programming%29">globs</a>. <code>Glob</code> has
only one public method, <code>matches(java.nio.file.Path)</code>, that can be used to
check if a path matches the glob pattern.
</p><h3 id="Constructing+Globs">Constructing Globs<a href="#Constructing+Globs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs can be constructed explicitly or using a dsl that uses the <code>/</code> operator to
extend queries. In all of the examples provided, we use <code>java.nio.file.Path</code>,
but <code>java.io.File</code> may also be used.
</p><p>The simplest Glob represents a single path. Explicitly create a single path glob
with:
</p><pre><code class="prettyprint lang-scala">val glob = Glob(Paths.get(&quot;foo/bar&quot;))
println(glob.matches(Paths.get(&quot;foo&quot;))) // prints false
println(glob.matches(Paths.get(&quot;foo/bar&quot;))) // prints true
println(glob.matches(Paths.get(&quot;foo/bar/baz&quot;))) // prints false
</code></pre><p>It can also be created using the glob dsl with:
</p><pre><code class="prettyprint lang-scala">val glob = Paths.get(&quot;foo/bar&quot;).toGlob
</code></pre><p>There are two special glob objects:
1) <code>AnyPath</code> (aliased by <code>*</code>) matches any path with just one name component
2) <code>RecursiveGlob</code> (aliased by <code>**</code>) matches all paths
</p><p>Using <code>AnyPath</code>, we can explicitly construct a glob that matches all children of
a directory:
</p><pre><code class="prettyprint lang-scala">val path = Paths.get(&quot;/foo/bar&quot;)
val children = Glob(path, AnyPath)
println(children.matches(path)) // prints false
println(children.matches(path.resolve(&quot;baz&quot;)) // prints true
println(children.matches(path.resolve(&quot;baz&quot;).resolve(&quot;buzz&quot;) // prints false
</code></pre><p>Using the dsl, the above becomes:
</p><pre><code class="prettyprint lang-scala">val children    = Paths.get(&quot;/foo/bar&quot;).toGlob / AnyPath
val dslChildren = Paths.get(&quot;/foo/bar&quot;).toGlob / *
// these two definitions have identical results
</code></pre><p>Recursive globs are similar:
</p><pre><code class="prettyprint lang-scala">val path = Paths.get(&quot;/foo/bar&quot;)
val allDescendants = Glob(path, RescursiveGlob)
println(allDescendants.matches(path)) // prints false
println(allDescendants.matches(path.resolve(&quot;baz&quot;)) // prints true
println(allDescendants.matches(path.resolve(&quot;baz&quot;).resolve(&quot;buzz&quot;) // prints true
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">val allDescendants = Paths.get(&quot;/foo/bar&quot;).toGlob / **
</code></pre><h3 id="Path+names">Path names<a href="#Path+names" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs may also be constructed using path names. The following three globs are
equivalent:
</p><pre><code class="prettyprint lang-scala">val pathGlob = Paths.get(&quot;foo&quot;).resolve(&quot;bar&quot;)
val glob = Glob(&quot;foo/bar&quot;)
val altGlob = Glob(&quot;foo&quot;) / &quot;bar&quot;
</code></pre><p>When parsing glob paths, any <code>/</code> characters are automatically converted to <code>\</code>
on windows.
</p><h3 id="Filters">Filters<a href="#Filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Globs can apply name filters at each path level. For example,
</p><pre><code class="prettyprint lang-scala">val scalaSources = Paths.get(&quot;/foo/bar&quot;).toGlob / ** / &quot;src&quot; / &quot;*.scala&quot;
</code></pre><p>specifies all of the descendants of <code>/foo/bar</code> that have the <code>scala</code> file
extension whose parent directory is named <code>src</code>.
</p><p>More advanced queries are also possible:
</p><pre><code class="prettyprint lang-scala">val scalaAndJavaSources =
  Paths.get(&quot;/foo/bar&quot;).toGlob / ** / &quot;src&quot; / &quot;*.{scala,java}&quot;
</code></pre><h3 id="Depth">Depth<a href="#Depth" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>AnyPath</code> special glob can be used to control the depth of the query. For
example, the glob
</p><pre><code class="prettyprint lang-scala">  val twoDeep = Glob(&quot;/foo/bar&quot;) / * / * / *
</code></pre><p>matches any path that is a descendant of <code>/foo/bar</code> that has exactly two
parents, e.g. <code>/foo/bar/a/b/c.txt</code> would be accepted but not <code>/foo/bar/a/b</code> or
<code>/foo/bar/a/b/c/d.txt</code>.
</p><h3 id="Regular+expressions">Regular expressions<a href="#Regular+expressions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Glob</code> apis use glob syntax (see
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)">PathMatcher</a>
for details). <a href="https://www.scala-lang.org/api/2.12.8/scala/util/matching/Regex.html">Regular
expressions</a>
can be used instead:
</p><pre><code class="prettyprint lang-scala">val digitGlob = Glob(&quot;/foo/bar&quot;) / &quot;.*-\d{2,3}[.]txt&quot;.r
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-1.txt&quot;)) // false
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-23.txt&quot;)) // true
digitGlob.matches(Paths.get(&quot;/foo/bar&quot;).resolve(&quot;foo-123.txt&quot;)) // true
</code></pre><p>It is possible to specify multiple path components in the regex:
</p><pre><code class="prettyprint lang-scala">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/.*/foo.txt&quot;
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/buzz/foo.txt&quot;)) // true
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-12/buzz/foo.txt&quot;)) // false
</code></pre><p>Recursive globs cannot be expressed using regex syntax because <code>**</code> is not valid
in a regex and paths are matched component wise (so <code>&quot;foo/.*/foo.txt&quot;</code> is actually
split into three regular expressions <code>{&quot;foo&quot;, &quot;.*&quot;, &quot;foo.txt&quot;}</code> for matching
purposes. To make the <code>multiRegex</code> from above recursive, one could write:
</p><pre><code class="">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/&quot;.r / ** / &quot;foo.txt&quot;
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/buzz/foo.txt&quot;)) // true
multiRegex.matches(Paths.get(&quot;/foo/bar/baz-1/fizz/buzz/foo.txt&quot;)) // true
</code></pre><p>In regex syntax, <code>\</code> is an escape character and cannot be used as a path
separator. If the regex covers multiple path components, <code>/</code> must be used as the
path separator, even on Windows:
</p><pre><code class="">val multiRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz-\d/foo\.txt&quot;.r
val validRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz/Foo[.].txt&quot;.r
// throws java.util.regex.PatternSyntaxException because \F is not a valid
// regex construct
val invalidRegex = Glob(&quot;/foo/bar&quot;) / &quot;baz\Foo[.].txt&quot;.r
</code></pre><a name="file-tree-view"></a><h3 id="Querying+the+file+system+with+FileTreeView">Querying the file system with FileTreeView<a href="#Querying+the+file+system+with+FileTreeView" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Querying the file system for the files that match one or more <code>Glob</code> patterns is
done via the <code>sbt.nio.file.FileTreeView</code> trait. It provides two methods
</p><ol><li><code>def list(glob: Glob): Seq[(Path, FileAttributes)]</code>
</li><li><code>def list(globs: Seq[Glob]): Seq[(Path, FileAttributes)]</code>
</li></ol><p>that can be used to retrieve all of the paths matching the provided patterns.
</p><pre><code class="prettyprint lang-scala">val scalaSources: Glob = ** / &quot;*.scala&quot;
val regularSources: Glob = &quot;/foo/src/main/scala&quot; / scalaSources
val scala212Sources: Glob = &quot;/foo/src/main/scala-2.12&quot;
val sources: Seq[Path] = FileTreeView.default.list(regularSources).map(_._1)
val allSources: Seq[Path] =
  FileTreeView.default.list(Seq(regularSources, scala212Sources)).map(_._1)
</code></pre><p>In the variant that takes <code>Seq[Glob]</code> as input, sbt will aggregate all of the
globs in such a way that it will only ever list any directory on the file system
once. It should return all of the files whose path name matches <em>any</em> of the
provided <code>Glob</code> patterns in the input <code>Seq[Glob]</code>.
</p><h4 id="File+attributes">File attributes<a href="#File+attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>FileTreeView</code> trait is parameterized by a type, <code>T</code>, that is always
<code>(java.nio.file.Path, sbt.nio.file.FileAttributes)</code> in sbt. The <code>FileAttributes</code>
trait provides access to the following properties:
</p><ol><li><code>isDirectory</code> — returns true if the <code>Path</code> represents a directory.
</li><li><code>isRegularFile</code> — returns true if the <code>Path</code> represents a regular file. This
should usually be the inverse of <code>isDirectory</code>.
</li><li><code>isSymbolicLink</code> — returns true if the <code>Path</code> is a symbolic link. The
default <code>FileTreeView</code> implementation always follows symbolic links. If the
symbolic link targets a regular file, both <code>isSymbolicLink</code> and <code>isRegularFile</code>
will be true. Similarly, if the link targets a directory, both <code>isSymbolicLink</code>
and <code>isDirectory</code> will be true. If the link is broken, <code>isSymbolicLink</code> will be
true but both <code>isDirectory</code> and <code>isRegularFile</code> will be false.
</li></ol><p>The reason that the <code>FileTreeView</code> always provides the attributes is because
checking the type of a file requires a system call, which can be slow. All of
the major desktop operating systems provide apis for listing a directory where
both the file names and file node types are returned. This allows sbt to provide
this information without making an extra system call. We can use this to
efficiently filter paths:
</p><pre><code class="prettyprint lang-scala">// No additional io is performed in the call to attributes.isRegularFile
val scalaSourcePaths =
  FileTreeView.default.list(Glob(&quot;/foo/src/main/scala/**/*.scala&quot;)).collect {
    case (path, attributes) if attributes.isRegularFile =&gt; path
  }
</code></pre><a name="path-filters"></a><h4 id="Filtering">Filtering<a href="#Filtering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to the <code>list</code> methods described above, there two additional
overloads that take an <code>sbt.nio.file.PathFilter</code> argument:
</p><ol><li><code>def list(glob: Glob, filter: PathFilter): Seq[(Path, FileAttributes)]</code>
</li><li><code>def list(globs: Seq[Glob], filter: PathFilter): Seq[(Path, FileAttributes)]</code>
</li></ol><p>The <code>PathFilter</code> has a single abstract method:
</p><pre><code class="prettyprint lang-scala">def accept(path: Path, attributes: FileAttributes): Boolean
</code></pre><p>It can be used to further filter the query specified by the glob patterns:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (_, a) =&gt; a.isRegularFile
val scalaSourceFiles =
  FileTreeView.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), regularFileFilter)
</code></pre><p>A <code>Glob</code> may be used as a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val filter: PathFilter = ** / &quot;*include*&quot;
val scalaSourceFiles =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), filter)
</code></pre><p>Instances of <code>PathFilter</code> can be negated with the <code>!</code> unary operator:
</p><pre><code class="prettyprint lang-scala">val hiddenFileFilter: PathFilter = (p, _) =&gt; Try(Files.isHidden(p)).getOrElse(false)
val notHiddenFileFilter: PathFilter = !hiddenFileFilter
</code></pre><p>They can be combined with the <code>&amp;&amp;</code> operator:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (_, a) =&gt; a.isRegularFile
val notHiddenFileFilter: PathFilter = (p, _) =&gt; Try(Files.isHidden(p)).getOrElse(false)
val andFilter = regularFileFilter &amp;&amp; notHiddenFileFilter
val scalaSources =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;), andFilter)
</code></pre><p>They can be combined with the <code>||</code> operator:
</p><pre><code class="prettyprint lang-scala">val scalaSources: PathFilter = ** / &quot;*.scala&quot;
val javaSources: PathFilter = ** / &quot;*.java&quot;
val jvmSourceFilter = scalaSources || javaSources
val jvmSourceFiles =
  FileTreeView.default.list(Glob(&quot;/foo/bar/src/**&quot;), jvmSourceFilter)
</code></pre><p>There is also an implicit conversion from <code>String</code> to <code>PathFilter</code> that converts
the <code>String</code> to a <code>Glob</code> and converts the <code>Glob</code> to a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val regularFileFilter: PathFilter = (p, a) =&gt; a.isRegularFile
val regularScalaFiles: PathFilter = regularFileFilter &amp;&amp; &quot;**/*.scala&quot;
</code></pre><p>In addition to the ad-hoc filters, there are some commonly used filters that are
available in the default sbt scope:
</p><ol><li><code>sbt.io.HiddenFileFilter</code> — accepts any file that is hidden according to
<code>Files.isHidden</code>. On posix systems, this will just check if the name starts with
<code>.</code> while on Windows, it will need to perform io to extract the <code>dos:hidden</code>
attribute.
</li><li><code>sbt.io.RegularFileFilter</code> — equivalent to <code>(_, a: FileAttributes) =&gt;
a.isRegularFile</code>
</li><li><code>sbt.io.DirectoryFilter</code> — equivalent to <code>(_, a: FileAttributes) =&gt;
a.isDirectory</code>
</li></ol><p>There is also a converter from <code>sbt.io.FileFilter</code> to <code>sbt.nio.file.PathFilter</code>
that can be invoked by calling <code>toNio</code> on the <code>sbt.io.FileFilter</code> instance:
</p><pre><code class="prettyprint lang-scala">val excludeFilter: sbt.io.FileFilter = HiddenFileFilter || DirectoryFilter
val excludePathFilter: sbt.nio.file.PathFilter = excludeFilter.toNio
</code></pre><p>The <code>HiddenFileFilter</code>, <code>RegularFileFilter</code> and <code>DirectoryFilter</code> inherit both
<code>sbt.io.FileFilter</code> and <code>sbt.nio.file.PathFilter</code>. They typically can be treated
like a <code>PathFilter</code>:
</p><pre><code class="prettyprint lang-scala">val regularScalaFiles: PathFilter = RegularFileFilter &amp;&amp; (** / &quot;*.scala&quot;)
</code></pre><p>This will not work when the implicit conversion from <code>String</code> to <code>PathFinder</code> is
required.
</p><pre><code class="prettyprint lang-scala"> val regularScalaFiles = RegularFileFilter &amp;&amp; &quot;**/*.scala&quot;
// won't compile because it gets interpreted as
// (RegularFileFilter: sbt.io.FileFilter).&amp;&amp;((&quot;**/*.scala&quot;): sbt.io.NameFilter)
</code></pre><p>In these situations, use <code>toNio</code>:
</p><pre><code class="prettyprint lang-scala"> val regularScalaFiles = RegularFileFilter.toNio &amp;&amp; &quot;**/*.scala&quot;
</code></pre><p>It is important to note that semantics of <code>Glob</code> are different from
<code>NameFilter</code>. When using the <code>sbt.io.FileFilter</code>, in order to filter files
ending with the <code>.scala</code> extension, one would write:
</p><pre><code class="prettyprint lang-scala">val scalaFilter: NameFilter = &quot;*.scala&quot;
</code></pre><p>An equivalent <code>PathFilter</code> is written
</p><pre><code class="prettyprint lang-scala">val scalaFilter: PathFilter = &quot;**/*.scala&quot;
</code></pre><p>The glob represented <code>&quot;*.scala&quot;</code> matches a path with a single component ending
in scala. In general, when converting <code>sbt.io.NameFilter</code> to
<code>sbt.nio.file.PathFilter</code>, it will be necessary to add a <code>&quot;**/&quot;</code> prefix.
</p><h4 id="Streaming">Streaming<a href="#Streaming" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In addition to <code>FileTreeView.list</code>, there is also <code>FileTreeView.iterator</code>. The
latter may be used to reduce memory pressure:
</p><pre><code class="">// Prints all of the files on the root file system
FileTreeView.iterator(Glob(&quot;/**&quot;)).foreach { case (p, _) =&gt; println(p) }
</code></pre><p>In the context of sbt, the type parameter, <code>T</code>, is always <code>(java.nio.file.Path,
sbt.nio.file.FileAttributes)</code>. An implementation of <code>FileTreeView</code> is provided in sbt with the <code>fileTreeView</code>
key:
</p><pre><code class="">fileTreeView.value.list(baseDirectory.value / ** / &quot;*.txt&quot;)
</code></pre><h4 id="Implementation">Implementation<a href="#Implementation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>FileTreeView[+T]</code> trait has a single abstract method:
</p><pre><code class="">def list(path: Path): Seq[T]
</code></pre><p>sbt only provides implementations of <code>FileTreeView[(Path, FileAttributes)]</code>. In
this context, the <code>list</code> method should return the <code>(Path, FileAttributes)</code> pairs
for all of the direct children of the input <code>path</code>.
</p><p>There are two implementations of <code>FileTreeView[(Path, FileAttribute)]</code>
provided by sbt:
1. <code>FileTreeView.native</code> — this uses a native jni library to efficiently
extract the file names and attributes from the file system without performing
additional io. Native implementations are available for 64 bit FreeBSD, Linux,
Mac OS and Windows. If no native implementation is available, it falls back to a
<code>java.nio.file</code> based implementation.
2. <code>FileTreeView.nio</code> — uses apis in <code>java.nio.file</code> to implement
<code>FileTreeView</code>
</p><p>The <code>FileTreeView.default</code> method returns <code>FileTreeView.native</code>.
</p><p>The <code>list</code> and <code>iterator</code> methods that take <code>Glob</code> or <code>Seq[Glob]</code> as arguments
are provided as extension methods to <code>FileTreeView[(Path, FileAttributes)]</code>.
Since any implementation of <code>FileTreeView[(Path, FileAttributes)]</code> automatically
receives these extensions, it is easy to write an alternative implementation
that will still correctly work with <code>Glob</code> and <code>Seq[Glob]</code>:
</p><pre><code class="prettyprint lang-scala">val listedDirectories = mutable.Set.empty[Path]
val trackingView: FileTreeView[(Path, FileAttributes)] = path =&gt; {
  val results = FileTreeView.default.list(path)
  listedDirectories += path
  results
}
val scalaSources =
  trackingView.list(Glob(&quot;/foo/bar/src/main/scala/**/*.scala&quot;)).map(_._1)
println(listedDirectories) // prints all of the directories traversed by list
</code></pre><a name="glob-vs-pathfinder"></a><h3 id="Globs+vs.+PathFinder">Globs vs. PathFinder<a href="#Globs+vs.+PathFinder" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt has long had the <a href="Paths.html#path-finder">PathFinder</a> api which provides a dsl for collecting
files. While there is overlap, Globs are a less powerful abstraction than
PathFinder. This makes them more suitable for optimization. Globs describe the
what, but not the how, of a query. PathFinders combine the what and the how,
which makes them more difficult to optimize. For example, the following sbt snippet:
</p><pre><code class="">val paths = fileTreeView.value.list(
    baseDirectory.value / ** / &quot;*.scala&quot;,
    baseDirectory.value / ** / &quot;*.java&quot;).map(_._1)
</code></pre><p>will only traverse the file system once to collect all of the scala and java
sources in the project. By contrast,
</p><pre><code class="">val paths =
    (baseDirectory.value ** &quot;*.scala&quot; +++
     baseDirectory.value ** &quot;*.java&quot;).allPaths
</code></pre><p>will make two passes and will thus take about twice as long to run when compared
to the Glob version.
</p><div class="bottom nav">
                <div class="row">
                  <div class="col-md-auto">
                    <a href="Remote-Caching.html">
                      <div class="arrowitem">
                        <span class="arrow">&gt;</span>
                      </div>

                      <div class="arrowitem">
                        <em>Next page</em><br/>
                        Remote Caching
                      </div>

                    </a>
                  </div>
                </div>
                <div class="row w-100">
        <div class="col-md-auto ml-auto">
          <ul class="language-bar">
            
          </ul>
        </div>
      </div>
              </div>
                  </div>
                </div>
          </div> <!-- row -->
        </div>
        <div class="header">
          <link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<!-- Algolia stylesheet -->
<link href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" rel="stylesheet" type = "text/css">
<div class="container-fluid top nav">
  <div class="row w-100">
    <div class="col-md-4">
      <div class="logo">
        <a href="../../"><img src="files/sbt-logo.svg" alt="sbt"></a>
        <span class="versions"><select id="versions"></select></span>
      </div>
    </div>
    <div class="col-md-8">
        <div class="docsearch">
          <input type="text" id="doc-search-bar" placeholder="Search...">
          <ul class="result-container" id="result-container" style="display: none;"></ul>
        </div>
        <div class="nav" id="topbar">
          <a href="../../learn.html">Learn</a>
          <a href="../../download.html">Download</a>
          <a href="../../community.html">Get Involved</a>
          <a id="source-code" href="https://github.com/sbt/sbt"><img src="files/github-logo-teal.svg" alt="Source code" class="social"></a>
          <a id="twitter" href="https://twitter.com/scala_sbt"><img src="files/twitter-logo-teal.svg" alt="sbt on Twitter" class="social"></a>
          <a id="edit-on-github" href="https://github.com/sbt/website/edit/develop/src/reference/02-DetailTopics/02-Configuration/16-Globs.md"><img src="files/octicon-pencil.svg" alt="Edit on GitHub"></a>
        </div>
    </div>
  </div>
</div>
<script defer data-domain="scala-sbt.org" src="https://plausible.scala-lang.org/js/script.js"></script>
<script type="text/javascript">
$(function() {
var scrollDown = function() {
if (window.location.hash !== "") {
  setTimeout(function() { $(window).scrollTop($(window).scrollTop() - 120); }, 100);
}
}
scrollDown();
$(window).bind('hashchange', function() {
scrollDown();
});
});
</script>

        </div>
        <div class="footer">
          <footer>
  <div class="container-fluid footer">
    <div class="row">
      <div class="col-md-8">
        <div class="support-item">
          <div class="support-icon">
            <svg class="svg-icon svg-icon-chat" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 97.5 85.2" enable-background="new 0 0 97.5 85.2"><path stroke="#fff" stroke-width="4.282" stroke-linecap="round" stroke-miterlimit="10" d="M27 29.5h-16.3c-4.7 0-8.6 3.9-8.6 8.6v25.7c0 4.7 3.9 8.6 8.6 8.6h2.7c.8 0 1.5.7 1.5 1.5v7.8c0 1.3 1.6 2 2.5 1l9.5-9.5c.5-.5 1.2-.8 2-.8h20.2c4.7 0 8.6-3.9 8.6-8.6v-7.8" fill="none"/><path fill="#fff" d="M85 0h-40c-6.9 0-12.5 5.6-12.5 12.5v33.4c0 2.2 1.8 4.1 4.1 4.1h29.9c.7 0 1.3.3 1.8.7l10 10c1.6 1.6 4.3.5 4.3-1.8v-6.5c0-1.4 1.1-2.5 2.5-2.5 6.9 0 12.5-5.6 12.5-12.5v-25c-.1-6.8-5.8-12.4-12.6-12.4z"/></svg>
          </div>
          <div class="support-detail">
            <h2>Community Support</h2>
            <a href="https://stackoverflow.com/questions/tagged/sbt">StackOverflow</a>
          </div>
        </div>
      </div>
      <div class="col-md-4 text-right ts">
        &copy; 2023-<script>document.write(new Date().getFullYear())</script> Scala Center
      </div>
    </div>
  </div>
</footer><script src="/assets/versions.js"></script><script src="/assets/set-versions.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript"> docsearch({
  apiKey: 'e47ee877a07ea1c48722f08430d54913',
  indexName: 'scala-sbt',
  inputSelector: '#doc-search-bar',
  debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
        </div>
        
        <div class="highlight-outer">
              <div class="highlight-menu">
                <ul>
                  <li><button id="highlight-button-twitter"><img src="img/twitter-bird-dark-bgs.png"/></button></li>
                </ul>
              </div>
            </div>
      </body>
    </html>