<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>Manual de referencia de sbt — Combined Pages</title>
        <link rel="shortcut icon" href="../favicon.ico"/>
        <link rel="stylesheet" href="../css/bootstrap.min.css" type="text/css"/>
        <link rel="stylesheet" href="../css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="../css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="../css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="../css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="../css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="../css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="../css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="../js/jquery-3.3.1.min.js"></script>
        <script type="text/javascript" src="../js/bootstrap.bundle.min.js"></script>
        <script type="text/javascript" src="../js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'es';
        </script>
        <script type="text/javascript" src="../js/prettify/prettify.js"></script><script type="text/javascript" src="../js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="../css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="../css/custom.css" type="text/css" media="screen, projection"/>
        
        <script type="text/javascript">
              Pamflet.twitter = '#sbt #scala';
            </script>
      </head>
      <body class="color_scheme-github">
        <div class="container-fluid contentswrapper h-100">
          <div class="row minh-100">
          <div class="col-md-4 col-xl-3 leftcolumn">&nbsp;</div><div class="col-md-8 col-xs-9">
                  <div class="rightcolmn contents">
                    <div class="tocwrapper">
        
        <div class="tocbody show" id="toc">
        <h4 class="toctitle">Contents</h4>
        <div><a href="#Manual+de+referencia+de+sbt">Manual de referencia de sbt</a></div><ol class="toc"> <li><div><a href="#Gu%C3%ADa+de+inicio+de+sbt">Guía de inicio de sbt</a></div><ol class="toc"> <li><div><a href="#Instalar+sbt">Instalar sbt</a></div><ol class="toc"> <li><div><a href="#Instalar+sbt+on+macOS">Instalar sbt on macOS</a></div></li><li><div><a href="#Instalar+sbt+en+Windows">Instalar sbt en Windows</a></div></li><li><div><a href="#Installing+sbt+on+Linux">Installing sbt on Linux</a></div></li> </ol></li><li><div><a href="#sbt+mediante+ejemplos">sbt mediante ejemplos</a></div></li><li><div><a href="#Estructura+de+directorios">Estructura de directorios</a></div></li><li><div><a href="#Ejecuci%C3%B3n">Ejecución</a></div></li><li><div><a href="#Definiciones+de+construcci%C3%B3n">Definiciones de construcción</a></div></li><li><div><a href="#Construcciones+multiproyecto">Construcciones multiproyecto</a></div></li><li><div><a href="#Grafos+de+tareas">Grafos de tareas</a></div></li><li><div><a href="#%C3%81mbitos">Ámbitos</a></div></li><li><div><a href="#A%C3%B1adir+valores">Añadir valores</a></div></li><li><div><a href="#Delegaci%C3%B3n+de+%C3%A1mbito+%28resoluci%C3%B3n+de+.value%29">Delegación de ámbito (resolución de .value)</a></div></li><li><div><a href="#Dependencias+de+bibliotecas">Dependencias de bibliotecas</a></div></li><li><div><a href="#Usar+plugins">Usar plugins</a></div></li><li><div><a href="#Entradas+y+tareas+personalizadas">Entradas y tareas personalizadas</a></div></li><li><div><a href="#Organizar+la+construcci%C3%B3n">Organizar la construcción</a></div></li><li><div><a href="#Gu%C3%ADa+de+inicio+-+resumen">Guía de inicio - resumen</a></div></li> </ol></li> </ol></div>
      </div><h1 id="Manual+de+referencia+de+sbt">Manual de referencia de sbt<a href="#Manual+de+referencia+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><h1 id="Gu%C3%ADa+de+inicio+de+sbt">Guía de inicio de sbt<a href="#Gu%C3%ADa+de+inicio+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>sbt utiliza unos cuantos conceptos que dan soporte a flexibles y poderosas
definiciones de construcción (build definitions).
No es que haya muchos conceptos, pero sbt no es exactamente como otros sistemas
de construcción y algunos detalles te <em>confundirán</em> si no has leído la
documentación.
</p><p>La Guía de inicio cubre los conceptos que necesitas conocer para crear y
mantener una definición de construcción de sbt.
</p><p>¡Es <em>altamente recomendable</em> leer la Guía de inicio!
</p><p>Si tienes prisa, los conceptos esenciales más importantes pueden ser encontrados
en <a href="Basic-Def.html">Definiciones de construcción</a>, <a href="Scopes.html">Ámbitos</a>, y
<a href="Task-Graph.html">Grafos de tareas</a>.
Aunque no te aseguramos que saltarte el resto de páginas de la guía sea una
buena idea.
</p><p>Lo mejor es leerlas en orden, ya que las páginas finales de la Guía de inicio se
basan en conceptos explicados antes.
</p><p>Gracias por probar sbt y… ¡<em>divértete</em>!
</p><h2 id="Instalar+sbt">Instalar sbt<a href="#Instalar+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Para crear un proyecto sbt necesitarás realizar los siguientes pasos:
</p><ul><li>Instalar JDK (recomendamos AdoptOpenJDK JDK 8 u AdoptOpenJDK JDK 11).
</li><li>Instalar sbt.
</li><li>Configurar un proyecto <a href="Hello.html">hola mundo</a> simple
</li><li>Continuar con <a href="Running.html">Ejecución</a> para aprender cómo ejecutar sbt.
</li><li>Continuar con <a href="Basic-Def.html">Definición de construcción</a> para aprender más
acerca de definiciones de construcción.
</li></ul><p>En última instancia, la instalación de sbt se reduce a un lanzador JAR y un
script de shell, pero dependiendo de tu plataforma, proporcionamos varias formas
de hacer el proceso menos tedioso. Echa un vistazo a los pasos de instalación para
<a href="Installing-sbt-on-Mac.html">macOS</a>, <a href="Installing-sbt-on-Windows.html">Windows</a>, o <a href="Installing-sbt-on-Linux.html">Linux</a>.
</p><h3 id="Consejos+y+notas">Consejos y notas<a href="#Consejos+y+notas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si has tenido algún problema ejecutando sbt, revisa las
<a href="../docs/Setup-Notes.html">Notas sobre configuración</a> sobre codificaciones en el terminal,
proxies HTTP y opciones de la JVM.
</p><h2 id="Instalar+sbt+on+macOS">Instalar sbt on macOS<a href="#Instalar+sbt+on+macOS" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Instalar+JDK">Instalar JDK<a href="#Instalar+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sigue el link para instalar <a href="https://adoptopenjdk.net/">JDK 8 u 11</a>.
</p><p>Or use <a href="https://sdkman.io/">SDKMAN!</a>:
</p><pre><code class="">$ sdk list java
$ sdk install java 11.0.4.hs-adpt
</code></pre><h3 id="Instalar+desde+un+paquete+universal">Instalar desde un paquete universal<a href="#Instalar+desde+un+paquete+universal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Descarga el paquete <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.zip">ZIP</a> o <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.tgz">TGZ</a> y descomprímelo.
</p><h3 id="Instalar+desde+un+paquete+de+terceros">Instalar desde un paquete de terceros<a href="#Instalar+desde+un+paquete+de+terceros" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><p><strong>Nota:</strong> Puede que algunos paquetes de terceros no proporcionen la última versión.
Por favor, asegúrate de reportar cualquier problema con dichos paquetes a sus 
respectivos mantenedores.
</p></blockquote><h4 id=""><a href="https://brew.sh/">Homebrew</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ brew install sbt
</code></pre><h4 id=""><a href="https://sdkman.io/">SDKMAN!</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ sdk install sbt
</code></pre><h2 id="Instalar+sbt+en+Windows">Instalar sbt en Windows<a href="#Instalar+sbt+en+Windows" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Instalar+JDK">Instalar JDK<a href="#Instalar+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sigue el link para instalar <a href="https://adoptopenjdk.net/">JDK 8 u 11</a>.
</p><h3 id="Instalar+desde+un+paquete+universal">Instalar desde un paquete universal<a href="#Instalar+desde+un+paquete+universal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Descarga el paquete <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.zip">ZIP</a> o <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.tgz">TGZ</a> y descomprímelo.
</p><h3 id="Instalador+Windows">Instalador Windows<a href="#Instalador+Windows" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Descarga el <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.msi">instalador msi</a> e instálalo.
</p><h3 id="Instalar+desde+un+paquete+de+terceros">Instalar desde un paquete de terceros<a href="#Instalar+desde+un+paquete+de+terceros" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><p><strong>Nota:</strong> Puede que algunos paquetes de terceros no proporcionen la última versión.
Por favor, asegúrate de reportar cualquier problema con dichos paquetes a sus
respectivos mantenedores.
</p></blockquote><h4 id=""><a href="https://scoop.sh/">Scoop</a><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="">$ scoop install sbt
</code></pre><h2 id="Installing+sbt+on+Linux">Installing sbt on Linux<a href="#Installing+sbt+on+Linux" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Installing+from+SDKMAN">Installing from SDKMAN<a href="#Installing+from+SDKMAN" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To install both JDK and sbt, consider using <a href="https://sdkman.io/">SDKMAN</a>.
</p><pre><code class="">$ sdk install java $(sdk list java | grep -o &quot;8\.[0-9]*\.[0-9]*\.hs-adpt&quot; | head -1)
$ sdk install sbt
</code></pre><p>This has two advantages.
1. It will install the official packaging by AdoptOpenJDK, as opposed to the <a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2019-May/009330.html">“mystery meat OpenJDK builds“</a>.
2. It will install <code>tgz</code> packaging of sbt that contains all JAR files. (DEB and RPM packages do not to save bandwidth)
</p><h3 id="Instalar+JDK">Instalar JDK<a href="#Instalar+JDK" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Primero desberás de instalar JDK. Recomendamos AdoptOpenJDK JDK 8 u AdoptOpenJDK JDK 11.
</p><p>Los detalles sobre el nombre de los paquetes cambian de una distribución a otra.
Por ejemplo, Ubuntu xenial (16.04LTS) usa
<a href="https://packages.ubuntu.com/hu/xenial/openjdk-8-jdk">openjdk-8-jdk</a>.
La familia Redhat lo llama
<a href="https://apps.fedoraproject.org/packages/java-1.8.0-openjdk-devel">java-1.8.0-openjdk-devel</a>.
</p><h3 id="Instalar+desde+un+paquete+universal">Instalar desde un paquete universal<a href="#Instalar+desde+un+paquete+universal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Descarga el paquete <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.zip">ZIP</a> o <a href="https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.tgz">TGZ</a> y descomprímelo.
</p><h3 id="Ubuntu+y+otras+distribuciones+basadas+en+Debian">Ubuntu y otras distribuciones basadas en Debian<a href="#Ubuntu+y+otras+distribuciones+basadas+en+Debian" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Los paquetes <a href="https://dl.bintray.com/sbt/debian/sbt-1.5.0.deb">DEB</a> son oficialmente soportados por sbt. (sbt 1.4.8 and onwards do not have DEB packaging yet due to Bintray going away)
</p><p>Ubuntu y otras distribuciones basadas en Debian usan el formato DEB, pero por lo
general no necesitas instalar software desde un fichero DEB local.
En su lugar lo que se utiliza son los gestores de paquetes, tanto desde la línea de
comandos (p.e. <code>apt-get</code>, <code>aptitude</code>) o con una interfaz gráfica de usuario
(p.e. Synaptic).
Ejecuta lo siguiente desde el terminal para instalar <code>sbt</code>
(necesitarás tener privilegios de administrador para hacerlo, de ahí el <code>sudo</code>).
</p><pre><code>echo &quot;deb https://dl.bintray.com/sbt/debian /&quot; | sudo tee -a /etc/apt/sources.list.d/sbt.list
curl -sL &quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot; | sudo apt-key add
sudo apt-get update
sudo apt-get install sbt
</code></pre><p>Los gestores de paquetes utilizan los repositorios para buscar los paquetes que
se desean instalar. Los binarios de sbt son publicados en Bintray y
convenientemente Bintray proporciona un repositorio APT.
Sólo tienes que añadir el repositorio en aquellos ficheros utilizados por tu
gestor de paquetes.
</p><p>Una vez <code>sbt</code> haya sido instalado podrás gestionar el paquete en <code>aptitude</code> o
Synaptic después de que hayas actualizado la caché de paquetes. También podrás
ver el repositorio recién añadido al final de la lista en
Preferencias del sistema -&gt; Software y actualizaciones -&gt; Otro software:
</p><p><img src="../files/ubuntu-sources.png" title="Ubuntu Software &amp; Updates Screenshot" alt="Ubuntu Software &amp; Updates Screenshot"/>
</p><p><strong>Nota</strong>: Se han reportado errores de SSL en Ubuntu: <code>Server access Error:
java.lang.RuntimeException: Unexpected error:
java.security.InvalidAlgorithmParameterException: the trustAnchors parameter
must be non-empty url=https://repo1.maven.org/maven2/org/scala-sbt/sbt/1.1.0/sbt-1.1.0.pom</code>,
los cuales aparentemente impiden a OpenJDK 9 utilizar el formato PKCS12 para
<code>/etc/ssl/certs/java/cacerts</code> <a href="https://bugs.launchpad.net/ubuntu/+source/ca-certificates-java/+bug/1739631">cert-bug</a>.
Según <a href="https://stackoverflow.com/a/50103533/3827">https://stackoverflow.com/a/50103533/3827</a> esto ha sido arreglado en
Ubuntu Cosmic (18.10) aunque Ubuntu Bionic LTS (18.04) aún sigue esperando una
release. Mira las respuesta para encontrar soluciones.
</p><h3 id="Red+Hat+Enterprise+Linux+y+otras+distribuciones+basadas+en+RPM">Red Hat Enterprise Linux y otras distribuciones basadas en RPM<a href="#Red+Hat+Enterprise+Linux+y+otras+distribuciones+basadas+en+RPM" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Los paquetes <a href="https://dl.bintray.com/sbt/rpm/sbt-1.5.0.rpm">RPM</a> son oficialmente soportados por sbt. (sbt 1.4.8 and onwards do not have DEB packaging yet due to Bintray going away)
</p><p>Red Hat Enterprise Linux y otras distribuciones basadas en RPM utilizan el
formato RPM. Ejecuta lo siguiente desde el terminal para instalar <code>sbt</code>
(necesitarás tener privilegios de administrador para hacerlo, de ahí el <code>sudo</code>).
</p><pre><code>curl https://bintray.com/sbt/rpm/rpm | sudo tee /etc/yum.repos.d/bintray-sbt-rpm.repo
sudo yum install sbt
</code></pre><p>Los binarios de sbt son publicados en Bintray y convenientemente Bintray
proporciona un repositorio RPM. Sólo tienes que añadir el repositorio en
aquellos ficheros utilizados por tu gestor de paquetes.
</p><p>En Fedora, <code>sbt 0.13.1</code> está <a href="https://fedora.pkgs.org/28/fedora-i386/sbt-0.13.1-9.fc28.1.noarch.rpm.html">disponible desde repos oficiales</a>.
Si quieres instalar <code>sbt 1.1.6</code> o superior tendrás que desinstalar <code>sbt 0.13</code>
(si es que está instaladoo) e indicar que quieres instalar las nuevas versiones
de <code>sbt</code> (p.e. <code>sbt 1.1.6</code> o superior) utilizando <code>bintray-sbt-rpm.repo</code>.
</p><pre><code>sudo dnf remove sbt # desinstalar sbt si sbt 0.13 estaba instalado (puede que no sea necesario)
sudo dnf --enablerepo=bintray--sbt-rpm install sbt
</code></pre><blockquote><p><strong>Nota:</strong> Por favor, reporta cualquier problema con estos paquetes al proyecto
<a href="https://github.com/sbt/sbt">sbt</a>
</p></blockquote><h3 id="Gentoo">Gentoo<a href="#Gentoo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>El árbol oficial contiene ebuilds para sbt. Para instalar la última versión
disponible escribe:
</p><pre><code>emerge dev-java/sbt
</code></pre><h2 id="sbt+mediante+ejemplos">sbt mediante ejemplos<a href="#sbt+mediante+ejemplos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página supone que has <a href="Setup.html">instalado sbt 1</a>.
</p><p>Empecemos mostrando algunos ejemplos en lugar de explicar cómo
o por qué sbt funciona.
</p><h3 id="Crear+una+construcci%C3%B3n+sbt+m%C3%ADnima">Crear una construcción sbt mínima<a href="#Crear+una+construcci%C3%B3n+sbt+m%C3%ADnima" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">$ mkdir foo-build
$ cd foo-build
$ touch build.sbt
</code></pre><h3 id="Iniciar+el+shell+de+sbt">Iniciar el shell de sbt<a href="#Iniciar+el+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">$ sbt
[info] Updated file /tmp/foo-build/project/build.properties: set sbt.version to 1.1.4
[info] Loading project definition from /tmp/foo-build/project
[info] Loading settings from build.sbt ...
[info] Set current project to foo-build (in build file:/tmp/foo-build/)
[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/abc4fb6c89985a00fd95/sock
sbt:foo-build&gt;
</code></pre><h3 id="Salir+del+shell+de+sbt">Salir del shell de sbt<a href="#Salir+del+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para salir del shell de sbt, escribe <code>exit</code> o pulsa Ctrl+D (Unix)
o Ctrl+Z (Windows).
</p><pre><code class="">sbt:foo-build&gt; exit
</code></pre><h3 id="Compilar+un+proyecto">Compilar un proyecto<a href="#Compilar+un+proyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Como convención, usaremos el prompt <code>sbt:...&gt;</code> o <code>&gt;</code> para indicar
que estamos en un shell de sbt interactivo.
</p><pre><code class="">$ sbt
sbt:foo-build&gt; compile
</code></pre><h3 id="Recompilar+cuando+el+c%C3%B3digo+cambie">Recompilar cuando el código cambie<a href="#Recompilar+cuando+el+c%C3%B3digo+cambie" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si prefijas el comando <code>compile</code> (o cualquier otro comando) con <code>~</code> harás que
dicho comando sea re-ejecutado automáticamente en cuanto uno de los ficheros
fuente dentro del proyecto sea modificado. Por ejemplo:
</p><pre><code class="">sbt:foo-build&gt; ~compile
[success] Total time: 0 s, completed May 6, 2018 3:52:08 PM
1. Waiting for source changes... (press enter to interrupt)
</code></pre><h3 id="Crear+un+fichero+fuente">Crear un fichero fuente<a href="#Crear+un+fichero+fuente" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Deja el comando anterior ejecutándose.
Desde un shell diferente (o desde tu gestor de ficheros) crea la siguiente
estructura de directorios <code>src/main/scala/example</code> en el directorio del
proyecto. Después, crea el fichero <code>Hello.scala</code> en el directorio <code>example</code>
utilizando tu editor de texto favorito con este contenido:
</p><pre><code class="prettyprint lang-scala">package example

object Hello extends App {
  println(&quot;Hello&quot;)
}
</code></pre><p>Este nuevo fichero debería de ser detectado por el comando en ejecución:
</p><pre><code class="">[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/classes ...
[info] Done compiling.
[success] Total time: 2 s, completed May 6, 2018 3:53:42 PM
2. Waiting for source changes... (press enter to interrupt)
</code></pre><p>Pulsa <code>Intro</code> para salir de <code>~compile</code>.
</p><h3 id="Ejecutar+un+comando+previo">Ejecutar un comando previo<a href="#Ejecutar+un+comando+previo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Desde el shell de sbt, pulsa la tecla arriba dos veces para encontrar el comando
<code>compile</code> que habías ejecutado al principio.
</p><pre><code class="">sbt:foo-build&gt; compile
</code></pre><h3 id="Obtener+ayuda">Obtener ayuda<a href="#Obtener+ayuda" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Usa el comando <code>help</code> para obtener ayuda básica sobre los comandos disponibles.
</p><pre><code class="">sbt:foo-build&gt; help

  about      Displays basic information about sbt and the build.
  tasks      Lists the tasks defined for the current project.
  settings   Lists the settings defined for the current project.
  reload     (Re)loads the current project or changes to plugins project or returns from it.
  new        Creates a new sbt build.
  projects   Lists the names of available projects or temporarily adds/removes extra builds to the session.
  project    Displays the current project or changes to the provided `project`.

....
</code></pre><h3 id="Mostrar+la+descripci%C3%B3n+de+una+tarea+espec%C3%ADfica">Mostrar la descripción de una tarea específica<a href="#Mostrar+la+descripci%C3%B3n+de+una+tarea+espec%C3%ADfica" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; help run
Runs a main class, passing along arguments provided on the command line.
</code></pre><h3 id="Ejecutar+tu+aplicaci%C3%B3n">Ejecutar tu aplicación<a href="#Ejecutar+tu+aplicaci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; run
[info] Packaging /tmp/foo-build/target/scala-2.12/foo-build_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Running example.Hello
Hello
[success] Total time: 1 s, completed May 6, 2018 4:10:44 PM
</code></pre><h3 id="Establecer++desde+el+shell+de+sbt">Establecer <code>ThisBuild / scalaVersion</code> desde el shell de sbt<a href="#Establecer++desde+el+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; set ThisBuild / scalaVersion := &quot;2.12.7&quot;
[info] Defining ThisBuild / scalaVersion
</code></pre><h3 id="Comprobar+la+entrada+%3A">Comprobar la entrada <code>scalaVersion</code>:<a href="#Comprobar+la+entrada+%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:foo-build&gt; scalaVersion
[info] 2.12.7
</code></pre><h3 id="Guardar+la+sesi%C3%B3n+actual+en+build.sbt">Guardar la sesión actual en build.sbt<a href="#Guardar+la+sesi%C3%B3n+actual+en+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Podemos guardar la configuración temporal utilizando <code>session save</code>.
</p><pre><code class="">sbt:foo-build&gt; session save
[info] Reapplying settings...
</code></pre><p>El fichero <code>build.sbt</code> ahora debería de contener:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
</code></pre><h3 id="Dar+un+nombre+a+tu+proyecto">Dar un nombre a tu proyecto<a href="#Dar+un+nombre+a+tu+proyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando un editor, modifica <code>build.sbt</code> con el siguiente contenido:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;
  )
</code></pre><h3 id="Recargar+la+construcci%C3%B3n">Recargar la construcción<a href="#Recargar+la+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Usa el comando <code>reload</code> para recargar la construcción.
El comando hace que el fichero <code>build.sbt</code> sea releído y su configuración
aplicada.
</p><pre><code class="">sbt:foo-build&gt; reload
[info] Loading project definition from /tmp/foo-build/project
[info] Loading settings from build.sbt ...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
sbt:Hello&gt;
</code></pre><p>Fíjate en cómo el prompt ha cambiado a <code>sbt:Hello&gt;</code>.
</p><h3 id="A%C3%B1adir+ScalaTest+a">Añadir ScalaTest a <code>libraryDependencies</code><a href="#A%C3%B1adir+ScalaTest+a" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando un editor, modifica <code>build.sbt</code> de la siguiente manera:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )
</code></pre><p>Usa el comando <code>reload</code> para reflejar los cambios de <code>build.sbt</code>.
</p><pre><code class="">sbt:Hello&gt; reload
</code></pre><h3 id="Lanzar+tests">Lanzar tests<a href="#Lanzar+tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; test
</code></pre><h3 id="Lanzar+tests+incrementales+continuamente">Lanzar tests incrementales continuamente<a href="#Lanzar+tests+incrementales+continuamente" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; ~testQuick
</code></pre><h3 id="Escribir+un+test">Escribir un test<a href="#Escribir+un+test" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Con el comando anterior ejecutándose, crea un fichero llamado
<code>src/test/scala/HelloSpec.scala</code> utilizando un editor:
</p><pre><code class="prettyprint lang-scala">import org.scalatest._

class HelloSpec extends FunSuite with DiagrammedAssertions {
  test(&quot;Hello should start with H&quot;) {
    assert(&quot;hello&quot;.startsWith(&quot;H&quot;))
  }
}
</code></pre><p><code>~testQuick</code> debería de coger el cambio:
</p><pre><code class="">2. Waiting for source changes... (press enter to interrupt)
[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/test-classes ...
[info] Done compiling.
[info] HelloSpec:
[info] - Hello should start with H *** FAILED ***
[info]   assert(&quot;hello&quot;.startsWith(&quot;H&quot;))
[info]          |       |          |
[info]          &quot;hello&quot; false      &quot;H&quot; (HelloSpec.scala:5)
[info] Run completed in 135 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0
[info] *** 1 TEST FAILED ***
[error] Failed tests:
[error]   HelloSpec
[error] (Test / testQuick) sbt.TestsFailedException: Tests unsuccessful
</code></pre><h3 id="Hacer+que+el+test+pase">Hacer que el test pase<a href="#Hacer+que+el+test+pase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando un editor, cambia <code>src/test/scala/HelloSpec.scala</code> a:
</p><pre><code class="prettyprint lang-scala">import org.scalatest._

class HelloSpec extends FunSuite with DiagrammedAssertions {
  test(&quot;Hello should start with H&quot;) {
    // Hello, as opposed to hello
    assert(&quot;Hello&quot;.startsWith(&quot;H&quot;))
  }
}
</code></pre><p>Confirma que el test pasa, luego pulsa <code>Intro</code> para salir del test continuo.
</p><h3 id="A%C3%B1adir+una+dependencia+de+biblioteca">Añadir una dependencia de biblioteca<a href="#A%C3%B1adir+una+dependencia+de+biblioteca" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando un editor, modifica <code>build.sbt</code> de esta forma:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )
</code></pre><p>Usa el comando <code>reload</code> para reflejar los cambios de <code>build.sbt</code>.
</p><h3 id="Usar+el+REPL+de+Scala">Usar el REPL de Scala<a href="#Usar+el+REPL+de+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Podemos averiguar qué tiempo hace actualmente en Nueva York.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; console
[info] Starting scala interpreter...
Welcome to Scala 2.12.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).
Type in expressions for evaluation. Or try :help.

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

import scala.concurrent._, duration._
import gigahorse._, support.okhttp.Gigahorse
import play.api.libs.json._

Gigahorse.withHttp(Gigahorse.config) { http =&gt;
  val baseUrl = &quot;https://www.metaweather.com/api/location&quot;
  val rLoc = Gigahorse.url(baseUrl + &quot;/search/&quot;).get.
    addQueryString(&quot;query&quot; -&gt; &quot;New York&quot;)
  val fLoc = http.run(rLoc, Gigahorse.asString)
  val loc = Await.result(fLoc, 10.seconds)
  val woeid = (Json.parse(loc) \ 0 \ &quot;woeid&quot;).get
  val rWeather = Gigahorse.url(baseUrl + s&quot;/$woeid/&quot;).get
  val fWeather = http.run(rWeather, Gigahorse.asString)
  val weather = Await.result(fWeather, 10.seconds)
  ({Json.parse(_: String)} andThen Json.prettyPrint)(weather)
}

// press Ctrl+D

// Exiting paste mode, now interpreting.

import scala.concurrent._
import duration._
import gigahorse._
import support.okhttp.Gigahorse
import play.api.libs.json._
res0: String =
{
  &quot;consolidated_weather&quot; : [ {
    &quot;id&quot; : 6446939314847744,
    &quot;weather_state_name&quot; : &quot;Light Rain&quot;,
    &quot;weather_state_abbr&quot; : &quot;lr&quot;,
    &quot;wind_direction_compass&quot; : &quot;WNW&quot;,
    &quot;created&quot; : &quot;2019-02-21T04:39:47.747805Z&quot;,
    &quot;applicable_date&quot; : &quot;2019-02-21&quot;,
    &quot;min_temp&quot; : 0.48000000000000004,
    &quot;max_temp&quot; : 7.84,
    &quot;the_temp&quot; : 2.1700000000000004,
    &quot;wind_speed&quot; : 5.996333145703094,
    &quot;wind_direction&quot; : 293.12257757287307,
    &quot;air_pressure&quot; : 1033.115,
    &quot;humidity&quot; : 77,
    &quot;visibility&quot; : 14.890539250775472,
    &quot;predictability&quot; : 75
  }, {
    &quot;id&quot; : 5806299509948416,
    &quot;weather_state_name&quot; : &quot;Heavy Cloud&quot;,
...

scala&gt; :q // para salir
</code></pre><h3 id="Crear+un+subproyecto">Crear un subproyecto<a href="#Crear+un+subproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cambia <code>build.sbt</code> como sigue:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot; % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
  )
</code></pre><p>Usa el comando <code>reload</code> para reflejar los cambios de <code>build.sbt</code>.
</p><h3 id="Listar+todos+los+subproyectos">Listar todos los subproyectos<a href="#Listar+todos+los+subproyectos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; projects
[info] In file:/tmp/foo-build/
[info]   * hello
[info]     helloCore
</code></pre><h3 id="Compilar+el+subproyecto">Compilar el subproyecto<a href="#Compilar+el+subproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; helloCore/compile
</code></pre><h3 id="A%C3%B1adir+ScalaTest+al+subproyecto">Añadir ScalaTest al subproyecto<a href="#A%C3%B1adir+ScalaTest+al+subproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cambia <code>build.sbt</code> como sigue:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Difundir+comandos">Difundir comandos<a href="#Difundir+comandos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Añade aggregate para que el comando enviado a <code>hello</code> sea difundido también a <code>helloCore</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><p>Tras un <code>reload</code>, <code>~testQuick</code> se ejecuta ahora en ambos subproyectos:
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; ~testQuick
</code></pre><p>Pulsa <code>Intro</code> para salir del test continuo.
</p><h3 id="Hacer+que+hello+dependa+de+helloCore">Hacer que hello dependa de helloCore<a href="#Hacer+que+hello+dependa+de+helloCore" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Usa <code>.dependsOn(...)</code> para añadir dependencias sobre otros subproyectos.
Además, movamos la dependencia de Gigahorse a <code>helloCore</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies += &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;,
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Parsear+JSON+con+Play+JSON">Parsear JSON con Play JSON<a href="#Parsear+JSON+con+Play+JSON" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Vamos a añadir Play JSON a <code>helloCore</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><p>Tras un <code>reload</code>, añade <code>core/src/main/scala/example/core/Weather.scala</code>:
</p><pre><code class="prettyprint lang-scala">package example.core

import gigahorse._, support.okhttp.Gigahorse
import scala.concurrent._, duration._
import play.api.libs.json._

object Weather {
  lazy val http = Gigahorse.http(Gigahorse.config)

  def weather: Future[String] = {
    val baseUrl = &quot;https://www.metaweather.com/api/location&quot;
    val locUrl = baseUrl + &quot;/search/&quot;
    val weatherUrl = baseUrl + &quot;/%s/&quot;
    val rLoc = Gigahorse.url(locUrl).get.
      addQueryString(&quot;query&quot; -&gt; &quot;New York&quot;)
    import ExecutionContext.Implicits.global
    for {
      loc &lt;- http.run(rLoc, parse)
      woeid = (loc \ 0  \ &quot;woeid&quot;).get
      rWeather = Gigahorse.url(weatherUrl format woeid).get
      weather &lt;- http.run(rWeather, parse)
    } yield (weather \\ &quot;weather_state_name&quot;)(0).as[String].toLowerCase
  }

  private def parse = Gigahorse.asString andThen Json.parse
}
</code></pre><p>Ahora, cambia <code>src/main/scala/example/Hello.scala</code> como sigue:
</p><pre><code class="prettyprint lang-scala">package example

import scala.concurrent._, duration._
import core.Weather

object Hello extends App {
  val w = Await.result(Weather.weather, 10.seconds)
  println(s&quot;Hello! The weather in New York is $w.&quot;)
  Weather.http.close()
}
</code></pre><p>Vamos a ejecutar la aplicación para ver si funciona:
</p><pre><code class="">sbt:Hello&gt; run
[info] Compiling 1 Scala source to /tmp/foo-build/core/target/scala-2.12/classes ...
[info] Done compiling.
[info] Compiling 1 Scala source to /tmp/foo-build/target/scala-2.12/classes ...
[info] Packaging /tmp/foo-build/core/target/scala-2.12/hello-core_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Done compiling.
[info] Packaging /tmp/foo-build/target/scala-2.12/hello_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Running example.Hello
Hello! The weather in New York is mostly cloudy.
</code></pre><h3 id="A%C3%B1adir+el+plugin+sbt-native-packager">Añadir el plugin sbt-native-packager<a href="#A%C3%B1adir+el+plugin+sbt-native-packager" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando un editor, crea <code>project/plugins.sbt</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-native-packager&quot; % &quot;1.3.4&quot;)
</code></pre><p>Después cambia <code>build.sbt</code> como sigue para añadir <code>JavaAppPackaging</code>:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .enablePlugins(JavaAppPackaging)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Recargar+y+crear+una+distribuci%C3%B3n+.zip">Recargar y crear una distribución .zip<a href="#Recargar+y+crear+una+distribuci%C3%B3n+.zip" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; reload
...
sbt:Hello&gt; dist
[info] Wrote /tmp/foo-build/target/scala-2.12/hello_2.12-0.1.0-SNAPSHOT.pom
[info] Wrote /tmp/foo-build/core/target/scala-2.12/hello-core_2.12-0.1.0-SNAPSHOT.pom
[info] Your package is ready in /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
</code></pre><p>Así es cómo puedes ejecutar la app una vez empaquetada:
</p><pre><code class="">$ /tmp/someother
$ cd /tmp/someother
$ unzip -o -d /tmp/someother /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
$ ./hello-0.1.0-SNAPSHOT/bin/hello
Hello! The weather in New York is mostly cloudy.
</code></pre><h3 id="Dockerizar+tu+app">Dockerizar tu app<a href="#Dockerizar+tu+app" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; Docker/publishLocal
....
[info] Successfully built b6ce1b6ab2c0
[info] Successfully tagged hello:0.1.0-SNAPSHOT
[info] Built image hello:0.1.0-SNAPSHOT
</code></pre><p>Así es cómo puedes ejecutar la app Dockerizada:
</p><pre><code class="">$ docker run hello:0.1.0-SNAPSHOT
Hello! The weather in New York is mostly cloudy
</code></pre><h3 id="Establecer+la+versi%C3%B3n">Establecer la versión<a href="#Establecer+la+versi%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cambia <code>build.sbt</code> como sigue:
</p><pre><code class="prettyprint lang-scala">ThisBuild / version      := &quot;0.1.0&quot;
ThisBuild / scalaVersion := &quot;2.12.7&quot;
ThisBuild / organization := &quot;com.example&quot;

val scalaTest = &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.5&quot;
val gigahorse = &quot;com.eed3si9n&quot; %% &quot;gigahorse-okhttp&quot; % &quot;0.3.1&quot;
val playJson  = &quot;com.typesafe.play&quot; %% &quot;play-json&quot; % &quot;2.6.9&quot;

lazy val hello = (project in file(&quot;.&quot;))
  .aggregate(helloCore)
  .dependsOn(helloCore)
  .enablePlugins(JavaAppPackaging)
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += scalaTest % Test,
  )

lazy val helloCore = (project in file(&quot;core&quot;))
  .settings(
    name := &quot;Hello Core&quot;,
    libraryDependencies ++= Seq(gigahorse, playJson),
    libraryDependencies += scalaTest % Test,
  )
</code></pre><h3 id="Cambiar++temporalmente">Cambiar <code>scalaVersion</code> temporalmente<a href="#Cambiar++temporalmente" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">sbt:Hello&gt; ++2.11.12!
[info] Forcing Scala version to 2.11.12 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/tmp/foo-build/)
</code></pre><p>Comprueba la entrada <code>scalaVersion</code>:
</p><pre><code class="">sbt:Hello&gt; scalaVersion
[info] helloCore / scalaVersion
[info]  2.11.12
[info] scalaVersion
[info]  2.11.12 scalaVersion
[info] 2.12.7
</code></pre><p>Esta entrada se esfumará tras un <code>reload</code>.
</p><h3 id="Inspeccionar+la+tarea">Inspeccionar la tarea <code>dist</code><a href="#Inspeccionar+la+tarea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para saber más acerca de <code>dist</code>, prueba <code>help</code> e <code>inspect</code>.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; help dist
Creates the distribution packages.
sbt:Hello&gt; inspect dist
</code></pre><p>Para llamar a <code>inspect</code> recursivamente en las tareas dependientes utiliza <code>inspect tree</code>.
</p><pre><code class="prettyprint lang-scala">sbt:Hello&gt; inspect tree dist
[info] dist = Task[java.io.File]
[info]   +-Universal / dist = Task[java.io.File]
....
</code></pre><h3 id="Modo+por+lotes">Modo por lotes<a href="#Modo+por+lotes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>También puedes ejecutar sbt en por lotes, pasando comandos de sbt directamente
desde el terminal.
</p><pre><code class="">$ sbt clean &quot;testOnly HelloSpec&quot;
</code></pre><p><strong>Note</strong>: El modo por lotes implica levantar una JVM y JIT cada vez, por lo que
<strong>la construcción será mucho más lenta</strong>.
Para el desarrollo del día a día recomendamos utilizar el shell de sbt
o tests continuos como <code>~testQuick</code>.
</p><h3 id="El+comando">El comando <code>new</code><a href="#El+comando" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Puedes utilizar el comando <code>new</code> para generar rápidamente una construcción
para un simple “Hola mundo”.
</p><pre><code class="">$ sbt new sbt/scala-seed.g8
....
A minimal Scala project.

name [My Something Project]: hello

Template applied in ./hello
</code></pre><p>Cuando se te pregunte por el nombre del proyecto escribe <code>hello</code>.
</p><p>Esto creará un nuevo proyecto en un directorio llamado <code>hello</code>.
</p><h3 id="Cr%C3%A9ditos">Créditos<a href="#Cr%C3%A9ditos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Esta página está basada en el tutorial <a href="https://www.scalawilliam.com/essential-sbt/">Essential sbt</a>
escrito por William “Scala William” Narmontas.
</p><h2 id="Estructura+de+directorios">Estructura de directorios<a href="#Estructura+de+directorios" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página supone que has <a href="Setup.html">instalado sbt</a> y leído
<a href="sbt-by-example.html">sbt mediante ejemplos</a>.
</p><h3 id="Directorio+base">Directorio base<a href="#Directorio+base" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En la terminología de sbt, el “directorio base” es el directorio que contiene
el proyecto. Así pues, si has creado un proyecto <code>hello</code> que contiene
<code>/tmp/foo-build/build.sbt</code> tal y como se muestra en <a href="sbt-by-example.html">sbt mediante ejemplos</a>,
el directorio base será <code>/tmp/foo-build</code>.
</p><h3 id="C%C3%B3digo+fuente.">Código fuente.<a href="#C%C3%B3digo+fuente." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt emplea de forma predeterminada la misma estructura de directorios utilizado
por <a href="https://maven.apache.org/">Maven</a> para ficheros fuente
(todas las rutas son relativas al directorio base):
</p><pre><code class="">src/
  main/
    resources/
       &lt;ficheros del jar principal aquí&gt;
    scala/
       &lt;fuentes principales de Scala&gt;
    scala-2.12/
       &lt;main Scala 2.12 specific sources&gt;
    java/
       &lt;fuentes principales de Java&gt;
  test/
    resources
       &lt;ficheros del jar de test aquí&gt;
    scala/
       &lt;fuentes de test de Scala&gt;
    scala-2.12/
       &lt;test Scala 2.12 specific sources&gt;
    java/
       &lt;fuentes de test de Java&gt;
</code></pre><p>Cualquier otro directorio en <code>src/</code> es ignorado.
También son ignorados todos los directorios ocultos.
</p><p>El código fuente puede estar situado en el directorio base del proyecto como
<code>hello/app.scala</code>, lo cual puede estar bien para proyectos pequeños,
aunque para proyectos normales la gente suele estructurar los proyectos en el
directorio <code>src/main/</code> para tener las cosas ordenadas.
</p><p>El hecho de que se permita código fuente del tipo <code>*.scala</code> en el directorio
base puede parecer algo raro, pero veremos que este hecho es relevante
<a href="Organizing-Build.html">más adelante</a>.
</p><h3 id="Ficheros+de+definici%C3%B3n+de+construcci%C3%B3n">Ficheros de definición de construcción<a href="#Ficheros+de+definici%C3%B3n+de+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>La definición de construcción es descrita en <code>build.sbt</code>
(en realidad cualquier fichero llamado <code>*.sbt</code>)
en el directorio base del proyecto.
</p><pre><code class="">build.sbt
</code></pre><h3 id="Ficheros+auxiliares">Ficheros auxiliares<a href="#Ficheros+auxiliares" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Además de <code>build.sbt</code>, el directorio <code>project</code> puede contener ficheros <code>.scala</code>
que definen objetos auxiliares y plugins puntuales.
</p><p>Para más información mira <a href="Organizing-Build.html">Organizar la construcción</a>.
</p><pre><code class="">build.sbt
project/
  Dependencies.scala
</code></pre><p>Puede que veas ficheros <code>.sbt</code> dentro de <code>project/</code>
pero no son equivalentes a los ficheros <code>.sbt</code> del directorio base del proyecto.
La explicación a esto vendrá <a href="Organizing-Build.html">más adelante</a>,
ya que primero necesitarás conocer algunos conceptos.
</p><h3 id="Construir+productos">Construir productos<a href="#Construir+productos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Los ficheros generados (clases compiladas, jars empaquetados,
ficheros gestionados, caches y documentación) son escritos en el directorio
<code>target</code> de forma predeterminada.
</p><h3 id="Configurar+el+control+de+versiones">Configurar el control de versiones<a href="#Configurar+el+control+de+versiones" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Tu <code>.gitignore</code> (o el equivalente para otros sistemas de control de versiones)
debería de contener:
</p><pre><code class="">target/
</code></pre><p>Fíjate en que deliberadamente acaba con <code>/</code>
(para coincidir sólo con directorios) y que deliberadamente no empieza con <code>/</code>
(para coincidir con <code>project/target/</code> además del <code>target/</code> en la raíz).
</p><h2 id="Ejecuci%C3%B3n">Ejecución<a href="#Ejecuci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página describe cómo usar sbt una vez has configurado tu proyecto.
Se supone que has <a href="Setup.html">instalado sbt</a> y leído <a href="sbt-by-example.html">sbt mediante ejemplos</a>.
</p><h3 id="El+shell+de+sbt">El shell de sbt<a href="#El+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Lanza sbt en el directorio de tu proyecto sin argumentos:
</p><pre><code class="">$ sbt
</code></pre><p>Ejecutar sbt sin argumentos hace que se inicie un shell de sbt.
El shell de sbt tiene un prompt de comandos (¡con autocompletado e historial!).
</p><p>Por ejemplo, podrías escribir <code>compile</code> en el shell:
</p><pre><code class="">&gt; compile
</code></pre><p>Para lanzar <code>compile</code> de nuevo pulsa la tecla arriba y pulsa <code>Intro</code>.
</p><p>Para ejecutar tu programa, escribe <code>run</code>.
</p><p>Para salir del shell escribe <code>exit</code> o usa Ctrl+D (Unix) o Ctrl+Z (Windows).
</p><h3 id="Modo+por+lotes">Modo por lotes<a href="#Modo+por+lotes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Puedes tambien ejecutar sbt en modo por lotes, proporcionando una lista de
comandos sbt separados por espacio como argumentos. Aquellos comandos de sbt que
necesiten argumentos pueden ser pasados como un único argumento entrecomillado,
por ejemplo:
</p><pre><code class="">$ sbt clean compile &quot;testOnly TestA TestB&quot;
</code></pre><p>En este ejemplo, <code>testOnly</code> tiene como argumentos <code>TestA</code> y <code>TestB</code>.
Los comandos son ejecutados secuencialmente: (<code>clean</code>, <code>compile</code> y luego
<code>testOnly</code>).
</p><p><strong>Note</strong>: El modo por lotes implica levantar una JVM y JIT cada vez, por lo que
<strong>la construcción será mucho más lenta</strong>.
Para el desarrollo del día a día recomendamos utilizar el shell de sbt o
construir y testear continuamente tal y como se explica más abajo.
</p><p>A partir de sbt 0.13.16, se lanza un mensaje informativo cuando sbt se utiliza
en el modo por lotes.
</p><pre><code class="">$ sbt clean compile
[info] Executing in batch mode. For better performance use sbt's shell
...
</code></pre><p>Sólo será mostrado con <code>sbt compile</code>.
Puede ser desactivado con <code>suppressSbtShellNotification := true</code>.
</p><h3 id="Construir+y+testear+continuamente">Construir y testear continuamente<a href="#Construir+y+testear+continuamente" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para acelerar el ciclo editar-compilar-testear puedes indicarle a sbt que
recompile automáticamente o lance tests cada vez que guardes un fichero fuente.
</p><p>Haz que un comando se ejecute cuando uno o más ficheros fuente cambien
prefijando dicho comando con <code>~</code>. Por ejemplo, prueba en el shell de sbt:
</p><pre><code class="">&gt; ~testQuick
</code></pre><p>Pulsa <code>Intro</code> para dejar de observar los cambios.
</p><p>Puedes utilizar el prefijo <code>~</code> tanto en el shell de sbt como en modo por lotes.
</p><p><!-- TODO: Triggered -> disparada?? -->
Para más información mira <a href="../docs/Triggered-Execution.html">Ejecución disparada</a>.
</p><h3 id="Comandos+comunes">Comandos comunes<a href="#Comandos+comunes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A continuación presentamos una lista con algunos de los comandos más comunes de sbt.
Para una lista más completa mira
<a href="../docs/Command-Line-Reference.html">Referencia de línea de comandos</a>.
</p><table class="table table-striped">
  <tr>
    <td><tt>clean</tt></td>
    <td>Borra todos los ficheros generados (en el directorio <tt>target</tt>).</td>
  </tr>
  <tr>
    <td><tt>compile</tt></td>
    <td>Compila los ficheros fuente principales (en los directorios <tt>src/main/scala</tt> y
   <tt>src/main/java</tt>).</td>
  </tr>
  <tr>
    <td><tt>test</tt></td>
    <td>Compila y ejecuta todos los tests.</td>
  </tr>
  <tr>
    <td><tt>console</tt></td>
    <td>Inicia el intérprete de Scala con un classpath que incluye los ficheros fuente
    compilados y todas sus dependencias. Para volver a sbt, escribe <tt>:quit</tt> o pulsa
   Ctrl+D (Unix) o Ctrl+Z (Windows).</td>
  </tr>
  <tr>
    <td><nobr><tt>run &lt;argument&gt;*</tt></nobr></td>
    <td>Ejecuta la clase principal del proyecto en la misma máquina virtual que sbt</td>
  </tr>
  <tr>
    <td><tt>package</tt></td>
    <td>Crea un fichero jar conteniendo los ficheros de
    <tt>src/main/resources</tt> y las clases compiladas de <tt>src/main/scala</tt> y
    <tt>src/main/java</tt>.</td>
  </tr>
  <tr>
    <td><tt>help &lt;comando&gt;</tt></td>
    <td>Muestra ayuda detallada para el comando especificado.
    Si no se proporciona ningún comando entonces mostrará una breve descripción de cada comando.</td>
  </tr>
  <tr>
    <td><tt>reload</tt></td>
    <td>Recarga la definición de construcción (los ficheros <tt>build.sbt</tt>, <tt>project/*.scala</tt>,
    <tt>project/*.sbt</tt>). Necesario si cambias la definición de construcción.</td>
  </tr>
</table><h3 id="Autocompletado">Autocompletado<a href="#Autocompletado" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>El shell de sbt tiene autocompletado, incluso con un prompt vacío.
Una convención especial de sbt es que si se presiona tab una vez se se mostrarán
las opciones más probables mientras que si se pulsa más veces se mostrarán aún más
opciones.
</p><h3 id="Comandos+hist%C3%B3ricos">Comandos históricos<a href="#Comandos+hist%C3%B3ricos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>El shell de sbt recuerda el histórico de comandos, incluso si sales de sbt y lo
reinicias. La forma más sencilla de acceder al histórico es con la tecla arriba.
Los siguientes comandos están soportados:
</p><table class="table table-striped">
  <tr>
    <td><tt>!</tt></td>
    <td>Muestra la ayuda para comandos históricos.</td>
  </tr>
  <tr>
    <td><tt>!!</tt></td>
    <td>Ejecuta el comando previo otra vez.</td>
  </tr>
  <tr>
    <td><tt>!:</tt></td>
    <td>Muestra todos los comandos escritos hasta el momento.</td>
  </tr>
  <tr>
    <td><tt>!:n</tt></td>
    <td>Muestra los últimos <tt>n</tt> comandos.</td>
  </tr>
  <tr>
    <td><tt>!n</tt></td>
    <td>Ejecuta el comando con índice <tt>n</tt>, como se muestra en el comando <tt>!:</tt>.</td>
  </tr>
  <tr>
    <td><tt>!-n</tt></td>
    <td>Ejecuta el n-ésimo comando anterior a este.</td>
  </tr>
  <tr>
    <td><tt>!string</tt></td>
    <td>Ejecuta el comando más reciente que empiece con 'string.'</td>
  </tr>
  <tr>
    <td><tt>!?string</tt></td>
    <td>Ejecuta el comando más reciente que contenga 'string.'</td>
  </tr>
</table><h2 id="Definiciones+de+construcci%C3%B3n">Definiciones de construcción<a href="#Definiciones+de+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página describe las definiciones de construcción (build definitions), 
incluyendo algo de “teoría” y la sintaxis de <code>build.sbt</code>. Se supone que has 
instalado una versión reciente de sbt, como sbt 1.5.0, que sabes cómo 
<a href="Running.html">usar sbt</a> y que has leído las páginas anteriores de la Guía de inicio.
</p><p>Esta página explica la definición de construcción de <code>build.sbt</code>.
</p><h3 id="Especificar+la+versi%C3%B3n+de+sbt">Especificar la versión de sbt<a href="#Especificar+la+versi%C3%B3n+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Como parte de tu definición de construcción debes de especificar la versión de 
sbt que tu construcción utiliza.
</p><p>Esto permitirá a la gente con diferentes versiones del lanzador de sbt 
construir los mismos proyectos con resultados consistentes. Para hacer esto, 
crea un fichero llamado <code>project/build.properties</code> en el que se especifica la 
versión de sbt como sigue:
</p><pre><code class="">sbt.version=1.5.0
</code></pre><p>Si la versión requerida no está disponible localmente, el lanzador <code>sbt</code> se la 
descargará por ti. Si este fichero no está presente, el lanzador <code>sbt</code> eligirá 
una versión arbitraria, lo cual no es aconsejable debido a que hará que tu 
construcción no sea portable.
</p><h3 id="%C2%BFQu%C3%A9+es+una+definici%C3%B3n+de+construcci%C3%B3n%3F">¿Qué es una definición de construcción?<a href="#%C2%BFQu%C3%A9+es+una+definici%C3%B3n+de+construcci%C3%B3n%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Una <em>definición de construcción</em> es definida en <code>build.sbt</code> y consiste en un 
conjunto de proyectos (de tipo <a href="../../api/sbt/Project.html"><code>Project</code></a>). Debido a 
que el término <em>project</em> puede ser ambiguo, con frecuencia utilizaremos el <em>subproyecto</em> para referirnos a ellos en esta guía.
</p><p>Por ejemplo, en <code>build.sbt</code> se define el subproyecto ubicado en el directorio 
actual así:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalaVersion := &quot;2.12.7&quot;
  )
</code></pre><p>Cada subproyecto es configurado como pares clave-valor.
</p><p>Por ejemplo, una clave es <code>name</code> y se mapea a una cadena de texto, el nombre 
de tu subproyecto. Los pares clave-valor se listan bajo el método 
<code>.settings(...)</code> de tal forma:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalaVersion := &quot;2.12.7&quot;
  )
</code></pre><h3 id="C%C3%B3mo+define+build.sbt+configuraciones">Cómo define build.sbt configuraciones<a href="#C%C3%B3mo+define+build.sbt+configuraciones" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>build.sbt</code> define subproyectos, los cuales contienen una secuencia de pares 
clave-valor llamados <em>expresiones de configuración</em> (expression settings) 
utilizando un <em>DSL de build.sbt</em>
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><p>Echemos un vistazo más de cerca al DSL de build.sbt:
</p><p><img src="../files/setting-expression.png" alt="setting expression"/><br>
<br>
</p><p>Cada entrada es llamada una <em>expresion de configuración</em>. De entre ellas, 
algunas son también llamadas expresiones de tareas. Veremos la diferencia entre 
ellas más tarde en esta página.
</p><p>Una expresión de configuración consiste en tres partes:
</p><ol><li>La parte izquierda, que es una <em>clave</em>.
</li><li>Un <em>operador</em>, que en este caso es <code>:=</code>
</li><li>La parte derecha es llamada <em>cuerpo</em> o <em>cuerpo de configuración</em>.
</li></ol><p>A la izquierda, <code>name</code>, <code>version</code> y <code>scalaVersion</code> son <em>claves</em>. Una clave es 
una instancia de
<a href="../../api/sbt/SettingKey.html"><code>SettingKey[T]</code></a>,
<a href="../../api/sbt/TaskKey.html"><code>TaskKey[T]</code></a> o
<a href="../../api/sbt/InputKey.html"><code>InputKey[T]</code></a>
donde <code>T</code> es el tipo esperado. Los tipos de claves son explicados más abajo.
</p><p>Debido a que la clave <code>name</code> tiene tipo <code>SettingsKey[String]</code>, el operador <code>:=</code> 
aplicado a <code>name</code> también está tipado como <code>String</code>. Si usas el tipo incorrecto 
la definición de construcción no compilará:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := 42  // no compila
  )
</code></pre><p>En <code>build.sbt</code> también se pueden entremezclar <code>val</code>, <code>lazy val</code> y <code>def</code>. Los 
<code>object</code> y <code>class</code> de primer nivel no están permitidos en <code>build.sbt</code>. De 
hacerlo deberían ir en el directorio <code>project/</code> como ficheros fuente de Scala.
</p><h3 id="Claves">Claves<a href="#Claves" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Tipos">Tipos<a href="#Tipos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Hay tres sabores de claves:
</p><ul><li><code>SettingKey[T]</code>: una clave para un valor calculado una única vez (el valor
es calculado cuando se carga un subproyecto)
</li><li><code>TaskKey[T]</code>: una clave para un valor, llamado una <em>tarea</em> que ha de ser
recalculado cada vez, potencialmente con efectos colaterales.
</li><li><code>InputKey[T]</code>: una clave para una tarea con argumentos de línea de comandos
como entrada. Para más información mira <a href="../docs/Input-Tasks.html">Tareas de entrada</a>.
</li></ul><h4 id="Claves+preconfiguradas">Claves preconfiguradas<a href="#Claves+preconfiguradas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Las claves preconfiguradas son simplemente campos de un objeto llamado 
<a href="../../api/sbt/Keys$.html">Keys</a>. Un <code>build.sbt</code> tiene de forma implícita un 
<code>import sbt.Keys._</code>, por lo que <code>sbt.Keys.name</code> puede ser accedido como <code>name</code>.
</p><h4 id="Claves+personalizadas">Claves personalizadas<a href="#Claves+personalizadas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Las claves personalizadas pueden ser definidas con sus respectivos métodos de 
creación: <code>settingKey</code>, <code>taskKey</code> e <code>inputKey</code>. Cada método espera el tipo del valor 
asociado con la clave además de su descripción. El nombre de la clave es tomado 
del <code>val</code> al cual la clave es asignada. Por ejemplo, para definir una clave para 
una nueva tarea llamada <code>hello</code>,
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;An example task&quot;)
</code></pre><p>Aquí hemos usado el hecho de que un fichero <code>.sbt</code> puede contener <code>val</code> y <code>def</code> 
además de configuración. Todas estas definiciones son evaluadas antes de la 
configuración sin importar en qué lugar del fichero han sido definidas.
</p><blockquote><p><strong>Nota:</strong> Tipicamente, se usan <code>lazy val</code> en lugar de <code>val</code> para evitar problemas de orden
durante la inicialización.
</p></blockquote><h4 id="Claves+de+tarea+vs+claves+de+entradas">Claves de tarea vs claves de entradas<a href="#Claves+de+tarea+vs+claves+de+entradas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Se dice de <code>TaskKey[T]</code> que define una <em>tarea</em>. Las tareas son operaciones 
tales como <code>compile</code> o <code>package</code>. A su vez pueden devolver <code>Unit</code> (<code>Unit</code> es el 
tipo de Scala para <code>void</code>) o pueden devolver un valor relacionado con la tarea, 
por ejemplo el de <code>package</code> es un <code>TaskKey[File]</code> y su valor es el fichero jar que 
crea.
</p><p>Cada vez que inicias la ejecución de una tarea, por ejemplo escribiendo 
<code>compile</code> en el prompt interactivo de sbt, sbt volverá a ejecutar cualesquiera 
tareas implicadas exactamente una vez.
</p><p>Los pares clave-valor de sbt que describen al subproyecto pueden ser 
almacenados en forma de cadena fija para configuraciones tales como <code>name</code>, 
pero tienen que poder guardar código ejecutable para tareas tales como 
<code>compile</code>. Incluso si dicho código ejecutable acaba devolviendo una cadena, 
tiene que ser ejecutado cada vez.
</p><p><em>Una cierta clave siempre se refiere o bien a una tarea o a una entrada plana.</em> 
El que tenga que ser ejecutada cada vez o no es una propiedad de la clave, no 
del
valor.
</p><h3 id="Definir+tareas+y+entradas+de+configuraci%C3%B3n">Definir tareas y entradas de configuración<a href="#Definir+tareas+y+entradas+de+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Utilizando <code>:=</code> se puede asignar un valor a una entrada y una computación a una 
tarea. Para una entrada, el valor será computado una única vez durante la carga 
del proyecto. Para una tarea, la computación será evaluada cada vez que la 
tarea sea ejecutada.
</p><p>Por ejemplo, para implementar la tarea <code>hello</code> de la sección anterior:
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;An example task&quot;)

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    hello := { println(&quot;Hello!&quot;) }
  )
</code></pre><p>Ya vimos un ejemplo sobre cómo definir entradas cuando definimos el nombre del 
proyecto:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><h4 id="Tipos+para+tareas+y+entradas">Tipos para tareas y entradas<a href="#Tipos+para+tareas+y+entradas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Desde una perspectiva del sistema de tipos, el <code>Setting</code> creado a partir de una 
clave tarea es ligeramente diferente de la creada para una clave entrada. 
<code>taskKey := 42</code> resulta en <code>Setting[Task[T]]</code> mientras que <code>settingKey := 42</code> 
resulta en <code>Setting[T]</code>. En la mayoría de los casos esto no supone ninguna 
diferencia; la clave tarea aún sigue creando un valor de tipo <code>T</code> cuando la 
tarea es ejecutada.
</p><p>La diferencia de tipos entre <code>T</code> y <code>Task[T]</code> tiene la siguiente implicación: 
una entrada no puede depender de una tarea, debido a que una entrada es 
evaluada una única vez durante la carga de un proyecto y no es re-evaluada. Más 
información sobre esto en <a href="Task-Graph.html">Grafos de tareas</a>.
</p><h3 id="Claves+en+el+shell+de+sbt">Claves en el shell de sbt<a href="#Claves+en+el+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En el shell de sbt, puedes escribir el nombre de cualquier tarea para ejecutar 
dicha tarea. Esta es la razón por la que al escribir <code>compile</code> se ejecuta la tarea <code>compile</code>. 
<code>compile</code> es una clave tarea.
</p><p>Si escribes el nombre de una clave entrada en lugar de una clave tarea el valor 
de la clave entrada será mostrado. Escribir el nombre de una clave tarea 
ejecuta la tarea pero muestra el valor resultante. Para ver el resultado de una 
tarea utiliza <code>show &lt;tarea&gt;</code> en lugar de simplemente <code>&lt;tarea&gt;</code>. La convención 
para nombres de claves es utilizar <code>camelCase</code> por lo que el nombre de linea de 
comandos y los identificadores de Scala son los mismos.
</p><p>Para aprender más acerca de cualquier clave escribe <code>inspect &lt;clave&gt;</code> en el 
prompt interactivo de sbt. Alguna de la información que <code>inspect</code> muestra no 
tendrá sentido (de momento), pero al principio de todo mostrará el tipo del 
valor y una breve descripción de esa entrada.
</p><h3 id="Importaciones+en+build.sbt">Importaciones en build.sbt<a href="#Importaciones+en+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Puedes incluir sentencias <code>import</code> al principio de <code>build.sbt</code>. No necesitan 
estar separadas por líneas en blanco.
</p><p>Existen algunas importaciones implícitas predeterminadas:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._
</code></pre><p>(Además, si tienes autoplugins, los nombres marcados bajo <code>autoImport</code> serán 
importados.)
</p><h3 id="Definiciones+de+construcci%C3%B3n+.sbt+planas">Definiciones de construcción .sbt planas<a href="#Definiciones+de+construcci%C3%B3n+.sbt+planas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>La configuración puede ser escrita directamente en el fichero <code>build.sbt</code> en 
lugar de ponerla dentro de la llamada a <code>.settings(...)</code>. Podemos llamar a esto 
el “estilo plano”.
</p><pre><code class="prettyprint lang-scala">ThisBuild / version := &quot;1.0&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
</code></pre><p>Esta sintaxis es la recomendada para configuraciones con ámbito <code>ThisBuild</code> plugins añadidos.
Mira secciones posteriores acerca de los ámbitos y los plugins.
</p><h3 id="A%C3%B1adir+dependencias+de+biblioteca">Añadir dependencias de biblioteca<a href="#A%C3%B1adir+dependencias+de+biblioteca" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para depender de bibliotecas de terceros hay dos opciones. La primera es copiar 
jars en <code>lib/</code> (dependencias no gestionadas) y la otra es añadir dependencias 
gestionadas, que en <code>build.sbt</code> tienen este aspecto:
</p><pre><code class="prettyprint lang-scala">val derby = &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    libraryDependencies += derby
  )
</code></pre><p>Así es como se puede añadir una dependencia gestionada de la biblioteca Apache 
Derby versión 10.4.1.3.
</p><p>La clave <code>libraryDependencies</code> posee dos complejidades: <code>+=</code> en lugar de <code>:=</code> y 
el método <code>%</code>. <code>+=</code> añade al valor antiguo de la clave en lugar de 
reemplazarlo, como se explica en <a href="Task-Graph.html">Grafos de tareas</a>. El método <code>%</code> 
es utilizado para construir un identificador de módulo Ivy a partir de cadenas, 
como se explica en <a href="Library-Dependencies.html">Dependencias de bibliotecas</a>.
</p><p>De momento nos saltaremos los detalles de las dependencias de bibliotecas hasta 
más tarde en la Guía de inicio. Hay una <a href="Library-Dependencies.html">página entera</a> 
que habla de ellas más tarde.
</p><h2 id="Construcciones+multiproyecto">Construcciones multiproyecto<a href="#Construcciones+multiproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página introduce múltiples subproyectos en una única construcción.
</p><p>Por favor, lee primero las páginas anteriores de la Guía de inicio, en
particular necesitarás entender el fichero <a href="Basic-Def.html">build.sbt</a> antes de leer
esta página.
</p><h3 id="M%C3%BAltiples+subproyectos">Múltiples subproyectos<a href="#M%C3%BAltiples+subproyectos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Puede ser útil mantener múltiples subproyectos relacionados en una única
construcción, especialmente si unos dependen de otros y sueles modificarlos
todos a la vez.
</p><p>Cada subproyecto en una construcción tiene sus propios directorios de código
fuente, genera su propio fichero jar cuando ejecutas <code>package</code> y en general
funcionan como cualquier otro proyecto.
</p><p>Un proyecto se define declarando un <code>lazy val</code> de tipo
<a href="../../api/sbt/Project.html">Project</a>. Por ejemplo:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))

lazy val core = (project in file(&quot;core&quot;))
</code></pre><p>El nombre del <code>val</code> es usado como ID de subproyecto, el cual es usado para
referirse al subproyecto en el shell de sbt.
</p><p>Opcionalmente,  el directorio base puede ser omitido si es el mismo que el
nombre del val.
</p><pre><code class="prettyprint lang-scala">lazy val util = project

lazy val core = project
</code></pre><h4 id="Configuraci%C3%B3n+com%C3%BAn+de+construcci%C3%B3n">Configuración común de construcción<a href="#Configuraci%C3%B3n+com%C3%BAn+de+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Para extraer configuración común a lo largo de múltiples proyectos puedes
definir la configuración en el ámbito de <code>ThisBuild</code>.
Para ello la parte derecha tiene que ser un valor puro o una configuración en el
ámbito de <code>Global</code> o <code>ThisBuild</code> y no puede haber configuraciones
predeterminadas en el ámbito de subproyectos. (Ver <a href="Scopes.html">Ámbitos</a>)
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    // otras configuraciones
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    // otras configuraciones
  )
</code></pre><p>Ahora podemos incrementar <code>version</code> en un único lugar y se verá reflejado a lo
largo de los subproyectos cuando recargues la construcción.
</p><h4 id="Configuraci%C3%B3n+com%C3%BAn">Configuración común<a href="#Configuraci%C3%B3n+com%C3%BAn" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Otra forma de extraer configuración común a lo largo de múltiples proyectos es
crear una secuencia llamada <code>commonSettings</code> y llamar al método <code>settings</code> en
cada proyecto.
</p><pre><code class="prettyprint lang-scala">lazy val commonSettings = Seq(
  target := { baseDirectory.value / &quot;target2&quot; }
)

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    commonSettings,
    // otras configuraciones
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    commonSettings,
    // otras configuraciones
  )
</code></pre><h3 id="Dependencias">Dependencias<a href="#Dependencias" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Los proyectos en la construcción pueden ser completamente independientes uno
de otro, pero por lo general estarán relacionados mediante algún tipo de
dependencia. Hay dos tipos de dependencias: agregadas y de classpath.
</p><h4 id="Agregaci%C3%B3n">Agregación<a href="#Agregaci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Una agregación implica que al ejecutar una tarea en el proyecto que agrega también
será ejecutada en los proyectos agregados. Por ejemplo:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)

lazy val util = (project in file(&quot;util&quot;))

lazy val core = (project in file(&quot;core&quot;))
</code></pre><p>En el ejemplo de arriba, el proyecto raíz agrega <code>util</code> y <code>core</code>. Si ejecutas sbt
con dos subproyectos como los del ejemplo e intentas compilar podrás ver cómo
los tres proyectos son compilados.
</p><p><em>En el proyecto que hace la agregación</em>, el proyecto raíz en este caso, puedes
controlar la agregación a nivel de tarea. Por ejemplo, para evitar agregar la
tarea <code>update</code>:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .aggregate(util, core)
  .settings(
    update / aggregate := false
  )

[...]
</code></pre><p><code>update / aggregate</code> es la clave agregada en el ámbito de la tarea <code>update</code>
(ver <a href="Scopes.html">Ámbitos</a>).
</p><p>Nota: La agregación ejecutará las tareas agregadas en paralelo y sin orden
predeterminado entre ellas.
</p><h4 id="Dependencias+de+classpath">Dependencias de classpath<a href="#Dependencias+de+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Un proyecto puede depender del código de otro proyecto. Esto se hace añadiendo
una llamada al método <code>dependsOn</code>. Por ejemplo, si <code>core</code> necesita <code>util</code> en su
classpath deberías de definir <code>core</code> así:
</p><pre><code class="prettyprint lang-scala">lazy val core = project.dependsOn(util)
</code></pre><p>A partir de ahora el código de <code>core</code> puede utilizar las clases de <code>util</code>. Esto
crea además un orden entre proyectos a la hora de compilarlos. <code>util</code> deberá ser
actualizado y compilado antes de que <code>core</code> pueda ser compilado.
</p><p>Para depender de múltiples proyectos puedes utilizar múltiples argumentos en
<code>dependsOn</code>, como <code>dependsOn(bar, baz)</code>.
</p><h5 id="Dependencias+de+classpath+por+configuraci%C3%B3n">Dependencias de classpath por configuración<a href="#Dependencias+de+classpath+por+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>core dependsOn(util)</code> implica que la configuración de <code>compile</code> en <code>core</code>
dependerá de la configuración de <code>compile</code> en <code>util</code>. Esto se puede escribir
de forma más explícita como <code>dependsOn(util % &quot;compile-&gt;compile&quot;)</code>.
</p><p>La <code>-&gt;</code> en <code>&quot;compile-&gt;compile&quot;</code> significa “depende de”, por lo que
<code>&quot;test-&gt;compile&quot;</code> significa que la configuración de <code>test</code> en <code>core</code> depende
de la configuración de <code>compile</code> en <code>util</code>.
</p><p>Omitir la parte de <code>-&gt;config</code> implica <code>-&gt;compile</code>, por lo que
<code>dependsOn(util % &quot;test&quot;)</code> significa que la configuración de <code>test</code> en <code>core</code>
depende de la configuración de <code>Compile</code> en <code>util</code>.
</p><p>Una declaración útil es <code>&quot;test-&gt;test&quot;</code> que significa que <code>test</code> depende de <code>test</code>.
Esto permite poner código auxiliar para testear en <code>util/src/test/scala</code> y luego
usar dicho código en <code>core/src/test/scala</code>, por ejemplo.
</p><p>Puedes declarar múltiples configuraciones para una dependencia, separadas por
punto y coma. Por ejemplo, <code>dependsOn(util % &quot;test-&gt;test;compile-&gt;compile&quot;)</code>.
</p><h3 id="Dependencias+inter-proyecto">Dependencias inter-proyecto<a href="#Dependencias+inter-proyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En proyectos extremadamente grandes con muchos ficheros y muchos subproyectos,
el rendimiento de sbt puede ser menos óptimo al tener que observar qué ficheros
han cambiado en una sesión interactiva por tener que realizar muchas operaciones de E/S.
</p><p>sbt posee las entradas <code>trackingInternalDependencies</code> y <code>exportToInternal</code>.
Éstas pueden ser utilizadas para controlar si la compilación de subproyectos
dependientes ha de ser lanzada automáticamente o no cuando se llama a <code>compile</code>.
Ambas claves pueden tomar uno de estos tres valores: <code>TrackLevel.NoTracking</code>,
<code>TrackLevel.TrackIfMissing</code> y <code>TrackLevel.TrackAlways</code>. De forma predeterminada
ambas son establecidas a <code>TrackLevel.TrackAlways</code>.
</p><p>Cuando <code>trackInternalDependencies</code> es establecido a <code>TrackLevel.TrackIfMissing</code>,
sbt no volverá a intentar compilar dependencias internas (inter-proyecto)
automáticamente, a menos que no haya ficheros <code>*.class</code> (o un fichero JAR
cuando <code>exportJars</code> sea <code>true</code>) en el directorio de salida.
</p><p>Cuando la entrada es establecida a <code>TrackLevel.NoTracking</code> la compilación de
dependencias internas es omitida. Fíjate en que el classpath aún sigue siendo anexado
y que el grafo de dependencias aún sigue mostrándolas como dependencias.
La razón es ahorrar el sobrecoste de E/S para observar cambios en una
construcción con muchos subproyectos durante el desarrollo. A continuación se
muestra cómo establecer todos los subproyectos a <code>TrackIfMissing</code>.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;)).
  aggregate(....).
  settings(
    inThisBuild(Seq(
      trackInternalDependencies := TrackLevel.TrackIfMissing,
      exportJars := true
    ))
  )
</code></pre><p>La entrada <code>exportToInternal</code> permite al proyecto del cual se depende optar si
puede ser vigilado internamente o no, lo cual puede resultar útil si lo que se
quiere es hacer seguimiento de la mayoría de los subproyectos excepto unos
cuantos. La intersección de las entradas <code>trackInternalDependencies</code> y
<code>exportToInternal</code> será usada para determinar el nivel de seguimiento real.
A continuación se muestra un ejemplo de un proyecto optando de ser seguido o no:
</p><pre><code class="prettyprint lang-scala">lazy val dontTrackMe = (project in file(&quot;dontTrackMe&quot;)).
  settings(
    exportToInternal := TrackLevel.NoTracking
  )
</code></pre><h3 id="Proyecto+ra%C3%ADz+predeterminado">Proyecto raíz predeterminado<a href="#Proyecto+ra%C3%ADz+predeterminado" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si un proyecto no está definido para el directorio raíz en la construcción, sbt
creará uno de forma predeterminada que agrega a los otros proyectos de la
construcción.
</p><p>Debido a que el proyecto <code>hello-foo</code> ha sido definido con <code>base = file(&quot;foo&quot;)</code>,
él estará contenido en el subdirectorio <code>foo</code>. Sus fuentes pueden estar tanto en
<code>foo</code>, como <code>foo/Foo.scala</code> o en <code>foo/src/main/scala</code>. La
<a href="Directories.html">estructura de directorios</a> habitual se aplica a <code>foo</code> a excepción
de los ficheros de definición de construcción.
</p><h3 id="Navegando+por+los+proyectos+interactivamente">Navegando por los proyectos interactivamente<a href="#Navegando+por+los+proyectos+interactivamente" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En el prompt interactivo de sbt, escribe <code>proyectos</code> para listar tus proyectos y
<code>project &lt;projectname&gt;</code> para seleccionar el proyecto actual. Al ejecutar una
tarea como <code>compile</code> ésta se ejecutará sobre el proyecto actual. Por eso no hay
por qué compilar el proyecto raíz necesariamente, es posible compilar solamente
un subproyecto.
</p><p>Puedes ejecutar una tarea en otro proyecto especificando explícitamente el ID de
proyecto, como en <code>subproyecto/compile</code>.
</p><h3 id="C%C3%B3digo+com%C3%BAn">Código común<a href="#C%C3%B3digo+com%C3%BAn" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Las definiciones en los ficheros <code>.sbt</code> no son visibles en otros ficheros
<code>.sbt</code>. Para poder compartir código entre ficheros <code>.sbt</code> hay que definir uno o
más ficheros de Scala en el directorio <code>project/</code> en la construcción raíz.
</p><p>Para más información ver <a href="Organizing-Build.html">Organizando la construcción</a>.
</p><h3 id="Appendix%3A+Subproject+build+definition+files">Appendix: Subproject build definition files<a href="#Appendix%3A+Subproject+build+definition+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cualquier fichero <code>.sbt</code> en <code>foo</code>, por ejemplo <code>foo/build.sbt</code>, será mezclado
con la definición de construcción para la construcción principal, pero con
ámbito del proyecto <code>hello-foo</code>.
</p><p>Si todo tu proyecto está en <code>hello</code>, intenta definir una versión diferente
(<code>version := &quot;0.6&quot;</code>) en <code>hello/build.sbt</code>, <code>hello/foo/build.sbt</code>, y
<code>hello/bar/build.sbt</code>. Ahora <code>show version</code> en el prompt interactivo de sbt
debería de tener este aspecto (respetando las versiones que hayas definido):
</p><pre><code class="">&gt; show version
[info] hello-foo/*:version
[info]  0.7
[info] hello-bar/*:version
[info]  0.9
[info] hello/*:version
[info]  0.5
</code></pre><p><code>hello-foo/*:version</code> está definido en <code>hello/foo/build.sbt</code>,
<code>hello-bar/*:version</code> está definido en <code>hello/bar/build.sbt</code> y
<code>hello/*:version</code> está definido en <code>hello/build.sbt</code>. Recuerda la
<a href="Scopes.html">sintaxis para claves con ámbito</a>. Cada clave <code>version</code> está en el
ámbito de un proyecto, basado en la ubicación de <code>build.sbt</code>. Pero los tres
<code>build.sbt</code> forman parte de la misma definición de construcción.
</p><p>Style choices:
</p><ul><li>Each subproject’s settings can go into <code>*.sbt</code> files in the base directory of that project,
while the root <code>build.sbt</code> declares only minimum project declarations in the form of <code>lazy val foo = (project in file(&quot;foo&quot;))</code> without the settings.
</li><li>We recommend putting all project declarations and settings in the root <code>build.sbt</code> file
in order to keep all build definition under a single file. However, it up to you.
</li></ul><p>No puedes tener un subdirectorio de proyecto o ficheros <code>project/*.scala</code> en los
subproyectos. <code>foo/project/Build.scala</code> sería ignorado.
</p><h2 id="Grafos+de+tareas">Grafos de tareas<a href="#Grafos+de+tareas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Continuando con la <a href="Basic-Def.html">definición de construcción</a>, esta página explica
la definición de <code>build.sbt</code> con más detalle.
</p><p>En lugar de pensar en la configuración como pares clave-valor una analogía más
apropiada sería pensar en ella como un <em>grafo acíclico dirigido</em> (GAD) de tareas
donde los vértices significan <strong>sucede antes de</strong>.
Lo llamaremos <em>grafo de tareas</em>.
</p><h3 id="Terminolog%C3%ADa">Terminología<a href="#Terminolog%C3%ADa" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Repasemos los términos clave antes de seguir profundizando.
</p><ul><li>Expresión de entrada/tarea: entrada dentro de <code>.settings(...)</code>.
</li><li>Clave: parte izquierda de una expresión. Puede ser de tipo
<code>SettingKey[A]</code>, <code>TaskKey[A]</code> o <code>InputKey[A]</code>.
</li><li>Entrada: Definida por una expressión de entrada con <code>SettingKey[A]</code>.
El valor es calculado una única vez durante la carga.
</li><li>Tarea: Definida por una expresión de tarea con <code>TaskKey[A]</code>.
El valor es calculado cada vez que es invocado.
</li></ul><h3 id="Declarando+dependencia+de+otras+tareas">Declarando dependencia de otras tareas<a href="#Declarando+dependencia+de+otras+tareas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En el DSL de <code>build.sbt</code> se utiliza el método <code>.value</code> para expresar una
dependencia de otra tarea o entrada. El método <code>value</code> es especial y sólo puede
ser llamado como argumento de <code>:=</code> (o <code>+=</code> o <code>++=</code>, los cuales veremos más
adelante).
</p><p>Como primer ejemplo supongamos que redefinimos <code>scalacOption</code> para que dependa de
las tareas <code>update</code> y <code>clean</code>. A continuación se muestran las definiciones de
estas claves (tal cual están definidas en <a href="../../api/sbt/Keys$.html">Keys</a>).
</p><p><strong>Nota</strong>: Los valores calculados abajo no tienen mucho sentido para
<code>scalacOptions</code> pero sirven a modo de demostración.
</p><pre><code class="prettyprint lang-scala">val scalacOptions = taskKey[Seq[String]](&quot;Options for the Scala compiler.&quot;)
val update = taskKey[UpdateReport](&quot;Resolves and optionally retrieves dependencies, producing a report.&quot;)
val clean = taskKey[Unit](&quot;Deletes files produced by the build, such as generated sources, compiled classes, and task caches.&quot;)
</code></pre><p>A continuación se muestra cómo podemos redefinir <code>scalacOptions</code>:
</p><pre><code class="prettyprint lang-scala">scalacOptions := {
  val ur = update.value  // la tarea update sucede antes de scalacOptions
  val x = clean.value    // la tarea clean sucede antes de scalacOptions
  // ---- scalacOptions empieza aquí ----
  ur.allConfigurations.take(3)
}
</code></pre><p><code>update.value</code> y <code>clean.value</code> declaran dependencias de tarea, mientras que
<code>ur.allConfigurations.take(3)</code> es el cuerpo de la tarea.
</p><p><code>.value</code> no es un método de Scala normal. El DSL de <code>build.sbt</code> utiliza una
macro para procesarlo fuera del cuerpo de la tarea. <strong>Ambas tareas, <code>update</code>
y <code>clean</code>, ya han sido completadas en el momento en el que el motor
de tareas evalúa el cuerpo de <code>scalacOptions</code>, sin importar que esas líneas
aparezcan en el cuerpo.</strong>
</p><p>Mira el siguiente ejemplo:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalacOptions := {
      val out = streams.value // la tarea streams sucede antes de scalacOptions
      val log = out.log
      log.info(&quot;123&quot;)
      val ur = update.value   // la tarea update sucede antes de scalacOptions
      log.info(&quot;456&quot;)
      ur.allConfigurations.take(3)
    }
  )
</code></pre><p>Después, desde el shell de sbt si se escribe <code>scalacOptions</code>:
</p><pre><code class="">&gt; scalacOptions
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[info] 123
[info] 456
[success] Total time: 0 s, completed Jan 2, 2017 10:38:24 PM
</code></pre><p>Incluso aunque <code>val ur = ...</code> aparezca entre <code>log.info(&quot;123&quot;)</code> y
<code>log.info(&quot;456&quot;)</code> la evaluación de la tarea <code>update</code> se ha realizado antes de
tales líneas.
</p><p>Aquí hay otro ejemplo:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    scalacOptions := {
      val ur = update.value  // la tarea update sucede antes de scalacOptions
      if (false) {
        val x = clean.value  // la tarea clean sucede antes de scalacOptions
      }
      ur.allConfigurations.take(3)
    }
  )
</code></pre><p>Después, si desde el shell de sbt se lanza <code>run</code> y luego <code>scalacOptions</code>:
</p><pre><code class="">&gt; run
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/eugene/work/quick-test/task-graph/target/scala-2.12/classes...
[info] Running example.Hello
hello
[success] Total time: 0 s, completed Jan 2, 2017 10:45:19 PM
&gt; scalacOptions
[info] Updating {file:/xxx/}root...
[info] Resolving jline#jline;2.14.1 ...
[info] Done updating.
[success] Total time: 0 s, completed Jan 2, 2017 10:45:23 PM
</code></pre><p>Si compruebas <code>target/scala-2.12/classes/</code> verás que no existe ya que la tarea
<code>clean</code> ha sido ejecutado incluso si aparece dentro de <code>if (false)</code>.
</p><p>Otra cosa importante a tener en cuenta es que no hay garantías sobre el orden
en el que las tareas <code>update</code> y <code>clean</code> son ejecutadas. Podría ejecutarse
primero <code>update</code> y luego <code>clean</code>, primero <code>clean</code> y luego <code>update</code> o ambas
ser ejecutadas en paralelo.
</p><h3 id="Llamadas+a+.value+en+l%C3%ADnea">Llamadas a .value en línea<a href="#Llamadas+a+.value+en+l%C3%ADnea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Como se ha explicado anteriormente, <code>.value</code> es un método especial que es usado
para expresar dependencias de otras tareas y entradas.
Hasta que te familiarices con <code>build.sbt</code> te recomendamos que pongas todas las
llamadas <code>.value</code> al principio del cuerpo.
</p><p>Sin embargo, a medida que te vayas sintiendo más cómodo, puedes optar por poner
dichas llamadas a <code>.value</code> en línea ya que puede hacer que la tarea/entrada sea
más concisa, sin tener que utilizar variables.
</p><p>A continuación se muestran unos cuantos ejemplos de llamadas en línea.
</p><pre><code class="prettyprint lang-scala">scalacOptions := {
  val x = clean.value
  update.value.allConfigurations.take(3)
}
</code></pre><p>Fíjate en que, aunque las llamadas a <code>.value</code> estén en línea o en cualquier parte
del cuerpo de la tarea, siguen siendo evaluadas antes de entrar al cuerpo de
la tarea.
</p><h4 id="Inspeccionar+la+tarea">Inspeccionar la tarea<a href="#Inspeccionar+la+tarea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>En el ejemplo anterior, <code>scalacOptions</code> tiene una <em>dependencia</em> de las tareas
<code>update</code> y <code>clean</code>. Si pones ese ejemplo en <code>build.sbt</code> y ejecutas la consola
interactiva de sbt y luego escribes <code>inspect scalacOptions</code> deberías de ver
algo similar (en parte):
</p><pre><code class="">&gt; inspect scalacOptions
[info] Task: scala.collection.Seq[java.lang.String]
[info] Description:
[info]  Options for the Scala compiler.
....
[info] Dependencies:
[info]  *:clean
[info]  *:update
....
</code></pre><p>Así es cómo sbt sabe qué tareas dependen de otras.
</p><p>Por ejemplo, si se lanza <code>inspect tree compile</code> verás que depende de otra clave
<code>incCompileSetup</code> que a su vez depende de otras claves como
<code>dependencyClasspath</code>.
Sigue recorriendo las dependencias y verás cómo ocurre la mágia.
</p><pre><code class="">&gt; inspect tree compile
[info] compile:compile = Task[sbt.inc.Analysis]
[info]   +-compile:incCompileSetup = Task[sbt.Compiler$IncSetup]
[info]   | +-*/*:skip = Task[Boolean]
[info]   | +-compile:compileAnalysisFilename = Task[java.lang.String]
[info]   | | +-*/*:crossPaths = true
[info]   | | +-{.}/*:scalaBinaryVersion = 2.12
[info]   | |
[info]   | +-*/*:compilerCache = Task[xsbti.compile.GlobalsCache]
[info]   | +-*/*:definesClass = Task[scala.Function1[java.io.File, scala.Function1[java.lang.String, Boolean]]]
[info]   | +-compile:dependencyClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | +-compile:dependencyClasspath::streams = Task[sbt.std.TaskStreams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | +-*/*:streamsManager = Task[sbt.std.Streams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | |
[info]   | | +-compile:externalDependencyClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | | +-compile:externalDependencyClasspath::streams = Task[sbt.std.TaskStreams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | | +-*/*:streamsManager = Task[sbt.std.Streams[sbt.Init$ScopedKey[_ &lt;: Any]]]
[info]   | | | |
[info]   | | | +-compile:managedClasspath = Task[scala.collection.Seq[sbt.Attributed[java.io.File]]]
[info]   | | | | +-compile:classpathConfiguration = Task[sbt.Configuration]
[info]   | | | | | +-compile:configuration = compile
[info]   | | | | | +-*/*:internalConfigurationMap = &lt;function1&gt;
[info]   | | | | | +-*:update = Task[sbt.UpdateReport]
[info]   | | | | |
....
</code></pre><p>Cuando escribes <code>compile</code> sbt automáticamente realiza un <code>update</code>, por ejemplo.
Esto funciona simplemente porque los valores de entrada requeridos por <code>compile</code>
necesitan que sbt lance un <code>update</code> primero.
</p><p>De esta forma, todas las dependencias de construcción en sbt son <em>automáticas</em>
en lugar de tener que ser declaradas de forma explícita. Si usas el valor de
una clave en otra computación entonces la computación dependerá de dicha clave.
</p><h4 id="Definir+una+tarea+que+depende+de+otra+configuraci%C3%B3n">Definir una tarea que depende de otra configuración<a href="#Definir+una+tarea+que+depende+de+otra+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>scalacOptions</code> es una clave tarea.
Supongamos que ya ha sido establecida a algún valor, pero que quieres filtrar
<code>&quot;-Xfatal-warnings&quot;</code> y <code>&quot;-deprecation&quot;</code> para las versiones distintas a la 2.12.
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    organization := &quot;com.example&quot;,
    scalaVersion := &quot;2.12.13&quot;,
    version := &quot;0.1.0-SNAPSHOT&quot;,
    scalacOptions := List(&quot;-encoding&quot;, &quot;utf8&quot;, &quot;-Xfatal-warnings&quot;, &quot;-deprecation&quot;, &quot;-unchecked&quot;),
    scalacOptions := {
      val old = scalacOptions.value
      scalaBinaryVersion.value match {
        case &quot;2.12&quot; =&gt; old
        case _      =&gt; old filterNot (Set(&quot;-Xfatal-warnings&quot;, &quot;-deprecation&quot;).apply)
      }
    }
  )
</code></pre><p>A continuación se muestra cómo aparecería en el shell de sbt:
</p><pre><code class="">&gt; show scalacOptions
[info] * -encoding
[info] * utf8
[info] * -Xfatal-warnings
[info] * -deprecation
[info] * -unchecked
[success] Total time: 0 s, completed Jan 2, 2017 11:44:44 PM
&gt; ++2.11.8!
[info] Forcing Scala version to 2.11.8 on all projects.
[info] Reapplying settings...
[info] Set current project to Hello (in build file:/xxx/)
&gt; show scalacOptions
[info] * -encoding
[info] * utf8
[info] * -unchecked
[success] Total time: 0 s, completed Jan 2, 2017 11:44:51 PM
</code></pre><p>Ahora, cojamos estas dos claves (desde <a href="../../api/sbt/Keys$.html">Keys</a>):
</p><pre><code class="prettyprint lang-scala">val scalacOptions = taskKey[Seq[String]](&quot;Options for the Scala compiler.&quot;)
val checksums = settingKey[Seq[String]](&quot;The list of checksums to generate and to verify for dependencies.&quot;)
</code></pre><p><strong>Nota</strong>: <code>scalacOptions</code> y <code>checksums</code> no tienen nada que ver la una con la
otra. Simplemente son dos claves con el mismo tipo de valor, donde una es una
tarea.
</p><p>Es posible compilar un <code>build.sbt</code> en donde <code>scalacOptions</code> hace referencia a
<code>checksums</code>, pero no en el sentido contrario.
Por ejemplo, lo siguiente está permitido:
</p><pre><code class="prettyprint lang-scala">// La tarea scalacOptions puede estar definida en
// terminos de la entrada checksums
scalacOptions := checksums.value
</code></pre><p>No hay forma de ir en la <em>otra</em> dirección. Es decir, una clave entrada no puede
depender de una clave tarea. Esto se debe a que una clave entrada es computada
una única vez cuando se carga el proyecto, por lo que una tarea no sería
re-ejecutada cada vez y las tareas esperan justamente lo contrario.
</p><pre><code class="prettyprint lang-scala">// Mal ejemplo: La entrada checksums no puede ser definida en términos de la
// tarea scalacOptions
checksums := scalacOptions.value
</code></pre><h4 id="Definir+una+entrada+que+depende+de+otras+entradas">Definir una entrada que depende de otras entradas<a href="#Definir+una+entrada+que+depende+de+otras+entradas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>En términos de ejecución, podemos pensar en las entradas como un tipo especial
de tarea que se evalúa durante la carga del proyecto.
</p><p>Consideremos definir la organización del proyecto para que coincida con el
nombre del proyecto.
</p><pre><code class="prettyprint lang-scala">// nombramos nuestra organizacón basándonos en el proyecto
// (ambos son SettingKey[String])
organization := name.value
</code></pre><p>A continuación se muestra un ejemplo más realista.
Esto cambia el valor de la clave <code>Compile / scalaSource</code> a un directorio
diferente sólo cuando <code>scalaBinaryVersion</code> es <code>&quot;2.11&quot;</code>.
</p><pre><code class="prettyprint lang-scala">Compile / scalaSource := {
  val old = (Compile / scalaSource).value
  scalaBinaryVersion.value match {
    case &quot;2.11&quot; =&gt; baseDirectory.value / &quot;src-2.11&quot; / &quot;main&quot; / &quot;scala&quot;
    case _      =&gt; old
  }
}
</code></pre><h3 id="%C2%BFCu%C3%A1l+es+el+prop%C3%B3sito+del+DSL+de+build.sbt%3F">¿Cuál es el propósito del DSL de build.sbt?<a href="#%C2%BFCu%C3%A1l+es+el+prop%C3%B3sito+del+DSL+de+build.sbt%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>El DSL  de <code>build.sbt</code> es un lenguage específico del dominio utilizado para
construir un GAD de entradas y tareas. Las expresiones de la configuración
construyen entradas, tareas y las dependencias entre ellas.
</p><p>Esta estructura es común a <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> (1976), <a href="https://ant.apache.org/">Ant</a> (2000) y
<a href="https://ruby.github.io/rake/">Rake</a> (2003).
</p><h4 id="Introducci%C3%B3n+a+Make">Introducción a Make<a href="#Introducci%C3%B3n+a+Make" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>La sintáxis básica de un Makefile tiene este aspecto:
</p><pre><code class="">objetivo: dependencias
[tab] comando 1
[tab] comando 2
</code></pre><p>En un Makefile el primer objetivo que aparece listado corresponde al objetivo
predeterminado (por convenio se suele nombrar <code>all</code>).
</p><ol><li>Make comprueba si las dependencias del objetivo han sido construidas y
construye cualesquiera dependencias que no hayan sido construídas aún.
</li><li>Make ejecuta los comandos en orden.
</li></ol><p>Echemos un ojo a un <code>Makefile</code>:
</p><pre><code class="">CC=g++
CFLAGS=-Wall

all: hello

hello: main.o hello.o
    $(CC) main.o hello.o -o hello

%.o: %.cpp
    $(CC) $(CFLAGS) -c $&lt; -o $@
</code></pre><p>Al ejecutar <code>make</code> sin parámetros se coge el primer objetivo listado (por
convenio <code>all</code>).
El objetivo lista <code>hello</code> como su dependencia, la cual aún no ha sido
construida, por lo que Make construirá <code>hello</code>.
</p><p>Después, Make comprueba si las dependencias del objetivo <code>hello</code> han sido
construidas. <code>hello</code> tiene dos objetivos: <code>main.o</code> y <code>hello.o</code>.
Una vez dichos objetivos han sido creados utilizando la última regla de
concordancia de patrones el comando de sistema es ejecutado para enlazar
<code>main.o</code> y <code>hello.o</code> en <code>hello</code>.
</p><p>Cuando trabajas con <code>make</code> te puedes enfocar en qué objetivos quieres mientras
que Make calcula la secuencia y el orden exacto de comandos que necesitan ser
lanzados para construir los productos intermedios.
Se puede considerar como programación orientada a dependencias o
programanción basada en flujo. Make es en realidad considerado como un sistema
híbrido porque mientras que su DSL describe las dependencias entre tareas las
acciones son delegadas a comandos del sistema.
</p><h4 id="Rake">Rake<a href="#Rake" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Este sistema híbrido es continuado por los sucesores de Make tales como Ant,
Rake y sbt.
Echemos un vistazo a la sintaxis básica para un Rakefile:
</p><pre><code class="prettyprint lang-ruby">task name: [:prereq1, :prereq2] do |t|
  # acciones (puede referenciar prerequisitos tales como t.name, etc...)
end
</code></pre><p>La innovación hecha por Rake fue que usaba un lenguage de programación para
describir las acciones en lugar de comandos del sistema.
</p><h4 id="Ventajas+de+la+programaci%C3%B3n+h%C3%ADbrida+basada+en+flujo">Ventajas de la programación híbrida basada en flujo<a href="#Ventajas+de+la+programaci%C3%B3n+h%C3%ADbrida+basada+en+flujo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Existen varias razones para organizar la construcción de esta forma.
</p><p>La primera es evitar la duplicación. Con la programación basada en flujo una
tarea es ejecutada una única vez incluso cuando de ella dependen múltiples
tareas.
Por ejemplo, incluso cuando múltiples tareas a lo largo del grafo de tareas
dependen de <code>compile in Compile</code> la compilación será ejecutada exactamente una
única vez.
</p><p>La segunda es la paralelización. Utilizando el grafo de tareas el motor
de tareas puede programar tareas mutuamente no dependientes en paralelo.
</p><p>La tercera es la separación de cometidos y la flexibilidad.
El grafo de tareas permite al usuario cablear las tareas juntas de diferentes
formas, mientras que sbt y los plugins pueden proporcionar varias
características tales como compilación y gestión de dependencias de bibliotecas
como funciones que pueden ser reutilizadas.
</p><h3 id="Resumen">Resumen<a href="#Resumen" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>La estructura central de las definiciones de construcción es un GAD de tareas
donde los vértices denotan relaciones “sucede antes de”.
<code>build.sbt</code> es un DSL diseñado para expresar programación orientada a
dependencias o programación basada en flujo, similar a un <code>Makefile</code> o
<code>Rakefile</code>.
</p><p>La razón clave para utilizar programación basada en flujo es evitar
duplicaciones, procesar en paralelo y la personalización.
</p><h2 id="%C3%81mbitos">Ámbitos<a href="#%C3%81mbitos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página explica los ámbitos. Se supone que has leído y entendido las
páginas anteriores, <a href="Basic-Def.html">Definiciones de construcción</a> y
<a href="Task-Graph.html">Grafos de tareas</a>.
</p><h3 id="Toda+la+historia+sobre+claves">Toda la historia sobre claves<a href="#Toda+la+historia+sobre+claves" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="Basic-Def.html">Anteriormente</a> fingimos que una clave tal como <code>name</code> correspondía
a una única entrada en el mapa de pares clave-valor de sbt. Esto fue una
simplificación.
</p><p>En realidad cada clave puede tener un valor asociado en más de un contexto,
llamado <em>ámbito</em>.
</p><p>Algunos ejemplos concretos:
</p><ul><li>si tienes múltiples proyectos (también llamados subproyectos) en tu definición
de construcción una clave puede tener diferentes valores en cada proyecto.
</li><li>la clave <code>compile</code> puede tener un valor para tus fuentes principales y otro
diferente para tus ficheros de test, si quisieras compilarlos de forma
distinta.
</li><li>la clave <code>packageOptions</code> (que contiene opciones para crear paquetes jar)
puede tener diferentes valores cuando se empaquetan ficheros de clases
(<code>packageBin</code>) o paquetes de código fuente (<code>packageSrc</code>).
</li></ul><p><em>No existe un único valor para una clave <code>name</code> data</em>, porque el valor puede
diferir según el ámbito.
</p><p>Sin embargo, existe un único valor para una cierta clave en un ámbito.
</p><p>Si piensas en sbt cuando procesa una lista de entradas para generar un mapa
de clave-valor que describan un proyecto, tal y como se
<a href="Basic-Def.html">explicó antes</a>, las claves en ese mapa de clave-valor son claves
con <em>ámbito</em>. Cada entrada definida en la definición de construcción (por
ejemplo en <code>build.sbt</code>) se aplica también a una clave con ámbito.
</p><p>Frecuentemente el ámbito está implícito o existe uno predeterminado, pero si
el ámbito predeterminado no es el que te interesa deberás mencionar
explícitamente el ámbito que deseas en <code>build.sbt</code>.
</p><h3 id="Ejes+de+%C3%A1mbito">Ejes de ámbito<a href="#Ejes+de+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Un <em>eje de ámbito</em> es un constructor de tipo similar a <code>Option[A]</code> que es usado
para formar un componente en un ámbito.
</p><p>Existen tres ejes de ámbito:
</p><ul><li>El eje de subproyecto
</li><li>El eje de configuración
</li><li>El eje de tareas
</li></ul><p>Si el concepto de <em>eje</em> no te resulta familiar podemos pensar en un cubo de
color RGB como ejemplo:
</p><p><img src="../files/rgb_color_solid_cube.png" alt="color cube"/>
</p><p>En el modelo de color RGB todos los colores son representados por un punto en el
cubo cuyos ejes corresponden a las componentes rojo, verde y azul codificadas
por un número. De forma similar un ámbito total en sbt está formado por el valor
de la <strong>tupla</strong> de un subproyecto, una configuración y un tarea:
</p><pre><code class="prettyprint lang-scala">projA / Compile / console / scalacOptions
</code></pre><p>Que es la sintaxis de barra, introducida en sbt 1.1, equivalente a:
</p><pre><code class="prettyprint lang-scala">scalacOptions in (
  Select(projA: Reference),
  Select(Compile: ConfigKey),
  Select(console.key)
)
</code></pre><h4 id="%C3%81mbito+con+el+eje+de+subproyecto">Ámbito con el eje de subproyecto<a href="#%C3%81mbito+con+el+eje+de+subproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Si <a href="Multi-Project.html">pones múltiples proyectos en una única construcción</a>, cada
proyecto necesitará su propia configuración. Es decir, las claves pueden tener
un ámbito u otro de acuerdo al proyecto.
</p><p>El eje de proyecto puede también ser establecido a <code>ThisBuild</code>, que quiere decir
la “construcción entera” por lo que una entrada se aplica a toda la construcción
en lugar de a un único proyecto.
</p><p>La configuración a nivel de construcción es frecuentemente utilizada como
configuración predeterminada cuando un proyecto no define una entrada
específica. Explicaremos configuraciones a nivel de construcción más adelante en
esta página.
</p><h4 id="%C3%81mbito+con+el+eje+de+configuraci%C3%B3n">Ámbito con el eje de configuración<a href="#%C3%81mbito+con+el+eje+de+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Una <em>configuración de dependencia</em> (o simplemente “configuración”) define un
grafo de dependencias de bibliotecas, potencialmente con su propio classpath,
ficheros fuentes, paquetes generados, etc… El concepto de configuración de
dependencia proviene de Ivy, el cual es usado por sbt para gestionar
<a href="Library-Dependencies.html">dependencias</a> y de los <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">ámbitos de Maven</a>.
</p><p>Algunas configuraciones que verás en sbt:
</p><ul><li><code>Compile</code> que define la construcción de los ficheros principales
(<code>src/main/scala</code>).
</li><li><code>Test</code> que define cómo construir los tests (<code>src/test/scala</code>).
</li><li><code>Runtime</code> que define el classpath para la tarea <code>run</code>.
</li></ul><p>De forma predeterminada, todas las claves asociadas a la compilación,
empaquetado y ejecución tienen como ámbito una configuración y por tanto pueden
funcionar de forma diferente en cada configuración. Los ejemplos más ovios son
las claves tarea <code>compile</code>, <code>package</code> y <code>run</code>, y todas las claves que afectan
a dichas claves (tales como <code>sourceDirectories</code>, <code>scalacOptions</code> o
<code>fullClasspath</code>) también tienen una configuración como ámbito.
</p><p>Otra cosa a tener en cuenta sobre una configuración es que puede extender otras
configuraciones. La siguiente figura muestra la relación de extensión entre las
configuraciones más comunes.
</p><p><img src="../files/sbt-configurations.png" alt="dependency configurations"/>
</p><p><code>Test</code> y <code>IntegrationTest</code> extienden <code>Runtime</code>; <code>Runtime</code> extiende <code>Compile</code>;
<code>CompileInternal</code> extiende <code>Compile</code>, <code>Optional</code>, y <code>Provided</code>.
</p><h4 id="%C3%81mbito+con+el+eje+de+tarea">Ámbito con el eje de tarea<a href="#%C3%81mbito+con+el+eje+de+tarea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>La configuración puede afectar a cómo funciona una tarea. Por ejemplo, la tarea
<code>packageSrc</code> es afectada por la entrada <code>packageOptions</code>.
</p><p>Para soportar esto, una clave tarea (tal como <code>packageSrc</code>) puede tener un
ámbito para otra clave (tal como <code>packageOptions</code>).
</p><p>Las distintas tareas que construyen un paquete (<code>packageSrc</code>, <code>packageBin</code>,
<code>packageDoc</code>) pueden compartir claves relacionadas con el empaquetado, tales
como <code>artifactName</code> y <code>packageOptions</code> Esas claves pueden tener distintos
valores para cada tarea de empaquetado.
</p><h4 id="Componentes+con+%C3%A1mbito">Componentes con ámbito <code>Zero</code><a href="#Componentes+con+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Cada eje de ámbito puede ser rellenado tanto con una instancia del tipo del eje
(análogamente a como ocurre con <code>Some(_)</code>), o con el valor especial <code>Zero</code>.
Podemos pensar en <code>Zero</code> como <code>None</code>.
</p><p><code>Zero</code> es un comodín universal para todos los ejes de ámbito pero su uso directo
debería de estar reservado para sbt y, en todo caso, para los autores de
plugins.
</p><p><code>Global</code> es un ámbito que establece <code>Zero</code> para todos los ejes:
<code>Zero / Zero / Zero</code>. En otras palabras, <code>Global / clave</code> es un atajo para
<code>Zero / Zero / Zero / clave</code>.
</p><h3 id="Referenciar+%C3%A1mbitos+en+la+definici%C3%B3n+de+construcci%C3%B3n">Referenciar ámbitos en la definición de construcción<a href="#Referenciar+%C3%A1mbitos+en+la+definici%C3%B3n+de+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si creas una entrada en <code>build.sbt</code> con una clave plana entonces tendrá como ámbito
(subproyecto actual / configuración <code>Zero</code> / tarea <code>Zero</code>):
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;hello&quot;
  )
</code></pre><p>Si ejecutas sbt y lanzas <code>inspect name</code> podrás comprobar que es proporcionada por
<code>ProjectRef(uri(&quot;file:/private/tmp/hello/&quot;), &quot;root&quot;) / name</code>, es decir,
el proyecto es <code>ProjectRef(uri(&quot;file:/Users/xxx/hello/&quot;), &quot;root&quot;)</code> y ni el
ámbito de la configuración ni el de la tarea son mostrados (lo que significa
que son <code>Zero</code>).
</p><p>Una clave plana a la derecha también tiene como ámbito
(subproyecto actual / configuración <code>Zero</code> / tarea <code>Zero</code>):
</p><pre><code class="prettyprint lang-scala">organization := name.value
</code></pre><p>Los tipos de cualesquiera de los ejes de ámbito están extendidos para tener un
operador <code>/</code>. El argumento de <code>/</code> puede ser una clave u otro eje de ámbito. Así
que por ejemplo, aunque no hay ninguna razón de peso para hacer lo siguiente,
se podría tener una instancia de la clave <code>name</code> en el ámbito de la
configuración <code>Compile</code>:
</p><pre><code class="prettyprint lang-scala">Compile / name := &quot;hello&quot;
</code></pre><p>o podrías establecer <code>name</code> en el ámbito de la tarea <code>packageBin</code> (algo inútil,
sólo es un ejemplo).
</p><pre><code class="prettyprint lang-scala">packageBin / name := &quot;hello&quot;
</code></pre><p>o podrías establecer <code>name</code> con múltiples ejes de ámbito, por ejemplo con la
tarea <code>packageBin</code> en la configuración <code>Compile</code>:
</p><pre><code class="prettyprint lang-scala">Compile / packageBin / name := &quot;hello&quot;
</code></pre><p>o puedes utilizar <code>Global</code>:
</p><pre><code class="prettyprint lang-scala">// same as Zero / Zero / Zero / concurrentRestrictions
Global / concurrentRestrictions := Seq(
  Tags.limitAll(1)
)
</code></pre><p>(<code>Global / concurrentRestrictions</code> es convertido implícitamente a 
<code>Zero / Zero / Zero / concurrentRestrictions</code>, estableciendo todos los ejes a
ámbito <code>Zero</code>. De forma predeterminada las tareas y las configuraciones ya son
<code>Zero</code> de forma predeterminada por lo que la única utilidad de emplear esto es
la de establecer el proyecto a <code>Zero</code> en lugar de a
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Zero / Zero / concurrentRestrictions</code>)
</p><h3 id="Referenciar+%C3%A1mbitos+desde+el+shell+de+sbt">Referenciar ámbitos desde el shell de sbt<a href="#Referenciar+%C3%A1mbitos+desde+el+shell+de+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En la línea de comandos y en el shell de sbt, sbt muestra (y analiza) claves
con ámbito como esta:
</p><pre><code class="">ref / Config / intask / key
</code></pre><ul><li><code>ref</code> identifica el eje de subproyecto. Puede ser <code>&lt;project-id&gt;</code>,
<code>ProjectRef(uri(&quot;file:...&quot;), &quot;id&quot;)</code>, o <code>ThisBuild</code> para denotar el ámbito de
la construcción entera.
</li><li><code>Config</code> identifica el eje de configuración utilizando el identificador de
Scala empezando por mayúscula.
</li><li><code>intask</code> identifica el eje de tarea.
</li><li><code>key</code> identifica la clave a la que se le aplica el ámbito.
</li></ul><p><code>Zero</code> puede aparecer en cada eje.
</p><p>Si se omiten partes del ámbito de la clave, éstas serán inferidas siguiendo las
siguientes reglas:
</p><ul><li>el proyecto actual será utilizado si el proyecto es omitido
</li><li>la configuración dependiente de la clave será autodetectada si se omite la
configuración o la tarea.
</li></ul><p>Para más información ver <a href="../docs/Inspecting-Settings.html">Interactuar con el sistema de configuración</a>.
</p><h3 id="Ejemplos+de+la+notaci%C3%B3n+de+claves+con+%C3%A1mbito">Ejemplos de la notación de claves con ámbito<a href="#Ejemplos+de+la+notaci%C3%B3n+de+claves+con+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>fullClasspath</code> especifica simplemente una clave, por lo que los ámbitos
predeterminados son utilizados: proyecto actual, una configuración dependiente
de la clave y el ámbito de tarea <code>Zero</code>.
</li><li><code>Test / fullClasspath</code> emplea una configuración, por lo que es <code>fullClasspath</code>
en la configuración <code>Test</code>, con valores predeterminados para el resto de ejes.
</li><li><code>root / fullClasspath</code> especifica el proyecto <code>root</code>, donde el proyecto es
identificado por el identificador de proyecto.
</li><li><code>root / Zero / fullClasspath</code> especifica el proyecto <code>root</code> y <code>Zero</code> para la
configuración, en lugar de la predeterminada.
</li><li><code>doc / fullClasspath</code> especifica la clave <code>fullClasspath</code> en el ámbito de la
tarea <code>doc</code>, con los valores predeterminados para el eje del proyecto y el de
la configuración.
</li><li><code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath</code>
especifica el proyecto <code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;)</code>.
Además especifca la configuración <code>Test</code>, dejando el eje de tarea al valor
predeterminado.
</li><li><code>ThisBuild / version</code> establece el eje de subproyecto a la “construcción
entera” donde la construcción es <code>ThisBuild</code>, con la configuración
predeterminada.
</li><li><code>Zero / fullClasspath</code> establece el eje de subproyecto a <code>Zero</code>,
con la configuración predeterminada.
</li><li><code>root / Compile / doc / fullClasspath</code> establece todos los ejes de ámbito.
</li></ul><h3 id="Inspeccionar+%C3%A1mbitos">Inspeccionar ámbitos<a href="#Inspeccionar+%C3%A1mbitos" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En el shell de sbt, puedes utilizar el comando <code>inspect</code> para comprender las
claves y sus ámbitos. Prueba <code>inspect test / fullClasspath</code>:
</p><pre><code class="">$ sbt
sbt:Hello&gt; inspect Test / fullClasspath
[info] Task: scala.collection.Seq[sbt.internal.util.Attributed[java.io.File]]
[info] Description:
[info]  The exported classpath, consisting of build products and unmanaged and managed, internal and external dependencies.
[info] Provided by:
[info]  ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath
[info] Defined at:
[info]  (sbt.Classpaths.classpaths) Defaults.scala:1639
[info] Dependencies:
[info]  Test / dependencyClasspath
[info]  Test / exportedProducts
[info]  Test / fullClasspath / streams
[info] Reverse dependencies:
[info]  Test / testLoader
[info] Delegates:
[info]  Test / fullClasspath
[info]  Runtime / fullClasspath
[info]  Compile / fullClasspath
[info]  fullClasspath
[info]  ThisBuild / Test / fullClasspath
[info]  ThisBuild / Runtime / fullClasspath
[info]  ThisBuild / Compile / fullClasspath
[info]  ThisBuild / fullClasspath
[info]  Zero / Test / fullClasspath
[info]  Zero / Runtime / fullClasspath
[info]  Zero / Compile / fullClasspath
[info]  Global / fullClasspath
[info] Related:
[info]  Compile / fullClasspath
[info]  Runtime / fullClasspath
</code></pre><p>En la primera línea, se puede apreciar que esta es una tarea (y no una entrada,
tal y como se explica en <a href="Basic-Def.html">Definiciones de construcción</a>).
El valor resultante de la tarea es del tipo
<code>scala.collection.Seq[sbt.Attributed[java.io.File]]</code>.
</p><p>“Provided by” indica la clave con ámbito que define el valor, en este caso
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;) / Test / fullClasspath</code> (que es la
clave <code>fullClasspath</code> en el ámbito de la configuración <code>Test</code> y el proyecto
<code>ProjectRef(uri(&quot;file:/tmp/hello/&quot;), &quot;root&quot;)</code> project).
</p><p>“Dependencies” fue explicado en detalle en la <a href="Task-Graph.html">página anterior</a>.
</p><p>“Delegates” será explicado más adelante.
</p><p>Si ejecutas <code>inspect fullClasspath</code> (en oposición al ejemplo de arriba,
inspect <code>Test / fullClasspath</code>) podrás apreciar la diferencia. Debido a que la
configuración es omitida, es autodetectada como <code>Compile</code>.
<code>inspect Compile / fullClasspath</code> debería por tanto ser lo mismo que
<code>inspect fullClasspath</code>.
</p><p>Si ejecutas <code>inspect ThisBuild / Zero / fullClasspath</code> podrás obtener otro ejemplo.
De forma predeterminada <code>fullClasspath</code> no está definido en la ámbito de la
configuración <code>Zero</code>.
</p><p>Una vez más, para más información ver
<a href="../docs/Inspecting-Settings.html">Interactuar con el sistema de configuración</a>.
</p><h3 id="Cu%C3%A1ndo+especificar+un+%C3%A1mbito">Cuándo especificar un ámbito<a href="#Cu%C3%A1ndo+especificar+un+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Un ámbito necesita ser especificado si la clave en cuestión ya está asociada
a otro ámbito.
Por ejemplo, la tarea <code>compile</code>, de forma predeterminada, tiene como ámbito
las configuraciones <code>Compile</code> y <code>Test</code> y no existe fuera de dichos ámbitos.
</p><p>Para cambiar el valor asociado con la clave <code>compile</code> necesitas escribir
<code>Compile / compile</code> o <code>Test / compile</code>. Utilizar solamente <code>compile</code> definiría
una nueva tarea <code>compile</code> en el ámbito del proyecto actual, en lugar de
sobrescribir la tarea de compilación estándar, la cual tiene como ámbito una
configuración.
</p><p>Si obtienes un error como <em>“Reference to undefined setting“</em>, con frecuencia
significará que no has especificado un ámbito, o que has especificado el ámbito
equivocado. La clave que estás utilizando puede estar definida en otro ámbito.
sbt intentará sugerir lo que querías decir como parte del mensaje de error.
Busca cosas tipo “Did you mean Compile / compile?”
</p><p>Una forma de pensar en esto es que un nombre es solo una <em>parte</em> de una clave.
En realidad, todas las claves consisten tanto en un nombre como en un ámbito
(donde el ámbito tiene tres ejes).
La expresión completa <code>Compile / packageBin / packageOptions</code> es un nombre de
clave, dicho de otra forma.
<code>packageOptions</code> a secas también es un nombre de clave, pero uno diferente (uno
donde los ámbitos son implícitamente establecidos: proyecto actual,
configuración <code>Zero</code> y tarea <code>Zero</code>).
</p><h3 id="Configuraci%C3%B3n+a+nivel+de+construcci%C3%B3n">Configuración a nivel de construcción<a href="#Configuraci%C3%B3n+a+nivel+de+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Una técnica avanzada para extraer configuración común a todos los subproyectos
es definir valores en el ámbito de <code>ThisBuild</code>.
</p><p>Si una clave que tiene como ámbito un subproyecto en particular no se encuentra,
sbt la buscará en el ámbito de <code>ThisBuild</code>.
Usando este mecanismo, podemos definir valores predeterminados a nivel de
construcción para claves usadas con frecuencia tales como <code>version</code>,
<code>scalaVersion</code> y <code>organization</code>.
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;,
ThisBuild / scalaVersion := &quot;2.12.13&quot;,
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;

lazy val root = (project in file(&quot;.&quot;))
  .settings(
    name := &quot;Hello&quot;,
    publish / skip := true
  )

lazy val core = (project in file(&quot;core&quot;))
  .settings(
    // other settings
  )

lazy val util = (project in file(&quot;util&quot;))
  .settings(
    // other settings
  )
</code></pre><p>Convenientemente, existe una función <code>inThisBuild(...)</code> que definirá tanto
la clave como el valor al ámbito de <code>ThisBuild</code>. Definir valores aquí sería
equivalente a prefijar cada uno con <code>ThisBuild /</code> allá donde fuera posible.
</p><p>Debido a la naturaleza de la <a href="Scope-Delegation.html">delegación de ámbito</a> que
explicaremos más adelante, la configuración a nivel de construcción debería ser
utilizada sólo para valores puros o para valores en el ámbito de <code>Global</code> o
<code>ThisBuild</code>.
</p><h3 id="Delegaci%C3%B3n+de+%C3%A1mbito">Delegación de ámbito<a href="#Delegaci%C3%B3n+de+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Una clave con ámbito puede no haber sido definida, si no tiene un valor asociado
en su ámbito.
</p><p>Para cada eje de ámbito, sbt tiene un camino de búsqueda alternativo consistente
en otros valores con ámbito. Habitualmente, si una clave no tiene asociado un
valor en un ámbito específico, sbt intentará obtener un valor de un ámbito más
general, tal como el ámbito <code>ThisBuild</code>.
</p><p>Esta característica te permitirá establecer un valor una única vez en un
ámbito general, permitiendo múltiples ámbitos específicos que heredan el valor.
Lo discutiremos con mas detalle más tarde en
<a href="Scope-Delegation.html">Delegación de ámbito</a>.
</p><h2 id="A%C3%B1adir+valores">Añadir valores<a href="#A%C3%B1adir+valores" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="A%C3%B1adir+a+valores+existentes%3A++y">Añadir a valores existentes: <code>+=</code> y <code>++=</code><a href="#A%C3%B1adir+a+valores+existentes%3A++y" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>La asignación <code>:=</code> es la transformación más simple, pero las claves tienen
también otros métodos. Si <code>T</code> en <code>SettingKey[T]</code> es una secuencia, es decir,
si el tipo del valor de una clave es una secuencia, podrás añadir elementos a la
secuencia en lugar de reemplazarla.
</p><ul><li><code>+=</code> añadirá un único elemento a la secuencia
</li><li><code>++=</code> concatenará otra secuencia
</li></ul><p>Por ejemplo, la clave <code>Compile / sourceDirectories</code> tiene un <code>Seq[File]</code> por
valor. De forma predeterminada el valor de esta clave incluye <code>src/main/scala</code>.
Si quieres que además se compile el código fuente de un directorio llamado
source (en el caso de que por ejemplo no utilices una estructura de directorios
estándar) podrás añadir dicho directorio:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories += new File(&quot;source&quot;)
</code></pre><p>O convenientemente puedes utilizar la función <code>file()</code> del paquete sbt.
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories += file(&quot;source&quot;)
</code></pre><p>(<code>file()</code> crea un nueva instancia de <code>File</code>)
</p><p>Puedes usar <code>++=</code> para añadir más de un directorio a la vez:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories ++= Seq(file(&quot;sources1&quot;), file(&quot;sources2&quot;))
</code></pre><p>Donde <code>Seq(a, b, c, ...)</code> es la sintaxis estándar de Scala para construir una
secuencia.
</p><p>Por supuesto, para reemplazar totalmente los directorios de código fuente
predeterminados puedes seguir utilizando <code>:=</code>:
</p><pre><code class="prettyprint lang-scala">Compile / sourceDirectories := Seq(file(&quot;sources1&quot;), file(&quot;sources2&quot;))
</code></pre><h4 id="Cu%C3%A1ndo+no+est%C3%A1+definida+una+configuraci%C3%B3n">Cuándo no está definida una configuración<a href="#Cu%C3%A1ndo+no+est%C3%A1+definida+una+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Cuando una entrada utiliza <code>:=</code>, <code>+=</code> o <code>++=</code> para crear una dependencia sobre
sí misma o sobre el valor de otra clave, el valor sobre el que depende debe
existir. De lo contrario sbt se quejará. Puede que por ejemplo diga
<em>“Reference to undefined setting“</em>. Cuando esto suceda asegúrate de que estás
utilizando la clave en el <a href="Scopes.html">ámbito</a> donde está definida.
</p><p>Es posible crear referencias circulares, lo cual es un error. sbt te lo dirá
si lo haces.
</p><h4 id="Tareas+basadas+en+valores+de+otras+claves">Tareas basadas en valores de otras claves<a href="#Tareas+basadas+en+valores+de+otras+claves" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Puedes calcular el valor de algunas tareas o entradas definiendo o añadiendo
el valor de otra tarea. Esto se hace utilizando <code>Def.task</code> como argumento de
<code>:=</code>, <code>+=</code>, or <code>++=</code>.
</p><p>Como ejemplo, considera añadir un generador de código fuente utilizando
el directorio base del proyecto y el classpath de compilación.
</p><pre><code class="prettyprint lang-scala">Compile / sourceGenerators += Def.task {
  myGenerator(baseDirectory.value, (Compile / managedClasspath).value)
}
</code></pre><h3 id="A%C3%B1adir+con+dependencia%3A++y">Añadir con dependencia: <code>+=</code> y <code>++=</code><a href="#A%C3%B1adir+con+dependencia%3A++y" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Otras claves pueden ser utilizadas cuando se añade a una entrada o tarea
existente, al igual que se hacía para asignar con <code>:=</code>.
</p><p>Por ejemplo, digamos que tienes un informe de cobertura de código cuyo nombre
se basa en el nombre del proyecto y que quieres añadirlo a la lista de ficheros
que se borran cuando se invoca <code>clean</code>:
</p><pre><code class="prettyprint lang-scala">cleanFiles += file(&quot;coverage-report-&quot; + name.value + &quot;.txt&quot;)
</code></pre><h2 id="Delegaci%C3%B3n+de+%C3%A1mbito+%28resoluci%C3%B3n+de+.value%29">Delegación de ámbito (resolución de .value)<a href="#Delegaci%C3%B3n+de+%C3%A1mbito+%28resoluci%C3%B3n+de+.value%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página explica la delegación de ámbito. Se supone que has leído y
comprendido las páginas anteriores, <a href="Basic-Def.html">Definiciones de construcción</a> y
<a href="Scopes.html">Ámbitos</a>.
</p><p>Ahora que hemos cubierto todos los detalles de los ámbitos, podemos explicar la
resolución de <code>.value</code> en detalle. Te puedes saltar esta sección si es la
primera vez que lees esta página.
</p><p>Resumamos lo que hemos aprendido hasta ahora:
</p><ul><li>Un ámbito es una tupla de componentes de tres ejes: el eje de subproyecto,
el eje de configuración y el eje de tarea.
</li><li>Existe el componente de ámbito especial <code>Zero</code> utilizado por los tres ejes
de ámbito.
</li><li>Existe el componente de ámbito especial <code>ThisBuild</code> utilizado únicamente por
</li></ul><p>  <em>el eje de subproyecto</em>.
- <code>Test</code> extiende <code>Runtime</code> y <code>Runtime</code> extiende la configuración <code>Compile</code>.
- Una clave definida en build.sbt tiene como ámbito a
  <code>${current subproject} / Zero / Zero</code> de forma predeterminada.
- Una clave puede especificar un ámbito utilizando el operador <code>/</code>.
</p><p>Ahora supongamos que tenemos la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">lazy val foo = settingKey[Int](&quot;&quot;)
lazy val bar = settingKey[Int](&quot;&quot;)

lazy val projX = (project in file(&quot;x&quot;))
  .settings(
    foo := {
      (Test / bar).value + 1
    },
    Compile / bar := 1
  )
</code></pre><p>Dentro del cuerpo de la entrada de <code>foo</code>, la clave con ámbito <code>Test / bar</code>
ha sido declarada.
Sin embargo, a pesar de que <code>Test / bar</code> no está definida en <code>projX</code>, sbt sigue
siendo capaz de resolver <code>Test / bar</code> utilizando otra clave con ámbito,
lo que lleva a que <code>foo</code> sea inicializado a <code>2</code>.
</p><p>sbt tiene un camino alternativo bien definido llamado <em>delegación de ámbito</em>.
Esto permite establecer un valor una única vez en un ámbito más general,
permitiendo que ámbitos más específicos hereden tal valor.
</p><h3 id="Reglas+de+delegaci%C3%B3n+de+%C3%A1mbito">Reglas de delegación de ámbito<a href="#Reglas+de+delegaci%C3%B3n+de+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Estas son las reglas para la delegación de ámbito:
</p><ul><li>Regla 1: los ejes de ámbito tienen la siguiente precedencia:
el eje de subproyecto, el eje de configuración y finalmente el eje de tarea.
</li><li>Regla 2: Dado un ámbito, la delegación de ámbitos es utilizada sustituyendo
el eje de tarea en el siguiente orden:
el ámbito de dicha tarea y luego
<code>Zero</code>, que es la versión tarea-nula con ámbito de este ámbito.
</li><li>Regla 3: Dado un ámbito, la delegación de ámbitos es utilizada sustituyendo
el eje de configuración en el siguiente orden:
la propia configuración, sus ancestros y luego <code>Zero</code> (equivalente a un eje
de configuración sin ámbito).
</li><li>Regla 4: Dado un ámbito, la delegación de ámbitos es utilizada sustituyendo
el eje de subproyecto en el siguiente orden:
el propio proyecto, <code>ThisBuild</code> y luego <code>Zero</code>.
</li><li>Regla 5: Una clave con delegación de ámbito y sus entradas/tareas dependientes
son evaluadas sin acarrear el contexto original.
</li></ul><p>Estudiaremos cada regla en el resto de esta página.
</p><h3 id="Regla+1%3A+Precedencia+de+ejes+de+%C3%A1mbito">Regla 1: Precedencia de ejes de ámbito<a href="#Regla+1%3A+Precedencia+de+ejes+de+%C3%A1mbito" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Regla 1: los ejes de ámbito tienen la siguiente precedencia:
el eje de subproyecto, el eje de configuración y finalmente el eje de tarea.
</li></ul><p>En otras palabras, dados dos ámbitos candidatos, si uno de ellos tiene un valor
más específico en el eje de subproyecto entonces dicho eje siempre ganará sin
importar el ámbito de la configuración o la tarea.
De forma similar, si los subproyectos son los mismos, ganará el que tenga
un valor más específico en el eje de configuración, sin importar lo que tenga
en el ámbito de tarea.
Veremos más reglas para definir <em>más específico</em>.
</p><h3 id="Regla+2%3A+Delegaci%C3%B3n+del+eje+de+tarea">Regla 2: Delegación del eje de tarea<a href="#Regla+2%3A+Delegaci%C3%B3n+del+eje+de+tarea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Regla 2: Dado un ámbito, la delegación de ámbitos es utilizada
</li></ul><p>  <strong>sustituyendo</strong> el eje de tarea en el siguiente orden:
  el ámbito de dicha tarea y luego
  <code>Zero</code>, que es la versión tarea-nula con ámbito de este ámbito.
</p><p>Aquí tenemos una regla concreta que muestra cómo sbt empleará la delegación de ámbitos
dada una clave.
Recuerda, estamos intentando mostrar el camino de búsqueda a partir de un
<code>(xxx / yyy).value</code> cualquiera.
</p><p><strong>Ejercicio A</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">lazy val projA = (project in file(&quot;a&quot;))
  .settings(
    name := {
      &quot;foo-&quot; + (packageBin / scalaVersion).value
    },
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>¿Cuál es el valor de <code>projA / name</code>?
</p><ol><li><code>&quot;foo-2.11.11&quot;</code>
</li><li><code>&quot;foo-2.12.13&quot;</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>&quot;foo-2.11.11&quot;</code>.
Dentro de <code>.settings(...)</code>, <code>scalaVersion</code> tiene automáticamente un ámbito de
<code>projA / Zero / Zero</code>, por lo que <code>packageBin / scalaVersion</code> se convierte en
<code>projA / Zero / packageBin / scalaVersion</code>.
Esa clave con ámbito en particular no está definida. Utilizando la regla 2, sbt
sustituirá el eje de tarea a <code>Zero</code> como <code>projA / Zero / Zero</code> o
(<code>projA / scalaVersion</code>).
Esta clave con ámbito está definida como <code>&quot;2.11.11&quot;</code>.
</p><h3 id="Regla+3%3A+Resoluci%C3%B3n+del+eje+de+configuraci%C3%B3n">Regla 3: Resolución del eje de configuración<a href="#Regla+3%3A+Resoluci%C3%B3n+del+eje+de+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Regla 3: Dado un ámbito, la delegación de ámbitos es utilizada sustituyendo
el eje de configuración en el siguiente orden:
la propia configuración, sus ancestros y luego <code>Zero</code> (equivalente a un eje
de configuración sin ámbito).
</li></ul><p>El ejemplo es el <code>projX</code> que vimos antes:
</p><pre><code class="prettyprint lang-scala">lazy val foo = settingKey[Int](&quot;&quot;)
lazy val bar = settingKey[Int](&quot;&quot;)

lazy val projX = (project in file(&quot;x&quot;))
  .settings(
    foo := {
      (Test / bar).value + 1
    },
    Compile / bar := 1
  )
</code></pre><p>El ámbito completo es <code>projX / Test / Zero</code>.
Además, recordemos que <code>Test</code> extiende <code>Runtime</code> y que <code>Runtime</code> extiende
<code>Compile</code>.
</p><p><code>Test / bar</code> no está definido pero, debido a la Regla 3, sbt buscará <code>bar</code> con
ámbito <code>projX / Test / Zero</code>, <code>projX / Runtime / Zero</code> y finalmente
<code>projX / Compile / Zero</code>. Este último es encontrado, el cual es <code>Compile / bar</code>.
</p><h3 id="Regla+4%3A+Resoluci%C3%B3n+del+eje+de+subproyecto">Regla 4: Resolución del eje de subproyecto<a href="#Regla+4%3A+Resoluci%C3%B3n+del+eje+de+subproyecto" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Regla 4: Dado un ámbito, la delegación de ámbitos es utilizada sustituyendo
el eje de subproyecto en el siguiente orden:
el propio proyecto, <code>ThisBuild</code> y luego <code>Zero</code>.
</li></ul><p><strong>Ejercicio B</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">ThisBuild / organization := &quot;com.example&quot;

lazy val projB = (project in file(&quot;b&quot;))
  .settings(
    name := &quot;abc-&quot; + organization.value,
    organization := &quot;org.tempuri&quot;
  )
</code></pre><p>¿Cuál es el valor de <code>projB / name</code>?
</p><ol><li><code>&quot;abc-com.example&quot;</code>
</li><li><code>&quot;abc-org.tempuri&quot;</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>abc-org.tempuri</code>.
Aplicando la Regla 4, el primer intento se hace mirando <code>organization</code> con
ámbito <code>projB / Zero / Zero</code>, el cuál está definido en <code>projB</code> como
<code>&quot;org.tempuri&quot;</code>.
Éste tiene mayor precedencia que la configuración a nivel de construcción
<code>ThisBuild / organization</code>.
</p><h4 id="Precedencia+de+ejes+de+%C3%A1mbito%2C+otra+vez">Precedencia de ejes de ámbito, otra vez<a href="#Precedencia+de+ejes+de+%C3%A1mbito%2C+otra+vez" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><strong>Ejercicio C</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">ThisBuild / packageBin / scalaVersion := &quot;2.12.2&quot;

lazy val projC = (project in file(&quot;c&quot;))
  .settings(
    name := {
      &quot;foo-&quot; + (packageBin / scalaVersion).value
    },
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>¿Cuál es el valor de <code>projC / name</code>?
</p><ol><li><code>&quot;foo-2.12.2&quot;</code>
</li><li><code>&quot;foo-2.11.11&quot;</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>foo-2.11.11</code>.
<code>scalaVersion</code> con ámbito <code>projC / Zero / packageBin</code> no está definida.
La Regla 2 encuentra <code>projC / Zero / Zero</code>.
La regla 4 encuentra <code>ThisBuild / Zero / packageBin</code>.
En este caso la Regla 1 dice que el valor más específico del eje de subproyecto
gana, el cual es <code>projC / Zero / Zero</code>, que está definido como <code>&quot;2.11.11&quot;</code>.
</p><p><strong>Ejercicio D</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions += &quot;-Ywarn-unused-import&quot;

lazy val projD = (project in file(&quot;d&quot;))
  .settings(
    test := {
      println((Compile / console / scalacOptions).value)
    },
    console / scalacOptions -= &quot;-Ywarn-unused-import&quot;,
    Compile / scalacOptions := scalacOptions.value // added by sbt
  )
</code></pre><p>¿Qué saldría si ejecutamos <code>projD / test</code>?
</p><ol><li><code>List()</code>
</li><li><code>List(-Ywarn-unused-import)</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>List(-Ywarn-unused-import)</code>.
La Regla 2 encuentra <code>projD / Compile / Zero</code>,
la Regla 3 encuentra <code>projD / Zero / console</code>,
y la Regla 4 encuentra <code>ThisBuild / Zero / Zero</code>.
La Regla 1 elige <code>projD / Compile / Zero</code>
porque tiene tiene <code>projD</code> en el eje de subproyecto y dicho eje tiene mayor
precedencia que el eje de tarea.
</p><p>Después, <code>Compile / scalacOptions</code> hace referencia a <code>scalacOptions.value</code>,
luego necesitamos encontrar un delegado para <code>projD / Zero / Zero</code>.
La Regla 4 encuentra <code>ThisBuild / Zero / Zero</code> que finalmente resuelve a
<code>(-Ywarn-unused-import)</code>.
</p><h3 id="El+comando+inspect+para+listar+delegaciones">El comando inspect para listar delegaciones<a href="#El+comando+inspect+para+listar+delegaciones" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para saber qué está pasando puedes utilizar el comando <code>inspect</code>.
</p><pre><code class="">sbt:projd&gt; inspect projD / Compile / console / scalacOptions
[info] Task: scala.collection.Seq[java.lang.String]
[info] Description:
[info]  Options for the Scala compiler.
[info] Provided by:
[info]  ProjectRef(uri(&quot;file:/tmp/projd/&quot;), &quot;projD&quot;) / Compile / scalacOptions
[info] Defined at:
[info]  /tmp/projd/build.sbt:9
[info] Reverse dependencies:
[info]  projD / test
[info]  projD / Compile / console
[info] Delegates:
[info]  projD / Compile / console / scalacOptions
[info]  projD / Compile / scalacOptions
[info]  projD / console / scalacOptions
[info]  projD / scalacOptions
[info]  ThisBuild / Compile / console / scalacOptions
[info]  ThisBuild / Compile / scalacOptions
[info]  ThisBuild / console / scalacOptions
[info]  ThisBuild / scalacOptions
[info]  Zero / Compile / console / scalacOptions
[info]  Zero / Compile / scalacOptions
[info]  Zero / console / scalacOptions
[info]  Global / scalacOptions
</code></pre><p>Fíjate en que “Provided by” muestra que <code>projD / Compile / console / scalacOptions</code>
es proporcionado por <code>projD / Compile / scalacOptions</code>.
Además, bajo “Delegates”, <em>todos</em> los posibles candidatos son listados en orden
de precedencia.
</p><ul><li>Todos los ámbitos con ámbito <code>projD</code> en el eje de subproyecto son listados
primero, luego <code>ThisBuild</code> y luego <code>Zero</code>.
</li><li>Dentro de un subproyecto, los ámbitos que utilizan <code>Compile</code> en el eje de
configuración son listados primero y luego los de <code>Zero</code>.
</li><li>Finalmente, se listan los ejes de tarea con ámbito <code>console</code> y luego los que
no lo tienen.
</li></ul><h3 id="Resoluci%C3%B3n+de+.value+vs+enlace+din%C3%A1mico">Resolución de .value vs enlace dinámico<a href="#Resoluci%C3%B3n+de+.value+vs+enlace+din%C3%A1mico" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Regla 5: Una clave con delegación de ámbito y sus entradas/tareas dependientes
son evaluadas sin acarrear el contexto original.
</li></ul><p>Fíjate en que la delegación de ámbito se parece mucho a la herencia de clases de
un lenguaje orientado a objetos, aunque con una diferencia:
En un lenguaje orientado a objetos como Scala, cuando existe un método llamado
<code>drawShape</code> en un trait <code>Shape</code> sus subclases pueden sobrescribir el
comportamiento incluso cuando <code>drawShape</code> es utilizado por otros métodos en el
trait, lo es lo que se llama enlace dinámico.
</p><p>Sin embargo, en sbt la delegación de ámbito puede delegar un ámbito a uno más
general, como una configuración a nivel de proyecto hacia una configuración a
nivel de construcción, pero dicha configuración a nivel de construcción no puede
hacer referencia a la configuración a nivel de proyecto.
</p><p><strong>Ejercicio E</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;))
  .settings(
    inThisBuild(List(
      organization := &quot;com.example&quot;,
      scalaVersion := &quot;2.12.2&quot;,
      version      := scalaVersion.value + &quot;_0.1.0&quot;
    )),
    name := &quot;Hello&quot;
  )

lazy val projE = (project in file(&quot;e&quot;))
  .settings(
    scalaVersion := &quot;2.11.11&quot;
  )
</code></pre><p>¿Qué devolverá <code>projE / version</code>?
</p><ol><li><code>&quot;2.12.2_0.1.0&quot;</code>
</li><li><code>&quot;2.11.11_0.1.0&quot;</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>2.12.2_0.1.0</code>.
<code>projD / version</code> delega en <code>ThisBuild / version</code>,
que a su vez depende de <code>ThisBuild / scalaVersion</code>.
Debido a esto, la configuración a nivel de construcción debería limitarse
únicamente a asignaciones simples de valores.
</p><p><strong>Ejercicio F</strong>: Dada la siguiente definición de construcción:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions += &quot;-D0&quot;
scalacOptions += &quot;-D1&quot;

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions += &quot;-D2&quot;,
    Compile / scalacOptions += &quot;-D3&quot;,
    Compile / compile / scalacOptions += &quot;-D4&quot;,
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><p>¿Qué mostrará <code>projF / test</code>?
</p><ol><li><code>&quot;bippy-D4&quot;</code>
</li><li><code>&quot;bippy-D2-D4&quot;</code>
</li><li><code>&quot;bippy-D0-D3-D4&quot;</code>
</li><li>¿otra cosa?
</li></ol><p>La respuesta es <code>&quot;bippy-D0-D3-D4&quot;</code>.
Esta es una variación de un ejercicio creado originalmente por
<a href="https://gist.github.com/paulp/923154ab2d61882195cdea47483592ca">Paul Phillips</a>.
</p><p>Es una gran demostración de todas las reglas porque <code>someKey += &quot;x&quot;</code> se expande
a
</p><pre><code class="prettyprint lang-scala">someKey := {
  val old = someKey.value
  old :+ &quot;x&quot;
}
</code></pre><p>Al obtener el valor antiguo se dispara la delegación y debido a la Regla 5
se irá a otra clave con ámbito.
Librémonos del <code>+=</code> primero y anotemos los delegados para valores antiguos:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions := {
  // Global / scalacOptions &lt;- Regla 4
  val old = (ThisBuild / scalacOptions).value
  old :+ &quot;-D0&quot;
}

scalacOptions := {
  // ThisBuild / scalacOptions &lt;- Regla 4
  val old = scalacOptions.value
  old :+ &quot;-D1&quot;
}

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions := {
      // ThisBuild / scalacOptions &lt;- Reglas 2 y 4
      val old = (compile / scalacOptions).value
      old :+ &quot;-D2&quot;
    },
    Compile / scalacOptions := {
      // ThisBuild / scalacOptions &lt;- Reglas 3 y 4
      val old = (Compile / scalacOptions).value
      old :+ &quot;-D3&quot;
    },
    Compile / compile / scalacOptions := {
      // projF / Compile / scalacOptions &lt;- Reglas 1 y 2
      val old = (Compile / compile / scalacOptions).value
      old :+ &quot;-D4&quot;
    },
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><p>Esto se convierte en:
</p><pre><code class="prettyprint lang-scala">ThisBuild / scalacOptions := {
  Nil :+ &quot;-D0&quot;
}

scalacOptions := {
  List(&quot;-D0&quot;) :+ &quot;-D1&quot;
}

lazy val projF = (project in file(&quot;f&quot;))
  .settings(
    compile / scalacOptions := List(&quot;-D0&quot;) :+ &quot;-D2&quot;,
    Compile / scalacOptions := List(&quot;-D0&quot;) :+ &quot;-D3&quot;,
    Compile / compile / scalacOptions := List(&quot;-D0&quot;, &quot;-D3&quot;) :+ &quot;-D4&quot;,
    test := {
      println(&quot;bippy&quot; + (Compile / compile / scalacOptions).value.mkString)
    }
  )
</code></pre><h2 id="Dependencias+de+bibliotecas">Dependencias de bibliotecas<a href="#Dependencias+de+bibliotecas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página asume que has leído las páginas anteriores de la Guía de inicio, en
particular <a href="Basic-Def.html">Definiciones de construcción</a>, <a href="Scopes.html">Ámbitos</a> y
<a href="Task-Graph.html">Grafos de tareas</a>.
</p><p>Las dependencias de bibliotecas pueden ser añadidas de dos formas:
</p><ul><li>las <em>dependencias no gestionadas</em> son jars copiados en el directorio <code>lib</code>
</li><li>las <em>dependencias gestionadas</em> son configuradas en la definición de
construcción y descargadas automáticamente desde repositorios
</li></ul><h3 id="Dependencias+no+gestionadas">Dependencias no gestionadas<a href="#Dependencias+no+gestionadas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>La mayoría de la gente utiliza dependencias gestionadas en lugar de no
gestionadas. Pero las segundas son más simples de explicar cuando se empieza
con las dependencias.
</p><p>Las dependencias no gestionadas funcionan así: copia jars en <code>lib</code> y serán
añadidas en el classpath del proyecto. Y no hay más.
</p><p>También puedes copiar jars para tests como
<a href="https://scalacheck.org/">ScalaCheck</a>,
<a href="http://specs2.org">Specs2</a> y 
<a href="https://www.scalatest.org/">ScalaTest</a> en <code>lib</code>.
</p><p>Las dependencias en <code>lib</code> aparecen en todos los classpaths (para <code>compile</code>,
<code>test</code>, <code>run</code> y <code>console</code>). Si quieres cambiar el classpath para una sola de esas tareas deberías de ajustar <code>Compile / dependencyClasspath</code> o
<code>Runtime / dependencyClasspath</code>, por ejemplo.
</p><p>No hay que añadir nada en <code>build.sbt</code> para empezar a utilizar dependencias no
gestionadas, aunque puedes cambiar la clave <code>unmanagedBase</code> si quisieras
utilizar un directorio diferente a <code>lib</code>.
</p><p>Para utilizar <code>custom_lib</code> en lugar de <code>lib</code>:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;custom_lib&quot;
</code></pre><p><code>baseDirectory</code> es el directorio raíz del proyecto, por lo que aquí se está
cambiando <code>unmanagedBase</code> para que dependa de <code>baseDirectory</code> utilizando el
método especial <code>value</code>, como se explicó en <a href="Task-Graph.html">Grafos de tareas</a>.
</p><p>Existe también una tarea llamada <code>unmanagedJars</code> la cual lista los jars del
directorio <code>unmanagedBase</code>. Si quieres utilizar múltiples directorios o hacer
algo más complejo tendrías que reemplazar por completo la tarea <code>unmanagedJars</code>
con una que hiciese algo diferente, por ejemplo, devolver una lista para la
configuración <code>Compile</code> en lugar de los ficheros en el directorio <code>lib</code>:
</p><pre><code class="prettyprint lang-scala">Compile / unmanagedJars := Seq.empty[sbt.Attributed[java.io.File]]
</code></pre><h3 id="Dependencias+gestionadas">Dependencias gestionadas<a href="#Dependencias+gestionadas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt utiliza <a href="https://ant.apache.org/ivy/">Apache Ivy</a> para implementar
dependencias gestionadas, por lo que no tendrás demasiados problemas si ya estás
familiarizado con Ivy o Maven.
</p><h4 id="La+clave">La clave <code>libraryDependencies</code><a href="#La+clave" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>La mayor parte del tiempo, podrás simplemente listar tus dependencias en la
entrada <code>libraryDependencies</code>. Es incluso posible escribir un fichero POM de
Maven o un fichero de configuración de Ivy para configurar externamente tus
dependencias y hacer que sbt use esos ficheros de configuración externos.
Puedes obtener más información sobre cómo se puede hacer
<a href="../docs/Library-Management.html#External+Maven+or+Ivy">aquí</a>.
</p><p>Declarar una dependencia es parecido a esto, donde <code>groupId</code>, <code>artifactId</code> y
<code>revision</code> son cadenas de caracteres:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision
</code></pre><p>o a esto, donde <code>configuration</code> puede ser una cadena de caracteres o una
<code>Configuration</code> (such as <code>Test</code>):
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre><p><code>libraryDependencies</code> está declarado en 
<a href="../../api/sbt/Keys$.html#libraryDependencies:sbt.SettingKey[Seq[sbt.librarymanagement.ModuleID]]">Keys</a>
de esta forma:
</p><pre><code class="prettyprint lang-scala">val libraryDependencies = settingKey[Seq[ModuleID]](&quot;Declares managed dependencies.&quot;)
</code></pre><p>El método <code>%</code> crea un objeto de tipo <code>ModuleID</code> a partir de cadenas de
caracteres, que luego puede ser añadido a <code>libraryDependencies</code>.
</p><p>Por supuesto, sbt (via Ivy) tiene que saber de dónde descargar los módulos.
Si tu módulo está en uno de los repositorios predeterminados con los que cuenta
sbt entonces será suficiente. Por ejemplo, Apache Derby está en el repositorio
estándar de Maven2:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;
</code></pre><p>Si escribes eso en <code>build.sbt</code> y luego ejecutas <code>update</code>, sbt debería descargar
Derby en <code>~/.ivy2/cache/org.apache.derby/</code>. (Por cierto, <code>update</code> es una
dependencia de <code>compile</code> por lo que no hay necesidad de estar escribiendo 
<code>update</code> todo el rato.)
</p><p>Por supuesto, puedes también utilizar <code>++=</code> para añadir en un único paso una
serie de dependencias:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  groupID % artifactID % revision,
  groupID % otherID % otherRevision
)
</code></pre><p>En contadas ocasiones necesitarás utilizar <code>:=</code> con <code>libraryDependencies</code>.
</p><h4 id="Obteniendo+la+versi%C3%B3n+de+Scala+correcta+con">Obteniendo la versión de Scala correcta con <code>%%</code><a href="#Obteniendo+la+versi%C3%B3n+de+Scala+correcta+con" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Si usas <code>groupID %% artifactID % revision</code> en lugar de
<code>groupID % artifactID % revision</code> (la diferencia está en el doble <code>%%</code> tras 
<code>groupId</code>), sbt añadirá la versión del binario de Scala de tu proyecto al nombre
del artefacto. Esto simplemente es un atajo. Podrías escribir esto sin el <code>%%</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-tools&quot; % &quot;scala-stm_2.11&quot; % &quot;0.3&quot;
</code></pre><p>Si asumimos que <code>scalaVersion</code> para tu construcción es <code>2.11.1</code> lo siguiente es
idéntico a lo anterior (fíjate en el doble <code>%%</code> tras <code>&quot;org.scala-tools&quot;</code>):
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-tools&quot; %% &quot;scala-stm&quot; % &quot;0.3&quot;
</code></pre><p>La idea es que muchas dependencias son compiladas para múltiples versiones de
Scala y con toda seguridad lo que querrás será obtener aquella que ofrece
compatibilidad binaria con tu proyecto.
</p><p>Para más información ver <a href="../docs/Cross-Build.html">Construcción cruzada</a>.
</p><h4 id="Revisiones+Ivy">Revisiones Ivy<a href="#Revisiones+Ivy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>revision</code> en <code>groupID % artifactID % revision</code> no tiene por qué ser una versión
fija. Ivy puede seleccionar la última revisión de un módulo de acuerdo a las
restricciones que especifiques. En lugar de una revisión fija como <code>&quot;1.6.1&quot;</code>,
puedes especificar <code>&quot;latest.integration&quot;</code>, <code>&quot;2.9.+&quot;</code>, or <code>&quot;[1.0,)&quot;</code>.
Para más información ver la documentación de
<a href="https://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision">Revisiones Ivy</a>.
</p><!-- TODO: Add aliases -->
<p>En ocasiones, un “rango de versiones” de Maven es utilizado para especificar una
dependencia (transitiva o de otro tipo), tales como <code>[1.3.0,)</code>. Si una versión
específica de la dependencia es declarada en la construcción y satisface el
rango entonces sbt usará la versión especificada. En otro caso, Ivy tendrá que
encontrar la última versión. Esto puede ocasionar un comportamiento inesperado
donde la versión efectiva va cambiando a lo largo del tiempo, incluso cuando hay
una versión específica de la biblioteca que satisface la condición del rango.
</p><!-- TODO: Maven version ranges will be replaced with its lower bound if the
build so that when a satisfactory version is found in the dependency
graph it will be used.  You can disable this behavior using the JVM
flag `-Dsbt.modversionrange=false`. -->
<h4 id="Resolvedores">Resolvedores<a href="#Resolvedores" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>No todos los paquetes viven en el mismo servidor. sbt utiliza el repositorio
estándar de Maven2 de forma predeterminada. Si tu dependencia no está en uno de
los repositorios predeterminados tendrás que añadir un <em>resolvedor</em> para que Ivy
lo pueda encontrar.
</p><p>Para añadir un repositorio adicional utiliza:
</p><pre><code class="prettyprint lang-scala">resolvers += name at location
</code></pre><p>con el método especial <code>at</code> entre dos cadenas de caracteres.
</p><p>Por ejemplo:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>La clave <code>resolvers</code> está definida
<a href="../../api/sbt/Keys$.html#resolvers:sbt.SettingKey[Seq[sbt.librarymanagement.Resolver]]">Keys</a>
de la siguiente forma:
</p><pre><code class="prettyprint lang-scala">val resolvers = settingKey[Seq[Resolver]](&quot;The user-defined additional resolvers for automatically managed dependencies.&quot;)
</code></pre><p>El método <code>at</code> crea un objecto de tipo <code>Resolver</code> a partir de dos cadenas de
caracteres.
</p><p>sbt puede buscar en tu repositorio local de Maven si lo añades como repositorio:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
</code></pre><p>o, convenientemente:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.mavenLocal
</code></pre><p>Para más información sobre cómo definir otros tipos de repositorios ver
<a href="../docs/Resolvers.html">Resolvedores</a>.
</p><h4 id="Sobrescribiendo+resolvedores+predeterminados">Sobrescribiendo resolvedores predeterminados<a href="#Sobrescribiendo+resolvedores+predeterminados" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>resolvers</code> no contiene los resolvedores predeterminados, solo los adicionales
añadidos por tu definición de construcción.
</p><p>sbt combina <code>resolvers</code> con algunos repositorios predeterminados para formar
<code>externalResolvers</code>.
</p><p>Por tanto, para cambiar o eliminar los resolvedores predeterminados tendrías que
sobrescribir <code>externalResolvers</code> en lugar de <code>resolvers</code>.
</p><h4 id="Dependencias+por+configuraci%C3%B3n">Dependencias por configuración<a href="#Dependencias+por+configuraci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A menudo una dependencia es necesaria para tu código de test
(en <code>src/test/scala</code>, el cual es compilado por la configuración <code>Test</code>)
pero no así tu código fuente principal.
</p><p>Si quieres añadir una dependencia que aparezca solo en el classpath de la
configuración <code>Test</code> pero no en la de <code>Compile</code> puedes añadir un <code>% &quot;test&quot;</code>
de la siguiente forma:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot; % &quot;test&quot;
</code></pre><p>También puedes utilizar la versión tipada de la configuración <code>Test</code> de esta
forma:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot; % Test
</code></pre><p>Ahora, si escribes <code>show compile:dependencyClasspath</code> en el prompt interactivo
de sbt no deberías ver listado el jar de Derby. Pero si escribes
<code>show test:dependencyClasspath</code> sí que deberías de verlo.
</p><p>Habitualmente, las dependencias relacionadas con tests tales como 
<a href="https://scalacheck.org/">ScalaCheck</a>,
<a href="http://specs2.org">Specs2</a> y 
<a href="https://www.scalatest.org/">ScalaTest</a> debería de ir definidas con <code>% &quot;test&quot;</code>.
</p><p>Existen más detalles, consejos y trucos relacionados con las dependencias de
bibliotecas en <a href="../docs/Library-Management.html">esta página</a>.
</p><h2 id="Usar+plugins">Usar plugins<a href="#Usar+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Por favor, lee primero las páginas anteriores de la Guía de inicio, en particular <a href="Basic-Def.html">Definiciones de construcción</a>, <a href="Task-Graph.html">Grafos de tareas</a> y 
<a href="Library-Dependencies.html">Dependencias de bibliotecas</a> antes de leer esta página.
</p><h3 id="%C2%BFQu%C3%A9+es+un+plugin%3F">¿Qué es un plugin?<a href="#%C2%BFQu%C3%A9+es+un+plugin%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Un plugin extiende la definición de construcción, usualmente añadiendo nueva configuración. La nueva configuración puede incluir nuevas tareas. Por ejemplo, un plugin puede añadir una tarea <code>codeCoverage</code> para generar un informe de cobertura de código de test.
</p><h3 id="Declarar+un+plugin">Declarar un plugin<a href="#Declarar+un+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si tu proyecto está en un directorio llamado <code>hello</code> y quieres añadir el plugin <code>sbt-site</code> a la definición de construcción, crea el fichero <code>hello/project/site.sbt</code> y declara la dependencia del plugin pasando el módulo Ivy del plugin a <code>addSbtPlugin</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-site&quot; % &quot;0.7.0&quot;)
</code></pre><p>Si quieres añadir <code>sbt-assembly</code>, crea <code>hello/project/assembly.sbt</code> con el siguiente contenido:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.11.2&quot;)
</code></pre><p>No todos los plugins están ubicados en uno de los repositorios predeterminados. La documentación del plugin te puede instar a que añadas el repositorio donde se encuentra:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sonatypeRepo(&quot;public&quot;)
</code></pre><p>Por lo general los plugins proporcionan configuraciones que son añadidas a la del proyecto para habilitar la funcionalidad del plugin. Esto es explicado en la siguiente sección:
</p><h3 id="Habilitando+e+inhabilitando+autoplugins">Habilitando e inhabilitando autoplugins<a href="#Habilitando+e+inhabilitando+autoplugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Un plugin puede declarar que su configuración debería de ser automáticamente añadida a la definición de construcción, en cuyo caso no tienes que hacer nada para añadirla.
</p><p>A partir de sbt 0.13.5 se introdujo la nueva característica <a href="../docs/Plugins.html">autoplugins</a> la cual permite asegurar que la configuración de un plugin está disponible en el proyecto de forma automática y de un modo seguro. Muchos autoplugins deberían contar con su configuración predeterminada automáticamente, sin embargo esto requiere la activación explícita.
</p><p>Si estás utilizando un autoplugin que requiere activación explícita entonces tendrás que añadir lo siguiente en tu <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))
  .enablePlugins(FooPlugin, BarPlugin)
  .settings(
    name := &quot;hello-util&quot;
  )
</code></pre><p>El método <code>enablePlugins</code> permite a los proyectos definir explícitamente qué autoplugins quieren utilizar.
</p><p>Los proyectos también pueden excluir plugins con el método <code>disablePlugins</code>. Por ejemplo, si queremos eliminar la configuración de <code>IvyPlugin</code> en <code>util</code> tendríamos que modificar nuestro <code>build.sbt</code> de la siguiente manera:
</p><pre><code class="prettyprint lang-scala">lazy val util = (project in file(&quot;util&quot;))
  .enablePlugins(FooPlugin, BarPlugin)
  .disablePlugins(plugins.IvyPlugin)
  .settings(
    name := &quot;hello-util&quot;
  )
</code></pre><p>Los autoplugins deberían documentar si necesitan o no ser explícitamente habilitados. Si sientes curiosidad por saber qué autoplugins están habilitados para un proyecto, puedes ejecutar el comando <code>plugins</code> en la consola de sbt.
</p><p>Por ejemplo:
</p><pre><code class="">&gt; plugins
In file:/home/jsuereth/projects/sbt/test-ivy-issues/
        sbt.plugins.IvyPlugin: enabled in scala-sbt-org
        sbt.plugins.JvmPlugin: enabled in scala-sbt-org
        sbt.plugins.CorePlugin: enabled in scala-sbt-org
        sbt.plugins.JUnitXmlReportPlugin: enabled in scala-sbt-org
</code></pre><p>Aquí, la salida de <code>plugins</code> nos está mostrando que los plugins predeterminados de sbt están todos habilitados. La configuración predeterminada de sbt es proporcionada via tres plugins:
</p><ol><li><code>CorePlugin</code>: Proporciona los controles de paralelismo de tareas del núcleo.
</li><li><code>IvyPlugin</code>: Proporciona los mecanismos para publicar/resolver módulos.
</li><li><code>JvmPlugin</code>: Proporciona los mecanismos para compilar/testear/ejecutar/empaquetar proyectos de Java/Scala.
</li></ol><p>Adicionalmente, <code>JUnitXmlReportPlugin</code> proporciona soporte experimental para generar junit-xml.
</p><p>Algunos plugins no automáticos antiguos a menudo necesitan que su configuración sea añadida explícitamente, por lo que las <a href="Multi-Project.html">construcciones multiproyecto</a> pueden tener diferentes tipos de proyectos.
La documentación del plugin indicará cómo configurarlo, pero típicamente para plugins antiguos esto implica añadir la configuración base del plugin y modificarla según sea necesario.
</p><p>Por ejemplo, para el plugin <code>sbt-site</code>, necesitarías crear un fichero <code>site.sbt</code> con el siguiente contenido para habilitarlo para ese proyecto:
</p><pre><code class="prettyprint lang-scala">site.settings
</code></pre><p>Si la construcción define múltiples proyectos, entonces añádelo directamente al proyecto:
</p><pre><code class="prettyprint lang-scala">// inhabilitar el plugin site para el proyecto ´util´
lazy val util = (project in file(&quot;util&quot;))

// habilitar el plugin site para el proyecto `core`
lazy val core = (project in file(&quot;core&quot;))
  .settings(site.settings)
</code></pre><h3 id="Plugins+globales">Plugins globales<a href="#Plugins+globales" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Los plugins pueden ser instalados para todos tus proyectos a la vez
declarándolos en <code>$HOME/.sbt/1.0/plugins/</code>. <code>$HOME/.sbt/1.0/plugins/</code> es un proyecto sbt cuyo classpath es exportado a todos los proyectos de la definición de construcción. Más o menos, cualquier fichero <code>.sbt</code> y <code>.scala</code> en <code>$HOME/.sbt/1.0/plugins/</code> se comporta como si estuviera en el directorio <code>project/</code> de cada uno de los proyectos.
</p><p>Puedes crear <code>$HOME/.sbt/1.0/plugins/build.sbt</code> y poner expresiones <code>addSbtPlugin()</code> ahí para añadir plugins a todos tus proyectos a la vez.
Debido a que hacer eso incrementaría la dependencia a nivel local, esta característica debería ser utilizada con moderación. Para más información ver <a href="../docs/Best-Practices.html#global-vs-local-plugins">Buenas prácticas</a>.
</p><h3 id="Plugins+disponibles">Plugins disponibles<a href="#Plugins+disponibles" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Existe <a href="../docs/Community-Plugins.html">una lista de plugins disponibles</a>.
</p><p>Algunos plugins especialmente famosos son:
</p><ul><li>aquellos para los IDEs (para importar un proyecto sbt en tu IDE)
</li><li>aquellos que soportan frameworks web, tales como <a href="https://github.com/earldouglas/xsbt-web-plugin">xsbt-web-plugin</a>
</li></ul><p>Para más información, incluyendo cómo desarrollar plugins, ver <a href="../docs/Plugins.html">Plugins</a>.
Para saber más acerca de las mejores prácticas ver <a href="../docs/Plugins-Best-Practices.html">Plugins - Mejores prácticas</a>.
</p><h2 id="Entradas+y+tareas+personalizadas">Entradas y tareas personalizadas<a href="#Entradas+y+tareas+personalizadas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página sirve de introducción para crear entradas y tareas personalizadas.
</p><p>Para entender esta página, asegúrate de que has leído las páginas anteriores de
la Guía de inicio, en particular <a href="Basic-Def.html">Definiciones de construcción</a> y
<a href="Task-Graph.html">Grafos de tareas</a>.
</p><h3 id="Definir+una+clave">Definir una clave<a href="#Definir+una+clave" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="../../api/sbt/Keys$.html">Keys</a> está lleno de ejemplos que ilustran cómo definir
claves. La mayoría de las claves están implementadas en
<a href="https://github.com/sbt/sbt/blob/develop/main/src/main/scala/sbt/Defaults.scala">Defaults</a>.
</p><p>Una clave tiene uno de tres posibles tipos: <code>SettingKey</code> y <code>TaskKey</code> son
descritos en <a href="Basic-Def.html">Definiciones de construcción</a>. Para saber más acerca de
<code>InputKey</code> puedes ver la página <a href="../docs/Input-Tasks.html">Tareas con entrada</a>.
</p><p>Algunos ejemplos de <a href="../../api/sbt/Keys$.html">Keys</a>:
</p><pre><code class="prettyprint lang-scala">val scalaVersion = settingKey[String](&quot;The version of Scala used for building.&quot;)
val clean = taskKey[Unit](&quot;Deletes files produced by the build, such as generated sources, compiled classes, and task caches.&quot;)
</code></pre><p>Los constructores de claves toman como parámetros dos cadenas de caracteres: el
nombre de la clave (<code>&quot;scalaVersion&quot;</code>) y una descripción
(<code>&quot;The version of Scala used for building.&quot;</code>).
</p><p>Como recordarás, en <a href="Basic-Def.html">Definición de construcción</a> se explica que el
tipo del parámetro <code>T</code> en <code>SettingsKey[T]</code> indica el tipo del valor que tiene la
entrada. <code>T</code> en <code>TaskKey[T]</code> indica el tipo del resultado de la tarea. También
recordarás que una entrada tiene un valor fijo único hasta la siguiente recarga
del proyecto, mientras que una tarea es recalculada para cada
“ejecución de la tarea” (cada vez que alguien escribe un comando en el prompt
interactivo de sbt o utiliza el modo por lotes).
</p><p>Las claves pueden estar definidas en un <a href="Basic-Def.html">fichero .sbt</a>, un
<a href="Organizing-Build.html">fichero .scala</a> o un <a href="Using-Plugins.html">autoplugin</a>.
Cualesquiera <code>val</code> encontrados bajo el objeto <code>autoImport</code> de un autoplugin
habilitado será importado automáticamente en tus ficheros <code>.sbt</code>.
</p><h3 id="Implementar+una+tarea">Implementar una tarea<a href="#Implementar+una+tarea" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Una vez que hayas definido una clave para tu tarea necesitarás completarla con
una definición de tarea. Puedes tanto definir tu propia tarea como redefinir
una ya existente. Para cualquiera de los dos casos hay que utilizar <code>:=</code> para
asociar cierto código con la clave tarea.
</p><pre><code class="prettyprint lang-scala">val sampleStringTask = taskKey[String](&quot;A sample string task.&quot;)
val sampleIntTask = taskKey[Int](&quot;A sample int task.&quot;)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val library = (project in file(&quot;library&quot;))
  .settings(
    sampleStringTask := System.getProperty(&quot;user.home&quot;),
    sampleIntTask := {
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      sum
    }
  )
</code></pre><p>Si la tarea tiene dependencias deberías referenciar su valor utilizando <code>value</code>
tal cual se explicó en <a href="Task-Graph.html">Grafos de tareas</a>.
</p><p>La parte más difícil sobre cómo implementar las tareas normalmente no tiene nada que ver
con sbt, ya que las tareas son simplemente código de Scala. La parte difícil
sería escribir el “cuerpo” de tu tarea para que haga aquello que estás
intentando hacer. Por ejemplo, puede que estés intentando formatear un texto en
HTML para lo cual puede que requieras la utilización de una biblioteca de HTML
(puede que necesites
<a href="Using-Plugins.html">añadir una dependencia de biblioteca a tu definición de construcción</a>
y escribir código basado en dicha biblioteca).
</p><p>sbt tiene algunas bibliotecas útiles y funciones convenientes, en particular
puedes utilizar la APIs de <a href="../../api/sbt/io/IO$.html">IO</a> para manipular ficheros
y directorios.
</p><h3 id="Sem%C3%A1ntica+de+ejecuci%C3%B3n+de+las+tareas">Semántica de ejecución de las tareas<a href="#Sem%C3%A1ntica+de+ejecuci%C3%B3n+de+las+tareas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Cuando una tarea personalizada utiliza <code>value</code> para depender de otras tareas, algo importante a tener en cuenta es la semántica de ejecución de las tareas.
Por semántica de ejecución nos referimos a <em>cuándo</em> exactamente estas tareas son
evaluadas.
</p><p>Si tomamos por ejemplo <code>sampleIntTask</code>, cada línea del cuerpo de la tarea
debería de ser evaluada estrictamente una tras otra.
Eso es semántica secuencial:
</p><pre><code class="prettyprint lang-scala">sampleIntTask := {
  val sum = 1 + 2        // primera
  println(&quot;sum: &quot; + sum) // segunda
  sum                    // tercera
}
</code></pre><p>En realidad, la JVM puede ejecutar <code>sum</code> en línea y hacer que valga 3, pero el
<em>efecto</em> observable de la tarea permanecerá intacto como si cada línea fuese
ejecutada una tras otra.
</p><p>Supongamos ahora que definimos dos o más tareas personalizadas <code>startServer</code> y
<code>stopServer</code>, y modificamos <code>sampleIntTask</code> como sigue:
</p><pre><code class="prettyprint lang-scala">val startServer = taskKey[Unit](&quot;start server&quot;)
val stopServer = taskKey[Unit](&quot;stop server&quot;)
val sampleIntTask = taskKey[Int](&quot;A sample int task.&quot;)
val sampleStringTask = taskKey[String](&quot;A sample string task.&quot;)

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val library = (project in file(&quot;library&quot;))
  .settings(
    startServer := {
      println(&quot;starting...&quot;)
      Thread.sleep(500)
    },
    stopServer := {
      println(&quot;stopping...&quot;)
      Thread.sleep(500)
    },
    sampleIntTask := {
      startServer.value
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      stopServer.value // THIS WON'T WORK
      sum
    },
    sampleStringTask := {
      startServer.value
      val s = sampleIntTask.value.toString
      println(&quot;s: &quot; + s)
      s
    }
  )
</code></pre><p>Al ejecutar <code>sampleIntTask</code> desde el prompt interactivo de sbt el resultado
será el siguiente:
</p><pre><code class="">&gt; sampleIntTask
stopping...
starting...
sum: 3
[success] Total time: 1 s, completed Dec 22, 2014 5:00:00 PM
</code></pre><p>Para revisar qué ha sucedido vamos a mirar la notación gráfica de
<code>sampleIntTask</code>:
</p><p><img src="../files/task-dependency00.png" alt="task-dependency"/>
</p><p>A diferencia de las llamadas a métodos normales de Scala, el hecho de llamar al método
<code>value</code> en tareas no hará que sea evaluado estrictamente. En su lugar,
simplemente servirá para declarar que <code>sampleIntTask</code> depende de
las tareas <code>startServer</code> y <code>stopServer</code>.
Cuando <code>sampleIntTask</code> es invocado, el motor de tareas de sbt hará lo siguiente:
</p><ul><li>evaluará las dependencias de las tareas <em>antes</em> de evaluar <code>sampleIntTask</code>
(orden parcial)
</li><li>intentará evaluar las dependencias de las tareas en paralelo si son
independientes (paralelización)
</li><li>cada dependencia de la tarea será evaluada una única vez por cada ejecución
del comando (deduplicación)
</li></ul><h4 id="Deduplicaci%C3%B3n+de+dependencias+de+tareas">Deduplicación de dependencias de tareas<a href="#Deduplicaci%C3%B3n+de+dependencias+de+tareas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Para demostrar el último punto, podemos ejecutar <code>sampleStringTask</code> desde el
prompt interactivo de sbt.
</p><pre><code class="">&gt; sampleStringTask
stopping...
starting...
sum: 3
s: 3
[success] Total time: 1 s, completed Dec 22, 2014 5:30:00 PM
</code></pre><p>Debido a que <code>sampleStringTask</code> depende tanto de <code>startServer</code> como de
<code>sampleIntTask</code>, y <code>sampleIntTask</code> depende a su vez de <code>startServer</code>, ésta
aparece dos veces listada como dependencia.
Si fuese una llamada normal a un método de Scala, ésta sería evaluada dos
veces, pero debido a que <code>value</code> se usa simplemente para indicar la
dependencia de otra tarea, ésta es evaluada sólo una vez. A continuación se
muestra una notación gráfica de la evaluación de <code>sampleStringTask</code>:
</p><p><img src="../files/task-dependency01.png" alt="task-dependency"/>
</p><p>Si no hubiésemos deduplicado las dependencias de tareas habríamos acabado
compilando el código fuente de los tests muchas veces cuando la tarea <code>test</code>
hubiese sido invocada, ya que <code>Test / compile</code> aparece muchas veces como
dependencia de <code>Test / test</code>.
</p><h4 id="Tarea+de+limpieza">Tarea de limpieza<a href="#Tarea+de+limpieza" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Entonces ¿cómo se podría implementar la tarea <code>stopServer</code>?
La noción de tarea de limpieza no encaja en el modelo de ejecución de tareas
debido a que las tareas tratan de seguir dependencias.
La última operación debería ser la tarea que depende de otras tareas
intermedias. Por ejemplo <code>stopServer</code> debería depender de <code>sampleStringTask</code> por
lo que <code>stopServer</code> debería de ser <code>sampleStringTask</code>.
</p><pre><code class="prettyprint lang-scala">lazy val library = (project in file(&quot;library&quot;))
  .settings(
    startServer := {
      println(&quot;starting...&quot;)
      Thread.sleep(500)
    },
    sampleIntTask := {
      startServer.value
      val sum = 1 + 2
      println(&quot;sum: &quot; + sum)
      sum
    },
    sampleStringTask := {
      startServer.value
      val s = sampleIntTask.value.toString
      println(&quot;s: &quot; + s)
      s
    },
    sampleStringTask := {
      val old = sampleStringTask.value
      println(&quot;stopping...&quot;)
      Thread.sleep(500)
      old
    }
  )
</code></pre><p>Para demostrar que esto funciona ejecutemos <code>sampleStringTask</code> desde el prompt
interactivo:
</p><pre><code class="">&gt; sampleStringTask
starting...
sum: 3
s: 3
stopping...
[success] Total time: 1 s, completed Dec 22, 2014 6:00:00 PM
</code></pre><p><img src="../files/task-dependency02.png" alt="task-dependency"/>
</p><h4 id="Usar+Scala">Usar Scala<a href="#Usar+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Otra forma de asegurarse de que algo sucede después de algo es usando Scala.
Si se implementa una función simple en <code>project/ServerUtil.scala</code> por ejemplo
se podrá escribir:
</p><pre><code class="prettyprint lang-scala">sampleIntTask := {
  ServerUtil.startServer
  try {
    val sum = 1 + 2
    println(&quot;sum: &quot; + sum)
  } finally {
    ServerUtil.stopServer
  }
  sum
}
</code></pre><p>Ya que las llamadas a métodos normales siguen la semántica secuencial todo
sucede en orden.
No hay deduplicación, por lo que ya no hay que preocuparse por eso.
</p><h3 id="Conversi%C3%B3n+en+plugins">Conversión en plugins<a href="#Conversi%C3%B3n+en+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Si te has encontrado con un montón de código personalizado podrías considerar
moverlo a un plugin para reutilizarlo a lo largo de múltiples construcciones.
Es muy fácil crear un plugin, como se <a href="Using-Plugins.html">mostró antes</a>
y <a href="../docs/Plugins.html">explicó con más detalle aquí</a>.
</p><p>Esta página ha sido solo un aperitivo. Hay mucho mucho más sobre tareas
personalizadas en la página de <a href="../docs/Tasks.html">Tareas</a>.
</p><h2 id="Organizar+la+construcci%C3%B3n">Organizar la construcción<a href="#Organizar+la+construcci%C3%B3n" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página explica la organización de la estructura de la construcción.
</p><p>Por favor, lee primero las páginas anteriores de la Guía de inicio, en particular <a href="Basic-Def.html">Definiciones de construcción</a>, <a href="Task-Graph.html">Grafos de tareas</a>,
<a href="Library-Dependencies.html">Dependencias de bibliotecas</a> y
<a href="Multi-Project.html">Construcciones multiproyecto</a> antes de leer esta página.
</p><h3 id="sbt+es+recursivo">sbt es recursivo<a href="#sbt+es+recursivo" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>build.sbt</code> esconde cómo trabaja en realidad sbt. Las construcciones de sbt son
definidas con código de Scala. Ese código, en sí mismo, ha de ser construido.
¿Qué mejor forma de hacerlo que con sbt?
</p><p>El directorio <code>project</code> <em>es otra construcción dentro de tu construcción</em>, la
cual sabe cómo construir tu construcción. Para distinguir las construcciones a
veces utilizamos el término <strong>construcción propia</strong> para referirnos a tu
construcción y <strong>metaconstrucción</strong> para referirnos a la construcción que está
en <code>project</code>. Los proyectos dentro de la metaconstrucción pueden hacer lo que
cualquier otro proyecto puede.
<em>Tu definición de construcción es un proyecto sbt.</em>
</p><p>Y así hasta el infinito. Si quieres, puedes personalizar la definición de
construcción de la definición de construcción del proyecto, creando un
directorio <code>project/project/</code>.
</p><p>Aquí se explica con una ilustración.
</p><pre><code class="">hello/                     # el directorio base del proyecto raíz
                           # de tu construcción

    Hello.scala            # un fichero fuente en el proyecto raíz de tu
                           # construcción (también podría estar en
                           # src/main/scala)

    build.sbt              # build.sbt es parte del código fuente para el
                           # proyecto raíz de la metaconstrucción dentro de
                           # project/; la definición de construcción para
                           # tu construcción

    project/               # directorio base del proyecto raíz de la
                           # metaconstrucción

        Dependencies.scala # un fichero fuente en el proyecto raíz de la
                           # metaconstrucción, es decir, un fichero fuente en
                           # la definición de construcción de la definición
                           # de construcción para tu construcción

        assembly.sbt       # esto es parte del código fuente para el proyecto
                           # raíz de la meta-metaconstrucción en
                           # project/project; la definición de construcción de
                           # la definición de construcción

        project/           # directorio base del proyecto raíz de la
                           # meta-metaconstrucción; el proyecto de la definición
                           # de construcción para la definición de construcción

            MetaDeps.scala # fichero fuente en el proyecto raíz de la
                           # meta-metaconstrucción en project/project/
</code></pre><p><em>¡No te preocupes!</em> La mayor parte del tiempo no necesitarás nada de eso. Pero
comprender los principios puede resultar útil.
</p><p>Por cierto, cada vez que se utilizan ficheros acabados en <code>.scala</code> o <code>.sbt</code>,
el que se llamen <code>build.sbt</code> y <code>Dependencies.scala</code> son meras convenciones. Esto
significa que se permiten múltiples ficheros.
</p><h3 id="Declarar+dependencias+en+un+%C3%BAnico+lugar">Declarar dependencias en un único lugar<a href="#Declarar+dependencias+en+un+%C3%BAnico+lugar" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Una forma de aprovechar el hecho de que los ficheros <code>.scala</code> bajo <code>project</code>
acaban convirtiéndose en parte de la definición de construcción es crear
<code>project/Dependencies.scala</code> para declarar las dependencias en un único lugar.
</p><pre><code class="prettyprint lang-scala">import sbt._

object Dependencies {
  // Versions
  lazy val akkaVersion = &quot;2.3.8&quot;

  // Libraries
  val akkaActor = &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % akkaVersion
  val akkaCluster = &quot;com.typesafe.akka&quot; %% &quot;akka-cluster&quot; % akkaVersion
  val specs2core = &quot;org.specs2&quot; %% &quot;specs2-core&quot; % &quot;2.4.17&quot;

  // Projects
  val backendDeps =
    Seq(akkaActor, specs2core % Test)
}
</code></pre><p>El objeto <code>Dependencies</code> estará disponible en <code>build.sbt</code>. Para simplificar aún
más el poder usar los <code>val</code> definidos en él, puedes importar <code>Dependencies._</code> en
tu fichero <code>build.sbt</code>.
</p><pre><code class="prettyprint lang-scala">import Dependencies._

ThisBuild / organization := &quot;com.example&quot;
ThisBuild / version      := &quot;0.1.0-SNAPSHOT&quot;
ThisBuild / scalaVersion := &quot;2.12.13&quot;

lazy val backend = (project in file(&quot;backend&quot;))
  .settings(
    name := &quot;backend&quot;,
    libraryDependencies ++= backendDeps
  )
</code></pre><p>Esta técnica es útil cuando tienes construcciones multiproyecto que se empiezan
a volver inmanejables y quieres asegurar que las dependencias en los
subproyectos son consistentes.
</p><h3 id="Cu%C3%A1ndo+usar+ficheros">Cuándo usar ficheros <code>.scala</code><a href="#Cu%C3%A1ndo+usar+ficheros" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>En los ficheros <code>.scala</code> puedes escribir cualquier código de Scala, incluyendo
clases y objetos de primer nivel.
</p><p>La solución recomendada es definir la mayoría de la configuración en un
fichero <code>build.sbt</code> de un multiproyecto y utilizar ficheros <code>project/*.scala</code>
para implementar tareas o compartir valores, tales como claves. El uso de
ficheros <code>.scala</code> también dependerá de cuán familiarizado estéis tú o tu equipo
con Scala.
</p><h3 id="Definir+autoplugins">Definir autoplugins<a href="#Definir+autoplugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Para usuarios más avanzados, otra forma de organizar tu construcción es definir
<a href="../docs/Plugins.html">autoplugins</a> de usar y tirar en <code>project/*.scala</code>.
Al definir plugins disparados, los autoplugins pueden ser usados como una forma
conveniente de inyectar tareas y comandos personalizados a lo largo de los
subproyectos.
</p><h2 id="Gu%C3%ADa+de+inicio+-+resumen">Guía de inicio - resumen<a href="#Gu%C3%ADa+de+inicio+-+resumen" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Esta página resume la Guía de inicio.
</p><p>Para usar sbt existe un pequeño número de conceptos que se han de comprender.
Cada uno tiene su curva de aprendizaje, pero siendo optimistas, sbt no es mucho
más que esos mismos conceptos. sbt usa un pequeño conjunto de poderosos
conceptos para hacer todo lo que hace.
</p><p>Si has leído la Guía de inicio de principio a fin ahora ya sabes lo que
necesitas saber.
</p><h3 id="sbt%3A+Los+conceptos+esenciales">sbt: Los conceptos esenciales<a href="#sbt%3A+Los+conceptos+esenciales" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Los fundamentos de Scala. Es indudablemente útil estar familiarizado con la
sintaxis de Scala. <a href="https://www.artima.com/shop/programming_in_scala_3ed">Programming in
Scala</a>, escrito por el
creador de Scala, es una magnífica introducción.
</li><li><a href="Basic-Def.html">Definiciones de construcción</a>
</li><li>La definición de construcción es un gran GAD de tareas y sus dependencias.
</li><li>Para crear una entrada, emplea uno de los pocos métodos de una clave: <code>:=</code>,
<code>+=</code> o <code>++=</code>.
</li><li>Cada entrada tiene un valor de un tipo en particular, determinado por la
clave.
</li><li>Las <em>tareas</em> son entradas especiales donde la computación que produce el valor
de la clave es re-evaluado cada vez que se lanza una tarea. Las entradas que no
son tareas computan su valor una única vez, durante la carga de la definición
de construcción.
</li><li><a href="Scopes.html">Ámbitos</a>
</li><li>Cada clave puede tener múltiples valores, con distintos ámbitos.
</li><li>Los ámbitos pueden utilizar tres ejes: configuración, proyecto y tarea.
</li><li>Los ámbitos permiten tener diferente comportamiento por proyecto, por tarea
o por configuración.
</li><li>Una configuración es una clase de construcción, como la principal (<code>Compile</code>)
o la de test (<code>Test</code>).
</li><li>El eje de proyecto soporta además el ámbito de “construcción entera”.
</li><li>Un ámbito puede <em>delegar</em> en otros ámbitos más generales.
</li><li>La mayoría de la configuración debe ir en <code>build.sbt</code> y el uso de ficheros
<code>.scala</code> debería de estar reservado para definir clases e implementaciones de
tareas más complejas.
</li><li>La definición de construcción es un proyecto sbt como los demás, ubicado en el
directorio <code>project</code>.
</li><li>Los <a href="Using-Plugins.html">plugins</a> extienden la definición de construcción
</li><li>Los plugins se pueden añadir con el método <code>addSbtPlugin</code> en
<code>project/plugins.sbt</code> (y NO en el fichero <code>build.sbt</code> del directorio base del
proyecto).
</li></ul><p>Si algunos de estos puntos no te queda claro, por favor,
<a href="../docs/faq.html#getting-help">solicita ayuda</a>, vuelve atrás y vuelve a leer, o haz algunos
experimentos utilizando el modo interactivo de sbt.
</p><p>¡Buena suerte!
</p><h3 id="Notas+avanzadas">Notas avanzadas<a href="#Notas+avanzadas" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><!-- TODO: Link to reference. The rest of this wiki consists of deeper dives and less-commonly-needed
information. -->
<p>Ya que sbt es código abierto, ¡no olvides que también puedes echarle un vistazo
al <a href="https://github.com/sbt/sbt">código fuente</a>!
</p>
                  </div>
                </div>
          </div> <!-- row -->
        </div>
        <div class="header">
          <link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<div class="container-fluid top nav">
  <div class="row w-100">
    <div class="col-md-4">
      <div class="logo">
        <a href="../../../index.html"><img src="../files/sbt-logo.svg" alt="sbt"></a>
        <span class="versions"><select id="versions"></select></span>
      </div>
    </div>
    <div class="col-md-8">
      <div class="nav" id="topbar">
        <a href="../../../learn.html">Learn</a>
        <a href="../../../download.html">Download</a>
        <a href="../../../support.html">Support</a>
        <a href="../../../community.html">Get Involved</a>
        <a id="source-code" href="https://github.com/sbt/sbt"><img src="../files/github-logo-teal.svg" alt="Source code" class="social"></a>
        <a id="twitter" href="https://twitter.com/scala_sbt"><img src="../files/twitter-logo-teal.svg" alt="sbt on Twitter" class="social"></a>
        <a id="edit-on-github" href="https://github.com/sbt/website/edit/develop/src/reference/Combined Pages"><img src="../files/octicon-pencil.svg" alt="Edit on GitHub"></a>
      </div>
    </div>
  </div>
</div>
<script type="text/javascript" async>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-41449189-1', 'scala-sbt.org');
ga('send', 'pageview');
</script>
<script type="text/javascript" async>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
  ga('tsTracker.require', 'linker');
  ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org']);
  ga('tsTracker.send', 'pageview');
</script>
<script type="text/javascript">
$(function() {
var scrollDown = function() {
if (window.location.hash !== "") {
  setTimeout(function() { $(window).scrollTop($(window).scrollTop() - 120); }, 100);
}
}
scrollDown();
$(window).bind('hashchange', function() {
scrollDown();
});
});
</script>

        </div>
        <div class="footer">
          <footer>
  <div class="container-fluid footer">
    <div class="row">
      <div class="col-md-8">
        <div class="support-item">
          <div class="support-icon">
            <svg class="svg-icon svg-icon-chat" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 97.5 85.2" enable-background="new 0 0 97.5 85.2"><path stroke="#fff" stroke-width="4.282" stroke-linecap="round" stroke-miterlimit="10" d="M27 29.5h-16.3c-4.7 0-8.6 3.9-8.6 8.6v25.7c0 4.7 3.9 8.6 8.6 8.6h2.7c.8 0 1.5.7 1.5 1.5v7.8c0 1.3 1.6 2 2.5 1l9.5-9.5c.5-.5 1.2-.8 2-.8h20.2c4.7 0 8.6-3.9 8.6-8.6v-7.8" fill="none"/><path fill="#fff" d="M85 0h-40c-6.9 0-12.5 5.6-12.5 12.5v33.4c0 2.2 1.8 4.1 4.1 4.1h29.9c.7 0 1.3.3 1.8.7l10 10c1.6 1.6 4.3.5 4.3-1.8v-6.5c0-1.4 1.1-2.5 2.5-2.5 6.9 0 12.5-5.6 12.5-12.5v-25c-.1-6.8-5.8-12.4-12.6-12.4z"/></svg>
          </div>
          <div class="support-detail">
            <h2>Community Support</h2>
            <a href="https://stackoverflow.com/questions/tagged/sbt">StackOverflow</a>
          </div>
        </div>
        <div class="support-item">
          <div class="support-icon">
            <svg id="lightbend-icon-reverse" class="svg-icon svg-icon-lightbend-reverse" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 302 262"><title>lightbend-icon</title><g id="icon"><path d="M1,195v56a10,10,0,0,0,10,10H291a10,10,0,0,0,10-10V195a557.85,557.85,0,0,1-150,20A557.85,557.85,0,0,1,1,195Z" style="fill:#fff"/><path d="M291,1H11A10,10,0,0,0,1,11V176a539.94,539.94,0,0,0,150,21,539.94,539.94,0,0,0,150-21V11A10,10,0,0,0,291,1Z" style="fill:#fff"/></g></svg>
          </div>
          <div class="support-detail">
            <h2>Commercial Support</h2>
            <a href="https://www.lightbend.com/services/expert-support">Lightbend Subscription</a>
            <a href="https://www.lightbend.com/services/training">Training</a>
            <a href="https://www.lightbend.com/services/consulting">Consulting</a>
          </div>
        </div>
      </div>
      <div class="col-md-4 text-right ts">
        &copy; 2016-<script>document.write(new Date().getFullYear())</script> Lightbend Inc.
        <a href="https://www.lightbend.com">
          <img src="../files/lightbend-reverse.svg" alt="Lightbend, Inc.">
        </a>
      </div>
    </div>
  </div>
</footer><script src="/assets/versions.js"></script><script src="/assets/set-versions.js"></script>
        </div>
        
        <div class="highlight-outer">
              <div class="highlight-menu">
                <ul>
                  <li><button id="highlight-button-twitter"><img src="../img/twitter-bird-dark-bgs.png"/></button></li>
                </ul>
              </div>
            </div>
      </body>
    </html>